/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		if (null) script.crossOrigin = null;
/******/ 		document.head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "611d468b5914319422ec";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "app";
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted &&
/******/ 				// removed self-accepted modules should not be required
/******/ 				appliedUpdate[moduleId] !== warnUnexpectedRequire
/******/ 			) {
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire("./example/index.jsx")(__webpack_require__.s = "./example/index.jsx");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./example/content.js":
/*!****************************!*\
  !*** ./example/content.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var content = "# h1 Heading 8-)\n## h2 Heading\n### h3 Heading\n#### h4 Heading\n##### h5 Heading\n###### h6 Heading\n\n\n## Horizontal Rules\n\n___\n\n---\n\n***\n\n\n## Typographic replacements\n\nEnable typographer option to see result.\n\n(c) (C) (r) (R) (tm) (TM) (p) (P) +-\n\ntest.. test... test..... test?..... test!....\n\n!!!!!! ???? ,,  -- ---\n\n\"Smartypants, double quotes\" and 'single quotes'\n\n\n## Emphasis\n\n**This is bold text**\n\n__This is bold text__\n\n*This is italic text*\n\n_This is italic text_\n\n~~Strikethrough~~\n\n\n## Blockquotes\n\n> Blockquotes test\n - nest\n> Blockquotes can also be nested...\n>> ...by using additional greater-than signs right next to each other...\n> > > ...or with spaces between arrows.\n\n\n## Lists\n\nUnordered\n\n+ Create a list by starting a line with `+`, `-`, or `*`\n+ Sub-lists are made by indenting 2 spaces:\n  - Marker character change forces new list start:\n    * Ac tristique libero volutpat at\n    + Facilisis in pretium nisl aliquet\n    - Nulla volutpat aliquam velit\n+ Very easy!\n\nOrdered\n\n1. Lorem ipsum dolor sit amet\n2. Consectetur adipiscing elit\n3. Integer molestie lorem at massa\n\n\n1. You can use sequential numbers...\n1. ...or keep all the numbers as `1.`\n\nStart numbering with offset:\n\n57. foo\n1. bar\n\n\n## Code\n\nInline `code`\n\nIndented code\n\n    // Some comments\n    line 1 of code\n    line 2 of code\n    line 3 of code\n\n\nBlock code \"fences\"\n\n```\nSample text here...\n```\n\nSyntax highlighting\n\n``` js\nvar foo = function (bar) {\n  return bar++;\n};\n\nconsole.log(foo(5));\n```\n\n## Tables\n\n| Option | Description |\n| ------ | ----------- |\n| data   | path to data files to supply the data that will be passed into templates. |\n| engine | engine to be used for processing templates. Handlebars is the default. |\n| ext    | extension to be used for dest files. |\n\nRight aligned columns\n\n| Option | Description |\n| ------:| -----------:|\n| data   | path to data files to supply the data that will be passed into templates. |\n| engine | engine to be used for processing templates. Handlebars is the default. |\n| ext    | extension to be used for dest files. |\n\n\n## Links\n\n[link text](http://dev.nodeca.com)\n\n[link with title](http://nodeca.github.io/pica/demo/ \"title text!\")\n\nAutoconverted link https://github.com/nodeca/pica (enable linkify to see)\n\n\n## Images\n\n![Minion](https://octodex.github.com/images/minion.png)\n![Stormtroopocat](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\")\n\nLike links, Images also have a footnote style syntax\n\n![Alt text][id]\n\nWith a reference later in the document defining the URL location:\n\n[id]: https://octodex.github.com/images/dojocat.jpg  \"The Dojocat\"\n\n\n## Plugins\n\nThe killer feature of `markdown-it` is very effective support of\n[syntax plugins](https://www.npmjs.org/browse/keyword/markdown-it-plugin).\n\n\n### [Emojies](https://github.com/markdown-it/markdown-it-emoji)\n\n> Classic markup: :wink: :crush: :cry: :tear: :laughing: :yum:\n>\n> Shortcuts (emoticons): :-) :-( 8-) ;)\n\nsee [how to change output](https://github.com/markdown-it/markdown-it-emoji#change-output) with twemoji.\n\n\n### [Subscript](https://github.com/markdown-it/markdown-it-sub) / [Superscript](https://github.com/markdown-it/markdown-it-sup)\n\n- 19^th^\n- H~2~O\n\n\n### [<ins>](https://github.com/markdown-it/markdown-it-ins)\n\n++Inserted text++\n\n\n### [<mark>](https://github.com/markdown-it/markdown-it-mark)\n\n==Marked text==\n\n\n### [Footnotes](https://github.com/markdown-it/markdown-it-footnote)\n\nFootnote 1 link[^first].\n\nFootnote 2 link[^second].\n\nInline footnote^[Text of inline footnote] definition.\n\nDuplicated footnote reference[^second].\n\n[^first]: Footnote **can have markup**\n\n    and multiple paragraphs.\n\n[^second]: Footnote text.\n\n\n### [Definition lists](https://github.com/markdown-it/markdown-it-deflist)\n\nTerm 1\n\n:   Definition 1\nwith lazy continuation.\n\nTerm 2 with *inline markup*\n\n:   Definition 2\n\n        { some code, part of Definition 2 }\n\n    Third paragraph of definition 2.\n\n_Compact style:_\n\nTerm 1\n  ~ Definition 1\n\nTerm 2\n  ~ Definition 2a\n  ~ Definition 2b\n\n\n### [Abbreviations](https://github.com/markdown-it/markdown-it-abbr)\n\nThis is HTML abbreviation example.\n\nIt converts \"HTML\", but keep intact partial entries like \"xxxHTMLyyy\" and so on.\n\n*[HTML]: Hyper Text Markup Language\n\n### [Custom containers](https://github.com/markdown-it/markdown-it-container)\n\n::: warning\n*here be dragons*\n:::\n";
/* harmony default export */ __webpack_exports__["default"] = (content);

/***/ }),

/***/ "./example/index.jsx":
/*!***************************!*\
  !*** ./example/index.jsx ***!
  \***************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var markdown_it__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! markdown-it */ "./node_modules/markdown-it/index.js");
/* harmony import */ var markdown_it__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(markdown_it__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _src_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/index.js */ "./src/index.js");
/* harmony import */ var _content_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./content.js */ "./example/content.js");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index.less */ "./example/index.less");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_index_less__WEBPACK_IMPORTED_MODULE_5__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




 // import MdEditor from '../lib/react-markdown-editor-lite.min.js'



var mock_content = _content_js__WEBPACK_IMPORTED_MODULE_4__["default"];

var Demo =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Demo, _React$Component);

  function Demo(props) {
    var _this;

    _classCallCheck(this, Demo);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Demo).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "mdEditor", null);

    _defineProperty(_assertThisInitialized(_this), "mdit", null);

    _this.mdit = new markdown_it__WEBPACK_IMPORTED_MODULE_0___default.a({
      html: true,
      linkify: true,
      typographer: true
    });
    return _this;
  }

  _createClass(Demo, [{
    key: "handleEditorChange",
    value: function handleEditorChange(_ref) {// console.log('handleEditorChange', text)

      var html = _ref.html,
          text = _ref.text;
    }
  }, {
    key: "handleImageUpload",
    value: function handleImageUpload(file, callback) {
      var reader = new FileReader();

      reader.onload = function () {
        var convertBase64UrlToBlob = function convertBase64UrlToBlob(urlData) {
          var arr = urlData.split(','),
              mime = arr[0].match(/:(.*?);/)[1];
          var bstr = atob(arr[1]);
          var n = bstr.length;
          var u8arr = new Uint8Array(n);

          while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
          }

          return new Blob([u8arr], {
            type: mime
          });
        };

        var blob = convertBase64UrlToBlob(reader.result);
        setTimeout(function () {
          // setTimeout 模拟oss异步上传图片
          // 当oss异步上传获取图片地址后，执行calback回调（参数为imageUrl字符串），即可将图片地址写入markdown
          callback('https://avatars0.githubusercontent.com/u/21263805?s=40&v=4');
        }, 1000);
      };

      reader.readAsDataURL(file);
    }
  }, {
    key: "handleGetMdValue",
    value: function handleGetMdValue() {
      if (this.mdEditor) {
        alert(this.mdEditor.getMdValue());
      }
    }
  }, {
    key: "handleGetHtmlValue",
    value: function handleGetHtmlValue() {
      if (this.mdEditor) {
        alert(this.mdEditor.getHtmlValue());
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      return react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
        className: "demo-wrap"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("h3", null, "react-markdown-editor-lite demo"), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("nav", {
        className: "nav"
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", {
        onClick: this.handleGetMdValue
      }, "getMdValue"), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("button", {
        onClick: this.handleGetHtmlValue
      }, "getHtmlValue")), react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement("div", {
        className: "editor-wrap",
        style: {
          marginTop: '30px'
        }
      }, react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_src_index_js__WEBPACK_IMPORTED_MODULE_3__["default"], {
        ref: function ref(node) {
          return _this2.mdEditor = node;
        },
        value: mock_content,
        style: {
          height: '500px',
          width: '100%'
        },
        renderHTML: function renderHTML(text) {
          return _this2.mdit.render(text);
        },
        config: {
          view: {
            menu: true,
            md: true,
            html: true
          },
          table: {
            maxRow: 5,
            maxCol: 6
          },
          imageUrl: 'https://octodex.github.com/images/minion.png'
        },
        onChange: this.handleEditorChange,
        onImageUpload: this.handleImageUpload
      })));
    }
  }]);

  return Demo;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

react_dom__WEBPACK_IMPORTED_MODULE_2___default.a.render(react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(Demo, null), document.getElementById('root'));

/***/ }),

/***/ "./example/index.less":
/*!****************************!*\
  !*** ./example/index.less ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js??ref--6-1!../node_modules/postcss-loader/lib!../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./example/index.less");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(true) {
	module.hot.accept(/*! !../node_modules/css-loader/dist/cjs.js??ref--6-1!../node_modules/postcss-loader/lib!../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./example/index.less", function() {
		var newContent = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js??ref--6-1!../node_modules/postcss-loader/lib!../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./example/index.less");

		if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./example/index.less":
/*!*****************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--6-1!./node_modules/postcss-loader/lib!./node_modules/less-loader/dist/cjs.js!./example/index.less ***!
  \*****************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".demo-wrap {\n  padding: 20px;\n}\n.demo-wrap .nav {\n  margin: 10px 0  10px 0;\n}\n.demo-wrap .nav button {\n  margin-right: 10px;\n}\n.demo-wrap .editor-wrap {\n  width: 100%;\n  height: 500px;\n}\n", ""]);



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/DropList/index.less":
/*!*********************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--6-1!./node_modules/postcss-loader/lib!./node_modules/less-loader/dist/cjs.js!./src/components/DropList/index.less ***!
  \*********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".drop-wrap {\n  display: block;\n  position: absolute;\n  left: 0;\n  top: 28px;\n  z-index: 2;\n  min-width: 20px;\n  padding: 10px 0;\n  text-align: center;\n  background-color: #fff;\n  border: 1px solid #f1f1f1;\n  border-right-color: #ddd;\n  border-bottom-color: #ddd;\n}\n.drop-wrap.hidden {\n  display: none !important;\n}\n", ""]);



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/HeaderList/index.less":
/*!***********************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--6-1!./node_modules/postcss-loader/lib!./node_modules/less-loader/dist/cjs.js!./src/components/HeaderList/index.less ***!
  \***********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".header-list .list-item {\n  width: 100px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  padding: 5px 0;\n}\n.header-list .list-item:hover {\n  background: #f1f1f1;\n}\n", ""]);



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/Icon/font.less":
/*!****************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--6-1!./node_modules/postcss-loader/lib!./node_modules/less-loader/dist/cjs.js!./src/components/Icon/font.less ***!
  \****************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Imports
var urlEscape = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/url-escape.js */ "./node_modules/css-loader/dist/runtime/url-escape.js");
var ___CSS_LOADER_URL___0___ = urlEscape(__webpack_require__(/*! ./fonts/icomoon.woff?cbt6hv */ "./src/components/Icon/fonts/icomoon.woff?cbt6hv"));

// Module
exports.push([module.i, "@font-face {\n  font-family: 'icomoon';\n  src: url(" + ___CSS_LOADER_URL___0___ + ") format('woff');\n  font-weight: normal;\n  font-style: normal;\n}\n[class^=\"icon-\"],\n[class*=\" icon-\"] {\n  /* use !important to prevent issues with browser extensions that change fonts */\n  font-family: 'icomoon' !important;\n  speak: none;\n  font-style: normal;\n  font-weight: normal;\n  font-variant: normal;\n  text-transform: none;\n  line-height: 1;\n  /* Better Font Rendering =========== */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n.icon-asterisk:before {\n  content: \"\\f069\";\n}\n.icon-power-off:before {\n  content: \"\\f011\";\n}\n.icon-cog:before {\n  content: \"\\f013\";\n}\n.icon-gear:before {\n  content: \"\\f013\";\n}\n.icon-refresh:before {\n  content: \"\\f021\";\n}\n.icon-bold:before {\n  content: \"\\f032\";\n}\n.icon-italic:before {\n  content: \"\\f033\";\n}\n.icon-image:before {\n  content: \"\\f03e\";\n}\n.icon-photo:before {\n  content: \"\\f03e\";\n}\n.icon-picture-o:before {\n  content: \"\\f03e\";\n}\n.icon-pencil:before {\n  content: \"\\f040\";\n}\n.icon-adjust:before {\n  content: \"\\f042\";\n}\n.icon-share-square-o:before {\n  content: \"\\f045\";\n}\n.icon-chevron-left:before {\n  content: \"\\f053\";\n}\n.icon-chevron-right:before {\n  content: \"\\f054\";\n}\n.icon-mail-forward:before {\n  content: \"\\f064\";\n}\n.icon-share:before {\n  content: \"\\f064\";\n}\n.icon-expand:before {\n  content: \"\\f065\";\n}\n.icon-compress:before {\n  content: \"\\f066\";\n}\n.icon-eye:before {\n  content: \"\\f06e\";\n}\n.icon-chevron-up:before {\n  content: \"\\f077\";\n}\n.icon-chevron-down:before {\n  content: \"\\f078\";\n}\n.icon-chain:before {\n  content: \"\\f0c1\";\n}\n.icon-link:before {\n  content: \"\\f0c1\";\n}\n.icon-cut:before {\n  content: \"\\f0c4\";\n}\n.icon-scissors:before {\n  content: \"\\f0c4\";\n}\n.icon-copy:before {\n  content: \"\\f0c5\";\n}\n.icon-files-o:before {\n  content: \"\\f0c5\";\n}\n.icon-list-ul:before {\n  content: \"\\f0ca\";\n}\n.icon-list-ol:before {\n  content: \"\\f0cb\";\n}\n.icon-strikethrough:before {\n  content: \"\\f0cc\";\n}\n.icon-underline:before {\n  content: \"\\f0cd\";\n}\n.icon-table:before {\n  content: \"\\f0ce\";\n}\n.icon-columns:before {\n  content: \"\\f0db\";\n}\n.icon-exchange:before {\n  content: \"\\f0ec\";\n}\n.icon-desktop:before {\n  content: \"\\f108\";\n}\n.icon-quote-left:before {\n  content: \"\\f10d\";\n}\n.icon-spinner:before {\n  content: \"\\f110\";\n}\n.icon-mail-reply:before {\n  content: \"\\f112\";\n}\n.icon-reply:before {\n  content: \"\\f112\";\n}\n.icon-terminal:before {\n  content: \"\\f120\";\n}\n.icon-superscript:before {\n  content: \"\\f12b\";\n}\n.icon-subscript:before {\n  content: \"\\f12c\";\n}\n.icon-eraser:before {\n  content: \"\\f12d\";\n}\n.icon-file-code-o:before {\n  content: \"\\f1c9\";\n}\n.icon-header:before {\n  content: \"\\f1dc\";\n}\n.icon-trash:before {\n  content: \"\\f1f8\";\n}\n.icon-window-minimize:before {\n  content: \"\\f2d1\";\n}\n.icon-enlarge:before {\n  content: \"\\e989\";\n}\n.icon-shrink:before {\n  content: \"\\e98a\";\n}\n.icon-embed:before {\n  content: \"\\ea7f\";\n}\n.icon-embed2:before {\n  content: \"\\ea80\";\n}\n", ""]);



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/InputFile/index.less":
/*!**********************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--6-1!./node_modules/postcss-loader/lib!./node_modules/less-loader/dist/cjs.js!./src/components/InputFile/index.less ***!
  \**********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, "", ""]);



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/TableList/index.less":
/*!**********************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--6-1!./node_modules/postcss-loader/lib!./node_modules/less-loader/dist/cjs.js!./src/components/TableList/index.less ***!
  \**********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".table-list.wrap {\n  position: relative;\n  margin: 0 10px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.table-list.wrap .list-item {\n  position: absolute;\n  top: 0;\n  left: 0;\n  display: inline-block;\n  width: 20px;\n  height: 20px;\n  background-color: #e0e0e0;\n  border-radius: 3px;\n}\n.table-list.wrap .list-item.active {\n  background: #b4b4b4;\n}\n", ""]);



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/ToolBar/index.less":
/*!********************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--6-1!./node_modules/postcss-loader/lib!./node_modules/less-loader/dist/cjs.js!./src/components/ToolBar/index.less ***!
  \********************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".tool-bar {\n  position: absolute;\n  z-index: 1;\n  right: 30px;\n  top: 10px;\n}\n.tool-bar .button {\n  min-width: 24px;\n  height: 28px;\n  margin-right: 5px;\n  display: inline-block;\n  cursor: pointer;\n  font-size: 14px;\n  line-height: 28px;\n  text-align: center;\n  color: #999;\n}\n.tool-bar .button:hover {\n  color: #333;\n}\n", ""]);



/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/editor/index.less":
/*!********************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??ref--6-1!./node_modules/postcss-loader/lib!./node_modules/less-loader/dist/cjs.js!./src/editor/index.less ***!
  \********************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js")(false);
// Module
exports.push([module.i, ".rc-md-editor {\n  height: 100%;\n  min-height: 0;\n  padding-bottom: 1px;\n  position: relative;\n  border: 1px solid #ddd;\n  background: #fff;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: vertical;\n  -webkit-box-direction: normal;\n  -webkit-flex-direction: column;\n      -ms-flex-direction: column;\n          flex-direction: column;\n}\n.rc-md-editor.full {\n  width: 100%;\n  height: 100% !important;\n  position: fixed;\n  left: 0px;\n  top: 0px;\n  z-index: 1000;\n}\n.rc-md-editor .ctrl-wrap {\n  position: absolute;\n  top: 0;\n  right: 0;\n}\n.rc-md-editor .ctrl-wrap button {\n  line-height: 24px;\n  background: #fff;\n  border: none;\n  border: 1px solid #d9d9d9;\n}\n.rc-md-editor .ctrl-wrap button.checked {\n  border: 1px solid #1890FF;\n  color: #1890FF;\n}\n.rc-md-editor .editor-container {\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  width: 100%;\n  min-height: 0;\n}\n.rc-md-editor .editor-container .sec-md {\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  position: relative;\n  min-height: 0;\n  min-width: 0;\n}\n.rc-md-editor .editor-container .sec-md .input {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  padding: 20px 15px 15px 15px;\n  overflow-y: scroll;\n  border: none;\n  resize: none;\n  outline: none;\n  min-height: 0;\n  background: #fff;\n  color: #333;\n  font-size: 14px;\n  line-height: 20px;\n}\n.rc-md-editor .editor-container .sec-html {\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  position: relative;\n  min-height: 0;\n  min-width: 0;\n  margin-left: 20px;\n}\n.rc-md-editor .editor-container .sec-html .html-wrap {\n  height: 100%;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  padding-top: 20px;\n  overflow: auto;\n}\n.rc-md-editor .editor-container .sec-html .html-code-wrap {\n  height: 100%;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  padding-top: 20px;\n}\n.rc-md-editor .editor-container .sec-html .html-code {\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  padding: 20px 15px 15px 15px;\n  border: none;\n  resize: none;\n  outline: none;\n  min-height: 200px;\n  background: #fff;\n  color: #333;\n  font-size: 14px;\n  line-height: 20px;\n}\n.rc-md-navigation {\n  min-height: 38px;\n  padding: 0px 8px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  border-bottom: 1px solid #ddd;\n  font-size: 16px;\n  background: #f1f1f1;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n  -webkit-flex-direction: row;\n      -ms-flex-direction: row;\n          flex-direction: row;\n  -webkit-box-pack: justify;\n  -webkit-justify-content: space-between;\n      -ms-flex-pack: justify;\n          justify-content: space-between;\n}\n.rc-md-navigation .navigation-nav {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n  -webkit-flex-direction: row;\n      -ms-flex-direction: row;\n          flex-direction: row;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  font-size: 14px;\n  color: #666;\n}\n.rc-md-navigation .button-wrap {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-orient: horizontal;\n  -webkit-box-direction: normal;\n  -webkit-flex-direction: row;\n      -ms-flex-direction: row;\n          flex-direction: row;\n  -webkit-flex-wrap: wrap;\n      -ms-flex-wrap: wrap;\n          flex-wrap: wrap;\n}\n.rc-md-navigation .button-wrap .button {\n  position: relative;\n  min-width: 24px;\n  height: 28px;\n  margin-right: 5px;\n  display: inline-block;\n  cursor: pointer;\n  line-height: 28px;\n  text-align: center;\n  color: #999;\n}\n.rc-md-navigation .button-wrap .button:hover {\n  color: #333;\n}\n.rc-md-navigation ul,\n.rc-md-navigation li {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n.rc-md-navigation h1,\n.rc-md-navigation h2,\n.rc-md-navigation h3,\n.rc-md-navigation h4,\n.rc-md-navigation h5,\n.rc-md-navigation h6,\n.rc-md-navigation .h1,\n.rc-md-navigation .h2,\n.rc-md-navigation .h3,\n.rc-md-navigation .h4,\n.rc-md-navigation .h5,\n.rc-md-navigation .h6 {\n  font-family: inherit;\n  font-weight: 500;\n  color: inherit;\n  padding: 0;\n  margin: 0;\n  line-height: 1.1;\n}\n.rc-md-navigation h1 {\n  font-size: 34px;\n}\n.rc-md-navigation h2 {\n  font-size: 30px;\n}\n.rc-md-navigation h3 {\n  font-size: 24px;\n}\n.rc-md-navigation h4 {\n  font-size: 18px;\n}\n.rc-md-navigation h5 {\n  font-size: 14px;\n}\n.rc-md-navigation h6 {\n  font-size: 12px;\n}\n.custom-html-style {\n  color: #333;\n}\n.custom-html-style h1 {\n  font-size: 32px;\n  padding: 16px 0;\n  border: none;\n  font-weight: 700;\n  margin: 0;\n}\n.custom-html-style h2 {\n  font-size: 26px;\n  padding: 12px 0;\n  border: none;\n  font-weight: 700;\n  margin: 0;\n}\n.custom-html-style h3 {\n  font-size: 20px;\n  line-height: 40px;\n  margin: 0;\n}\n.custom-html-style p {\n  font-size: 14px;\n  line-height: 28px;\n  margin-bottom: 20px;\n}\n.custom-html-style a {\n  color: #0052d9;\n}\n.custom-html-style a:hover {\n  text-decoration: none;\n}\n.custom-html-style strong {\n  font-weight: 700;\n}\n.custom-html-style ol,\n.custom-html-style ul {\n  font-size: 14px;\n  line-height: 28px;\n  padding-left: 36px;\n}\n.custom-html-style hr {\n  margin-top: 20px;\n  margin-bottom: 20px;\n  border: 0;\n  border-top: 1px solid #eee;\n}\n.custom-html-style pre {\n  background-color: #f5f5f5;\n  padding: 20px;\n  font-size: 14px;\n  line-height: 28px;\n  border-radius: 0;\n}\n.custom-html-style code {\n  background-color: transparent;\n}\n.custom-html-style code {\n  background-color: #f5f5f5;\n  border-radius: 0;\n  padding: 3px 0;\n  margin: 0;\n  font-size: 14px;\n}\n.custom-html-style code:after,\n.custom-html-style code:before {\n  letter-spacing: 0;\n}\n.custom-html-style blockquote {\n  margin: 0;\n  background: none repeat scroll 0 0 rgba(102, 128, 153, 0.05);\n  padding-left: 30px;\n  border: none;\n  padding: 5px 8px 5px 30px;\n  color: #333;\n  position: relative;\n  border-left: 10px solid #D6DBDF;\n}\n.custom-html-style img {\n  max-width: 35%;\n}\n.custom-html-style table {\n  font-size: 16px;\n  line-height: 24px;\n  border-spacing: 0;\n  border-collapse: collapse;\n}\n.custom-html-style table td,\n.custom-html-style table th {\n  word-break: break-all;\n  word-wrap: break-word;\n  white-space: normal;\n}\n.custom-html-style table th {\n  text-align: center;\n  font-weight: 700;\n  border: 1px solid #efefef;\n  padding: 14px;\n  background-color: #f5f7fa;\n}\n.custom-html-style table tr {\n  border: 1px solid #efefef;\n}\n.custom-html-style table tr:nth-child(2n) {\n  background-color: transparent;\n}\n.custom-html-style table td {\n  border: 1px solid #efefef;\n  text-align: left;\n  padding: 9px 15px;\n}\n.custom-html-style table td,\n.custom-html-style table th {\n  min-width: 80px;\n  max-width: 430px;\n}\n", ""]);



/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader

module.exports = function (useSourceMap) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item, useSourceMap);

      if (item[2]) {
        return '@media ' + item[2] + '{' + content + '}';
      } else {
        return content;
      }
    }).join('');
  }; // import a list of modules into the list


  list.i = function (modules, mediaQuery) {
    if (typeof modules === 'string') {
      modules = [[null, modules, '']];
    }

    var alreadyImportedModules = {};

    for (var i = 0; i < this.length; i++) {
      var id = this[i][0];

      if (id != null) {
        alreadyImportedModules[id] = true;
      }
    }

    for (i = 0; i < modules.length; i++) {
      var item = modules[i]; // skip already imported module
      // this implementation is not 100% perfect for weird media query combinations
      // when a module is imported multiple times with different media queries.
      // I hope this will never occur (Hey this way we have smaller bundles)

      if (item[0] == null || !alreadyImportedModules[item[0]]) {
        if (mediaQuery && !item[2]) {
          item[2] = mediaQuery;
        } else if (mediaQuery) {
          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';
        }

        list.push(item);
      }
    }
  };

  return list;
};

function cssWithMappingToString(item, useSourceMap) {
  var content = item[1] || '';
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (useSourceMap && typeof btoa === 'function') {
    var sourceMapping = toComment(cssMapping);
    var sourceURLs = cssMapping.sources.map(function (source) {
      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
  }

  return [content].join('\n');
} // Adapted from convert-source-map (MIT)


function toComment(sourceMap) {
  // eslint-disable-next-line no-undef
  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
  return '/*# ' + data + ' */';
}

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/url-escape.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/url-escape.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function escape(url, needQuotes) {
  if (typeof url !== 'string') {
    return url;
  } // If url is already wrapped in quotes, remove them


  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  } // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls


  if (/["'() \t\n]/.test(url) || needQuotes) {
    return '"' + url.replace(/"/g, '\\"').replace(/\n/g, '\\n') + '"';
  }

  return url;
};

/***/ }),

/***/ "./node_modules/entities/maps/entities.json":
/*!**************************************************!*\
  !*** ./node_modules/entities/maps/entities.json ***!
  \**************************************************/
/*! exports provided: Aacute, aacute, Abreve, abreve, ac, acd, acE, Acirc, acirc, acute, Acy, acy, AElig, aelig, af, Afr, afr, Agrave, agrave, alefsym, aleph, Alpha, alpha, Amacr, amacr, amalg, amp, AMP, andand, And, and, andd, andslope, andv, ang, ange, angle, angmsdaa, angmsdab, angmsdac, angmsdad, angmsdae, angmsdaf, angmsdag, angmsdah, angmsd, angrt, angrtvb, angrtvbd, angsph, angst, angzarr, Aogon, aogon, Aopf, aopf, apacir, ap, apE, ape, apid, apos, ApplyFunction, approx, approxeq, Aring, aring, Ascr, ascr, Assign, ast, asymp, asympeq, Atilde, atilde, Auml, auml, awconint, awint, backcong, backepsilon, backprime, backsim, backsimeq, Backslash, Barv, barvee, barwed, Barwed, barwedge, bbrk, bbrktbrk, bcong, Bcy, bcy, bdquo, becaus, because, Because, bemptyv, bepsi, bernou, Bernoullis, Beta, beta, beth, between, Bfr, bfr, bigcap, bigcirc, bigcup, bigodot, bigoplus, bigotimes, bigsqcup, bigstar, bigtriangledown, bigtriangleup, biguplus, bigvee, bigwedge, bkarow, blacklozenge, blacksquare, blacktriangle, blacktriangledown, blacktriangleleft, blacktriangleright, blank, blk12, blk14, blk34, block, bne, bnequiv, bNot, bnot, Bopf, bopf, bot, bottom, bowtie, boxbox, boxdl, boxdL, boxDl, boxDL, boxdr, boxdR, boxDr, boxDR, boxh, boxH, boxhd, boxHd, boxhD, boxHD, boxhu, boxHu, boxhU, boxHU, boxminus, boxplus, boxtimes, boxul, boxuL, boxUl, boxUL, boxur, boxuR, boxUr, boxUR, boxv, boxV, boxvh, boxvH, boxVh, boxVH, boxvl, boxvL, boxVl, boxVL, boxvr, boxvR, boxVr, boxVR, bprime, breve, Breve, brvbar, bscr, Bscr, bsemi, bsim, bsime, bsolb, bsol, bsolhsub, bull, bullet, bump, bumpE, bumpe, Bumpeq, bumpeq, Cacute, cacute, capand, capbrcup, capcap, cap, Cap, capcup, capdot, CapitalDifferentialD, caps, caret, caron, Cayleys, ccaps, Ccaron, ccaron, Ccedil, ccedil, Ccirc, ccirc, Cconint, ccups, ccupssm, Cdot, cdot, cedil, Cedilla, cemptyv, cent, centerdot, CenterDot, cfr, Cfr, CHcy, chcy, check, checkmark, Chi, chi, circ, circeq, circlearrowleft, circlearrowright, circledast, circledcirc, circleddash, CircleDot, circledR, circledS, CircleMinus, CirclePlus, CircleTimes, cir, cirE, cire, cirfnint, cirmid, cirscir, ClockwiseContourIntegral, CloseCurlyDoubleQuote, CloseCurlyQuote, clubs, clubsuit, colon, Colon, Colone, colone, coloneq, comma, commat, comp, compfn, complement, complexes, cong, congdot, Congruent, conint, Conint, ContourIntegral, copf, Copf, coprod, Coproduct, copy, COPY, copysr, CounterClockwiseContourIntegral, crarr, cross, Cross, Cscr, cscr, csub, csube, csup, csupe, ctdot, cudarrl, cudarrr, cuepr, cuesc, cularr, cularrp, cupbrcap, cupcap, CupCap, cup, Cup, cupcup, cupdot, cupor, cups, curarr, curarrm, curlyeqprec, curlyeqsucc, curlyvee, curlywedge, curren, curvearrowleft, curvearrowright, cuvee, cuwed, cwconint, cwint, cylcty, dagger, Dagger, daleth, darr, Darr, dArr, dash, Dashv, dashv, dbkarow, dblac, Dcaron, dcaron, Dcy, dcy, ddagger, ddarr, DD, dd, DDotrahd, ddotseq, deg, Del, Delta, delta, demptyv, dfisht, Dfr, dfr, dHar, dharl, dharr, DiacriticalAcute, DiacriticalDot, DiacriticalDoubleAcute, DiacriticalGrave, DiacriticalTilde, diam, diamond, Diamond, diamondsuit, diams, die, DifferentialD, digamma, disin, div, divide, divideontimes, divonx, DJcy, djcy, dlcorn, dlcrop, dollar, Dopf, dopf, Dot, dot, DotDot, doteq, doteqdot, DotEqual, dotminus, dotplus, dotsquare, doublebarwedge, DoubleContourIntegral, DoubleDot, DoubleDownArrow, DoubleLeftArrow, DoubleLeftRightArrow, DoubleLeftTee, DoubleLongLeftArrow, DoubleLongLeftRightArrow, DoubleLongRightArrow, DoubleRightArrow, DoubleRightTee, DoubleUpArrow, DoubleUpDownArrow, DoubleVerticalBar, DownArrowBar, downarrow, DownArrow, Downarrow, DownArrowUpArrow, DownBreve, downdownarrows, downharpoonleft, downharpoonright, DownLeftRightVector, DownLeftTeeVector, DownLeftVectorBar, DownLeftVector, DownRightTeeVector, DownRightVectorBar, DownRightVector, DownTeeArrow, DownTee, drbkarow, drcorn, drcrop, Dscr, dscr, DScy, dscy, dsol, Dstrok, dstrok, dtdot, dtri, dtrif, duarr, duhar, dwangle, DZcy, dzcy, dzigrarr, Eacute, eacute, easter, Ecaron, ecaron, Ecirc, ecirc, ecir, ecolon, Ecy, ecy, eDDot, Edot, edot, eDot, ee, efDot, Efr, efr, eg, Egrave, egrave, egs, egsdot, el, Element, elinters, ell, els, elsdot, Emacr, emacr, empty, emptyset, EmptySmallSquare, emptyv, EmptyVerySmallSquare, emsp13, emsp14, emsp, ENG, eng, ensp, Eogon, eogon, Eopf, eopf, epar, eparsl, eplus, epsi, Epsilon, epsilon, epsiv, eqcirc, eqcolon, eqsim, eqslantgtr, eqslantless, Equal, equals, EqualTilde, equest, Equilibrium, equiv, equivDD, eqvparsl, erarr, erDot, escr, Escr, esdot, Esim, esim, Eta, eta, ETH, eth, Euml, euml, euro, excl, exist, Exists, expectation, exponentiale, ExponentialE, fallingdotseq, Fcy, fcy, female, ffilig, fflig, ffllig, Ffr, ffr, filig, FilledSmallSquare, FilledVerySmallSquare, fjlig, flat, fllig, fltns, fnof, Fopf, fopf, forall, ForAll, fork, forkv, Fouriertrf, fpartint, frac12, frac13, frac14, frac15, frac16, frac18, frac23, frac25, frac34, frac35, frac38, frac45, frac56, frac58, frac78, frasl, frown, fscr, Fscr, gacute, Gamma, gamma, Gammad, gammad, gap, Gbreve, gbreve, Gcedil, Gcirc, gcirc, Gcy, gcy, Gdot, gdot, ge, gE, gEl, gel, geq, geqq, geqslant, gescc, ges, gesdot, gesdoto, gesdotol, gesl, gesles, Gfr, gfr, gg, Gg, ggg, gimel, GJcy, gjcy, gla, gl, glE, glj, gnap, gnapprox, gne, gnE, gneq, gneqq, gnsim, Gopf, gopf, grave, GreaterEqual, GreaterEqualLess, GreaterFullEqual, GreaterGreater, GreaterLess, GreaterSlantEqual, GreaterTilde, Gscr, gscr, gsim, gsime, gsiml, gtcc, gtcir, gt, GT, Gt, gtdot, gtlPar, gtquest, gtrapprox, gtrarr, gtrdot, gtreqless, gtreqqless, gtrless, gtrsim, gvertneqq, gvnE, Hacek, hairsp, half, hamilt, HARDcy, hardcy, harrcir, harr, hArr, harrw, Hat, hbar, Hcirc, hcirc, hearts, heartsuit, hellip, hercon, hfr, Hfr, HilbertSpace, hksearow, hkswarow, hoarr, homtht, hookleftarrow, hookrightarrow, hopf, Hopf, horbar, HorizontalLine, hscr, Hscr, hslash, Hstrok, hstrok, HumpDownHump, HumpEqual, hybull, hyphen, Iacute, iacute, ic, Icirc, icirc, Icy, icy, Idot, IEcy, iecy, iexcl, iff, ifr, Ifr, Igrave, igrave, ii, iiiint, iiint, iinfin, iiota, IJlig, ijlig, Imacr, imacr, image, ImaginaryI, imagline, imagpart, imath, Im, imof, imped, Implies, incare, in, infin, infintie, inodot, intcal, int, Int, integers, Integral, intercal, Intersection, intlarhk, intprod, InvisibleComma, InvisibleTimes, IOcy, iocy, Iogon, iogon, Iopf, iopf, Iota, iota, iprod, iquest, iscr, Iscr, isin, isindot, isinE, isins, isinsv, isinv, it, Itilde, itilde, Iukcy, iukcy, Iuml, iuml, Jcirc, jcirc, Jcy, jcy, Jfr, jfr, jmath, Jopf, jopf, Jscr, jscr, Jsercy, jsercy, Jukcy, jukcy, Kappa, kappa, kappav, Kcedil, kcedil, Kcy, kcy, Kfr, kfr, kgreen, KHcy, khcy, KJcy, kjcy, Kopf, kopf, Kscr, kscr, lAarr, Lacute, lacute, laemptyv, lagran, Lambda, lambda, lang, Lang, langd, langle, lap, Laplacetrf, laquo, larrb, larrbfs, larr, Larr, lArr, larrfs, larrhk, larrlp, larrpl, larrsim, larrtl, latail, lAtail, lat, late, lates, lbarr, lBarr, lbbrk, lbrace, lbrack, lbrke, lbrksld, lbrkslu, Lcaron, lcaron, Lcedil, lcedil, lceil, lcub, Lcy, lcy, ldca, ldquo, ldquor, ldrdhar, ldrushar, ldsh, le, lE, LeftAngleBracket, LeftArrowBar, leftarrow, LeftArrow, Leftarrow, LeftArrowRightArrow, leftarrowtail, LeftCeiling, LeftDoubleBracket, LeftDownTeeVector, LeftDownVectorBar, LeftDownVector, LeftFloor, leftharpoondown, leftharpoonup, leftleftarrows, leftrightarrow, LeftRightArrow, Leftrightarrow, leftrightarrows, leftrightharpoons, leftrightsquigarrow, LeftRightVector, LeftTeeArrow, LeftTee, LeftTeeVector, leftthreetimes, LeftTriangleBar, LeftTriangle, LeftTriangleEqual, LeftUpDownVector, LeftUpTeeVector, LeftUpVectorBar, LeftUpVector, LeftVectorBar, LeftVector, lEg, leg, leq, leqq, leqslant, lescc, les, lesdot, lesdoto, lesdotor, lesg, lesges, lessapprox, lessdot, lesseqgtr, lesseqqgtr, LessEqualGreater, LessFullEqual, LessGreater, lessgtr, LessLess, lesssim, LessSlantEqual, LessTilde, lfisht, lfloor, Lfr, lfr, lg, lgE, lHar, lhard, lharu, lharul, lhblk, LJcy, ljcy, llarr, ll, Ll, llcorner, Lleftarrow, llhard, lltri, Lmidot, lmidot, lmoustache, lmoust, lnap, lnapprox, lne, lnE, lneq, lneqq, lnsim, loang, loarr, lobrk, longleftarrow, LongLeftArrow, Longleftarrow, longleftrightarrow, LongLeftRightArrow, Longleftrightarrow, longmapsto, longrightarrow, LongRightArrow, Longrightarrow, looparrowleft, looparrowright, lopar, Lopf, lopf, loplus, lotimes, lowast, lowbar, LowerLeftArrow, LowerRightArrow, loz, lozenge, lozf, lpar, lparlt, lrarr, lrcorner, lrhar, lrhard, lrm, lrtri, lsaquo, lscr, Lscr, lsh, Lsh, lsim, lsime, lsimg, lsqb, lsquo, lsquor, Lstrok, lstrok, ltcc, ltcir, lt, LT, Lt, ltdot, lthree, ltimes, ltlarr, ltquest, ltri, ltrie, ltrif, ltrPar, lurdshar, luruhar, lvertneqq, lvnE, macr, male, malt, maltese, Map, map, mapsto, mapstodown, mapstoleft, mapstoup, marker, mcomma, Mcy, mcy, mdash, mDDot, measuredangle, MediumSpace, Mellintrf, Mfr, mfr, mho, micro, midast, midcir, mid, middot, minusb, minus, minusd, minusdu, MinusPlus, mlcp, mldr, mnplus, models, Mopf, mopf, mp, mscr, Mscr, mstpos, Mu, mu, multimap, mumap, nabla, Nacute, nacute, nang, nap, napE, napid, napos, napprox, natural, naturals, natur, nbsp, nbump, nbumpe, ncap, Ncaron, ncaron, Ncedil, ncedil, ncong, ncongdot, ncup, Ncy, ncy, ndash, nearhk, nearr, neArr, nearrow, ne, nedot, NegativeMediumSpace, NegativeThickSpace, NegativeThinSpace, NegativeVeryThinSpace, nequiv, nesear, nesim, NestedGreaterGreater, NestedLessLess, NewLine, nexist, nexists, Nfr, nfr, ngE, nge, ngeq, ngeqq, ngeqslant, nges, nGg, ngsim, nGt, ngt, ngtr, nGtv, nharr, nhArr, nhpar, ni, nis, nisd, niv, NJcy, njcy, nlarr, nlArr, nldr, nlE, nle, nleftarrow, nLeftarrow, nleftrightarrow, nLeftrightarrow, nleq, nleqq, nleqslant, nles, nless, nLl, nlsim, nLt, nlt, nltri, nltrie, nLtv, nmid, NoBreak, NonBreakingSpace, nopf, Nopf, Not, not, NotCongruent, NotCupCap, NotDoubleVerticalBar, NotElement, NotEqual, NotEqualTilde, NotExists, NotGreater, NotGreaterEqual, NotGreaterFullEqual, NotGreaterGreater, NotGreaterLess, NotGreaterSlantEqual, NotGreaterTilde, NotHumpDownHump, NotHumpEqual, notin, notindot, notinE, notinva, notinvb, notinvc, NotLeftTriangleBar, NotLeftTriangle, NotLeftTriangleEqual, NotLess, NotLessEqual, NotLessGreater, NotLessLess, NotLessSlantEqual, NotLessTilde, NotNestedGreaterGreater, NotNestedLessLess, notni, notniva, notnivb, notnivc, NotPrecedes, NotPrecedesEqual, NotPrecedesSlantEqual, NotReverseElement, NotRightTriangleBar, NotRightTriangle, NotRightTriangleEqual, NotSquareSubset, NotSquareSubsetEqual, NotSquareSuperset, NotSquareSupersetEqual, NotSubset, NotSubsetEqual, NotSucceeds, NotSucceedsEqual, NotSucceedsSlantEqual, NotSucceedsTilde, NotSuperset, NotSupersetEqual, NotTilde, NotTildeEqual, NotTildeFullEqual, NotTildeTilde, NotVerticalBar, nparallel, npar, nparsl, npart, npolint, npr, nprcue, nprec, npreceq, npre, nrarrc, nrarr, nrArr, nrarrw, nrightarrow, nRightarrow, nrtri, nrtrie, nsc, nsccue, nsce, Nscr, nscr, nshortmid, nshortparallel, nsim, nsime, nsimeq, nsmid, nspar, nsqsube, nsqsupe, nsub, nsubE, nsube, nsubset, nsubseteq, nsubseteqq, nsucc, nsucceq, nsup, nsupE, nsupe, nsupset, nsupseteq, nsupseteqq, ntgl, Ntilde, ntilde, ntlg, ntriangleleft, ntrianglelefteq, ntriangleright, ntrianglerighteq, Nu, nu, num, numero, numsp, nvap, nvdash, nvDash, nVdash, nVDash, nvge, nvgt, nvHarr, nvinfin, nvlArr, nvle, nvlt, nvltrie, nvrArr, nvrtrie, nvsim, nwarhk, nwarr, nwArr, nwarrow, nwnear, Oacute, oacute, oast, Ocirc, ocirc, ocir, Ocy, ocy, odash, Odblac, odblac, odiv, odot, odsold, OElig, oelig, ofcir, Ofr, ofr, ogon, Ograve, ograve, ogt, ohbar, ohm, oint, olarr, olcir, olcross, oline, olt, Omacr, omacr, Omega, omega, Omicron, omicron, omid, ominus, Oopf, oopf, opar, OpenCurlyDoubleQuote, OpenCurlyQuote, operp, oplus, orarr, Or, or, ord, order, orderof, ordf, ordm, origof, oror, orslope, orv, oS, Oscr, oscr, Oslash, oslash, osol, Otilde, otilde, otimesas, Otimes, otimes, Ouml, ouml, ovbar, OverBar, OverBrace, OverBracket, OverParenthesis, para, parallel, par, parsim, parsl, part, PartialD, Pcy, pcy, percnt, period, permil, perp, pertenk, Pfr, pfr, Phi, phi, phiv, phmmat, phone, Pi, pi, pitchfork, piv, planck, planckh, plankv, plusacir, plusb, pluscir, plus, plusdo, plusdu, pluse, PlusMinus, plusmn, plussim, plustwo, pm, Poincareplane, pointint, popf, Popf, pound, prap, Pr, pr, prcue, precapprox, prec, preccurlyeq, Precedes, PrecedesEqual, PrecedesSlantEqual, PrecedesTilde, preceq, precnapprox, precneqq, precnsim, pre, prE, precsim, prime, Prime, primes, prnap, prnE, prnsim, prod, Product, profalar, profline, profsurf, prop, Proportional, Proportion, propto, prsim, prurel, Pscr, pscr, Psi, psi, puncsp, Qfr, qfr, qint, qopf, Qopf, qprime, Qscr, qscr, quaternions, quatint, quest, questeq, quot, QUOT, rAarr, race, Racute, racute, radic, raemptyv, rang, Rang, rangd, range, rangle, raquo, rarrap, rarrb, rarrbfs, rarrc, rarr, Rarr, rArr, rarrfs, rarrhk, rarrlp, rarrpl, rarrsim, Rarrtl, rarrtl, rarrw, ratail, rAtail, ratio, rationals, rbarr, rBarr, RBarr, rbbrk, rbrace, rbrack, rbrke, rbrksld, rbrkslu, Rcaron, rcaron, Rcedil, rcedil, rceil, rcub, Rcy, rcy, rdca, rdldhar, rdquo, rdquor, rdsh, real, realine, realpart, reals, Re, rect, reg, REG, ReverseElement, ReverseEquilibrium, ReverseUpEquilibrium, rfisht, rfloor, rfr, Rfr, rHar, rhard, rharu, rharul, Rho, rho, rhov, RightAngleBracket, RightArrowBar, rightarrow, RightArrow, Rightarrow, RightArrowLeftArrow, rightarrowtail, RightCeiling, RightDoubleBracket, RightDownTeeVector, RightDownVectorBar, RightDownVector, RightFloor, rightharpoondown, rightharpoonup, rightleftarrows, rightleftharpoons, rightrightarrows, rightsquigarrow, RightTeeArrow, RightTee, RightTeeVector, rightthreetimes, RightTriangleBar, RightTriangle, RightTriangleEqual, RightUpDownVector, RightUpTeeVector, RightUpVectorBar, RightUpVector, RightVectorBar, RightVector, ring, risingdotseq, rlarr, rlhar, rlm, rmoustache, rmoust, rnmid, roang, roarr, robrk, ropar, ropf, Ropf, roplus, rotimes, RoundImplies, rpar, rpargt, rppolint, rrarr, Rrightarrow, rsaquo, rscr, Rscr, rsh, Rsh, rsqb, rsquo, rsquor, rthree, rtimes, rtri, rtrie, rtrif, rtriltri, RuleDelayed, ruluhar, rx, Sacute, sacute, sbquo, scap, Scaron, scaron, Sc, sc, sccue, sce, scE, Scedil, scedil, Scirc, scirc, scnap, scnE, scnsim, scpolint, scsim, Scy, scy, sdotb, sdot, sdote, searhk, searr, seArr, searrow, sect, semi, seswar, setminus, setmn, sext, Sfr, sfr, sfrown, sharp, SHCHcy, shchcy, SHcy, shcy, ShortDownArrow, ShortLeftArrow, shortmid, shortparallel, ShortRightArrow, ShortUpArrow, shy, Sigma, sigma, sigmaf, sigmav, sim, simdot, sime, simeq, simg, simgE, siml, simlE, simne, simplus, simrarr, slarr, SmallCircle, smallsetminus, smashp, smeparsl, smid, smile, smt, smte, smtes, SOFTcy, softcy, solbar, solb, sol, Sopf, sopf, spades, spadesuit, spar, sqcap, sqcaps, sqcup, sqcups, Sqrt, sqsub, sqsube, sqsubset, sqsubseteq, sqsup, sqsupe, sqsupset, sqsupseteq, square, Square, SquareIntersection, SquareSubset, SquareSubsetEqual, SquareSuperset, SquareSupersetEqual, SquareUnion, squarf, squ, squf, srarr, Sscr, sscr, ssetmn, ssmile, sstarf, Star, star, starf, straightepsilon, straightphi, strns, sub, Sub, subdot, subE, sube, subedot, submult, subnE, subne, subplus, subrarr, subset, Subset, subseteq, subseteqq, SubsetEqual, subsetneq, subsetneqq, subsim, subsub, subsup, succapprox, succ, succcurlyeq, Succeeds, SucceedsEqual, SucceedsSlantEqual, SucceedsTilde, succeq, succnapprox, succneqq, succnsim, succsim, SuchThat, sum, Sum, sung, sup1, sup2, sup3, sup, Sup, supdot, supdsub, supE, supe, supedot, Superset, SupersetEqual, suphsol, suphsub, suplarr, supmult, supnE, supne, supplus, supset, Supset, supseteq, supseteqq, supsetneq, supsetneqq, supsim, supsub, supsup, swarhk, swarr, swArr, swarrow, swnwar, szlig, Tab, target, Tau, tau, tbrk, Tcaron, tcaron, Tcedil, tcedil, Tcy, tcy, tdot, telrec, Tfr, tfr, there4, therefore, Therefore, Theta, theta, thetasym, thetav, thickapprox, thicksim, ThickSpace, ThinSpace, thinsp, thkap, thksim, THORN, thorn, tilde, Tilde, TildeEqual, TildeFullEqual, TildeTilde, timesbar, timesb, times, timesd, tint, toea, topbot, topcir, top, Topf, topf, topfork, tosa, tprime, trade, TRADE, triangle, triangledown, triangleleft, trianglelefteq, triangleq, triangleright, trianglerighteq, tridot, trie, triminus, TripleDot, triplus, trisb, tritime, trpezium, Tscr, tscr, TScy, tscy, TSHcy, tshcy, Tstrok, tstrok, twixt, twoheadleftarrow, twoheadrightarrow, Uacute, uacute, uarr, Uarr, uArr, Uarrocir, Ubrcy, ubrcy, Ubreve, ubreve, Ucirc, ucirc, Ucy, ucy, udarr, Udblac, udblac, udhar, ufisht, Ufr, ufr, Ugrave, ugrave, uHar, uharl, uharr, uhblk, ulcorn, ulcorner, ulcrop, ultri, Umacr, umacr, uml, UnderBar, UnderBrace, UnderBracket, UnderParenthesis, Union, UnionPlus, Uogon, uogon, Uopf, uopf, UpArrowBar, uparrow, UpArrow, Uparrow, UpArrowDownArrow, updownarrow, UpDownArrow, Updownarrow, UpEquilibrium, upharpoonleft, upharpoonright, uplus, UpperLeftArrow, UpperRightArrow, upsi, Upsi, upsih, Upsilon, upsilon, UpTeeArrow, UpTee, upuparrows, urcorn, urcorner, urcrop, Uring, uring, urtri, Uscr, uscr, utdot, Utilde, utilde, utri, utrif, uuarr, Uuml, uuml, uwangle, vangrt, varepsilon, varkappa, varnothing, varphi, varpi, varpropto, varr, vArr, varrho, varsigma, varsubsetneq, varsubsetneqq, varsupsetneq, varsupsetneqq, vartheta, vartriangleleft, vartriangleright, vBar, Vbar, vBarv, Vcy, vcy, vdash, vDash, Vdash, VDash, Vdashl, veebar, vee, Vee, veeeq, vellip, verbar, Verbar, vert, Vert, VerticalBar, VerticalLine, VerticalSeparator, VerticalTilde, VeryThinSpace, Vfr, vfr, vltri, vnsub, vnsup, Vopf, vopf, vprop, vrtri, Vscr, vscr, vsubnE, vsubne, vsupnE, vsupne, Vvdash, vzigzag, Wcirc, wcirc, wedbar, wedge, Wedge, wedgeq, weierp, Wfr, wfr, Wopf, wopf, wp, wr, wreath, Wscr, wscr, xcap, xcirc, xcup, xdtri, Xfr, xfr, xharr, xhArr, Xi, xi, xlarr, xlArr, xmap, xnis, xodot, Xopf, xopf, xoplus, xotime, xrarr, xrArr, Xscr, xscr, xsqcup, xuplus, xutri, xvee, xwedge, Yacute, yacute, YAcy, yacy, Ycirc, ycirc, Ycy, ycy, yen, Yfr, yfr, YIcy, yicy, Yopf, yopf, Yscr, yscr, YUcy, yucy, yuml, Yuml, Zacute, zacute, Zcaron, zcaron, Zcy, zcy, Zdot, zdot, zeetrf, ZeroWidthSpace, Zeta, zeta, zfr, Zfr, ZHcy, zhcy, zigrarr, zopf, Zopf, Zscr, zscr, zwj, zwnj, default */
/***/ (function(module) {

module.exports = {"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\"","QUOT":"\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"};

/***/ }),

/***/ "./node_modules/linkify-it/index.js":
/*!******************************************!*\
  !*** ./node_modules/linkify-it/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 ////////////////////////////////////////////////////////////////////////////////
// Helpers
// Merge objects
//

function assign(obj
/*from1, from2, from3, ...*/
) {
  var sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });
  return obj;
}

function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

function isObject(obj) {
  return _class(obj) === '[object Object]';
}

function isRegExp(obj) {
  return _class(obj) === '[object RegExp]';
}

function isFunction(obj) {
  return _class(obj) === '[object Function]';
}

function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&');
} ////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};

function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}

var defaultSchemas = {
  'http:': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http = new RegExp('^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i');
      }

      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }

      return 0;
    }
  },
  'https:': 'http:',
  'ftp:': 'http:',
  '//': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http = new RegExp('^' + self.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
        // with code comments
        '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' + self.re.src_port + self.re.src_host_terminator + self.re.src_path, 'i');
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') {
          return 0;
        }

        if (pos >= 3 && text[pos - 3] === '/') {
          return 0;
        }

        return tail.match(self.re.no_http)[0].length;
      }

      return 0;
    }
  },
  'mailto:': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto = new RegExp('^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i');
      }

      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }

      return 0;
    }
  }
};
/*eslint-disable max-len*/
// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)

var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]'; // DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead

var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');
/*eslint-enable max-len*/
////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__ = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }

    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
} // Schemas compiler. Build regexps.
//


function compile(self) {
  // Load & clone RE patterns.
  var re = self.re = __webpack_require__(/*! ./lib/re */ "./node_modules/linkify-it/lib/re.js")(self.__opts__); // Define dynamic patterns


  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }

  tlds.push(re.src_xn);
  re.src_tlds = tlds.join('|');

  function untpl(tpl) {
    return tpl.replace('%TLDS%', re.src_tlds);
  }

  re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), 'i');
  re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), 'i');
  re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), 'i');
  re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), 'i'); //
  // Compile each schema
  //

  var aliases = [];
  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name]; // skip disabled methods

    if (val === null) {
      return;
    }

    var compiled = {
      validate: null,
      link: null
    };
    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  }); //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate = self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize = self.__compiled__[self.__schemas__[alias]].normalize;
  }); //
  // Fake record for guessed links
  //

  self.__compiled__[''] = {
    validate: null,
    normalize: createNormalizer()
  }; //
  // Build schema condition
  //

  var slist = Object.keys(self.__compiled__).filter(function (name) {
    // Filter disabled & fake schemas
    return name.length > 0 && self.__compiled__[name];
  }).map(escapeRE).join('|'); // (?!_) cause 1.5x slowdown

  self.re.schema_test = RegExp('(^|(?!_)(?:[><\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uff5c]|' + re.src_ZPCc + '))(' + slist + ')', 'ig');
  self.re.pretest = RegExp('(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@', 'i'); //
  // Cleanup
  //

  resetScanCache(self);
}
/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/


function Match(self, shift) {
  var start = self.__index__,
      end = self.__last_index__,
      text = self.__text_cache__.slice(start, end);
  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/


  this.schema = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/

  this.index = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/

  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/

  this.raw = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/

  this.text = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/

  this.url = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}
/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/


function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__ = assign({}, defaultOptions, options); // Cache last tested result. Used to skip repeating steps on next `match` call.

  this.__index__ = -1;
  this.__last_index__ = -1; // Next scan position

  this.__schema__ = '';
  this.__text_cache__ = '';
  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/


LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};
/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/


LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};
/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/


LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__ = -1;

  if (!text.length) {
    return false;
  }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos; // try to scan for link with schema - that's the most simple rule

  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;

    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);

      if (len) {
        this.__schema__ = m[2];
        this.__index__ = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);

    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = '';
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');

    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = 'mailto:';
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};
/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/


LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};
/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/


LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }

  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};
/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/


LinkifyIt.prototype.match = function match(text) {
  var shift = 0,
      result = []; // Try to take previous element from cache, if .test() called before

  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  } // Cut head if cache was used


  var tail = shift ? text.slice(shift) : text; // Scan string until end reached

  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};
/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/


LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [list];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list).sort().filter(function (el, idx, arr) {
    return el !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/


LinkifyIt.prototype.normalize = function normalize(match) {
  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1
  if (!match.schema) {
    match.url = 'http://' + match.url;
  }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};
/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/


LinkifyIt.prototype.onCompile = function onCompile() {};

module.exports = LinkifyIt;

/***/ }),

/***/ "./node_modules/linkify-it/lib/re.js":
/*!*******************************************!*\
  !*** ./node_modules/linkify-it/lib/re.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (opts) {
  var re = {}; // Use direct extract instead of `regenerate` to reduse browserified size

  re.src_Any = __webpack_require__(/*! uc.micro/properties/Any/regex */ "./node_modules/uc.micro/properties/Any/regex.js").source;
  re.src_Cc = __webpack_require__(/*! uc.micro/categories/Cc/regex */ "./node_modules/uc.micro/categories/Cc/regex.js").source;
  re.src_Z = __webpack_require__(/*! uc.micro/categories/Z/regex */ "./node_modules/uc.micro/categories/Z/regex.js").source;
  re.src_P = __webpack_require__(/*! uc.micro/categories/P/regex */ "./node_modules/uc.micro/categories/P/regex.js").source; // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)

  re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join('|'); // \p{\Z\Cc} (white spaces + control)

  re.src_ZCc = [re.src_Z, re.src_Cc].join('|'); // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text

  var text_separators = '[><\uff5c]'; // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)

  re.src_pseudo_letter = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')'; // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';
  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 = '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)'; // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.

  re.src_auth = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';
  re.src_port = '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';
  re.src_host_terminator = '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';
  re.src_path = '(?:' + '[/?#]' + '(?:' + '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' + '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' + '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' + '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' + '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' + "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" + "\\'(?=" + re.src_pseudo_letter + '|[-]).|' + // allow `I'm_king` if no pair found
  '\\.{2,3}[a-zA-Z0-9%/]|' + // github has ... in commit range links. Restrict to
  // - english
  // - percent-encoded
  // - parts of file path
  // until more examples found.
  '\\.(?!' + re.src_ZCc + '|[.]).|' + (opts && opts['---'] ? '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
  : '\\-+|') + '\\,(?!' + re.src_ZCc + ').|' + // allow `,,,` in paths
  '\\!(?!' + re.src_ZCc + '|[!]).|' + '\\?(?!' + re.src_ZCc + '|[?]).' + ')+' + '|\\/' + ')?';
  re.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+';
  re.src_xn = 'xn--[a-z0-9\\-]{1,59}'; // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root = // Allow letters & digits (http://test1)
  '(?:' + re.src_xn + '|' + re.src_pseudo_letter + '{1,63}' + ')';
  re.src_domain = '(?:' + re.src_xn + '|' + '(?:' + re.src_pseudo_letter + ')' + '|' + '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' + ')';
  re.src_host = '(?:' + // Don't need IP check, because digits are already allowed in normal domain names
  //   src_ip4 +
  // '|' +
  '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain
  /*_root*/
  + ')' + ')';
  re.tpl_host_fuzzy = '(?:' + re.src_ip4 + '|' + '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' + ')';
  re.tpl_host_no_ip_fuzzy = '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';
  re.src_host_strict = re.src_host + re.src_host_terminator;
  re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
  re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
  re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
  re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator; ////////////////////////////////////////////////////////////////////////////////
  // Main rules
  // Rude test fuzzy links by host, for quick deny

  re.tpl_host_fuzzy_test = 'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';
  re.tpl_email_fuzzy = '(^|' + text_separators + '|\\(|' + re.src_ZCc + ')(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';
  re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';
  re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
  // but can start with > (markdown blockquote)
  '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' + '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';
  return re;
};

/***/ }),

/***/ "./node_modules/markdown-it/index.js":
/*!*******************************************!*\
  !*** ./node_modules/markdown-it/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(/*! ./lib/ */ "./node_modules/markdown-it/lib/index.js");

/***/ }),

/***/ "./node_modules/markdown-it/lib/common/entities.js":
/*!*********************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/entities.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML5 entities map: { name -> utf16string }
//

/*eslint quotes:0*/

module.exports = __webpack_require__(/*! entities/maps/entities.json */ "./node_modules/entities/maps/entities.json");

/***/ }),

/***/ "./node_modules/markdown-it/lib/common/html_blocks.js":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/html_blocks.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// List of valid html blocks names, accorting to commonmark spec
// http://jgm.github.io/CommonMark/spec.html#html-blocks


module.exports = ['address', 'article', 'aside', 'base', 'basefont', 'blockquote', 'body', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dialog', 'dir', 'div', 'dl', 'dt', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hr', 'html', 'iframe', 'legend', 'li', 'link', 'main', 'menu', 'menuitem', 'meta', 'nav', 'noframes', 'ol', 'optgroup', 'option', 'p', 'param', 'section', 'source', 'summary', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul'];

/***/ }),

/***/ "./node_modules/markdown-it/lib/common/html_re.js":
/*!********************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/html_re.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Regexps to match html elements


var attr_name = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
var unquoted = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';
var attribute = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';
var open_tag = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';
var close_tag = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing = '<[?].*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';
var HTML_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');
module.exports.HTML_TAG_RE = HTML_TAG_RE;
module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;

/***/ }),

/***/ "./node_modules/markdown-it/lib/common/utils.js":
/*!******************************************************!*\
  !*** ./node_modules/markdown-it/lib/common/utils.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Utilities
//


function _class(obj) {
  return Object.prototype.toString.call(obj);
}

function isString(obj) {
  return _class(obj) === '[object String]';
}

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
} // Merge objects
//


function assign(obj
/*from1, from2, from3, ...*/
) {
  var sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function (source) {
    if (!source) {
      return;
    }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });
  return obj;
} // Remove element from array and put another array at those position.
// Useful for some operations with tokens


function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
} ////////////////////////////////////////////////////////////////////////////////


function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) {
    return false;
  } // never used


  if (c >= 0xFDD0 && c <= 0xFDEF) {
    return false;
  }

  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {
    return false;
  } // control codes


  if (c >= 0x00 && c <= 0x08) {
    return false;
  }

  if (c === 0x0B) {
    return false;
  }

  if (c >= 0x0E && c <= 0x1F) {
    return false;
  }

  if (c >= 0x7F && c <= 0x9F) {
    return false;
  } // out of range


  if (c > 0x10FFFF) {
    return false;
  }

  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);
    return String.fromCharCode(surrogate1, surrogate2);
  }

  return String.fromCharCode(c);
}

var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');
var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;

var entities = __webpack_require__(/*! ./entities */ "./node_modules/markdown-it/lib/common/entities.js");

function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23
  /* # */
  && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);

    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}
/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/


function unescapeMd(str) {
  if (str.indexOf('\\') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) {
    return str;
  }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) {
      return escaped;
    }

    return replaceEntityPattern(match, entity);
  });
} ////////////////////////////////////////////////////////////////////////////////


var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }

  return str;
} ////////////////////////////////////////////////////////////////////////////////


var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
} ////////////////////////////////////////////////////////////////////////////////


function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }

  return false;
} // Zs (unicode class) || [\t\f\v\r\n]


function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) {
    return true;
  }

  switch (code) {
    case 0x09: // \t

    case 0x0A: // \n

    case 0x0B: // \v

    case 0x0C: // \f

    case 0x0D: // \r

    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }

  return false;
} ////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/


var UNICODE_PUNCT_RE = __webpack_require__(/*! uc.micro/categories/P/regex */ "./node_modules/uc.micro/categories/P/regex.js"); // Currently without astral characters support.


function isPunctChar(ch) {
  return UNICODE_PUNCT_RE.test(ch);
} // Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//


function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21
    /* ! */
    :
    case 0x22
    /* " */
    :
    case 0x23
    /* # */
    :
    case 0x24
    /* $ */
    :
    case 0x25
    /* % */
    :
    case 0x26
    /* & */
    :
    case 0x27
    /* ' */
    :
    case 0x28
    /* ( */
    :
    case 0x29
    /* ) */
    :
    case 0x2A
    /* * */
    :
    case 0x2B
    /* + */
    :
    case 0x2C
    /* , */
    :
    case 0x2D
    /* - */
    :
    case 0x2E
    /* . */
    :
    case 0x2F
    /* / */
    :
    case 0x3A
    /* : */
    :
    case 0x3B
    /* ; */
    :
    case 0x3C
    /* < */
    :
    case 0x3D
    /* = */
    :
    case 0x3E
    /* > */
    :
    case 0x3F
    /* ? */
    :
    case 0x40
    /* @ */
    :
    case 0x5B
    /* [ */
    :
    case 0x5C
    /* \ */
    :
    case 0x5D
    /* ] */
    :
    case 0x5E
    /* ^ */
    :
    case 0x5F
    /* _ */
    :
    case 0x60
    /* ` */
    :
    case 0x7B
    /* { */
    :
    case 0x7C
    /* | */
    :
    case 0x7D
    /* } */
    :
    case 0x7E
    /* ~ */
    :
      return true;

    default:
      return false;
  }
} // Hepler to unify [reference labels].
//


function normalizeReference(str) {
  // use .toUpperCase() instead of .toLowerCase()
  // here to avoid a conflict with Object.prototype
  // members (most notably, `__proto__`)
  return str.trim().replace(/\s+/g, ' ').toUpperCase();
} ////////////////////////////////////////////////////////////////////////////////
// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//


exports.lib = {};
exports.lib.mdurl = __webpack_require__(/*! mdurl */ "./node_modules/mdurl/index.js");
exports.lib.ucmicro = __webpack_require__(/*! uc.micro */ "./node_modules/uc.micro/index.js");
exports.assign = assign;
exports.isString = isString;
exports.has = has;
exports.unescapeMd = unescapeMd;
exports.unescapeAll = unescapeAll;
exports.isValidEntityCode = isValidEntityCode;
exports.fromCodePoint = fromCodePoint; // exports.replaceEntities     = replaceEntities;

exports.escapeHtml = escapeHtml;
exports.arrayReplaceAt = arrayReplaceAt;
exports.isSpace = isSpace;
exports.isWhiteSpace = isWhiteSpace;
exports.isMdAsciiPunct = isMdAsciiPunct;
exports.isPunctChar = isPunctChar;
exports.escapeRE = escapeRE;
exports.normalizeReference = normalizeReference;

/***/ }),

/***/ "./node_modules/markdown-it/lib/helpers/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Just a shortcut for bulk export


exports.parseLinkLabel = __webpack_require__(/*! ./parse_link_label */ "./node_modules/markdown-it/lib/helpers/parse_link_label.js");
exports.parseLinkDestination = __webpack_require__(/*! ./parse_link_destination */ "./node_modules/markdown-it/lib/helpers/parse_link_destination.js");
exports.parseLinkTitle = __webpack_require__(/*! ./parse_link_title */ "./node_modules/markdown-it/lib/helpers/parse_link_title.js");

/***/ }),

/***/ "./node_modules/markdown-it/lib/helpers/parse_link_destination.js":
/*!************************************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/parse_link_destination.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link destination
//


var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;

var unescapeAll = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").unescapeAll;

module.exports = function parseLinkDestination(str, pos, max) {
  var code,
      level,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (str.charCodeAt(pos) === 0x3C
  /* < */
  ) {
      pos++;

      while (pos < max) {
        code = str.charCodeAt(pos);

        if (code === 0x0A
        /* \n */
        || isSpace(code)) {
          return result;
        }

        if (code === 0x3E
        /* > */
        ) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }

        if (code === 0x5C
        /* \ */
        && pos + 1 < max) {
          pos += 2;
          continue;
        }

        pos++;
      } // no closing '>'


      return result;
    } // this should be ... } else { ... branch


  level = 0;

  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) {
      break;
    } // ascii control characters


    if (code < 0x20 || code === 0x7F) {
      break;
    }

    if (code === 0x5C
    /* \ */
    && pos + 1 < max) {
      pos += 2;
      continue;
    }

    if (code === 0x28
    /* ( */
    ) {
        level++;
      }

    if (code === 0x29
    /* ) */
    ) {
        if (level === 0) {
          break;
        }

        level--;
      }

    pos++;
  }

  if (start === pos) {
    return result;
  }

  if (level !== 0) {
    return result;
  }

  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/helpers/parse_link_label.js":
/*!******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/parse_link_label.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link label
//
// this function assumes that first character ("[") already matches;
// returns the end of the label
//


module.exports = function parseLinkLabel(state, start, disableNested) {
  var level,
      found,
      marker,
      prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;
  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);

    if (marker === 0x5D
    /* ] */
    ) {
        level--;

        if (level === 0) {
          found = true;
          break;
        }
      }

    prevPos = state.pos;
    state.md.inline.skipToken(state);

    if (marker === 0x5B
    /* [ */
    ) {
        if (prevPos === state.pos - 1) {
          // increase level if we find text `[`, which is not a part of any token
          level++;
        } else if (disableNested) {
          state.pos = oldPos;
          return -1;
        }
      }
  }

  if (found) {
    labelEnd = state.pos;
  } // restore old state


  state.pos = oldPos;
  return labelEnd;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/helpers/parse_link_title.js":
/*!******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/helpers/parse_link_title.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse link title
//


var unescapeAll = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").unescapeAll;

module.exports = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ''
  };

  if (pos >= max) {
    return result;
  }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22
  /* " */
  && marker !== 0x27
  /* ' */
  && marker !== 0x28
  /* ( */
  ) {
      return result;
    }

  pos++; // if opening marker is "(", switch it to closing marker ")"

  if (marker === 0x28) {
    marker = 0x29;
  }

  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C
    /* \ */
    && pos + 1 < max) {
      pos++;

      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/index.js":
/*!***********************************************!*\
  !*** ./node_modules/markdown-it/lib/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Main parser class


var utils = __webpack_require__(/*! ./common/utils */ "./node_modules/markdown-it/lib/common/utils.js");

var helpers = __webpack_require__(/*! ./helpers */ "./node_modules/markdown-it/lib/helpers/index.js");

var Renderer = __webpack_require__(/*! ./renderer */ "./node_modules/markdown-it/lib/renderer.js");

var ParserCore = __webpack_require__(/*! ./parser_core */ "./node_modules/markdown-it/lib/parser_core.js");

var ParserBlock = __webpack_require__(/*! ./parser_block */ "./node_modules/markdown-it/lib/parser_block.js");

var ParserInline = __webpack_require__(/*! ./parser_inline */ "./node_modules/markdown-it/lib/parser_inline.js");

var LinkifyIt = __webpack_require__(/*! linkify-it */ "./node_modules/linkify-it/index.js");

var mdurl = __webpack_require__(/*! mdurl */ "./node_modules/mdurl/index.js");

var punycode = __webpack_require__(/*! punycode */ "./node_modules/node-libs-browser/node_modules/punycode/punycode.js");

var config = {
  'default': __webpack_require__(/*! ./presets/default */ "./node_modules/markdown-it/lib/presets/default.js"),
  zero: __webpack_require__(/*! ./presets/zero */ "./node_modules/markdown-it/lib/presets/zero.js"),
  commonmark: __webpack_require__(/*! ./presets/commonmark */ "./node_modules/markdown-it/lib/presets/commonmark.js")
}; ////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
} ////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = ['http:', 'https:', 'mailto:'];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {
        /**/
      }
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {
        /**/
      }
    }
  }

  return mdurl.decode(mdurl.format(parsed));
}
/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/


function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }
  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/


  this.inline = new ParserInline();
  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/

  this.block = new ParserBlock();
  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/

  this.core = new ParserCore();
  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/

  this.renderer = new Renderer();
  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/

  this.linkify = new LinkifyIt();
  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/

  this.validateLink = validateLink;
  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/

  this.normalizeLink = normalizeLink;
  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/

  this.normalizeLinkText = normalizeLinkText; // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/

  this.utils = utils;
  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/

  this.helpers = utils.assign({}, helpers);
  this.options = {};
  this.configure(presetName);

  if (options) {
    this.set(options);
  }
}
/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/


MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};
/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you with - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/


MarkdownIt.prototype.configure = function (presets) {
  var self = this,
      presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];

    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }

  if (!presets) {
    throw new Error('Wrong `markdown-it` preset, can\'t be empty');
  }

  if (presets.options) {
    self.set(presets.options);
  }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }

      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }

  return this;
};
/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/


MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list, true));
  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};
/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/


MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) {
    list = [list];
  }

  ['core', 'block', 'inline'].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list, true));
  var missed = list.filter(function (name) {
    return result.indexOf(name) < 0;
  });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }

  return this;
};
/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/


MarkdownIt.prototype.use = function (plugin
/*, params, ... */
) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};
/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and returns list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/


MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);
  this.core.process(state);
  return state.tokens;
};
/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/


MarkdownIt.prototype.render = function (src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/


MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/


MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};

module.exports = MarkdownIt;

/***/ }),

/***/ "./node_modules/markdown-it/lib/parser_block.js":
/*!******************************************************!*\
  !*** ./node_modules/markdown-it/lib/parser_block.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/


var Ruler = __webpack_require__(/*! ./ruler */ "./node_modules/markdown-it/lib/ruler.js");

var _rules = [// First 2 params - rule name & source. Secondary array - list of rules,
// which can be terminated by this one.
['table', __webpack_require__(/*! ./rules_block/table */ "./node_modules/markdown-it/lib/rules_block/table.js"), ['paragraph', 'reference']], ['code', __webpack_require__(/*! ./rules_block/code */ "./node_modules/markdown-it/lib/rules_block/code.js")], ['fence', __webpack_require__(/*! ./rules_block/fence */ "./node_modules/markdown-it/lib/rules_block/fence.js"), ['paragraph', 'reference', 'blockquote', 'list']], ['blockquote', __webpack_require__(/*! ./rules_block/blockquote */ "./node_modules/markdown-it/lib/rules_block/blockquote.js"), ['paragraph', 'reference', 'blockquote', 'list']], ['hr', __webpack_require__(/*! ./rules_block/hr */ "./node_modules/markdown-it/lib/rules_block/hr.js"), ['paragraph', 'reference', 'blockquote', 'list']], ['list', __webpack_require__(/*! ./rules_block/list */ "./node_modules/markdown-it/lib/rules_block/list.js"), ['paragraph', 'reference', 'blockquote']], ['reference', __webpack_require__(/*! ./rules_block/reference */ "./node_modules/markdown-it/lib/rules_block/reference.js")], ['heading', __webpack_require__(/*! ./rules_block/heading */ "./node_modules/markdown-it/lib/rules_block/heading.js"), ['paragraph', 'reference', 'blockquote']], ['lheading', __webpack_require__(/*! ./rules_block/lheading */ "./node_modules/markdown-it/lib/rules_block/lheading.js")], ['html_block', __webpack_require__(/*! ./rules_block/html_block */ "./node_modules/markdown-it/lib/rules_block/html_block.js"), ['paragraph', 'reference', 'blockquote']], ['paragraph', __webpack_require__(/*! ./rules_block/paragraph */ "./node_modules/markdown-it/lib/rules_block/paragraph.js")]];
/**
 * new ParserBlock()
 **/

function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1], {
      alt: (_rules[i][2] || []).slice()
    });
  }
} // Generate tokens for input range
//


ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);

    if (line >= endLine) {
      break;
    } // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists


    if (state.sCount[line] < state.blkIndent) {
      break;
    } // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.


    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    } // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true


    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);

      if (ok) {
        break;
      }
    } // set state.tight if we had an empty line before current tag
    // i.e. latest empty line should not count


    state.tight = !hasEmptyLines; // paragraph might "eat" one newline after it in nested lists

    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};
/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/


ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) {
    return;
  }

  state = new this.State(src, md, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};

ParserBlock.prototype.State = __webpack_require__(/*! ./rules_block/state_block */ "./node_modules/markdown-it/lib/rules_block/state_block.js");
module.exports = ParserBlock;

/***/ }),

/***/ "./node_modules/markdown-it/lib/parser_core.js":
/*!*****************************************************!*\
  !*** ./node_modules/markdown-it/lib/parser_core.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class Core
 *
 * Top-level rules executor. Glues block/inline parsers and does intermediate
 * transformations.
 **/


var Ruler = __webpack_require__(/*! ./ruler */ "./node_modules/markdown-it/lib/ruler.js");

var _rules = [['normalize', __webpack_require__(/*! ./rules_core/normalize */ "./node_modules/markdown-it/lib/rules_core/normalize.js")], ['block', __webpack_require__(/*! ./rules_core/block */ "./node_modules/markdown-it/lib/rules_core/block.js")], ['inline', __webpack_require__(/*! ./rules_core/inline */ "./node_modules/markdown-it/lib/rules_core/inline.js")], ['linkify', __webpack_require__(/*! ./rules_core/linkify */ "./node_modules/markdown-it/lib/rules_core/linkify.js")], ['replacements', __webpack_require__(/*! ./rules_core/replacements */ "./node_modules/markdown-it/lib/rules_core/replacements.js")], ['smartquotes', __webpack_require__(/*! ./rules_core/smartquotes */ "./node_modules/markdown-it/lib/rules_core/smartquotes.js")]];
/**
 * new Core()
 **/

function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new Ruler();

  for (var i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
}
/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/


Core.prototype.process = function (state) {
  var i, l, rules;
  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = __webpack_require__(/*! ./rules_core/state_core */ "./node_modules/markdown-it/lib/rules_core/state_core.js");
module.exports = Core;

/***/ }),

/***/ "./node_modules/markdown-it/lib/parser_inline.js":
/*!*******************************************************!*\
  !*** ./node_modules/markdown-it/lib/parser_inline.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/


var Ruler = __webpack_require__(/*! ./ruler */ "./node_modules/markdown-it/lib/ruler.js"); ////////////////////////////////////////////////////////////////////////////////
// Parser rules


var _rules = [['text', __webpack_require__(/*! ./rules_inline/text */ "./node_modules/markdown-it/lib/rules_inline/text.js")], ['newline', __webpack_require__(/*! ./rules_inline/newline */ "./node_modules/markdown-it/lib/rules_inline/newline.js")], ['escape', __webpack_require__(/*! ./rules_inline/escape */ "./node_modules/markdown-it/lib/rules_inline/escape.js")], ['backticks', __webpack_require__(/*! ./rules_inline/backticks */ "./node_modules/markdown-it/lib/rules_inline/backticks.js")], ['strikethrough', __webpack_require__(/*! ./rules_inline/strikethrough */ "./node_modules/markdown-it/lib/rules_inline/strikethrough.js").tokenize], ['emphasis', __webpack_require__(/*! ./rules_inline/emphasis */ "./node_modules/markdown-it/lib/rules_inline/emphasis.js").tokenize], ['link', __webpack_require__(/*! ./rules_inline/link */ "./node_modules/markdown-it/lib/rules_inline/link.js")], ['image', __webpack_require__(/*! ./rules_inline/image */ "./node_modules/markdown-it/lib/rules_inline/image.js")], ['autolink', __webpack_require__(/*! ./rules_inline/autolink */ "./node_modules/markdown-it/lib/rules_inline/autolink.js")], ['html_inline', __webpack_require__(/*! ./rules_inline/html_inline */ "./node_modules/markdown-it/lib/rules_inline/html_inline.js")], ['entity', __webpack_require__(/*! ./rules_inline/entity */ "./node_modules/markdown-it/lib/rules_inline/entity.js")]];
var _rules2 = [['balance_pairs', __webpack_require__(/*! ./rules_inline/balance_pairs */ "./node_modules/markdown-it/lib/rules_inline/balance_pairs.js")], ['strikethrough', __webpack_require__(/*! ./rules_inline/strikethrough */ "./node_modules/markdown-it/lib/rules_inline/strikethrough.js").postProcess], ['emphasis', __webpack_require__(/*! ./rules_inline/emphasis */ "./node_modules/markdown-it/lib/rules_inline/emphasis.js").postProcess], ['text_collapse', __webpack_require__(/*! ./rules_inline/text_collapse */ "./node_modules/markdown-it/lib/rules_inline/text_collapse.js")]];
/**
 * new ParserInline()
 **/

function ParserInline() {
  var i;
  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/

  this.ruler = new Ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/


  this.ruler2 = new Ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
} // Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//


ParserInline.prototype.skipToken = function (state) {
  var ok,
      i,
      pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;

  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) {
        break;
      }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) {
    state.pos++;
  }

  cache[pos] = state.pos;
}; // Generate tokens for input range
//


ParserInline.prototype.tokenize = function (state) {
  var ok,
      i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true
    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);

        if (ok) {
          break;
        }
      }
    }

    if (ok) {
      if (state.pos >= end) {
        break;
      }

      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};
/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/


ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);
  this.tokenize(state);
  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};

ParserInline.prototype.State = __webpack_require__(/*! ./rules_inline/state_inline */ "./node_modules/markdown-it/lib/rules_inline/state_inline.js");
module.exports = ParserInline;

/***/ }),

/***/ "./node_modules/markdown-it/lib/presets/commonmark.js":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/presets/commonmark.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Commonmark default options


module.exports = {
  options: {
    html: true,
    // Enable HTML tags in source
    xhtmlOut: true,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-',
    // CSS language prefix for fenced blocks
    linkify: false,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019',

    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20 // Internal protection, recursion limit

  },
  components: {
    core: {
      rules: ['normalize', 'block', 'inline']
    },
    block: {
      rules: ['blockquote', 'code', 'fence', 'heading', 'hr', 'html_block', 'lheading', 'list', 'reference', 'paragraph']
    },
    inline: {
      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'html_inline', 'image', 'link', 'newline', 'text'],
      rules2: ['balance_pairs', 'emphasis', 'text_collapse']
    }
  }
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/presets/default.js":
/*!*********************************************************!*\
  !*** ./node_modules/markdown-it/lib/presets/default.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// markdown-it default options


module.exports = {
  options: {
    html: false,
    // Enable HTML tags in source
    xhtmlOut: false,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-',
    // CSS language prefix for fenced blocks
    linkify: false,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019',

    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 100 // Internal protection, recursion limit

  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/presets/zero.js":
/*!******************************************************!*\
  !*** ./node_modules/markdown-it/lib/presets/zero.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// "Zero" preset, with nothing enabled. Useful for manual configuring of simple
// modes. For example, to parse bold/italic only.


module.exports = {
  options: {
    html: false,
    // Enable HTML tags in source
    xhtmlOut: false,
    // Use '/' to close single tags (<br />)
    breaks: false,
    // Convert '\n' in paragraphs into <br>
    langPrefix: 'language-',
    // CSS language prefix for fenced blocks
    linkify: false,
    // autoconvert URL-like texts to links
    // Enable some language-neutral replacements + quotes beautification
    typographer: false,
    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019',

    /* “”‘’ */
    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,
    maxNesting: 20 // Internal protection, recursion limit

  },
  components: {
    core: {
      rules: ['normalize', 'block', 'inline']
    },
    block: {
      rules: ['paragraph']
    },
    inline: {
      rules: ['text'],
      rules2: ['balance_pairs', 'text_collapse']
    }
  }
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/renderer.js":
/*!**************************************************!*\
  !*** ./node_modules/markdown-it/lib/renderer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/


var assign = __webpack_require__(/*! ./common/utils */ "./node_modules/markdown-it/lib/common/utils.js").assign;

var unescapeAll = __webpack_require__(/*! ./common/utils */ "./node_modules/markdown-it/lib/common/utils.js").unescapeAll;

var escapeHtml = __webpack_require__(/*! ./common/utils */ "./node_modules/markdown-it/lib/common/utils.js").escapeHtml; ////////////////////////////////////////////////////////////////////////////////


var default_rules = {};

default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];
  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(tokens[idx].content) + '</code>';
};

default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];
  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\n';
};

default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      highlighted,
      i,
      tmpAttrs,
      tmpToken;

  if (info) {
    langName = info.split(/\s+/g)[0];
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  } // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .clone() for token and simplify this part, but
  // now we prefer to keep things local.


  if (info) {
    i = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push(['class', options.langPrefix + langName]);
    } else {
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    } // Fake token just to render attributes


    tmpToken = {
      attrs: tmpAttrs
    };
    return '<pre><code' + slf.renderAttrs(tmpToken) + '>' + highlighted + '</code></pre>\n';
  }

  return '<pre><code' + slf.renderAttrs(token) + '>' + highlighted + '</code></pre>\n';
};

default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx]; // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);
  return slf.renderToken(tokens, idx, options);
};

default_rules.hardbreak = function (tokens, idx, options
/*, env */
) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};

default_rules.softbreak = function (tokens, idx, options
/*, env */
) {
  return options.breaks ? options.xhtmlOut ? '<br />\n' : '<br>\n' : '\n';
};

default_rules.text = function (tokens, idx
/*, options, env */
) {
  return escapeHtml(tokens[idx].content);
};

default_rules.html_block = function (tokens, idx
/*, options, env */
) {
  return tokens[idx].content;
};

default_rules.html_inline = function (tokens, idx
/*, options, env */
) {
  return tokens[idx].content;
};
/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/


function Renderer() {
  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independent static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign({}, default_rules);
}
/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/


Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) {
    return '';
  }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};
/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/


Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx]; // Tight list paragraphs

  if (token.hidden) {
    return '';
  } // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //


  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  } // Add token name, e.g. `<img`


  result += (token.nesting === -1 ? '</' : '<') + token.tag; // Encode attributes, e.g. `<img src="foo"`

  result += this.renderAttrs(token); // Add a slash for self-closing tags, e.g. `<img src="foo" /`

  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  } // Check if we need to add a newline after this tag


  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';
  return result;
};
/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/


Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};
/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/


Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};
/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/


Renderer.prototype.render = function (tokens, options, env) {
  var i,
      len,
      type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

module.exports = Renderer;

/***/ }),

/***/ "./node_modules/markdown-it/lib/ruler.js":
/*!***********************************************!*\
  !*** ./node_modules/markdown-it/lib/ruler.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * class Ruler
 *
 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
 *
 * - keep rules in defined order
 * - assign the name to each rule
 * - enable/disable rules
 * - add/replace rules
 * - allow assign rules to additional named chains (in the same)
 * - cacheing lists of active rules
 *
 * You will not need use this class directly until write plugins. For simple
 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
 * [[MarkdownIt.use]].
 **/

/**
 * new Ruler()
 **/

function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = []; // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //

  this.__cache__ = null;
} ////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly
// Find rule index by name
//


Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }

  return -1;
}; // Build rules lookup cache
//


Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = ['']; // collect unique names

  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) {
      return;
    }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};
  chains.forEach(function (chain) {
    self.__cache__[chain] = [];

    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) {
        return;
      }

      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }

      self.__cache__[chain].push(rule.fn);
    });
  });
};
/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typographer replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/


Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);

  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + name);
  }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};
/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/


Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);

  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + beforeName);
  }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};
/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/


Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);

  var opt = options || {};

  if (index === -1) {
    throw new Error('Parser rule not found: ' + afterName);
  }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};
/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/


Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};
/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/


Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = []; // Search by name and enable

  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }

      throw new Error('Rules manager: invalid rule name ' + name);
    }

    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/


Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  this.__rules__.forEach(function (rule) {
    rule.enabled = false;
  });

  this.enable(list, ignoreInvalid);
};
/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/


Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) {
    list = [list];
  }

  var result = []; // Search by name and disable

  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }

      throw new Error('Rules manager: invalid rule name ' + name);
    }

    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);
  this.__cache__ = null;
  return result;
};
/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/


Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  } // Chain can be empty, if rules disabled. But we still have to return Array.


  return this.__cache__[chainName] || [];
};

module.exports = Ruler;

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/blockquote.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/blockquote.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Block quotes


var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;

module.exports = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      wasOutdented,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block

  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  } // check the block quote marker


  if (state.src.charCodeAt(pos++) !== 0x3E
  /* > */
  ) {
      return false;
    } // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode


  if (silent) {
    return true;
  } // skip spaces after ">" and re-calculate offset


  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]); // skip one optional space after '>'

  if (state.src.charCodeAt(pos) === 0x20
  /* space */
  ) {
      // ' >   test '
      //     ^ -- position start of line here:
      pos++;
      initial++;
      offset++;
      adjustTab = false;
      spaceAfterMarker = true;
    } else if (state.src.charCodeAt(pos) === 0x09
  /* tab */
  ) {
      spaceAfterMarker = true;

      if ((state.bsCount[startLine] + offset) % 4 === 3) {
        // '  >\t  test '
        //       ^ -- position start of line here (tab has width===1)
        pos++;
        initial++;
        offset++;
        adjustTab = false;
      } else {
        // ' >\t  test '
        //    ^ -- position start of line here + shift bsCount slightly
        //         to make extra space appear
        adjustTab = true;
      }
    } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
  lastLineEmpty = pos >= max;
  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;
  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];
  terminatorRules = state.md.block.ruler.getRules('blockquote');
  oldParentType = state.parentType;
  state.parentType = 'blockquote';
  wasOutdented = false; // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```

  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E
    /* > */
    && !wasOutdented) {
      // This line is inside the blockquote.
      // skip spaces after ">" and re-calculate offset
      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]); // skip one optional space after '>'

      if (state.src.charCodeAt(pos) === 0x20
      /* space */
      ) {
          // ' >   test '
          //     ^ -- position start of line here:
          pos++;
          initial++;
          offset++;
          adjustTab = false;
          spaceAfterMarker = true;
        } else if (state.src.charCodeAt(pos) === 0x09
      /* tab */
      ) {
          spaceAfterMarker = true;

          if ((state.bsCount[nextLine] + offset) % 4 === 3) {
            // '  >\t  test '
            //       ^ -- position start of line here (tab has width===1)
            pos++;
            initial++;
            offset++;
            adjustTab = false;
          } else {
            // ' >\t  test '
            //    ^ -- position start of line here + shift bsCount slightly
            //         to make extra space appear
            adjustTab = true;
          }
        } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    } // Case 2: line is not inside the blockquote, and the last line was empty.


    if (lastLineEmpty) {
      break;
    } // Case 3: another tag found.


    terminate = false;

    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]); // A negative indentation means that this is a paragraph continuation
    //

    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;
  token = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map = lines = [startLine, 0];
  state.md.block.tokenize(state, startLine, nextLine);
  token = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line; // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.

  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }

  state.blkIndent = oldIndent;
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/code.js":
/*!**********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/code.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Code block (4 spaces padded)


module.exports = function code(state, startLine, endLine
/*, silent*/
) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }

    break;
  }

  state.line = last;
  token = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map = [startLine, state.line];
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/fence.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/fence.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// fences (``` lang, ~~~ lang)


module.exports = function fence(state, startLine, endLine, silent) {
  var marker,
      len,
      params,
      nextLine,
      mem,
      token,
      markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block

  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (pos + 3 > max) {
    return false;
  }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E
  /* ~ */
  && marker !== 0x60
  /* ` */
  ) {
      return false;
    } // scan marker length


  mem = pos;
  pos = state.skipChars(pos, marker);
  len = pos - mem;

  if (len < 3) {
    return false;
  }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (params.indexOf(String.fromCharCode(marker)) >= 0) {
    return false;
  } // Since start is found, we can report success here in validation mode


  if (silent) {
    return true;
  } // search end of block


  nextLine = startLine;

  for (;;) {
    nextLine++;

    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) {
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker); // closing code fence must be at least as long as the opening one

    if (pos - mem < len) {
      continue;
    } // make sure tail has spaces only


    pos = state.skipSpaces(pos);

    if (pos < max) {
      continue;
    }

    haveEndMarker = true; // found!

    break;
  } // If a fence has heading spaces, they should be removed from its inner block


  len = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  token = state.push('fence', 'code', 0);
  token.info = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup = markup;
  token.map = [startLine, state.line];
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/heading.js":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/heading.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// heading (#, ##, ...)


var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;

module.exports = function heading(state, startLine, endLine, silent) {
  var ch,
      level,
      tmp,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block

  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  ch = state.src.charCodeAt(pos);

  if (ch !== 0x23
  /* # */
  || pos >= max) {
    return false;
  } // count heading level


  level = 1;
  ch = state.src.charCodeAt(++pos);

  while (ch === 0x23
  /* # */
  && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || pos < max && !isSpace(ch)) {
    return false;
  }

  if (silent) {
    return true;
  } // Let's cut tails like '    ###  ' from the end of string


  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #

  if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;
  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map = [startLine, state.line];
  token = state.push('inline', '', 0);
  token.content = state.src.slice(pos, max).trim();
  token.map = [startLine, state.line];
  token.children = [];
  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/hr.js":
/*!********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/hr.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Horizontal rule


var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;

module.exports = function hr(state, startLine, endLine, silent) {
  var marker,
      cnt,
      ch,
      token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block

  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  marker = state.src.charCodeAt(pos++); // Check hr marker

  if (marker !== 0x2A
  /* * */
  && marker !== 0x2D
  /* - */
  && marker !== 0x5F
  /* _ */
  ) {
      return false;
    } // markers can be mixed with spaces, but there should be at least 3 of them


  cnt = 1;

  while (pos < max) {
    ch = state.src.charCodeAt(pos++);

    if (ch !== marker && !isSpace(ch)) {
      return false;
    }

    if (ch === marker) {
      cnt++;
    }
  }

  if (cnt < 3) {
    return false;
  }

  if (silent) {
    return true;
  }

  state.line = startLine + 1;
  token = state.push('hr', 'hr', 0);
  token.map = [startLine, state.line];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/html_block.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/html_block.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// HTML block


var block_names = __webpack_require__(/*! ../common/html_blocks */ "./node_modules/markdown-it/lib/common/html_blocks.js");

var HTML_OPEN_CLOSE_TAG_RE = __webpack_require__(/*! ../common/html_re */ "./node_modules/markdown-it/lib/common/html_re.js").HTML_OPEN_CLOSE_TAG_RE; // An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//


var HTML_SEQUENCES = [[/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\?/, /\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\[CDATA\[/, /\]\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'), /^$/, false]];

module.exports = function html_block(state, startLine, endLine, silent) {
  var i,
      nextLine,
      token,
      lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine]; // if it's indented more than 3 spaces, it should be a code block

  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (!state.md.options.html) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x3C
  /* < */
  ) {
      return false;
    }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }

  if (i === HTML_SEQUENCES.length) {
    return false;
  }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1; // If we are here - we detected HTML block.
  // Let's roll down till block end.

  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }

        break;
      }
    }
  }

  state.line = nextLine;
  token = state.push('html_block', '', 0);
  token.map = [startLine, nextLine];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/lheading.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/lheading.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// lheading (---, ===)


module.exports = function lheading(state, startLine, endLine
/*, silent*/
) {
  var content,
      terminate,
      i,
      l,
      token,
      pos,
      max,
      level,
      marker,
      nextLine = startLine + 1,
      oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph'); // if it's indented more than 3 spaces, it should be a code block

  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules
  // jump line-by-line until empty one or EOF

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    } //
    // Check for underline in setext header
    //


    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D
        /* - */
        || marker === 0x3D
        /* = */
        ) {
            pos = state.skipChars(pos, marker);
            pos = state.skipSpaces(pos);

            if (pos >= max) {
              level = marker === 0x3D
              /* = */
              ? 1 : 2;
              break;
            }
          }
      }
    } // quirk for blockquotes, this line should already be checked by that rule


    if (state.sCount[nextLine] < 0) {
      continue;
    } // Some tags can terminate paragraph without empty line.


    terminate = false;

    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      break;
    }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  token = state.push('heading_open', 'h' + String(level), 1);
  token.markup = String.fromCharCode(marker);
  token.map = [startLine, state.line];
  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line - 1];
  token.children = [];
  token = state.push('heading_close', 'h' + String(level), -1);
  token.markup = String.fromCharCode(marker);
  state.parentType = oldParentType;
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/list.js":
/*!**********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/list.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Lists


var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace; // Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.


function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;
  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];
  marker = state.src.charCodeAt(pos++); // Check bullet

  if (marker !== 0x2A
  /* * */
  && marker !== 0x2D
  /* - */
  && marker !== 0x2B
  /* + */
  ) {
      return -1;
    }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
} // Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.


function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine]; // List marker should have at least 2 chars (digit + dot)

  if (pos + 1 >= max) {
    return -1;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30
  /* 0 */
  || ch > 0x39
  /* 9 */
  ) {
      return -1;
    }

  for (;;) {
    // EOL -> fail
    if (pos >= max) {
      return -1;
    }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30
    /* 0 */
    && ch <= 0x39
    /* 9 */
    ) {
        // List marker should have no more than 9 digits
        // (prevents integer overflow in browsers)
        if (pos - start >= 10) {
          return -1;
        }

        continue;
      } // found valid marker


    if (ch === 0x29
    /* ) */
    || ch === 0x2e
    /* . */
    ) {
        break;
      }

    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }

  return pos;
}

function markTightParagraphs(state, idx) {
  var i,
      l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}

module.exports = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldIndent,
      oldLIndent,
      oldParentType,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true; // if it's indented more than 3 spaces, it should be a code block

  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  } // limit conditions when list can interrupt
  // a paragraph (validation mode only)


  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  } // Detect list type and position after marker


  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1)); // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.

    if (isTerminatingParagraph && markerValue !== 1) return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  } // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.


  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  } // We should terminate list on style change. Remember first one to compare.


  markerCharCode = state.src.charCodeAt(posAfterMarker - 1); // For validation mode we can terminate immediately

  if (silent) {
    return true;
  } // Start list


  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token = state.push('ordered_list_open', 'ol', 1);

    if (markerValue !== 1) {
      token.attrs = [['start', markerValue]];
    }
  } else {
    token = state.push('bullet_list_open', 'ul', 1);
  }

  token.map = listLines = [startLine, 0];
  token.markup = String.fromCharCode(markerCharCode); //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');
  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];
    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 0x20) {
        offset++;
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    } // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)


    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    } // "  -  test"
    //  ^^^^^ - calculating total length of this thing


    indent = initial + indentAfterMarker; // Run subparser & write tokens

    token = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map = itemLines = [startLine, 0];
    oldIndent = state.blkIndent;
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldLIndent = state.sCount[startLine];
    state.blkIndent = indent;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    } // If any of list item is tight, mark list as tight


    if (!state.tight || prevEmptyEnd) {
      tight = false;
    } // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish


    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = oldIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldLIndent;
    state.tight = oldTight;
    token = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);
    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) {
      break;
    } //
    // Try to check if list is terminated or continued.
    //


    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    } // fail if terminating block found


    terminate = false;

    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      break;
    } // fail if list has another type


    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);

      if (posAfterMarker < 0) {
        break;
      }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);

      if (posAfterMarker < 0) {
        break;
      }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  } // Finalize list


  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }

  token.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType; // mark paragraphs tight if needed

  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/paragraph.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/paragraph.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Paragraph


module.exports = function paragraph(state, startLine
/*, endLine*/
) {
  var content,
      terminate,
      i,
      l,
      token,
      oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;
  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // jump line-by-line until empty one or EOF

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    } // quirk for blockquotes, this line should already be checked by that rule


    if (state.sCount[nextLine] < 0) {
      continue;
    } // Some tags can terminate paragraph without empty line.


    terminate = false;

    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      break;
    }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  token = state.push('paragraph_open', 'p', 1);
  token.map = [startLine, state.line];
  token = state.push('inline', '', 0);
  token.content = content;
  token.map = [startLine, state.line];
  token.children = [];
  token = state.push('paragraph_close', 'p', -1);
  state.parentType = oldParentType;
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/reference.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/reference.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var normalizeReference = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").normalizeReference;

var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;

module.exports = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1; // if it's indented more than 3 spaces, it should be a code block

  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  if (state.src.charCodeAt(pos) !== 0x5B
  /* [ */
  ) {
      return false;
    } // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54


  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D
    /* ] */
    && state.src.charCodeAt(pos - 1) !== 0x5C
    /* \ */
    ) {
        if (pos + 1 === max) {
          return false;
        }

        if (state.src.charCodeAt(pos + 1) !== 0x3A
        /* : */
        ) {
            return false;
          }

        break;
      }
  }

  endLine = state.lineMax; // jump line-by-line until empty one or EOF

  terminatorRules = state.md.block.ruler.getRules('reference');
  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    } // quirk for blockquotes, this line should already be checked by that rule


    if (state.sCount[nextLine] < 0) {
      continue;
    } // Some tags can terminate paragraph without empty line.


    terminate = false;

    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      break;
    }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);

    if (ch === 0x5B
    /* [ */
    ) {
        return false;
      } else if (ch === 0x5D
    /* ] */
    ) {
        labelEnd = pos;
        break;
      } else if (ch === 0x0A
    /* \n */
    ) {
        lines++;
      } else if (ch === 0x5C
    /* \ */
    ) {
        pos++;

        if (pos < max && str.charCodeAt(pos) === 0x0A) {
          lines++;
        }
      }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A
  /* : */
  ) {
      return false;
    } // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here


  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);

    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  } // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this


  res = state.md.helpers.parseLinkDestination(str, pos, max);

  if (!res.ok) {
    return false;
  }

  href = state.md.normalizeLink(res.str);

  if (!state.md.validateLink(href)) {
    return false;
  }

  pos = res.pos;
  lines += res.lines; // save cursor state, we could require to rollback later

  destEndPos = pos;
  destEndLineNo = lines; // [label]:   destination   'title'
  //                       ^^^ skipping those spaces

  start = pos;

  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);

    if (ch === 0x0A) {
      lines++;
    } else if (isSpace(ch)) {
      /*eslint no-empty:0*/
    } else {
      break;
    }
  } // [label]:   destination   'title'
  //                          ^^^^^^^ parse this


  res = state.md.helpers.parseLinkTitle(str, pos, max);

  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  } // skip trailing spaces until the rest of the line


  while (pos < max) {
    ch = str.charCodeAt(pos);

    if (!isSpace(ch)) {
      break;
    }

    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;

      while (pos < max) {
        ch = str.charCodeAt(pos);

        if (!isSpace(ch)) {
          break;
        }

        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference(str.slice(1, labelEnd));

  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  } // Reference can not terminate anything. This check is for safety only.

  /*istanbul ignore if*/


  if (silent) {
    return true;
  }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }

  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = {
      title: title,
      href: href
    };
  }

  state.parentType = oldParentType;
  state.line = startLine + lines + 1;
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/state_block.js":
/*!*****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/state_block.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parser state class


var Token = __webpack_require__(/*! ../token */ "./node_modules/markdown-it/lib/token.js");

var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;

function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;
  this.src = src; // link to parser instance

  this.md = md;
  this.env = env; //
  // Internal state vartiables
  //

  this.tokens = tokens;
  this.bMarks = []; // line begin offsets for fast jumps

  this.eMarks = []; // line end offsets for fast jumps

  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)

  this.sCount = []; // indents for each line (tabs expanded)
  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //

  this.bsCount = []; // block parser variables

  this.blkIndent = 0; // required block content indent
  // (for example, if we are in list)

  this.line = 0; // line index in src

  this.lineMax = 0; // lines count

  this.tight = false; // loose/tight mode for lists

  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)
  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph

  this.parentType = 'root';
  this.level = 0; // renderer

  this.result = ''; // Create caches
  // Generate markers.

  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }

        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) {
        pos++;
      }

      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  } // Push fake entry to simplify cache bounds checks


  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1; // don't count last fake line
} // Push new token to "stream".
//


StateBlock.prototype.push = function (type, tag, nesting) {
  var token = new Token(type, tag, nesting);
  token.block = true;

  if (nesting < 0) {
    this.level--;
  }

  token.level = this.level;

  if (nesting > 0) {
    this.level++;
  }

  this.tokens.push(token);
  return token;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }

  return from;
}; // Skip spaces from given position.


StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);

    if (!isSpace(ch)) {
      break;
    }
  }

  return pos;
}; // Skip spaces from given position in reverse.


StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (!isSpace(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }

  return pos;
}; // Skip char codes from given position


StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) {
      break;
    }
  }

  return pos;
}; // Skip char codes reverse from given position - 1


StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) {
    return pos;
  }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }

  return pos;
}; // cut lines range from source.


StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i,
      lineIndent,
      ch,
      first,
      last,
      queue,
      lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
}; // re-export Token class to use in block rules


StateBlock.prototype.Token = Token;
module.exports = StateBlock;

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_block/table.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_block/table.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// GFM table, non-standard


var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;

function getLine(state, line) {
  var pos = state.bMarks[line] + state.blkIndent,
      max = state.eMarks[line];
  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      escapes = 0,
      lastPos = 0,
      backTicked = false,
      lastBackTick = 0;
  ch = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x60
    /* ` */
    ) {
        if (backTicked) {
          // make \` close code sequence, but not open it;
          // the reason is: `\` is correct code block
          backTicked = false;
          lastBackTick = pos;
        } else if (escapes % 2 === 0) {
          backTicked = true;
          lastBackTick = pos;
        }
      } else if (ch === 0x7c
    /* | */
    && escapes % 2 === 0 && !backTicked) {
      result.push(str.substring(lastPos, pos));
      lastPos = pos + 1;
    }

    if (ch === 0x5c
    /* \ */
    ) {
        escapes++;
      } else {
      escapes = 0;
    }

    pos++; // If there was an un-closed backtick, go back to just after
    // the last backtick, but as if it was a normal character

    if (pos === max && backTicked) {
      backTicked = false;
      pos = lastBackTick + 1;
    }

    ch = str.charCodeAt(pos);
  }

  result.push(str.substring(lastPos));
  return result;
}

module.exports = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines; // should have at least two lines

  if (startLine + 2 > endLine) {
    return false;
  }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  } // if it's indented more than 3 spaces, it should be a code block


  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  } // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp


  pos = state.bMarks[nextLine] + state.tShift[nextLine];

  if (pos >= state.eMarks[nextLine]) {
    return false;
  }

  ch = state.src.charCodeAt(pos++);

  if (ch !== 0x7C
  /* | */
  && ch !== 0x2D
  /* - */
  && ch !== 0x3A
  /* : */
  ) {
      return false;
    }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C
    /* | */
    && ch !== 0x2D
    /* - */
    && ch !== 0x3A
    /* : */
    && !isSpace(ch)) {
      return false;
    }

    pos++;
  }

  lineText = getLine(state, startLine + 1);
  columns = lineText.split('|');
  aligns = [];

  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();

    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) {
      return false;
    }

    if (t.charCodeAt(t.length - 1) === 0x3A
    /* : */
    ) {
        aligns.push(t.charCodeAt(0) === 0x3A
        /* : */
        ? 'center' : 'right');
      } else if (t.charCodeAt(0) === 0x3A
    /* : */
    ) {
        aligns.push('left');
      } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();

  if (lineText.indexOf('|') === -1) {
    return false;
  }

  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }

  columns = escapedSplit(lineText.replace(/^\||\|$/g, '')); // header row will define an amount of columns in the entire table,
  // and align row shouldn't be smaller than that (the rest of the rows can)

  columnCount = columns.length;

  if (columnCount > aligns.length) {
    return false;
  }

  if (silent) {
    return true;
  }

  token = state.push('table_open', 'table', 1);
  token.map = tableLines = [startLine, 0];
  token = state.push('thead_open', 'thead', 1);
  token.map = [startLine, startLine + 1];
  token = state.push('tr_open', 'tr', 1);
  token.map = [startLine, startLine + 1];

  for (i = 0; i < columns.length; i++) {
    token = state.push('th_open', 'th', 1);
    token.map = [startLine, startLine + 1];

    if (aligns[i]) {
      token.attrs = [['style', 'text-align:' + aligns[i]]];
    }

    token = state.push('inline', '', 0);
    token.content = columns[i].trim();
    token.map = [startLine, startLine + 1];
    token.children = [];
    token = state.push('th_close', 'th', -1);
  }

  token = state.push('tr_close', 'tr', -1);
  token = state.push('thead_close', 'thead', -1);
  token = state.push('tbody_open', 'tbody', 1);
  token.map = tbodyLines = [startLine + 2, 0];

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }

    lineText = getLine(state, nextLine).trim();

    if (lineText.indexOf('|') === -1) {
      break;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }

    columns = escapedSplit(lineText.replace(/^\||\|$/g, ''));
    token = state.push('tr_open', 'tr', 1);

    for (i = 0; i < columnCount; i++) {
      token = state.push('td_open', 'td', 1);

      if (aligns[i]) {
        token.attrs = [['style', 'text-align:' + aligns[i]]];
      }

      token = state.push('inline', '', 0);
      token.content = columns[i] ? columns[i].trim() : '';
      token.children = [];
      token = state.push('td_close', 'td', -1);
    }

    token = state.push('tr_close', 'tr', -1);
  }

  token = state.push('tbody_close', 'tbody', -1);
  token = state.push('table_close', 'table', -1);
  tableLines[1] = tbodyLines[1] = nextLine;
  state.line = nextLine;
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/block.js":
/*!**********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/block.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function block(state) {
  var token;

  if (state.inlineMode) {
    token = new state.Token('inline', '', 0);
    token.content = state.src;
    token.map = [0, 1];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/inline.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/inline.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function inline(state) {
  var tokens = state.tokens,
      tok,
      i,
      l; // Parse inlines

  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];

    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/linkify.js":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/linkify.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Replace link-like texts with link nodes.
//
// Currently restricted by `md.validateLink()` to http/https/ftp
//


var arrayReplaceAt = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").arrayReplaceAt;

function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}

function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}

module.exports = function linkify(state) {
  var i,
      j,
      l,
      tokens,
      token,
      currentToken,
      nodes,
      ln,
      text,
      pos,
      lastPos,
      level,
      htmlLinkLevel,
      url,
      fullUrl,
      urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) {
    return;
  }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;
    htmlLinkLevel = 0; // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match

    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i]; // Skip content of markdown links

      if (currentToken.type === 'link_close') {
        i--;

        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }

        continue;
      } // Skip content of html tag links


      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }

        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }

      if (htmlLinkLevel > 0) {
        continue;
      }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {
        text = currentToken.content;
        links = state.md.linkify.match(text); // Now split string to nodes

        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {
          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);

          if (!state.md.validateLink(fullUrl)) {
            continue;
          }

          urlText = links[ln].text; // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //

          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level = level;
            nodes.push(token);
          }

          token = new state.Token('link_open', 'a', 1);
          token.attrs = [['href', fullUrl]];
          token.level = level++;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);
          token = new state.Token('text', '', 0);
          token.content = urlText;
          token.level = level;
          nodes.push(token);
          token = new state.Token('link_close', 'a', -1);
          token.level = --level;
          token.markup = 'linkify';
          token.info = 'auto';
          nodes.push(token);
          lastPos = links[ln].lastIndex;
        }

        if (lastPos < text.length) {
          token = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level = level;
          nodes.push(token);
        } // replace current node


        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/normalize.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/normalize.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Normalize input string


var NEWLINES_RE = /\r[\n\u0085]?|[\u2424\u2028\u0085]/g;
var NULL_RE = /\u0000/g;

module.exports = function inline(state) {
  var str; // Normalize newlines

  str = state.src.replace(NEWLINES_RE, '\n'); // Replace NULL characters

  str = str.replace(NULL_RE, '\uFFFD');
  state.src = str;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/replacements.js":
/*!*****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/replacements.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Simple typographyc replacements
//
// (c) (C) → ©
// (tm) (TM) → ™
// (r) (R) → ®
// +- → ±
// (p) (P) -> §
// ... → … (also ?.... → ?.., !.... → !..)
// ???????? → ???, !!!!! → !!!, `,,` → `,`
// -- → &ndash;, --- → &mdash;
//
 // TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/; // Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time

var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i,
      token,
      inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content.replace(/\+-/g, '±') // .., ..., ....... -> …
        // but ?..... & !..... -> ?.. & !..
        .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',') // em-dash
        .replace(/(^|[^-])---([^-]|$)/mg, '$1\u2014$2') // en-dash
        .replace(/(^|\s)--(\s|$)/mg, '$1\u2013$2').replace(/(^|[^-\s])--([^-\s]|$)/mg, '$1\u2013$2');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

module.exports = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== 'inline') {
      continue;
    }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/smartquotes.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/smartquotes.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Convert straight quotation marks to typographic ones
//


var isWhiteSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isWhiteSpace;

var isPunctChar = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isPunctChar;

var isMdAsciiPunct = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019';
/* ’ */

function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];
    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }

    stack.length = j + 1;

    if (token.type !== 'text') {
      continue;
    }

    text = token.content;
    pos = 0;
    max = text.length;
    /*eslint no-labels:0,block-scoped-var:0*/

    OUTER: while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);

      if (!t) {
        break;
      }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = t[0] === "'"; // Find previous character,
      // default to space if it's the beginning of the line
      //

      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20

          if (tokens[j].type !== 'text') continue;
          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      } // Find next character,
      // default to space if it's the end of the line
      //


      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20

          if (tokens[j].type !== 'text') continue;
          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22
      /* " */
      && t[0] === '"') {
        if (lastChar >= 0x30
        /* 0 */
        && lastChar <= 0x39
        /* 9 */
        ) {
            // special case: 1"" - count first quote as an inch
            canClose = canOpen = false;
          }
      }

      if (canOpen && canClose) {
        // treat this as the middle of the word
        canOpen = false;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }

        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];

          if (stack[j].level < thisLevel) {
            break;
          }

          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            } // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1


            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
            pos += closeQuote.length - 1;

            if (item.token === i) {
              pos += openQuote.length - 1;
            }

            text = token.content;
            max = text.length;
            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}

module.exports = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) {
    return;
  }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_core/state_core.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_core/state_core.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Core state object
//


var Token = __webpack_require__(/*! ../token */ "./node_modules/markdown-it/lib/token.js");

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
} // re-export Token class to use in core rules


StateCore.prototype.Token = Token;
module.exports = StateCore;

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/autolink.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/autolink.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process autolinks '<protocol:...>'

/*eslint max-len:0*/

var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;

module.exports = function autolink(state, silent) {
  var tail,
      linkMatch,
      emailMatch,
      url,
      fullUrl,
      token,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C
  /* < */
  ) {
      return false;
    }

  tail = state.src.slice(pos);

  if (tail.indexOf('>') < 0) {
    return false;
  }

  if (AUTOLINK_RE.test(tail)) {
    linkMatch = tail.match(AUTOLINK_RE);
    url = linkMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink(url);

    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';
      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);
      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += linkMatch[0].length;
    return true;
  }

  if (EMAIL_RE.test(tail)) {
    emailMatch = tail.match(EMAIL_RE);
    url = emailMatch[0].slice(1, -1);
    fullUrl = state.md.normalizeLink('mailto:' + url);

    if (!state.md.validateLink(fullUrl)) {
      return false;
    }

    if (!silent) {
      token = state.push('link_open', 'a', 1);
      token.attrs = [['href', fullUrl]];
      token.markup = 'autolink';
      token.info = 'auto';
      token = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);
      token = state.push('link_close', 'a', -1);
      token.markup = 'autolink';
      token.info = 'auto';
    }

    state.pos += emailMatch[0].length;
    return true;
  }

  return false;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/backticks.js":
/*!****************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/backticks.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Parse backticks


module.exports = function backtick(state, silent) {
  var start,
      max,
      marker,
      matchStart,
      matchEnd,
      token,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60
  /* ` */
  ) {
      return false;
    }

  start = pos;
  pos++;
  max = state.posMax;

  while (pos < max && state.src.charCodeAt(pos) === 0x60
  /* ` */
  ) {
    pos++;
  }

  marker = state.src.slice(start, pos);
  matchStart = matchEnd = pos;

  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60
    /* ` */
    ) {
      matchEnd++;
    }

    if (matchEnd - matchStart === marker.length) {
      if (!silent) {
        token = state.push('code_inline', 'code', 0);
        token.markup = marker;
        token.content = state.src.slice(pos, matchStart).replace(/[ \n]+/g, ' ').trim();
      }

      state.pos = matchEnd;
      return true;
    }
  }

  if (!silent) {
    state.pending += marker;
  }

  state.pos += marker.length;
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/balance_pairs.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/balance_pairs.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// For each opening emphasis-like marker find a matching closing one
//


module.exports = function link_pairs(state) {
  var i,
      j,
      lastDelim,
      currDelim,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    lastDelim = delimiters[i];

    if (!lastDelim.close) {
      continue;
    }

    j = i - lastDelim.jump - 1;

    while (j >= 0) {
      currDelim = delimiters[j];

      if (currDelim.open && currDelim.marker === lastDelim.marker && currDelim.end < 0 && currDelim.level === lastDelim.level) {
        // typeofs are for backward compatibility with plugins
        var odd_match = (currDelim.close || lastDelim.open) && typeof currDelim.length !== 'undefined' && typeof lastDelim.length !== 'undefined' && (currDelim.length + lastDelim.length) % 3 === 0;

        if (!odd_match) {
          lastDelim.jump = i - j;
          lastDelim.open = false;
          currDelim.end = i;
          currDelim.jump = 0;
          break;
        }
      }

      j -= currDelim.jump + 1;
    }
  }
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/emphasis.js":
/*!***************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/emphasis.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process *this* and _that_
//
 // Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function emphasis(state, silent) {
  var i,
      scanned,
      token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x5F
  /* _ */
  && marker !== 0x2A
  /* * */
  ) {
      return false;
    }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);
    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,
      // Total length of these series of delimiters.
      //
      length: scanned.length,
      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump: i,
      // A position of the token this delimiter corresponds to.
      //
      token: state.tokens.length - 1,
      // Token level.
      //
      level: state.level,
      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end: -1,
      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;
  return true;
}; // Walk through delimiter list and replace text tokens with tags
//


module.exports.postProcess = function emphasis(state) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = max - 1; i >= 0; i--) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F
    /* _ */
    && startDelim.marker !== 0x2A
    /* * */
    ) {
        continue;
      } // Process only opening markers


    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end]; // If the previous delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //

    isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1 && delimiters[i - 1].marker === startDelim.marker;
    ch = String.fromCharCode(startDelim.marker);
    token = state.tokens[startDelim.token];
    token.type = isStrong ? 'strong_open' : 'em_open';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';
    token = state.tokens[endDelim.token];
    token.type = isStrong ? 'strong_close' : 'em_close';
    token.tag = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = '';
      state.tokens[delimiters[startDelim.end + 1].token].content = '';
      i--;
    }
  }
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/entity.js":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/entity.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html entity - &#123;, &#xAF;, &quot;, ...


var entities = __webpack_require__(/*! ../common/entities */ "./node_modules/markdown-it/lib/common/entities.js");

var has = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").has;

var isValidEntityCode = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isValidEntityCode;

var fromCodePoint = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").fromCodePoint;

var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;

module.exports = function entity(state, silent) {
  var ch,
      code,
      match,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26
  /* & */
  ) {
      return false;
    }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23
    /* # */
    ) {
        match = state.src.slice(pos).match(DIGITAL_RE);

        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
          }

          state.pos += match[0].length;
          return true;
        }
      } else {
      match = state.src.slice(pos).match(NAMED_RE);

      if (match) {
        if (has(entities, match[1])) {
          if (!silent) {
            state.pending += entities[match[1]];
          }

          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) {
    state.pending += '&';
  }

  state.pos++;
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/escape.js":
/*!*************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/escape.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process escaped chars and hardbreaks


var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});

module.exports = function escape(state, silent) {
  var ch,
      pos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C
  /* \ */
  ) {
      return false;
    }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }

      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++; // skip leading whitespaces from next line

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (!isSpace(ch)) {
          break;
        }

        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) {
    state.pending += '\\';
  }

  state.pos++;
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/html_inline.js":
/*!******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/html_inline.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process html tags


var HTML_TAG_RE = __webpack_require__(/*! ../common/html_re */ "./node_modules/markdown-it/lib/common/html_re.js").HTML_TAG_RE;

function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case

  return lc >= 0x61
  /* a */
  && lc <= 0x7a
  /* z */
  ;
}

module.exports = function html_inline(state, silent) {
  var ch,
      match,
      max,
      token,
      pos = state.pos;

  if (!state.md.options.html) {
    return false;
  } // Check start


  max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x3C
  /* < */
  || pos + 2 >= max) {
    return false;
  } // Quick fail on second char


  ch = state.src.charCodeAt(pos + 1);

  if (ch !== 0x21
  /* ! */
  && ch !== 0x3F
  /* ? */
  && ch !== 0x2F
  /* / */
  && !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);

  if (!match) {
    return false;
  }

  if (!silent) {
    token = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }

  state.pos += match[0].length;
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/image.js":
/*!************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/image.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process ![image](<src> "title")


var normalizeReference = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").normalizeReference;

var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;

module.exports = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21
  /* ! */
  ) {
      return false;
    }

  if (state.src.charCodeAt(state.pos + 1) !== 0x5B
  /* [ */
  ) {
      return false;
    }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false); // parser failed to find ']', so it's not a valid link

  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;

  if (pos < max && state.src.charCodeAt(pos) === 0x28
  /* ( */
  ) {
      //
      // Inline link
      //
      // [link](  <href>  "title"  )
      //        ^^ skipping these spaces
      pos++;

      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);

        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      if (pos >= max) {
        return false;
      } // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination


      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);

      if (res.ok) {
        href = state.md.normalizeLink(res.str);

        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      } // [link](  <href>  "title"  )
      //                ^^ skipping these spaces


      start = pos;

      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);

        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      } // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title


      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);

      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos; // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces

        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);

          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29
      /* ) */
      ) {
          state.pos = oldPos;
          return false;
        }

      pos++;
    } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B
    /* [ */
    ) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);

        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    } // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)


    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];

    if (!ref) {
      state.pos = oldPos;
      return false;
    }

    href = ref.href;
    title = ref.title;
  } //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //


  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);
    state.md.inline.parse(content, state.md, state.env, tokens = []);
    token = state.push('image', 'img', 0);
    token.attrs = attrs = [['src', href], ['alt', '']];
    token.children = tokens;
    token.content = content;

    if (title) {
      attrs.push(['title', title]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/link.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/link.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Process [link](<to> "stuff")


var normalizeReference = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").normalizeReference;

var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;

module.exports = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      title,
      token,
      href = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B
  /* [ */
  ) {
      return false;
    }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true); // parser failed to find ']', so it's not a valid link

  if (labelEnd < 0) {
    return false;
  }

  pos = labelEnd + 1;

  if (pos < max && state.src.charCodeAt(pos) === 0x28
  /* ( */
  ) {
      //
      // Inline link
      //
      // might have found a valid shortcut link, disable reference parsing
      parseReference = false; // [link](  <href>  "title"  )
      //        ^^ skipping these spaces

      pos++;

      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);

        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      }

      if (pos >= max) {
        return false;
      } // [link](  <href>  "title"  )
      //          ^^^^^^ parsing link destination


      start = pos;
      res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);

      if (res.ok) {
        href = state.md.normalizeLink(res.str);

        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = '';
        }
      } // [link](  <href>  "title"  )
      //                ^^ skipping these spaces


      start = pos;

      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);

        if (!isSpace(code) && code !== 0x0A) {
          break;
        }
      } // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title


      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);

      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos; // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces

        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);

          if (!isSpace(code) && code !== 0x0A) {
            break;
          }
        }
      } else {
        title = '';
      }

      if (pos >= max || state.src.charCodeAt(pos) !== 0x29
      /* ) */
      ) {
          // parsing a valid shortcut link failed, fallback to reference
          parseReference = true;
        }

      pos++;
    }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') {
      return false;
    }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B
    /* [ */
    ) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);

        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
      pos = labelEnd + 1;
    } // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)


    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }

    ref = state.env.references[normalizeReference(label)];

    if (!ref) {
      state.pos = oldPos;
      return false;
    }

    href = ref.href;
    title = ref.title;
  } //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //


  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    token = state.push('link_open', 'a', 1);
    token.attrs = attrs = [['href', href]];

    if (title) {
      attrs.push(['title', title]);
    }

    state.md.inline.tokenize(state);
    token = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/newline.js":
/*!**************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/newline.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Proceess '\n'


var isSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isSpace;

module.exports = function newline(state, silent) {
  var pmax,
      max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A
  /* \n */
  ) {
      return false;
    }

  pmax = state.pending.length - 1;
  max = state.posMax; // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.

  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }
    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++; // skip heading spaces for next line

  while (pos < max && isSpace(state.src.charCodeAt(pos))) {
    pos++;
  }

  state.pos = pos;
  return true;
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/state_inline.js":
/*!*******************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/state_inline.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Inline parser state


var Token = __webpack_require__(/*! ../token */ "./node_modules/markdown-it/lib/token.js");

var isWhiteSpace = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isWhiteSpace;

var isPunctChar = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isPunctChar;

var isMdAsciiPunct = __webpack_require__(/*! ../common/utils */ "./node_modules/markdown-it/lib/common/utils.js").isMdAsciiPunct;

function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;
  this.cache = {}; // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).

  this.delimiters = []; // Emphasis-like delimiters
} // Flush pending text
//


StateInline.prototype.pushPending = function () {
  var token = new Token('text', '', 0);
  token.content = this.pending;
  token.level = this.pendingLevel;
  this.tokens.push(token);
  this.pending = '';
  return token;
}; // Push new token to "stream".
// If pending text exists - flush it as text token
//


StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token = new Token(type, tag, nesting);

  if (nesting < 0) {
    this.level--;
  }

  token.level = this.level;

  if (nesting > 0) {
    this.level++;
  }

  this.pendingLevel = this.level;
  this.tokens.push(token);
  return token;
}; // Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//


StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start,
      lastChar,
      nextChar,
      count,
      can_open,
      can_close,
      isLastWhiteSpace,
      isLastPunctChar,
      isNextWhiteSpace,
      isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start); // treat beginning of the line as a whitespace

  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) {
    pos++;
  }

  count = pos - start; // treat end of the line as a whitespace

  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;
  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open: can_open,
    can_close: can_close,
    length: count
  };
}; // re-export Token class to use in block rules


StateInline.prototype.Token = Token;
module.exports = StateInline;

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/strikethrough.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/strikethrough.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// ~~strike through~~
//
 // Insert each marker as a separate text token, and add it to delimiter list
//

module.exports.tokenize = function strikethrough(state, silent) {
  var i,
      scanned,
      token,
      len,
      ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) {
    return false;
  }

  if (marker !== 0x7E
  /* ~ */
  ) {
      return false;
    }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) {
    return false;
  }

  if (len % 2) {
    token = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token = state.push('text', '', 0);
    token.content = ch + ch;
    state.delimiters.push({
      marker: marker,
      jump: i,
      token: state.tokens.length - 1,
      level: state.level,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }

  state.pos += scanned.length;
  return true;
}; // Walk through delimiter list and replace text tokens with tags
//


module.exports.postProcess = function strikethrough(state) {
  var i,
      j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      delimiters = state.delimiters,
      max = state.delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E
    /* ~ */
    ) {
        continue;
      }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];
    token = state.tokens[startDelim.token];
    token.type = 's_open';
    token.tag = 's';
    token.nesting = 1;
    token.markup = '~~';
    token.content = '';
    token = state.tokens[endDelim.token];
    token.type = 's_close';
    token.tag = 's';
    token.nesting = -1;
    token.markup = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' && state.tokens[endDelim.token - 1].content === '~') {
      loneMarkers.push(endDelim.token - 1);
    }
  } // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //


  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/text.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/text.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Skip text characters for text token, place those to pending buffer
// and increment current pos
 // Rule to skip pure text
// '{}$%@~+=:' reserved for extentions
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character

function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A
    /* \n */
    :
    case 0x21
    /* ! */
    :
    case 0x23
    /* # */
    :
    case 0x24
    /* $ */
    :
    case 0x25
    /* % */
    :
    case 0x26
    /* & */
    :
    case 0x2A
    /* * */
    :
    case 0x2B
    /* + */
    :
    case 0x2D
    /* - */
    :
    case 0x3A
    /* : */
    :
    case 0x3C
    /* < */
    :
    case 0x3D
    /* = */
    :
    case 0x3E
    /* > */
    :
    case 0x40
    /* @ */
    :
    case 0x5B
    /* [ */
    :
    case 0x5C
    /* \ */
    :
    case 0x5D
    /* ] */
    :
    case 0x5E
    /* ^ */
    :
    case 0x5F
    /* _ */
    :
    case 0x60
    /* ` */
    :
    case 0x7B
    /* { */
    :
    case 0x7D
    /* } */
    :
    case 0x7E
    /* ~ */
    :
      return true;

    default:
      return false;
  }
}

module.exports = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) {
    return false;
  }

  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }

  state.pos = pos;
  return true;
}; // Alternative implementation, for memory.
//
// It costs 10% of performance, but allows extend terminators list, if place it
// to `ParcerInline` property. Probably, will switch to it sometime, such
// flexibility required.

/*
var TERMINATOR_RE = /[\n!#$%&*+\-:<=>@[\\\]^_`{}~]/;

module.exports = function text(state, silent) {
  var pos = state.pos,
      idx = state.src.slice(pos).search(TERMINATOR_RE);

  // first char is terminator -> empty text
  if (idx === 0) { return false; }

  // no terminator -> text till end of string
  if (idx < 0) {
    if (!silent) { state.pending += state.src.slice(pos); }
    state.pos = state.src.length;
    return true;
  }

  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }

  state.pos += idx;

  return true;
};*/

/***/ }),

/***/ "./node_modules/markdown-it/lib/rules_inline/text_collapse.js":
/*!********************************************************************!*\
  !*** ./node_modules/markdown-it/lib/rules_inline/text_collapse.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Merge adjacent text nodes into one, and re-calculate all token levels
//


module.exports = function text_collapse(state) {
  var curr,
      last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels
    level += tokens[curr].nesting;
    tokens[curr].level = level;

    if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {
      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

/***/ }),

/***/ "./node_modules/markdown-it/lib/token.js":
/*!***********************************************!*\
  !*** ./node_modules/markdown-it/lib/token.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Token class

/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/

function Token(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type = type;
  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/

  this.tag = tag;
  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/

  this.attrs = null;
  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/

  this.map = null;
  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/

  this.nesting = nesting;
  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/

  this.level = 0;
  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/

  this.children = null;
  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/

  this.content = '';
  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/

  this.markup = '';
  /**
   * Token#info -> String
   *
   * fence infostring
   **/

  this.info = '';
  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/

  this.meta = null;
  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/

  this.block = false;
  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/

  this.hidden = false;
}
/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/


Token.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) {
    return -1;
  }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) {
      return i;
    }
  }

  return -1;
};
/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/


Token.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/


Token.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [name, value];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/


Token.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name),
      value = null;

  if (idx >= 0) {
    value = this.attrs[idx][1];
  }

  return value;
};
/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/


Token.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([name, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};

module.exports = Token;

/***/ }),

/***/ "./node_modules/mdurl/decode.js":
/*!**************************************!*\
  !*** ./node_modules/mdurl/decode.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i,
      ch,
      cache = decodeCache[exclude];

  if (cache) {
    return cache;
  }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
} // Decode percent-encoded string.
//


function decode(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode.defaultChars;
  }

  cache = getDecodeCache(exclude);
  return string.replace(/(%[a-f0-9]{2})+/gi, function (seq) {
    var i,
        l,
        b1,
        b2,
        b3,
        b4,
        chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && i + 3 < l) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = b1 << 6 & 0x7C0 | b2 & 0x3F;

          if (chr < 0x80) {
            result += '\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && i + 6 < l) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = b1 << 12 & 0xF000 | b2 << 6 & 0xFC0 | b3 & 0x3F;

          if (chr < 0x800 || chr >= 0xD800 && chr <= 0xDFFF) {
            result += '\ufffd\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && i + 9 < l) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = b1 << 18 & 0x1C0000 | b2 << 12 & 0x3F000 | b3 << 6 & 0xFC0 | b4 & 0x3F;

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\ufffd\ufffd\ufffd\ufffd';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\ufffd';
    }

    return result;
  });
}

decode.defaultChars = ';/?:@&=+$,#';
decode.componentChars = '';
module.exports = decode;

/***/ }),

/***/ "./node_modules/mdurl/encode.js":
/*!**************************************!*\
  !*** ./node_modules/mdurl/encode.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var encodeCache = {}; // Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//

function getEncodeCache(exclude) {
  var i,
      ch,
      cache = encodeCache[exclude];

  if (cache) {
    return cache;
  }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
} // Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//


function encode(string, exclude, keepEscaped) {
  var i,
      l,
      code,
      nextCode,
      cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped = exclude;
    exclude = encode.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25
    /* % */
    && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);

        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }

      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode.componentChars = "-_.!~*'()";
module.exports = encode;

/***/ }),

/***/ "./node_modules/mdurl/format.js":
/*!**************************************!*\
  !*** ./node_modules/mdurl/format.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function format(url) {
  var result = '';
  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';
  return result;
};

/***/ }),

/***/ "./node_modules/mdurl/index.js":
/*!*************************************!*\
  !*** ./node_modules/mdurl/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports.encode = __webpack_require__(/*! ./encode */ "./node_modules/mdurl/encode.js");
module.exports.decode = __webpack_require__(/*! ./decode */ "./node_modules/mdurl/decode.js");
module.exports.format = __webpack_require__(/*! ./format */ "./node_modules/mdurl/format.js");
module.exports.parse = __webpack_require__(/*! ./parse */ "./node_modules/mdurl/parse.js");

/***/ }),

/***/ "./node_modules/mdurl/parse.js":
/*!*************************************!*\
  !*** ./node_modules/mdurl/parse.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 //
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
} // Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.


var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,
    // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    // RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.

/* eslint-disable no-script-url */
// protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
};
/* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, slashesDenoteHost) {
  var i,
      l,
      lowerProto,
      hec,
      slashes,
      rest = url; // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"

  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);

    if (simplePath) {
      this.pathname = simplePath[1];

      if (simplePath[2]) {
        this.search = simplePath[2];
      }

      return this;
    }
  }

  var proto = protocolPattern.exec(rest);

  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  } // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.


  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';

    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c
    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.
    // find the first instance of any hostEndingChars
    var hostEnd = -1;

    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);

      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    } // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.


    var auth, atSign;

    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    } // Now we have a portion which is definitely the auth.
    // Pull that off.


    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    } // the host is the remaining to the left of the first non-host char


    hostEnd = -1;

    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);

      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    } // if we still have not hit it, then the entire thing is a host.


    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') {
      hostEnd--;
    }

    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd); // pull out port.

    this.parseHost(host); // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.

    this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.

    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);

      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];

        if (!part) {
          continue;
        }

        if (!part.match(hostnamePartPattern)) {
          var newpart = '';

          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          } // we test again with ASCII char only


          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);

            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }

            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }

            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } // strip [ and ] from the hostname
    // the host field still retains them, though


    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  } // chop off from the tail first.


  var hash = rest.indexOf('#');

  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }

  var qm = rest.indexOf('?');

  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }

  if (rest) {
    this.pathname = rest;
  }

  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function (host) {
  var port = portPattern.exec(host);

  if (port) {
    port = port[0];

    if (port !== ':') {
      this.port = port.substr(1);
    }

    host = host.substr(0, host.length - port.length);
  }

  if (host) {
    this.hostname = host;
  }
};

module.exports = urlParse;

/***/ }),

/***/ "./node_modules/node-libs-browser/node_modules/punycode/punycode.js":
/*!**************************************************************************!*\
  !*** ./node_modules/node-libs-browser/node_modules/punycode/punycode.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;

(function (root) {
  /** Detect free variables */
  var freeExports =  true && exports && !exports.nodeType && exports;
  var freeModule =  true && module && !module.nodeType && module;
  var freeGlobal = typeof global == 'object' && global;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
    root = freeGlobal;
  }
  /**
   * The `punycode` object.
   * @name punycode
   * @type Object
   */


  var punycode,

  /** Highest positive signed 32-bit float value */
  maxInt = 2147483647,
      // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  base = 36,
      tMin = 1,
      tMax = 26,
      skew = 38,
      damp = 700,
      initialBias = 72,
      initialN = 128,
      // 0x80
  delimiter = '-',
      // '\x2D'

  /** Regular expressions */
  regexPunycode = /^xn--/,
      regexNonASCII = /[^\x20-\x7E]/,
      // unprintable ASCII chars + non-ASCII chars
  regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
      // RFC 3490 separators

  /** Error messages */
  errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  },

  /** Convenience shortcuts */
  baseMinusTMin = base - tMin,
      floor = Math.floor,
      stringFromCharCode = String.fromCharCode,

  /** Temporary variable */
  key;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error(type) {
    throw new RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var length = array.length;
    var result = [];

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;

    while (counter < length) {
      value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  function ucs2encode(array) {
    return map(array, function (value) {
      var output = '';

      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }

      output += stringFromCharCode(value);
      return output;
    }).join('');
  }
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }

    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }

    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }

    return base;
  }
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * https://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (;
    /* no initialization */
    delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  function decode(input) {
    // Don't use UCS-2
    var output = [],
        inputLength = input.length,
        out,
        i = 0,
        n = initialN,
        bias = initialBias,
        basic,
        j,
        index,
        oldi,
        w,
        k,
        digit,
        t,

    /** Cached calculation results */
    baseMinusT; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;)
    /* no final expression */
    {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      for (oldi = i, w = 1, k = base;;
      /* no condition */
      k += base) {
        if (index >= inputLength) {
          error('invalid-input');
        }

        digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error('overflow');
        }

        i += digit * w;
        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error('overflow');
        }

        w *= baseMinusT;
      }

      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output

      output.splice(i++, 0, n);
    }

    return ucs2encode(output);
  }
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  function encode(input) {
    var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],

    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,

    /** Cached calculation results */
    handledCPCountPlusOne,
        baseMinusT,
        qMinusT; // Convert the input in UCS-2 to Unicode

    input = ucs2decode(input); // Cache the length

    inputLength = input.length; // Initialize the state

    n = initialN;
    delta = 0;
    bias = initialBias; // Handle the basic code points

    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];

      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string - if it is not empty - with a delimiter

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow


      handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < n && ++delta > maxInt) {
          error('overflow');
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base;;
          /* no condition */
          k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (q < t) {
              break;
            }

            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  }
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  }
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  }
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '1.4.1',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /** Expose `punycode` */
  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return punycode;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var printWarning = function () {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");

  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function (text) {
    var message = 'Warning: ' + text;

    if (typeof console !== 'undefined') {
      console.error(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */


function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.');
            err.name = 'Invariant Violation';
            throw err;
          }

          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }

        if (error && !(error instanceof Error)) {
          printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
        }

        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;
          var stack = getStack ? getStack() : '';
          printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
        }
      }
    }
  }
}
/**
 * Resets warning cache when testing.
 *
 * @private
 */


checkPropTypes.resetWarningCache = function () {
  if (true) {
    loggedTypeFailures = {};
  }
};

module.exports = checkPropTypes;

/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
module.exports = ReactPropTypesSecret;

/***/ }),

/***/ "./node_modules/react-dom/cjs/react-dom.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-dom/cjs/react-dom.development.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.8.6
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */if(true){(function(){'use strict';var React=__webpack_require__(/*! react */ "./node_modules/react/index.js");var _assign=__webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");var checkPropTypes=__webpack_require__(/*! prop-types/checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");var scheduler=__webpack_require__(/*! scheduler */ "./node_modules/scheduler/index.js");var tracing=__webpack_require__(/*! scheduler/tracing */ "./node_modules/scheduler/tracing.js");/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */var validateFormat=function(){};{validateFormat=function(format){if(format===undefined){throw new Error('invariant requires an error message argument');}};}function invariant(condition,format,a,b,c,d,e,f){validateFormat(format);if(!condition){var error=void 0;if(format===undefined){error=new Error('Minified exception occurred; use the non-minified dev environment '+'for the full error message and additional helpful warnings.');}else{var args=[a,b,c,d,e,f];var argIndex=0;error=new Error(format.replace(/%s/g,function(){return args[argIndex++];}));error.name='Invariant Violation';}error.framesToPop=1;// we don't care about invariant's own frame
throw error;}}// Relying on the `invariant()` implementation lets us
// preserve the format and params in the www builds.
!React?invariant(false,'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.'):void 0;var invokeGuardedCallbackImpl=function(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}};{// In DEV mode, we swap out invokeGuardedCallback for a special version
// that plays more nicely with the browser's DevTools. The idea is to preserve
// "Pause on exceptions" behavior. Because React wraps all user-provided
// functions in invokeGuardedCallback, and the production version of
// invokeGuardedCallback uses a try-catch, all user exceptions are treated
// like caught exceptions, and the DevTools won't pause unless the developer
// takes the extra step of enabling pause on caught exceptions. This is
// unintuitive, though, because even though React has caught the error, from
// the developer's perspective, the error is uncaught.
//
// To preserve the expected "Pause on exceptions" behavior, we don't use a
// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
// DOM node, and call the user-provided callback from inside an event handler
// for that fake event. If the callback throws, the error is "captured" using
// a global event handler. But because the error happens in a different
// event loop context, it does not interrupt the normal program flow.
// Effectively, this gives us try-catch behavior without actually using
// try-catch. Neat!
// Check that the browser supports the APIs we need to implement our special
// DEV version of invokeGuardedCallback
if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');var invokeGuardedCallbackDev=function(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method
// when we call document.createEvent(). However this can cause confusing
// errors: https://github.com/facebookincubator/create-react-app/issues/3482
// So we preemptively throw with a better message instead.
!(typeof document!=='undefined')?invariant(false,'The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.'):void 0;var evt=document.createEvent('Event');// Keeps track of whether the user-provided callback threw an error. We
// set this to true at the beginning, then set it to false right after
// calling the function. If the function errors, `didError` will never be
// set to false. This strategy works even if the browser is flaky and
// fails to call our global error handler, because it doesn't rely on
// the error event at all.
var didError=true;// Keeps track of the value of window.event so that we can reset it
// during the callback to let user code access window.event in the
// browsers that support it.
var windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event
// dispatching: https://github.com/facebook/react/issues/13688
var windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');// Create an event handler for our fake event. We will synchronously
// dispatch our fake event using `dispatchEvent`. Inside the handler, we
// call the user-provided callback.
var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){// We immediately remove the callback from event listeners so that
// nested `invokeGuardedCallback` calls do not clash. Otherwise, a
// nested call would trigger the fake event handlers of any call higher
// in the stack.
fakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the
// window.event assignment in both IE <= 10 as they throw an error
// "Member not found" in strict mode, and in Firefox which does not
// support window.event.
if(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
// that was thrown. It's possible that this error handler will fire more
// than once; for example, if non-React code also calls `dispatchEvent`
// and a handler for that event throws. We should be resilient to most of
// those cases. Even if our error event handler fires more than once, the
// last error event is always used. If the callback actually does error,
// we know that the last error event is the correct one, because it's not
// possible for anything else to have happened in between our callback
// erroring and the code that follows the `dispatchEvent` call below. If
// the callback doesn't error, but the error event was fired, we know to
// ignore it because `didError` will be false, as described above.
var error=void 0;// Use this to track whether the error event is ever called.
var didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.
// Browsers silence the error report if this happens.
// We'll remember this to later decide whether to log it or not.
if(error!=null&&typeof error==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.
}}}}// Create a fake event type.
var evtType='react-'+(name?name:'invokeguardedcallback');// Attach our event handlers
window.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
// errors, it will trigger our global error handler.
evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didError){if(!didSetError){// The callback errored, but the error event never fired.
error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://fb.me/react-crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners
window.removeEventListener('error',handleWindowError);};invokeGuardedCallbackImpl=invokeGuardedCallbackDev;}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;// Used by Fiber to simulate a try-catch.
var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.
var hasRethrowError=false;var rethrowError=null;var reporter={onError:function(error){hasError=true;caughtError=error;}};/**
 * Call a function while guarding against errors that happens within it.
 * Returns an error if it throws, otherwise null.
 *
 * In production, this is implemented using a try-catch. The reason we don't
 * use a try-catch directly is so that we can swap out a different
 * implementation in DEV mode.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**
 * Same as invokeGuardedCallback, but instead of returning an error, it stores
 * it in a global so it can be rethrown by `rethrowCaughtError` later.
 * TODO: See if caughtError and rethrowError can be unified.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} context The context to use when calling the function
 * @param {...*} args Arguments for function
 */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**
 * During execution of guarded functions we will capture the first error which
 * we will rethrow to be handled by the top level error handler.
 */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else{invariant(false,'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');}}/**
 * Injectable ordering of event plugins.
 */var eventPluginOrder=null;/**
 * Injectable mapping from names to event plugin modules.
 */var namesToPlugins={};/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */function recomputePluginOrdering(){if(!eventPluginOrder){// Wait until an `eventPluginOrder` is injected.
return;}for(var pluginName in namesToPlugins){var pluginModule=namesToPlugins[pluginName];var pluginIndex=eventPluginOrder.indexOf(pluginName);!(pluginIndex>-1)?invariant(false,'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.',pluginName):void 0;if(plugins[pluginIndex]){continue;}!pluginModule.extractEvents?invariant(false,'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.',pluginName):void 0;plugins[pluginIndex]=pluginModule;var publishedEvents=pluginModule.eventTypes;for(var eventName in publishedEvents){!publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName)?invariant(false,'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',eventName,pluginName):void 0;}}}/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */function publishEventForPlugin(dispatchConfig,pluginModule,eventName){!!eventNameDispatchConfigs.hasOwnProperty(eventName)?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.',eventName):void 0;eventNameDispatchConfigs[eventName]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(var phaseName in phasedRegistrationNames){if(phasedRegistrationNames.hasOwnProperty(phaseName)){var phasedRegistrationName=phasedRegistrationNames[phaseName];publishRegistrationName(phasedRegistrationName,pluginModule,eventName);}}return true;}else if(dispatchConfig.registrationName){publishRegistrationName(dispatchConfig.registrationName,pluginModule,eventName);return true;}return false;}/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */function publishRegistrationName(registrationName,pluginModule,eventName){!!registrationNameModules[registrationName]?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.',registrationName):void 0;registrationNameModules[registrationName]=pluginModule;registrationNameDependencies[registrationName]=pluginModule.eventTypes[eventName].dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}}/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */ /**
 * Ordered list of injected plugins.
 */var plugins=[];/**
 * Mapping from event name to dispatch config
 */var eventNameDispatchConfigs={};/**
 * Mapping from registration name to plugin module
 */var registrationNameModules={};/**
 * Mapping from registration name to event name
 */var registrationNameDependencies={};/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */function injectEventPluginOrder(injectedEventPluginOrder){!!eventPluginOrder?invariant(false,'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.'):void 0;// Clone the ordering so it cannot be dynamically mutated.
eventPluginOrder=Array.prototype.slice.call(injectedEventPluginOrder);recomputePluginOrdering();}/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */function injectEventPluginsByName(injectedNamesToPlugins){var isOrderingDirty=false;for(var pluginName in injectedNamesToPlugins){if(!injectedNamesToPlugins.hasOwnProperty(pluginName)){continue;}var pluginModule=injectedNamesToPlugins[pluginName];if(!namesToPlugins.hasOwnProperty(pluginName)||namesToPlugins[pluginName]!==pluginModule){!!namesToPlugins[pluginName]?invariant(false,'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.',pluginName):void 0;namesToPlugins[pluginName]=pluginModule;isOrderingDirty=true;}}if(isOrderingDirty){recomputePluginOrdering();}}/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var warningWithoutStack=function(){};{warningWithoutStack=function(condition,format){for(var _len=arguments.length,args=Array(_len>2?_len-2:0),_key=2;_key<_len;_key++){args[_key-2]=arguments[_key];}if(format===undefined){throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning '+'message argument');}if(args.length>8){// Check before the condition to catch violations early.
throw new Error('warningWithoutStack() currently supports at most 8 arguments.');}if(condition){return;}if(typeof console!=='undefined'){var argsWithFormat=args.map(function(item){return''+item;});argsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it
// breaks IE9: https://github.com/facebook/react/issues/13610
Function.prototype.apply.call(console.error,console,argsWithFormat);}try{// --- Welcome to debugging React ---
// This error was thrown as a convenience so that you can use this stack
// to find the callsite that caused this warning to fire.
var argIndex=0;var message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});throw new Error(message);}catch(x){}};}var warningWithoutStack$1=warningWithoutStack;var getFiberCurrentPropsFromNode=null;var getInstanceFromNode=null;var getNodeFromInstance=null;function setComponentTree(getFiberCurrentPropsFromNodeImpl,getInstanceFromNodeImpl,getNodeFromInstanceImpl){getFiberCurrentPropsFromNode=getFiberCurrentPropsFromNodeImpl;getInstanceFromNode=getInstanceFromNodeImpl;getNodeFromInstance=getNodeFromInstanceImpl;{!(getNodeFromInstance&&getInstanceFromNode)?warningWithoutStack$1(false,'EventPluginUtils.setComponentTree(...): Injected '+'module is missing getNodeFromInstance or getInstanceFromNode.'):void 0;}}var validateEventDispatches=void 0;{validateEventDispatches=function(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;var listenersIsArr=Array.isArray(dispatchListeners);var listenersLen=listenersIsArr?dispatchListeners.length:dispatchListeners?1:0;var instancesIsArr=Array.isArray(dispatchInstances);var instancesLen=instancesIsArr?dispatchInstances.length:dispatchInstances?1:0;!(instancesIsArr===listenersIsArr&&instancesLen===listenersLen)?warningWithoutStack$1(false,'EventPluginUtils: Invalid `event`.'):void 0;};}/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */function executeDispatch(event,listener,inst){var type=event.type||'unknown-event';event.currentTarget=getNodeFromInstance(inst);invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}/**
 * Standard/simple iteration through an event's collected dispatches.
 */function executeDispatchesInOrder(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;{validateEventDispatches(event);}if(Array.isArray(dispatchListeners)){for(var i=0;i<dispatchListeners.length;i++){if(event.isPropagationStopped()){break;}// Listeners and Instances are two parallel arrays that are always in sync.
executeDispatch(event,dispatchListeners[i],dispatchInstances[i]);}}else if(dispatchListeners){executeDispatch(event,dispatchListeners,dispatchInstances);}event._dispatchListeners=null;event._dispatchInstances=null;}/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */ /**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */ /**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */ /**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */function accumulateInto(current,next){!(next!=null)?invariant(false,'accumulateInto(...): Accumulated items must not be null or undefined.'):void 0;if(current==null){return next;}// Both are not empty. Warning: Never call x.concat(y) when you are not
// certain that x is an Array (x could be a string with concat method).
if(Array.isArray(current)){if(Array.isArray(next)){current.push.apply(current,next);return current;}current.push(next);return current;}if(Array.isArray(next)){// A bit too dangerous to mutate `next`.
return[current].concat(next);}return[current,next];}/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */function forEachAccumulated(arr,cb,scope){if(Array.isArray(arr)){arr.forEach(cb,scope);}else if(arr){cb.call(scope,arr);}}/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */var eventQueue=null;/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @private
 */var executeDispatchesAndRelease=function(event){if(event){executeDispatchesInOrder(event);if(!event.isPersistent()){event.constructor.release(event);}}};var executeDispatchesAndReleaseTopLevel=function(e){return executeDispatchesAndRelease(e);};function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':return!!(props.disabled&&isInteractive(type));default:return false;}}/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */ /**
 * Methods for injecting dependencies.
 */var injection={/**
   * @param {array} InjectedEventPluginOrder
   * @public
   */injectEventPluginOrder:injectEventPluginOrder,/**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */injectEventPluginsByName:injectEventPluginsByName};/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */function getListener(inst,registrationName){var listener=void 0;// TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
// live here; needs to be moved to a better place soon
var stateNode=inst.stateNode;if(!stateNode){// Work in progress (ex: onload events in incremental mode).
return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(!props){// Work in progress.
return null;}listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}!(!listener||typeof listener==='function')?invariant(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener):void 0;return listener;}/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=null;for(var i=0;i<plugins.length;i++){// Not every plugin in the ordering may be loaded at runtime.
var possiblePlugin=plugins[i];if(possiblePlugin){var extractedEvents=possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(extractedEvents){events=accumulateInto(events,extractedEvents);}}}return events;}function runEventsInBatch(events){if(events!==null){eventQueue=accumulateInto(eventQueue,events);}// Set `eventQueue` to null before processing it so that we can tell if more
// events get enqueued while processing.
var processingEventQueue=eventQueue;eventQueue=null;if(!processingEventQueue){return;}forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseTopLevel);!!eventQueue?invariant(false,'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.'):void 0;// This would be a good time to rethrow if any of the event handlers threw.
rethrowCaughtError();}function runExtractedEventsInBatch(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);runEventsInBatch(events);}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class
var HostRoot=3;// Root of a host tree. Could be nested inside another node.
var HostPortal=4;// A subtree. Could be an entry point to a different renderer.
var HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedSuspenseComponent=18;var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactInternalInstance$'+randomKey;var internalEventHandlersKey='__reactEventHandlers$'+randomKey;function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */function getClosestInstanceFromNode(node){if(node[internalInstanceKey]){return node[internalInstanceKey];}while(!node[internalInstanceKey]){if(node.parentNode){node=node.parentNode;}else{// Top of the tree. This node must not be part of a React tree (or is
// unmounted, potentially).
return null;}}var inst=node[internalInstanceKey];if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber, this will always be the deepest root.
return inst;}return null;}/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */function getInstanceFromNode$1(node){var inst=node[internalInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText){return inst;}else{return null;}}return null;}/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */function getNodeFromInstance$1(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
// a host component or host text.
return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
// invariant for a missing parent, which is super confusing.
invariant(false,'getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode$1(node){return node[internalEventHandlersKey]||null;}function updateFiberProps(node,props){node[internalEventHandlersKey]=props;}function getParent(inst){do{inst=inst.return;// TODO: If this is a HostRoot we might want to bail out.
// That is depending on if we want nested subtrees (layers) to bubble
// events to their parent. We could also go through parentNode on the
// host node but that wouldn't work for React Native and doesn't let us
// do the portal feature.
}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */function getLowestCommonAncestor(instA,instB){var depthA=0;for(var tempA=instA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=instB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
while(depthA-depthB>0){instA=getParent(instA);depthA--;}// If B is deeper, crawl up.
while(depthB-depthA>0){instB=getParent(instB);depthB--;}// Walk in lockstep until we find a match.
var depth=depthA;while(depth--){if(instA===instB||instA===instB.alternate){return instA;}instA=getParent(instA);instB=getParent(instB);}return null;}/**
 * Return if A is an ancestor of B.
 */ /**
 * Return the parent instance of the passed-in instance.
 */ /**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */function traverseTwoPhase(inst,fn,arg){var path=[];while(inst){path.push(inst);inst=getParent(inst);}var i=void 0;for(i=path.length;i-->0;){fn(path[i],'captured',arg);}for(i=0;i<path.length;i++){fn(path[i],'bubbled',arg);}}/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */function traverseEnterLeave(from,to,fn,argFrom,argTo){var common=from&&to?getLowestCommonAncestor(from,to):null;var pathFrom=[];while(true){if(!from){break;}if(from===common){break;}var alternate=from.alternate;if(alternate!==null&&alternate===common){break;}pathFrom.push(from);from=getParent(from);}var pathTo=[];while(true){if(!to){break;}if(to===common){break;}var _alternate=to.alternate;if(_alternate!==null&&_alternate===common){break;}pathTo.push(to);to=getParent(to);}for(var i=0;i<pathFrom.length;i++){fn(pathFrom[i],'bubbled',argFrom);}for(var _i=pathTo.length;_i-->0;){fn(pathTo[_i],'captured',argTo);}}/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */function listenerAtPhase(inst,event,propagationPhase){var registrationName=event.dispatchConfig.phasedRegistrationNames[propagationPhase];return getListener(inst,registrationName);}/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 */ /**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */function accumulateDirectionalDispatches(inst,phase,event){{!inst?warningWithoutStack$1(false,'Dispatching inst must not be null'):void 0;}var listener=listenerAtPhase(inst,event,phase);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */function accumulateTwoPhaseDispatchesSingle(event){if(event&&event.dispatchConfig.phasedRegistrationNames){traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event);}}/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */function accumulateDispatches(inst,ignoredDirection,event){if(inst&&event&&event.dispatchConfig.registrationName){var registrationName=event.dispatchConfig.registrationName;var listener=getListener(inst,registrationName);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}}/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */function accumulateDirectDispatchesSingle(event){if(event&&event.dispatchConfig.registrationName){accumulateDispatches(event._targetInst,null,event);}}function accumulateTwoPhaseDispatches(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle);}function accumulateEnterLeaveDispatches(leave,enter,from,to){traverseEnterLeave(from,to,accumulateDispatches,leave,enter);}function accumulateDirectDispatches(events){forEachAccumulated(events,accumulateDirectDispatchesSingle);}var canUseDOM=!!(typeof window!=='undefined'&&window.document&&window.document.createElement);// Do not uses the below two methods directly!
// Instead use constants exported from DOMTopLevelEventTypes in ReactDOM.
// (It is the only module that is allowed to access these methods.)
function unsafeCastStringToDOMTopLevelType(topLevelType){return topLevelType;}function unsafeCastDOMTopLevelTypeToString(topLevelType){return topLevelType;}/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**
 * A list of event names to a configurable list of vendor prefixes.
 */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
 * Event names that have already been detected and prefixed (if applicable).
 */var prefixedEventNames={};/**
 * Element to check for prefixes on.
 */var style={};/**
 * Bootstrap if a DOM exists.
 */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
// the un-prefixed "animation" and "transition" properties are defined on the
// style object but the events that fire will still be prefixed, so we need
// to check if the un-prefixed events are usable, and if not remove them from the map.
if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}/**
 * To identify top level events in ReactDOM, we use constants defined by this
 * module. This is the only module that uses the unsafe* methods to express
 * that the constants actually correspond to the browser event names. This lets
 * us save some bundle size by avoiding a top level type -> event name map.
 * The rest of ReactDOM code should import top level types from this file.
 */var TOP_ABORT=unsafeCastStringToDOMTopLevelType('abort');var TOP_ANIMATION_END=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationend'));var TOP_ANIMATION_ITERATION=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationiteration'));var TOP_ANIMATION_START=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('animationstart'));var TOP_BLUR=unsafeCastStringToDOMTopLevelType('blur');var TOP_CAN_PLAY=unsafeCastStringToDOMTopLevelType('canplay');var TOP_CAN_PLAY_THROUGH=unsafeCastStringToDOMTopLevelType('canplaythrough');var TOP_CANCEL=unsafeCastStringToDOMTopLevelType('cancel');var TOP_CHANGE=unsafeCastStringToDOMTopLevelType('change');var TOP_CLICK=unsafeCastStringToDOMTopLevelType('click');var TOP_CLOSE=unsafeCastStringToDOMTopLevelType('close');var TOP_COMPOSITION_END=unsafeCastStringToDOMTopLevelType('compositionend');var TOP_COMPOSITION_START=unsafeCastStringToDOMTopLevelType('compositionstart');var TOP_COMPOSITION_UPDATE=unsafeCastStringToDOMTopLevelType('compositionupdate');var TOP_CONTEXT_MENU=unsafeCastStringToDOMTopLevelType('contextmenu');var TOP_COPY=unsafeCastStringToDOMTopLevelType('copy');var TOP_CUT=unsafeCastStringToDOMTopLevelType('cut');var TOP_DOUBLE_CLICK=unsafeCastStringToDOMTopLevelType('dblclick');var TOP_AUX_CLICK=unsafeCastStringToDOMTopLevelType('auxclick');var TOP_DRAG=unsafeCastStringToDOMTopLevelType('drag');var TOP_DRAG_END=unsafeCastStringToDOMTopLevelType('dragend');var TOP_DRAG_ENTER=unsafeCastStringToDOMTopLevelType('dragenter');var TOP_DRAG_EXIT=unsafeCastStringToDOMTopLevelType('dragexit');var TOP_DRAG_LEAVE=unsafeCastStringToDOMTopLevelType('dragleave');var TOP_DRAG_OVER=unsafeCastStringToDOMTopLevelType('dragover');var TOP_DRAG_START=unsafeCastStringToDOMTopLevelType('dragstart');var TOP_DROP=unsafeCastStringToDOMTopLevelType('drop');var TOP_DURATION_CHANGE=unsafeCastStringToDOMTopLevelType('durationchange');var TOP_EMPTIED=unsafeCastStringToDOMTopLevelType('emptied');var TOP_ENCRYPTED=unsafeCastStringToDOMTopLevelType('encrypted');var TOP_ENDED=unsafeCastStringToDOMTopLevelType('ended');var TOP_ERROR=unsafeCastStringToDOMTopLevelType('error');var TOP_FOCUS=unsafeCastStringToDOMTopLevelType('focus');var TOP_GOT_POINTER_CAPTURE=unsafeCastStringToDOMTopLevelType('gotpointercapture');var TOP_INPUT=unsafeCastStringToDOMTopLevelType('input');var TOP_INVALID=unsafeCastStringToDOMTopLevelType('invalid');var TOP_KEY_DOWN=unsafeCastStringToDOMTopLevelType('keydown');var TOP_KEY_PRESS=unsafeCastStringToDOMTopLevelType('keypress');var TOP_KEY_UP=unsafeCastStringToDOMTopLevelType('keyup');var TOP_LOAD=unsafeCastStringToDOMTopLevelType('load');var TOP_LOAD_START=unsafeCastStringToDOMTopLevelType('loadstart');var TOP_LOADED_DATA=unsafeCastStringToDOMTopLevelType('loadeddata');var TOP_LOADED_METADATA=unsafeCastStringToDOMTopLevelType('loadedmetadata');var TOP_LOST_POINTER_CAPTURE=unsafeCastStringToDOMTopLevelType('lostpointercapture');var TOP_MOUSE_DOWN=unsafeCastStringToDOMTopLevelType('mousedown');var TOP_MOUSE_MOVE=unsafeCastStringToDOMTopLevelType('mousemove');var TOP_MOUSE_OUT=unsafeCastStringToDOMTopLevelType('mouseout');var TOP_MOUSE_OVER=unsafeCastStringToDOMTopLevelType('mouseover');var TOP_MOUSE_UP=unsafeCastStringToDOMTopLevelType('mouseup');var TOP_PASTE=unsafeCastStringToDOMTopLevelType('paste');var TOP_PAUSE=unsafeCastStringToDOMTopLevelType('pause');var TOP_PLAY=unsafeCastStringToDOMTopLevelType('play');var TOP_PLAYING=unsafeCastStringToDOMTopLevelType('playing');var TOP_POINTER_CANCEL=unsafeCastStringToDOMTopLevelType('pointercancel');var TOP_POINTER_DOWN=unsafeCastStringToDOMTopLevelType('pointerdown');var TOP_POINTER_MOVE=unsafeCastStringToDOMTopLevelType('pointermove');var TOP_POINTER_OUT=unsafeCastStringToDOMTopLevelType('pointerout');var TOP_POINTER_OVER=unsafeCastStringToDOMTopLevelType('pointerover');var TOP_POINTER_UP=unsafeCastStringToDOMTopLevelType('pointerup');var TOP_PROGRESS=unsafeCastStringToDOMTopLevelType('progress');var TOP_RATE_CHANGE=unsafeCastStringToDOMTopLevelType('ratechange');var TOP_RESET=unsafeCastStringToDOMTopLevelType('reset');var TOP_SCROLL=unsafeCastStringToDOMTopLevelType('scroll');var TOP_SEEKED=unsafeCastStringToDOMTopLevelType('seeked');var TOP_SEEKING=unsafeCastStringToDOMTopLevelType('seeking');var TOP_SELECTION_CHANGE=unsafeCastStringToDOMTopLevelType('selectionchange');var TOP_STALLED=unsafeCastStringToDOMTopLevelType('stalled');var TOP_SUBMIT=unsafeCastStringToDOMTopLevelType('submit');var TOP_SUSPEND=unsafeCastStringToDOMTopLevelType('suspend');var TOP_TEXT_INPUT=unsafeCastStringToDOMTopLevelType('textInput');var TOP_TIME_UPDATE=unsafeCastStringToDOMTopLevelType('timeupdate');var TOP_TOGGLE=unsafeCastStringToDOMTopLevelType('toggle');var TOP_TOUCH_CANCEL=unsafeCastStringToDOMTopLevelType('touchcancel');var TOP_TOUCH_END=unsafeCastStringToDOMTopLevelType('touchend');var TOP_TOUCH_MOVE=unsafeCastStringToDOMTopLevelType('touchmove');var TOP_TOUCH_START=unsafeCastStringToDOMTopLevelType('touchstart');var TOP_TRANSITION_END=unsafeCastStringToDOMTopLevelType(getVendorPrefixedEventName('transitionend'));var TOP_VOLUME_CHANGE=unsafeCastStringToDOMTopLevelType('volumechange');var TOP_WAITING=unsafeCastStringToDOMTopLevelType('waiting');var TOP_WHEEL=unsafeCastStringToDOMTopLevelType('wheel');// List of events that need to be individually attached to media elements.
// Note that events in this list will *not* be listened to at the top level
// unless they're explicitly whitelisted in `ReactBrowserEventEmitter.listenTo`.
var mediaEventTypes=[TOP_ABORT,TOP_CAN_PLAY,TOP_CAN_PLAY_THROUGH,TOP_DURATION_CHANGE,TOP_EMPTIED,TOP_ENCRYPTED,TOP_ENDED,TOP_ERROR,TOP_LOADED_DATA,TOP_LOADED_METADATA,TOP_LOAD_START,TOP_PAUSE,TOP_PLAY,TOP_PLAYING,TOP_PROGRESS,TOP_RATE_CHANGE,TOP_SEEKED,TOP_SEEKING,TOP_STALLED,TOP_SUSPEND,TOP_TIME_UPDATE,TOP_VOLUME_CHANGE,TOP_WAITING];function getRawEventName(topLevelType){return unsafeCastDOMTopLevelTypeToString(topLevelType);}/**
 * These variables store information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start=void 0;var startValue=startText;var startLength=startValue.length;var end=void 0;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/* eslint valid-typeof: 0 */var EVENT_POOL_SIZE=10;/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var EventInterface={type:null,target:null,// currentTarget is set when dispatching; no use in copying it here
currentTarget:function(){return null;},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(event){return event.timeStamp||Date.now();},defaultPrevented:null,isTrusted:null};function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */function SyntheticEvent(dispatchConfig,targetInst,nativeEvent,nativeEventTarget){{// these have a getter/setter for warnings
delete this.nativeEvent;delete this.preventDefault;delete this.stopPropagation;delete this.isDefaultPrevented;delete this.isPropagationStopped;}this.dispatchConfig=dispatchConfig;this._targetInst=targetInst;this.nativeEvent=nativeEvent;var Interface=this.constructor.Interface;for(var propName in Interface){if(!Interface.hasOwnProperty(propName)){continue;}{delete this[propName];// this has a getter/setter for warnings
}var normalize=Interface[propName];if(normalize){this[propName]=normalize(nativeEvent);}else{if(propName==='target'){this.target=nativeEventTarget;}else{this[propName]=nativeEvent[propName];}}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else{this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}_assign(SyntheticEvent.prototype,{preventDefault:function(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
// IE. This event does not support bubbling or cancelling, and
// any references to cancelBubble throw "Member not found".  A
// typeof check of "unknown" circumvents this issue (and is also
// IE specific).
event.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */persist:function(){this.isPersistent=functionThatReturnsTrue;},/**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */isPersistent:functionThatReturnsFalse,/**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */destructor:function(){var Interface=this.constructor.Interface;for(var propName in Interface){{Object.defineProperty(this,propName,getPooledWarningPropertyDefinition(propName,Interface[propName]));}}this.dispatchConfig=null;this._targetInst=null;this.nativeEvent=null;this.isDefaultPrevented=functionThatReturnsFalse;this.isPropagationStopped=functionThatReturnsFalse;this._dispatchListeners=null;this._dispatchInstances=null;{Object.defineProperty(this,'nativeEvent',getPooledWarningPropertyDefinition('nativeEvent',null));Object.defineProperty(this,'isDefaultPrevented',getPooledWarningPropertyDefinition('isDefaultPrevented',functionThatReturnsFalse));Object.defineProperty(this,'isPropagationStopped',getPooledWarningPropertyDefinition('isPropagationStopped',functionThatReturnsFalse));Object.defineProperty(this,'preventDefault',getPooledWarningPropertyDefinition('preventDefault',function(){}));Object.defineProperty(this,'stopPropagation',getPooledWarningPropertyDefinition('stopPropagation',function(){}));}}});SyntheticEvent.Interface=EventInterface;/**
 * Helper to reduce boilerplate when creating subclasses.
 */SyntheticEvent.extend=function(Interface){var Super=this;var E=function(){};E.prototype=Super.prototype;var prototype=new E();function Class(){return Super.apply(this,arguments);}_assign(prototype,Class.prototype);Class.prototype=prototype;Class.prototype.constructor=Class;Class.Interface=_assign({},Super.Interface,Interface);Class.extend=Super.extend;addEventPoolingTo(Class);return Class;};addEventPoolingTo(SyntheticEvent);/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */function getPooledWarningPropertyDefinition(propName,getVal){var isFunction=typeof getVal==='function';return{configurable:true,set:set,get:get};function set(val){var action=isFunction?'setting the method':'setting the property';warn(action,'This is effectively a no-op');return val;}function get(){var action=isFunction?'accessing the method':'accessing the property';var result=isFunction?'This is a no-op function':'This is set to null';warn(action,result);return getVal;}function warn(action,result){var warningCondition=false;!warningCondition?warningWithoutStack$1(false,"This synthetic event is reused for performance reasons. If you're seeing this, "+"you're %s `%s` on a released/nullified synthetic event. %s. "+'If you must keep the original synthetic event around, use event.persist(). '+'See https://fb.me/react-event-pooling for more information.',action,propName,result):void 0;}}function getPooledEvent(dispatchConfig,targetInst,nativeEvent,nativeInst){var EventConstructor=this;if(EventConstructor.eventPool.length){var instance=EventConstructor.eventPool.pop();EventConstructor.call(instance,dispatchConfig,targetInst,nativeEvent,nativeInst);return instance;}return new EventConstructor(dispatchConfig,targetInst,nativeEvent,nativeInst);}function releasePooledEvent(event){var EventConstructor=this;!(event instanceof EventConstructor)?invariant(false,'Trying to release an event instance into a pool of a different type.'):void 0;event.destructor();if(EventConstructor.eventPool.length<EVENT_POOL_SIZE){EventConstructor.eventPool.push(event);}}function addEventPoolingTo(EventConstructor){EventConstructor.eventPool=[];EventConstructor.getPooled=getPooledEvent;EventConstructor.release=releasePooledEvent;}/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */var SyntheticCompositionEvent=SyntheticEvent.extend({data:null});/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */var SyntheticInputEvent=SyntheticEvent.extend({data:null});var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
var START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);// Events and their corresponding property names.
var eventTypes={beforeInput:{phasedRegistrationNames:{bubbled:'onBeforeInput',captured:'onBeforeInputCapture'},dependencies:[TOP_COMPOSITION_END,TOP_KEY_PRESS,TOP_TEXT_INPUT,TOP_PASTE]},compositionEnd:{phasedRegistrationNames:{bubbled:'onCompositionEnd',captured:'onCompositionEndCapture'},dependencies:[TOP_BLUR,TOP_COMPOSITION_END,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_MOUSE_DOWN]},compositionStart:{phasedRegistrationNames:{bubbled:'onCompositionStart',captured:'onCompositionStartCapture'},dependencies:[TOP_BLUR,TOP_COMPOSITION_START,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_MOUSE_DOWN]},compositionUpdate:{phasedRegistrationNames:{bubbled:'onCompositionUpdate',captured:'onCompositionUpdateCapture'},dependencies:[TOP_BLUR,TOP_COMPOSITION_UPDATE,TOP_KEY_DOWN,TOP_KEY_PRESS,TOP_KEY_UP,TOP_MOUSE_DOWN]}};// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress=false;/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */function getCompositionEventType(topLevelType){switch(topLevelType){case TOP_COMPOSITION_START:return eventTypes.compositionStart;case TOP_COMPOSITION_END:return eventTypes.compositionEnd;case TOP_COMPOSITION_UPDATE:return eventTypes.compositionUpdate;}}/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionStart(topLevelType,nativeEvent){return topLevelType===TOP_KEY_DOWN&&nativeEvent.keyCode===START_KEYCODE;}/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionEnd(topLevelType,nativeEvent){switch(topLevelType){case TOP_KEY_UP:// Command keys insert or clear IME input.
return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case TOP_KEY_DOWN:// Expect IME keyCode on each keydown. If we get any other
// code we must have exited earlier.
return nativeEvent.keyCode!==START_KEYCODE;case TOP_KEY_PRESS:case TOP_MOUSE_DOWN:case TOP_BLUR:// Events are not possible without cancelling IME.
return true;default:return false;}}/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(typeof detail==='object'&&'data'in detail){return detail.data;}return null;}/**
 * Check if a composition event was triggered by Korean IME.
 * Our fallback mode does not work well with IE's Korean IME,
 * so just use native composition events when Korean IME is used.
 * Although CompositionEvent.locale property is deprecated,
 * it is available in IE, where our fallback mode is enabled.
 *
 * @param {object} nativeEvent
 * @return {boolean}
 */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.
var isComposing=false;/**
 * @return {?object} A SyntheticCompositionEvent.
 */function extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var eventType=void 0;var fallbackData=void 0;if(canUseCompositionEvent){eventType=getCompositionEventType(topLevelType);}else if(!isComposing){if(isFallbackCompositionStart(topLevelType,nativeEvent)){eventType=eventTypes.compositionStart;}}else if(isFallbackCompositionEnd(topLevelType,nativeEvent)){eventType=eventTypes.compositionEnd;}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be
// overwritten while composition continues.
if(!isComposing&&eventType===eventTypes.compositionStart){isComposing=initialize(nativeEventTarget);}else if(eventType===eventTypes.compositionEnd){if(isComposing){fallbackData=getData();}}}var event=SyntheticCompositionEvent.getPooled(eventType,targetInst,nativeEvent,nativeEventTarget);if(fallbackData){// Inject data generated from fallback path into the synthetic event.
// This matches the property of native CompositionEventInterface.
event.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}accumulateTwoPhaseDispatches(event);return event;}/**
 * @param {TopLevelType} topLevelType Number from `TopLevelType`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */function getNativeBeforeInputChars(topLevelType,nativeEvent){switch(topLevelType){case TOP_COMPOSITION_END:return getDataFromCustomEvent(nativeEvent);case TOP_KEY_PRESS:/**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case TOP_TEXT_INPUT:// Record the characters to be added to the DOM.
var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
// it at the keypress level and bail immediately. Android Chrome
// doesn't give us keycodes, so we need to ignore it.
if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
return null;}}/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {number} topLevelType Number from `TopLevelEventTypes`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */function getFallbackBeforeInputChars(topLevelType,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if(isComposing){if(topLevelType===TOP_COMPOSITION_END||!canUseCompositionEvent&&isFallbackCompositionEnd(topLevelType,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(topLevelType){case TOP_PASTE:// If a paste event occurs after a keypress, throw out the input
// chars. Paste events should not lead to BeforeInput events.
return null;case TOP_KEY_PRESS:/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
// Touch keyboard of Windows.  In such a case, the `char` property
// holds an emoji character like `\uD83D\uDE0A`.  Because its length
// is 2, the property `which` does not represent an emoji correctly.
// In such a case, we directly return the `char` property instead of
// using `which`.
if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case TOP_COMPOSITION_END:return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */function extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var chars=void 0;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(topLevelType,nativeEvent);}else{chars=getFallbackBeforeInputChars(topLevelType,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
// be fired.
if(!chars){return null;}var event=SyntheticInputEvent.getPooled(eventTypes.beforeInput,targetInst,nativeEvent,nativeEventTarget);event.data=chars;accumulateTwoPhaseDispatches(event);return event;}/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */var BeforeInputEventPlugin={eventTypes:eventTypes,extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){var composition=extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget);var beforeInput=extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(composition===null){return beforeInput;}if(beforeInput===null){return composition;}return[composition,beforeInput];}};// Use to restore controlled state after a change event has fired.
var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
// always receive the correct fiber here
var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
return;}!(typeof restoreImpl==='function')?invariant(false,'setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.'):void 0;var props=getFiberCurrentPropsFromNode(internalInstance.stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,props);}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults
var _batchedUpdatesImpl=function(fn,bookkeeping){return fn(bookkeeping);};var _interactiveUpdatesImpl=function(fn,a,b){return fn(a,b);};var _flushInteractiveUpdatesImpl=function(){};var isBatching=false;function batchedUpdates(fn,bookkeeping){if(isBatching){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state.
return fn(bookkeeping);}isBatching=true;try{return _batchedUpdatesImpl(fn,bookkeeping);}finally{// Here we wait until all updates have propagated, which is important
// when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
// Then we restore state of any controlled component.
isBatching=false;var controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of
// the DOM node back to the controlled value. This is necessary when React
// bails out of the update without touching the DOM.
_flushInteractiveUpdatesImpl();restoreStateIfNeeded();}}}function interactiveUpdates(fn,a,b){return _interactiveUpdatesImpl(fn,a,b);}function setBatchingImplementation(batchedUpdatesImpl,interactiveUpdatesImpl,flushInteractiveUpdatesImpl){_batchedUpdatesImpl=batchedUpdatesImpl;_interactiveUpdatesImpl=interactiveUpdatesImpl;_flushInteractiveUpdatesImpl=flushInteractiveUpdatesImpl;}/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**
 * HTML nodeType values that represent the type of the node
 */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9
// https://github.com/facebook/react/issues/12506
var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
// @see http://www.quirksmode.org/js/events_properties.html
return target.nodeType===TEXT_NODE?target.parentNode:target;}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
// and don't track value will cause over reporting of changes,
// but it's better then a hard failure
// (needed for certain tests that spyOn input values and Safari)
if(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var get=descriptor.get,set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function(){return get.call(this);},set:function(value){currentValue=''+value;set.call(this,value);}});// We could've passed this the first time
// but it triggers a bug in IE11 and Edge 14/15.
// Calling defineProperty() again should be equivalent.
// https://github.com/facebook/react/issues/11768
Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function(){return currentValue;},setValue:function(value){currentValue=''+value;},stopTracking:function(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
// that trying again will succeed
if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;// Prevent newer renderers from RTE when used with older react package versions.
// Current owner and dispatcher used to share the same ref,
// but PR #14548 split them out to better support the react-debug-tools package.
if(!ReactSharedInternals.hasOwnProperty('ReactCurrentDispatcher')){ReactSharedInternals.ReactCurrentDispatcher={current:null};}var BEFORE_SLASH_RE=/^(.*)[\\\/]/;var describeComponentFrame=function(name,source,ownerName){var sourceInfo='';if(source){var path=source.fileName;var fileName=path.replace(BEFORE_SLASH_RE,'');{// In DEV, include code for a common special case:
// prefer "folder/index.js" instead of just "index.js".
if(/^index\./.test(fileName)){var match=path.match(BEFORE_SLASH_RE);if(match){var pathBeforeSlash=match[1];if(pathBeforeSlash){var folderName=pathBeforeSlash.replace(BEFORE_SLASH_RE,'');fileName=folderName+'/'+fileName;}}}}sourceInfo=' (at '+fileName+':'+source.lineNumber+')';}else if(ownerName){sourceInfo=' (created by '+ownerName+')';}return'\n    in '+(name||'Unknown')+sourceInfo;};// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol=typeof Symbol==='function'&&Symbol.for;var REACT_ELEMENT_TYPE=hasSymbol?Symbol.for('react.element'):0xeac7;var REACT_PORTAL_TYPE=hasSymbol?Symbol.for('react.portal'):0xeaca;var REACT_FRAGMENT_TYPE=hasSymbol?Symbol.for('react.fragment'):0xeacb;var REACT_STRICT_MODE_TYPE=hasSymbol?Symbol.for('react.strict_mode'):0xeacc;var REACT_PROFILER_TYPE=hasSymbol?Symbol.for('react.profiler'):0xead2;var REACT_PROVIDER_TYPE=hasSymbol?Symbol.for('react.provider'):0xeacd;var REACT_CONTEXT_TYPE=hasSymbol?Symbol.for('react.context'):0xeace;var REACT_CONCURRENT_MODE_TYPE=hasSymbol?Symbol.for('react.concurrent_mode'):0xeacf;var REACT_FORWARD_REF_TYPE=hasSymbol?Symbol.for('react.forward_ref'):0xead0;var REACT_SUSPENSE_TYPE=hasSymbol?Symbol.for('react.suspense'):0xead1;var REACT_MEMO_TYPE=hasSymbol?Symbol.for('react.memo'):0xead3;var REACT_LAZY_TYPE=hasSymbol?Symbol.for('react.lazy'):0xead4;var MAYBE_ITERATOR_SYMBOL=typeof Symbol==='function'&&Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var Pending=0;var Resolved=1;var Rejected=2;function refineResolvedLazyComponent(lazyComponent){return lazyComponent._status===Resolved?lazyComponent._result:null;}function getWrappedName(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+'('+functionName+')':wrapperName);}function getComponentName(type){if(type==null){// Host root, text node or just invalid type.
return null;}{if(typeof type.tag==='number'){warningWithoutStack$1(false,'Received an unexpected object in getComponentName(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_CONCURRENT_MODE_TYPE:return'ConcurrentMode';case REACT_FRAGMENT_TYPE:return'Fragment';case REACT_PORTAL_TYPE:return'Portal';case REACT_PROFILER_TYPE:return'Profiler';case REACT_STRICT_MODE_TYPE:return'StrictMode';case REACT_SUSPENSE_TYPE:return'Suspense';}if(typeof type==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:return'Context.Consumer';case REACT_PROVIDER_TYPE:return'Context.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:return getComponentName(type.type);case REACT_LAZY_TYPE:{var thenable=type;var resolvedThenable=refineResolvedLazyComponent(thenable);if(resolvedThenable){return getComponentName(resolvedThenable);}}}}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;function describeFiber(fiber){switch(fiber.tag){case HostRoot:case HostPortal:case HostText:case Fragment:case ContextProvider:case ContextConsumer:return'';default:var owner=fiber._debugOwner;var source=fiber._debugSource;var name=getComponentName(fiber.type);var ownerName=null;if(owner){ownerName=getComponentName(owner.type);}return describeComponentFrame(name,source,ownerName);}}function getStackByFiberInDevAndProd(workInProgress){var info='';var node=workInProgress;do{info+=describeFiber(node);node=node.return;}while(node);return info;}var current=null;var phase=null;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentName(owner.type);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return'';}// Safe because if current fiber exists, we are reconciling,
// and it is guaranteed to be the work-in-progress version.
return getStackByFiberInDevAndProd(current);}return'';}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;phase=null;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=getCurrentFiberStackInDev;current=fiber;phase=null;}}function setCurrentPhase(lifeCyclePhase){{phase=lifeCyclePhase;}}/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var warning=warningWithoutStack$1;{warning=function(condition,format){if(condition){return;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();// eslint-disable-next-line react-internal/warning-and-invariant-args
for(var _len=arguments.length,args=Array(_len>2?_len-2:0),_key=2;_key<_len;_key++){args[_key-2]=arguments[_key];}warningWithoutStack$1.apply(undefined,[false,format+'%s'].concat(args,[stack]));};}var warning$1=warning;// A reserved attribute.
// It is handled by React separately and shouldn't be written to the DOM.
var RESERVED=0;// A simple string attribute.
// Attributes that aren't in the whitelist are presumed to have this type.
var STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called
// "enumerated" attributes with "true" and "false" as possible values.
// When true, it should be set to a "true" string.
// When false, it should be set to a "false" string.
var BOOLEANISH_STRING=2;// A real boolean attribute.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
var BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.
// When true, it should be present (set either to an empty string or its name).
// When false, it should be omitted.
// For any other value, should be present with that value.
var OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.
// When falsy, it should be removed.
var NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.
// When falsy, it should be removed.
var POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+'\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';var ROOT_ATTRIBUTE_NAME='data-reactroot';var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty=Object.prototype.hasOwnProperty;var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{warning$1(false,'Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(typeof value){case'function':// $FlowIssue symbol is perfectly valid here
case'symbol':// eslint-disable-line
return true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return!propertyInfo.acceptsBooleans;}else{var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;}// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
var properties={};// These props are reserved by React. They shouldn't be written to the DOM.
['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular
// elements (not just inputs). Now that ReactDOMInput assigns to the
// defaultValue property -- do we need this?
'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty
name,// attributeName
null);}// attributeNamespace
);// A few React string attributes have a different name.
// This is a mapping from React prop names to the attribute names.
[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,// attributeName
null);}// attributeNamespace
);// These are "enumerated" HTML attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty
name.toLowerCase(),// attributeName
null);}// attributeNamespace
);// These are "enumerated" SVG attributes that accept "true" and "false".
// In React, we let users pass `true` and `false` even though technically
// these aren't boolean attributes (they are coerced to strings).
// Since these are SVG attributes, their attribute names are case-sensitive.
['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty
name,// attributeName
null);}// attributeNamespace
);// These are HTML boolean attributes.
['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
'autoFocus','autoPlay','controls','default','defer','disabled','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata
'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty
name.toLowerCase(),// attributeName
null);}// attributeNamespace
);// These are the few React props that we set as DOM properties
// rather than attributes. These are all booleans.
['checked',// Note: `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`. We have special logic for handling this.
'multiple','muted','selected'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty
name,// attributeName
null);}// attributeNamespace
);// These are HTML attributes that are "overloaded booleans": they behave like
// booleans, but can also accept a string value.
['capture','download'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty
name,// attributeName
null);}// attributeNamespace
);// These are HTML attributes that must be positive numbers.
['cols','rows','size','span'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty
name,// attributeName
null);}// attributeNamespace
);// These are HTML attributes that must be numbers.
['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty
name.toLowerCase(),// attributeName
null);}// attributeNamespace
);var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,
// or boolean value assignment. Regular attributes that just accept strings
// and have the same names are omitted, just like in the HTML whitelist.
// Some of these attributes can be hard to find. This list was created by
// scrapping the MDN documentation.
['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,null);}// attributeNamespace
);// String SVG attributes with the xlink namespace.
['xlink:actuate','xlink:arcrole','xlink:href','xlink:role','xlink:show','xlink:title','xlink:type'].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,'http://www.w3.org/1999/xlink');});// String SVG attributes with the xml namespace.
['xml:base','xml:lang','xml:space'].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty
attributeName,'http://www.w3.org/XML/1998/namespace');});// These attribute exists both in HTML and SVG.
// The attribute name is case-sensitive in SVG so we can't just use
// the React name like we do for attributes that exist only in HTML.
['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty
attributeName.toLowerCase(),// attributeName
null);}// attributeNamespace
);/**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else{var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it
// for the error message.
return node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is
// the fact that we have it is the same as the expected.
return expected;}// Even if this property uses a namespace we use getAttribute
// because we assume its namespaced name is the same as our config.
// To use getAttributeNS we need the local name which we don't have
// in our config atm.
stringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);if(value===''+expected){return expected;}return value;}}/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}// If the prop isn't in the special list, treat it as a simple attribute.
if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else{node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else{// Contrary to `setAttribute`, object properties are properly
// `toString`ed by IE8/9.
node[propertyName]=value;}return;}// The rest are treated as attributes with special cases.
var attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else{var _type=propertyInfo.type;var attributeValue=void 0;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){attributeValue='';}else{// `setAttribute` with objects becomes only `[object]` in IE8/9,
// ('' + value) makes it output the correct toString()-value.
attributeValue=''+value;}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else{node.setAttribute(attributeName,attributeValue);}}}// Flow does not allow string concatenation of most non-string types. To work
// around this limitation, we use an opaque type that can only be obtained by
// passing the value through getToStringValue first.
function toString(value){return''+value;}function getToStringValue(value){switch(typeof value){case'boolean':case'number':case'object':case'string':case'undefined':return value;default:// function, symbol are assigned as empty strings
return'';}}var ReactDebugCurrentFrame$1=null;var ReactControlledValuePropTypes={checkPropTypes:null};{ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};var propTypes={value:function(props,propName,componentName){if(hasReadOnlyValue[props.type]||props.onChange||props.readOnly||props.disabled||props[propName]==null){return null;}return new Error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');},checked:function(props,propName,componentName){if(props.onChange||props.readOnly||props.disabled||props[propName]==null){return null;}return new Error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}};/**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */ReactControlledValuePropTypes.checkPropTypes=function(tagName,props){checkPropTypes(propTypes,props,'prop',tagName,ReactDebugCurrentFrame$1.getStackAddendum);};}var enableUserTimingAPI=true;// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects=false;// In some cases, StrictMode should also double-render lifecycles.
// This can be confusing for tests though,
// And it can be bad for performance in production.
// This feature flag can be used to control the behavior:
var debugRenderPhaseSideEffectsForStrictMode=true;// To preserve the "Pause on caught exceptions" behavior of the debugger, we
// replay the begin phase of a failed component inside invokeGuardedCallback.
var replayFailedUnitOfWorkWithInvokeGuardedCallback=true;// Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:
var warnAboutDeprecatedLifecycles=false;// Gather advanced timing metrics for Profiler subtrees.
var enableProfilerTimer=true;// Trace which interactions trigger each commit.
var enableSchedulerTracing=true;// Only used in www builds.
var enableSuspenseServerRenderer=false;// TODO: true? Here it might just be false.
// Only used in www builds.
// Only used in www builds.
// React Fire: prevent the value and checked attributes from syncing
// with their related DOM properties
var disableInputAttributeSyncing=false;// These APIs will no longer be "unstable" in the upcoming 16.7 release,
// Control this behavior with a flag to support 16.6 minor releases in the meanwhile.
var enableStableConcurrentModeAPIs=false;var warnAboutShorthandPropertyCollision=false;// TODO: direct imports like some-package/src/* are bad. Fix me.
var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=_assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{ReactControlledValuePropTypes.checkPropTypes('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){warning$1(false,'%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){warning$1(false,'%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var _controlled=isControlled(props);if(!node._wrapperState.controlled&&_controlled&&!didWarnUncontrolledToControlled){warning$1(false,'A component is changing an uncontrolled input of type %s to be controlled. '+'Input elements should not switch from uncontrolled to controlled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components',props.type);didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!_controlled&&!didWarnControlledToUncontrolled){warning$1(false,'A component is changing a controlled input of type %s to be uncontrolled. '+'Input elements should not switch from controlled to uncontrolled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components',props.type);didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.
// eslint-disable-next-line
node.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid
// blank-text buttons.
node.removeAttribute('value');return;}if(disableInputAttributeSyncing){// When not syncing the value attribute, React only assigns a new value
// whenever the defaultValue React prop has changed. When not present,
// React does nothing
if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}else{// When syncing the value attribute, the value comes from a cascade of
// properties:
//  1. The value React property
//  2. The defaultValue React property
//  3. Otherwise there should be no change
if(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}if(disableInputAttributeSyncing){// When not syncing the checked attribute, the attribute is directly
// controllable from the defaultValue React property. It needs to be
// updated as new props come in.
if(props.defaultChecked==null){node.removeAttribute('checked');}else{node.defaultChecked=!!props.defaultChecked;}}else{// When syncing the checked attribute, it only changes when it needs
// to be removed, such as transitioning from a checkbox into a text input
if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input
// from being lost during SSR hydration.
if(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the
// default value provided by the browser. See: #12872
if(isButton&&(props.value===undefined||props.value===null)){return;}var _initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input
// from being lost during SSR hydration.
if(!isHydrating){if(disableInputAttributeSyncing){var value=getToStringValue(props.value);// When not syncing the value attribute, the value property points
// directly to the React prop. Only assign it if it exists.
if(value!=null){// Always assign on buttons so that it is possible to assign an
// empty string to clear button text.
//
// Otherwise, do not re-assign the value property if is empty. This
// potentially avoids a DOM write and prevents Firefox (~60.0.1) from
// prematurely marking required inputs as invalid. Equality is compared
// to the current value in case the browser provided value is not an
// empty string.
if(isButton||value!==node.value){node.value=toString(value);}}}else{// When syncing the value attribute, the value property should use
// the wrapperState._initialValue property. This uses:
//
//   1. The value React property when present
//   2. The defaultValue React property when present
//   3. An empty string
if(_initialValue!==node.value){node.value=_initialValue;}}}if(disableInputAttributeSyncing){// When not syncing the value attribute, assign the value attribute
// directly from the defaultValue React property (when present)
var defaultValue=getToStringValue(props.defaultValue);if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}else{// Otherwise, the value attribute is synchronized to the property,
// so we assign defaultValue to the same thing as the value property
// assignment step above.
node.defaultValue=_initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
// this is needed to work around a chrome bug where setting defaultChecked
// will sometimes influence the value of checked (even after detachment).
// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
// We need to temporarily unset name to avoid disrupting radio button groups.
var name=node.name;if(name!==''){node.name='';}if(disableInputAttributeSyncing){// When not syncing the checked attribute, the checked property
// never gets assigned. It must be manually set. We don't want
// to do this when hydrating so that existing user input isn't
// modified
if(!isHydrating){updateChecked(element,props);}// Only assign the checked attribute if it is defined. This saves
// a DOM write when controlling the checked attribute isn't needed
// (text inputs, submit/reset)
if(props.hasOwnProperty('defaultChecked')){node.defaultChecked=!node.defaultChecked;node.defaultChecked=!!props.defaultChecked;}}else{// When syncing the checked attribute, both the checked property and
// attribute are assigned at the same time using defaultChecked. This uses:
//
//   1. The checked React property when present
//   2. The defaultChecked React property when present
//   3. Otherwise, false
node.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
// but that sometimes behaves strangely in IE8. We could also try using
// `form.getElementsByName`, but that will only return direct children
// and won't include inputs that use the HTML5 `form=` attribute. Since
// the input might not even be in a form. It might not even be in the
// document. Let's just use the local `querySelectorAll` to ensure we don't
// miss anything.
var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
// and the same name are rendered into the same form (same as #1939).
// That's probably okay; we don't support it just as we don't support
// mixing React radio buttons with non-React ones.
var otherProps=getFiberCurrentPropsFromNode$1(otherNode);!otherProps?invariant(false,'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'):void 0;// We need update the tracked value on the named cousin since the value
// was changed but the input saw no event or value set
updateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that
// was previously checked to update will cause it to be come re-checked
// as appropriate.
updateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
function setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js
type!=='number'||node.ownerDocument.activeElement!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var eventTypes$1={change:{phasedRegistrationNames:{bubbled:'onChange',captured:'onChangeCapture'},dependencies:[TOP_BLUR,TOP_CHANGE,TOP_CLICK,TOP_FOCUS,TOP_INPUT,TOP_KEY_DOWN,TOP_KEY_UP,TOP_SELECTION_CHANGE]}};function createAndAccumulateChangeEvent(inst,nativeEvent,target){var event=SyntheticEvent.getPooled(eventTypes$1.change,inst,nativeEvent,target);event.type='change';// Flag this event loop as needing state restore.
enqueueStateRestore(target);accumulateTwoPhaseDispatches(event);return event;}/**
 * For IE shims
 */var activeElement=null;var activeElementInst=null;/**
 * SECTION: handle `change` event
 */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var event=createAndAccumulateChangeEvent(activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
// other events and have it go through ReactBrowserEventEmitter. Since it
// doesn't, we manually listen for the events and so we have to enqueue and
// process the abstract event manually.
//
// Batching is necessary here in order to ensure that all event handlers run
// before the next rerender (including event handlers attached to ancestor
// elements instead of directly on the input). Without this, controlled
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
batchedUpdates(runEventInBatch,event);}function runEventInBatch(event){runEventsInBatch(event);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance$1(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(topLevelType,targetInst){if(topLevelType===TOP_CHANGE){return targetInst;}}/**
 * SECTION: handle `input` event
 */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when
// deleting text, so we ignore its input events.
isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(topLevelType,target,targetInst){if(topLevelType===TOP_FOCUS){// In IE9, propertychange fires for most input events but is buggy and
// doesn't fire when text is deleted, but conveniently, selectionchange
// appears to fire in all of the remaining cases so we catch those and
// forward the event if the value has changed
// In either case, we don't want to call the event handler if the value
// is changed from JS so we redefine a setter for `.value` that updates
// our activeElementValue variable, allowing us to ignore those changes
//
// stopWatching() should be a noop here but we call it just in case we
// missed a blur event somehow.
stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(topLevelType===TOP_BLUR){stopWatchingForValueChange();}}// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType,targetInst){if(topLevelType===TOP_SELECTION_CHANGE||topLevelType===TOP_KEY_UP||topLevelType===TOP_KEY_DOWN){// On the selectionchange event, the target is just document which isn't
// helpful for us so just check activeElement instead.
//
// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
// propertychange on the first input event after setting `value` from a
// script and fires only keydown, keypress, keyup. Catching keyup usually
// gets it and catching keydown lets us fire an event for the first
// keystroke if user does a key repeat (it'll be a little delayed: right
// before the second keystroke). Other input methods (e.g., paste) seem to
// fire selectionchange normally.
return getInstIfValueChanged(activeElementInst);}}/**
 * SECTION: handle `click` event
 */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
// This approach works across all browsers, whereas `change` does not fire
// until `blur` in IE8.
var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(topLevelType,targetInst){if(topLevelType===TOP_CLICK){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(topLevelType,targetInst){if(topLevelType===TOP_INPUT||topLevelType===TOP_CHANGE){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}if(!disableInputAttributeSyncing){// If controlled, assign the value attribute to the current value on blur
setDefaultValue(node,'number',node.value);}}/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */var ChangeEventPlugin={eventTypes:eventTypes$1,_isInputEventSupported:isInputEventSupported,extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;var getTargetInstFunc=void 0,handleEventFunc=void 0;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(topLevelType,targetInst);if(inst){var event=createAndAccumulateChangeEvent(inst,nativeEvent,nativeEventTarget);return event;}}if(handleEventFunc){handleEventFunc(topLevelType,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
if(topLevelType===TOP_BLUR){handleControlledInputBlur(targetNode);}}};/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */var DOMEventPluginOrder=['ResponderEventPlugin','SimpleEventPlugin','EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin','BeforeInputEventPlugin'];var SyntheticUIEvent=SyntheticEvent.extend({view:null,detail:null});var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support
// getModifierState. If getModifierState is not supported, we map it to a set of
// modifier keys exposed by the event. In this case, Lock-keys are not supported.
/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}var previousScreenX=0;var previousScreenY=0;// Use flags to signal movementX/Y has already been set
var isMovementXSet=false;var isMovementYSet=false;/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var SyntheticMouseEvent=SyntheticUIEvent.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:getEventModifierState,button:null,buttons:null,relatedTarget:function(event){return event.relatedTarget||(event.fromElement===event.srcElement?event.toElement:event.fromElement);},movementX:function(event){if('movementX'in event){return event.movementX;}var screenX=previousScreenX;previousScreenX=event.screenX;if(!isMovementXSet){isMovementXSet=true;return 0;}return event.type==='mousemove'?event.screenX-screenX:0;},movementY:function(event){if('movementY'in event){return event.movementY;}var screenY=previousScreenY;previousScreenY=event.screenY;if(!isMovementYSet){isMovementYSet=true;return 0;}return event.type==='mousemove'?event.screenY-screenY:0;}});/**
 * @interface PointerEvent
 * @see http://www.w3.org/TR/pointerevents/
 */var SyntheticPointerEvent=SyntheticMouseEvent.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null});var eventTypes$2={mouseEnter:{registrationName:'onMouseEnter',dependencies:[TOP_MOUSE_OUT,TOP_MOUSE_OVER]},mouseLeave:{registrationName:'onMouseLeave',dependencies:[TOP_MOUSE_OUT,TOP_MOUSE_OVER]},pointerEnter:{registrationName:'onPointerEnter',dependencies:[TOP_POINTER_OUT,TOP_POINTER_OVER]},pointerLeave:{registrationName:'onPointerLeave',dependencies:[TOP_POINTER_OUT,TOP_POINTER_OVER]}};var EnterLeaveEventPlugin={eventTypes:eventTypes$2,/**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){var isOverEvent=topLevelType===TOP_MOUSE_OVER||topLevelType===TOP_POINTER_OVER;var isOutEvent=topLevelType===TOP_MOUSE_OUT||topLevelType===TOP_POINTER_OUT;if(isOverEvent&&(nativeEvent.relatedTarget||nativeEvent.fromElement)){return null;}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.
return null;}var win=void 0;if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
win=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from=void 0;var to=void 0;if(isOutEvent){from=targetInst;var related=nativeEvent.relatedTarget||nativeEvent.toElement;to=related?getClosestInstanceFromNode(related):null;}else{// Moving to a node from outside the window.
from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
return null;}var eventInterface=void 0,leaveEventType=void 0,enterEventType=void 0,eventTypePrefix=void 0;if(topLevelType===TOP_MOUSE_OUT||topLevelType===TOP_MOUSE_OVER){eventInterface=SyntheticMouseEvent;leaveEventType=eventTypes$2.mouseLeave;enterEventType=eventTypes$2.mouseEnter;eventTypePrefix='mouse';}else if(topLevelType===TOP_POINTER_OUT||topLevelType===TOP_POINTER_OVER){eventInterface=SyntheticPointerEvent;leaveEventType=eventTypes$2.pointerLeave;enterEventType=eventTypes$2.pointerEnter;eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance$1(from);var toNode=to==null?win:getNodeFromInstance$1(to);var leave=eventInterface.getPooled(leaveEventType,from,nativeEvent,nativeEventTarget);leave.type=eventTypePrefix+'leave';leave.target=fromNode;leave.relatedTarget=toNode;var enter=eventInterface.getPooled(enterEventType,to,nativeEvent,nativeEventTarget);enter.type=eventTypePrefix+'enter';enter.target=toNode;enter.relatedTarget=fromNode;accumulateEnterLeaveDispatches(leave,enter,from,to);return[leave,enter];}};/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare
;}var hasOwnProperty$1=Object.prototype.hasOwnProperty;/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */function shallowEqual(objA,objB){if(is(objA,objB)){return true;}if(typeof objA!=='object'||objA===null||typeof objB!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.
for(var i=0;i<keysA.length;i++){if(!hasOwnProperty$1.call(objB,keysA[i])||!is(objA[keysA[i]],objB[keysA[i]])){return false;}}return true;}/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */ /**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */function get(key){return key._reactInternalFiber;}function has(key){return key._reactInternalFiber!==undefined;}function set(key,value){key._reactInternalFiber=value;}// Don't change these two values. They're used by React Dev Tools.
var NoEffect=/*              */0;var PerformedWork=/*         */1;// You can change the rest (and add more).
var Placement=/*             */2;var Update=/*                */4;var PlacementAndUpdate=/*    */6;var Deletion=/*              */8;var ContentReset=/*          */16;var Callback=/*              */32;var DidCapture=/*            */64;var Ref=/*                   */128;var Snapshot=/*              */256;var Passive=/*               */512;// Passive & Update & Callback & Ref & Snapshot
var LifecycleEffectMask=/*   */932;// Union of all host effects
var HostEffectMask=/*        */1023;var Incomplete=/*            */1024;var ShouldCapture=/*         */2048;var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var MOUNTING=1;var MOUNTED=2;var UNMOUNTED=3;function isFiberMountedImpl(fiber){var node=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
// yet. If it is, then it will have a pending insertion effect on it.
if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}while(node.return){node=node.return;if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}}}else{while(node.return){node=node.return;}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
// renderContainerIntoSubtree.
return MOUNTED;}// If we didn't hit the root, that means that we're in an disconnected tree
// that has been unmounted.
return UNMOUNTED;}function isFiberMounted(fiber){return isFiberMountedImpl(fiber)===MOUNTED;}function isMounted(component){{var owner=ReactCurrentOwner$1.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;!instance._warnedAboutRefsInRender?warningWithoutStack$1(false,'%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(ownerFiber.type)||'A component'):void 0;instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return isFiberMountedImpl(fiber)===MOUNTED;}function assertIsMounted(fiber){!(isFiberMountedImpl(fiber)===MOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
var state=isFiberMountedImpl(fiber);!(state!==UNMOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(state===MOUNTING){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
// to see what path the root points to. On the way we may hit one of the
// special cases and we'll deal with them.
var a=fiber;var b=alternate;while(true){var parentA=a.return;var parentB=parentA?parentA.alternate:null;if(!parentA||!parentB){// We're at the root.
break;}// If both copies of the parent fiber point to the same child, we can
// assume that the child is current. This happens when we bailout on low
// priority: the bailed out fiber's child reuses the current child.
if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
// way this could possibly happen is if this was unmounted, if at all.
invariant(false,'Unable to find node on an unmounted component.');}if(a.return!==b.return){// The return pointer of A and the return pointer of B point to different
// fibers. We assume that return pointers never criss-cross, so A must
// belong to the child set of A.return, and B must belong to the child
// set of B.return.
a=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the
// default, slow path: scan the child sets of each parent alternate to see
// which child belongs to which set.
//
// Search parent A's child set
var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}!didFindChild?invariant(false,'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'):void 0;}}!(a.alternate===b)?invariant(false,'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.'):void 0;}// If the root is not a host container, we're in a disconnected tree. I.e.
// unmounted.
!(a.tag===HostRoot)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(a.stateNode.current===a){// We've determined that A is the current branch.
return fiber;}// Otherwise B has to be current branch.
return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child){node.child.return=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node.return||node.return===currentParent){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child&&node.tag!==HostPortal){node.child.return=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node.return||node.return===currentParent){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function addEventBubbleListener(element,eventType,listener){element.addEventListener(eventType,listener,false);}function addEventCaptureListener(element,eventType,listener){element.addEventListener(eventType,listener,true);}/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */var SyntheticAnimationEvent=SyntheticEvent.extend({animationName:null,elapsedTime:null,pseudoElement:null});/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */var SyntheticClipboardEvent=SyntheticEvent.extend({clipboardData:function(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}});/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var SyntheticFocusEvent=SyntheticUIEvent.extend({relatedTarget:null});/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */function getEventCharCode(nativeEvent){var charCode=void 0;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
if(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.
charCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)
// report Enter as charCode 10 when ctrl is pressed.
if(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
// Must not discard the (non-)printable Enter-key.
if(charCode>=32||charCode===13){return charCode;}return 0;}/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
// implementations of a working draft specification.
// FireFox implements `key` but returns `MozPrintableKey` for all
// printable characters (normalized to `Unidentified`), ignore it.
var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
// thus be captured by `keypress`, no other non-printable key should.
return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
// `keyCode` value, almost all function keys have a universal value.
return translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var SyntheticKeyboardEvent=SyntheticUIEvent.extend({key:getEventKey,location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:getEventModifierState,// Legacy Interface
charCode:function(event){// `charCode` is the result of a KeyPress event and represents the value of
// the actual printable character.
// KeyPress is deprecated, but its replacement is not yet final and not
// implemented in any major browser. Only KeyPress has charCode.
if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
// physical keyboard key.
// The actual meaning of the value depends on the users' keyboard layout
// which cannot be detected. Assuming that it is a US keyboard layout
// provides a surprisingly accurate mapping for US and European users.
// Due to this, it is left to the user to implement at this time.
if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
// type of the event.
if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var SyntheticDragEvent=SyntheticMouseEvent.extend({dataTransfer:null});/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */var SyntheticTouchEvent=SyntheticUIEvent.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:getEventModifierState});/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */var SyntheticTransitionEvent=SyntheticEvent.extend({propertyName:null,elapsedTime:null,pseudoElement:null});/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var SyntheticWheelEvent=SyntheticMouseEvent.extend({deltaX:function(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:null,// Browsers without "deltaMode" is reporting in raw wheel delta where one
// notch on the scroll is always +/- 120, roughly equivalent to pixels.
// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
deltaMode:null});/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: [TOP_ABORT],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = new Map([
 *   [TOP_ABORT, { sameConfig }],
 * ]);
 */var interactiveEventTypeNames=[[TOP_BLUR,'blur'],[TOP_CANCEL,'cancel'],[TOP_CLICK,'click'],[TOP_CLOSE,'close'],[TOP_CONTEXT_MENU,'contextMenu'],[TOP_COPY,'copy'],[TOP_CUT,'cut'],[TOP_AUX_CLICK,'auxClick'],[TOP_DOUBLE_CLICK,'doubleClick'],[TOP_DRAG_END,'dragEnd'],[TOP_DRAG_START,'dragStart'],[TOP_DROP,'drop'],[TOP_FOCUS,'focus'],[TOP_INPUT,'input'],[TOP_INVALID,'invalid'],[TOP_KEY_DOWN,'keyDown'],[TOP_KEY_PRESS,'keyPress'],[TOP_KEY_UP,'keyUp'],[TOP_MOUSE_DOWN,'mouseDown'],[TOP_MOUSE_UP,'mouseUp'],[TOP_PASTE,'paste'],[TOP_PAUSE,'pause'],[TOP_PLAY,'play'],[TOP_POINTER_CANCEL,'pointerCancel'],[TOP_POINTER_DOWN,'pointerDown'],[TOP_POINTER_UP,'pointerUp'],[TOP_RATE_CHANGE,'rateChange'],[TOP_RESET,'reset'],[TOP_SEEKED,'seeked'],[TOP_SUBMIT,'submit'],[TOP_TOUCH_CANCEL,'touchCancel'],[TOP_TOUCH_END,'touchEnd'],[TOP_TOUCH_START,'touchStart'],[TOP_VOLUME_CHANGE,'volumeChange']];var nonInteractiveEventTypeNames=[[TOP_ABORT,'abort'],[TOP_ANIMATION_END,'animationEnd'],[TOP_ANIMATION_ITERATION,'animationIteration'],[TOP_ANIMATION_START,'animationStart'],[TOP_CAN_PLAY,'canPlay'],[TOP_CAN_PLAY_THROUGH,'canPlayThrough'],[TOP_DRAG,'drag'],[TOP_DRAG_ENTER,'dragEnter'],[TOP_DRAG_EXIT,'dragExit'],[TOP_DRAG_LEAVE,'dragLeave'],[TOP_DRAG_OVER,'dragOver'],[TOP_DURATION_CHANGE,'durationChange'],[TOP_EMPTIED,'emptied'],[TOP_ENCRYPTED,'encrypted'],[TOP_ENDED,'ended'],[TOP_ERROR,'error'],[TOP_GOT_POINTER_CAPTURE,'gotPointerCapture'],[TOP_LOAD,'load'],[TOP_LOADED_DATA,'loadedData'],[TOP_LOADED_METADATA,'loadedMetadata'],[TOP_LOAD_START,'loadStart'],[TOP_LOST_POINTER_CAPTURE,'lostPointerCapture'],[TOP_MOUSE_MOVE,'mouseMove'],[TOP_MOUSE_OUT,'mouseOut'],[TOP_MOUSE_OVER,'mouseOver'],[TOP_PLAYING,'playing'],[TOP_POINTER_MOVE,'pointerMove'],[TOP_POINTER_OUT,'pointerOut'],[TOP_POINTER_OVER,'pointerOver'],[TOP_PROGRESS,'progress'],[TOP_SCROLL,'scroll'],[TOP_SEEKING,'seeking'],[TOP_STALLED,'stalled'],[TOP_SUSPEND,'suspend'],[TOP_TIME_UPDATE,'timeUpdate'],[TOP_TOGGLE,'toggle'],[TOP_TOUCH_MOVE,'touchMove'],[TOP_TRANSITION_END,'transitionEnd'],[TOP_WAITING,'waiting'],[TOP_WHEEL,'wheel']];var eventTypes$4={};var topLevelEventsToDispatchConfig={};function addEventTypeNameToConfig(_ref,isInteractive){var topEvent=_ref[0],event=_ref[1];var capitalizedEvent=event[0].toUpperCase()+event.slice(1);var onEvent='on'+capitalizedEvent;var type={phasedRegistrationNames:{bubbled:onEvent,captured:onEvent+'Capture'},dependencies:[topEvent],isInteractive:isInteractive};eventTypes$4[event]=type;topLevelEventsToDispatchConfig[topEvent]=type;}interactiveEventTypeNames.forEach(function(eventTuple){addEventTypeNameToConfig(eventTuple,true);});nonInteractiveEventTypeNames.forEach(function(eventTuple){addEventTypeNameToConfig(eventTuple,false);});// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes=[TOP_ABORT,TOP_CANCEL,TOP_CAN_PLAY,TOP_CAN_PLAY_THROUGH,TOP_CLOSE,TOP_DURATION_CHANGE,TOP_EMPTIED,TOP_ENCRYPTED,TOP_ENDED,TOP_ERROR,TOP_INPUT,TOP_INVALID,TOP_LOAD,TOP_LOADED_DATA,TOP_LOADED_METADATA,TOP_LOAD_START,TOP_PAUSE,TOP_PLAY,TOP_PLAYING,TOP_PROGRESS,TOP_RATE_CHANGE,TOP_RESET,TOP_SEEKED,TOP_SEEKING,TOP_STALLED,TOP_SUBMIT,TOP_SUSPEND,TOP_TIME_UPDATE,TOP_TOGGLE,TOP_VOLUME_CHANGE,TOP_WAITING];var SimpleEventPlugin={eventTypes:eventTypes$4,isInteractiveTopLevelEventType:function(topLevelType){var config=topLevelEventsToDispatchConfig[topLevelType];return config!==undefined&&config.isInteractive===true;},extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){var dispatchConfig=topLevelEventsToDispatchConfig[topLevelType];if(!dispatchConfig){return null;}var EventConstructor=void 0;switch(topLevelType){case TOP_KEY_PRESS:// Firefox creates a keypress event for function keys too. This removes
// the unwanted keypress events. Enter is however both printable and
// non-printable. One would expect Tab to be as well (but it isn't).
if(getEventCharCode(nativeEvent)===0){return null;}/* falls through */case TOP_KEY_DOWN:case TOP_KEY_UP:EventConstructor=SyntheticKeyboardEvent;break;case TOP_BLUR:case TOP_FOCUS:EventConstructor=SyntheticFocusEvent;break;case TOP_CLICK:// Firefox creates a click event on right mouse clicks. This removes the
// unwanted click events.
if(nativeEvent.button===2){return null;}/* falls through */case TOP_AUX_CLICK:case TOP_DOUBLE_CLICK:case TOP_MOUSE_DOWN:case TOP_MOUSE_MOVE:case TOP_MOUSE_UP:// TODO: Disabled elements should not respond to mouse events
/* falls through */case TOP_MOUSE_OUT:case TOP_MOUSE_OVER:case TOP_CONTEXT_MENU:EventConstructor=SyntheticMouseEvent;break;case TOP_DRAG:case TOP_DRAG_END:case TOP_DRAG_ENTER:case TOP_DRAG_EXIT:case TOP_DRAG_LEAVE:case TOP_DRAG_OVER:case TOP_DRAG_START:case TOP_DROP:EventConstructor=SyntheticDragEvent;break;case TOP_TOUCH_CANCEL:case TOP_TOUCH_END:case TOP_TOUCH_MOVE:case TOP_TOUCH_START:EventConstructor=SyntheticTouchEvent;break;case TOP_ANIMATION_END:case TOP_ANIMATION_ITERATION:case TOP_ANIMATION_START:EventConstructor=SyntheticAnimationEvent;break;case TOP_TRANSITION_END:EventConstructor=SyntheticTransitionEvent;break;case TOP_SCROLL:EventConstructor=SyntheticUIEvent;break;case TOP_WHEEL:EventConstructor=SyntheticWheelEvent;break;case TOP_COPY:case TOP_CUT:case TOP_PASTE:EventConstructor=SyntheticClipboardEvent;break;case TOP_GOT_POINTER_CAPTURE:case TOP_LOST_POINTER_CAPTURE:case TOP_POINTER_CANCEL:case TOP_POINTER_DOWN:case TOP_POINTER_MOVE:case TOP_POINTER_OUT:case TOP_POINTER_OVER:case TOP_POINTER_UP:EventConstructor=SyntheticPointerEvent;break;default:{if(knownHTMLTopLevelTypes.indexOf(topLevelType)===-1){warningWithoutStack$1(false,'SimpleEventPlugin: Unhandled event type, `%s`. This warning '+'is likely caused by a bug in React. Please file an issue.',topLevelType);}}// HTML Events
// @see http://www.w3.org/TR/html5/index.html#events-0
EventConstructor=SyntheticEvent;break;}var event=EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget);accumulateTwoPhaseDispatches(event);return event;}};var isInteractiveTopLevelEventType=SimpleEventPlugin.isInteractiveTopLevelEventType;var CALLBACK_BOOKKEEPING_POOL_SIZE=10;var callbackBookkeepingPool=[];/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */function findRootContainerNode(inst){// TODO: It may be a good idea to cache this to prevent unnecessary DOM
// traversal, but caching is difficult to do correctly without using a
// mutation observer to listen for all DOM changes.
while(inst.return){inst=inst.return;}if(inst.tag!==HostRoot){// This can happen if we're in a detached tree.
return null;}return inst.stateNode.containerInfo;}// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst){if(callbackBookkeepingPool.length){var instance=callbackBookkeepingPool.pop();instance.topLevelType=topLevelType;instance.nativeEvent=nativeEvent;instance.targetInst=targetInst;return instance;}return{topLevelType:topLevelType,nativeEvent:nativeEvent,targetInst:targetInst,ancestors:[]};}function releaseTopLevelCallbackBookKeeping(instance){instance.topLevelType=null;instance.nativeEvent=null;instance.targetInst=null;instance.ancestors.length=0;if(callbackBookkeepingPool.length<CALLBACK_BOOKKEEPING_POOL_SIZE){callbackBookkeepingPool.push(instance);}}function handleTopLevel(bookKeeping){var targetInst=bookKeeping.targetInst;// Loop through the hierarchy, in case there's any nested components.
// It's important that we build the array of ancestors before calling any
// event handlers, because event handlers can modify the DOM, leading to
// inconsistencies with ReactMount's node cache. See #1105.
var ancestor=targetInst;do{if(!ancestor){bookKeeping.ancestors.push(ancestor);break;}var root=findRootContainerNode(ancestor);if(!root){break;}bookKeeping.ancestors.push(ancestor);ancestor=getClosestInstanceFromNode(root);}while(ancestor);for(var i=0;i<bookKeeping.ancestors.length;i++){targetInst=bookKeeping.ancestors[i];runExtractedEventsInBatch(bookKeeping.topLevelType,targetInst,bookKeeping.nativeEvent,getEventTarget(bookKeeping.nativeEvent));}}// TODO: can we stop exporting these?
var _enabled=true;function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}/**
 * Traps top-level events by using event bubbling.
 *
 * @param {number} topLevelType Number from `TopLevelEventTypes`.
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapBubbledEvent(topLevelType,element){if(!element){return null;}var dispatch=isInteractiveTopLevelEventType(topLevelType)?dispatchInteractiveEvent:dispatchEvent;addEventBubbleListener(element,getRawEventName(topLevelType),// Check if interactive and wrap in interactiveUpdates
dispatch.bind(null,topLevelType));}/**
 * Traps a top-level event by using event capturing.
 *
 * @param {number} topLevelType Number from `TopLevelEventTypes`.
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapCapturedEvent(topLevelType,element){if(!element){return null;}var dispatch=isInteractiveTopLevelEventType(topLevelType)?dispatchInteractiveEvent:dispatchEvent;addEventCaptureListener(element,getRawEventName(topLevelType),// Check if interactive and wrap in interactiveUpdates
dispatch.bind(null,topLevelType));}function dispatchInteractiveEvent(topLevelType,nativeEvent){interactiveUpdates(dispatchEvent,topLevelType,nativeEvent);}function dispatchEvent(topLevelType,nativeEvent){if(!_enabled){return;}var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null&&typeof targetInst.tag==='number'&&!isFiberMounted(targetInst)){// If we get an event (ex: img onload) before committing that
// component's mount, ignore it for now (that is, treat it as if it was an
// event on a non-React tree). We might also consider queueing events and
// dispatching them after the mount.
targetInst=null;}var bookKeeping=getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst);try{// Event queue being processed in the same cycle allows
// `preventDefault`.
batchedUpdates(handleTopLevel,bookKeeping);}finally{releaseTopLevelCallbackBookKeeping(bookKeeping);}}/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */var alreadyListeningTo={};var reactTopListenersCounter=0;/**
 * To ensure no conflicts with other potential React instances on the page
 */var topListenersIDKey='_reactListenersID'+(''+Math.random()).slice(2);function getListeningForDocument(mountAt){// In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
// directly.
if(!Object.prototype.hasOwnProperty.call(mountAt,topListenersIDKey)){mountAt[topListenersIDKey]=reactTopListenersCounter++;alreadyListeningTo[mountAt[topListenersIDKey]]={};}return alreadyListeningTo[mountAt[topListenersIDKey]];}/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} mountAt Container where to mount the listener
 */function listenTo(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){switch(dependency){case TOP_SCROLL:trapCapturedEvent(TOP_SCROLL,mountAt);break;case TOP_FOCUS:case TOP_BLUR:trapCapturedEvent(TOP_FOCUS,mountAt);trapCapturedEvent(TOP_BLUR,mountAt);// We set the flag for a single dependency later in this function,
// but this ensures we mark both as attached rather than just one.
isListening[TOP_BLUR]=true;isListening[TOP_FOCUS]=true;break;case TOP_CANCEL:case TOP_CLOSE:if(isEventSupported(getRawEventName(dependency))){trapCapturedEvent(dependency,mountAt);}break;case TOP_INVALID:case TOP_SUBMIT:case TOP_RESET:// We listen to them on the target DOM elements.
// Some of them bubble so we don't want them to fire twice.
break;default:// By default, listen on the top level to all non-media events.
// Media events don't bubble so adding the listener wouldn't do anything.
var isMediaEvent=mediaEventTypes.indexOf(dependency)!==-1;if(!isMediaEvent){trapBubbledEvent(dependency,mountAt);}break;}isListening[dependency]=true;}}}function isListeningToAllDependencies(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){return false;}}return true;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
// up/down buttons on an <input type="number">. Anonymous divs do not seem to
// expose properties, triggering a "Permission denied error" if any of its
// properties are accessed. The only seemingly possible way to avoid erroring
// is to access a property that typically works for non-anonymous divs and
// catch any error that may otherwise arise. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=208427
try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
// it. If it has no children, this is still the first loop, and the only
// valid selection is anchorNode and focusNode both equal to this node
// and both offsets 0, in which case we will have handled above.
break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
// actually inside the passed-in node.)
return null;}return{start:start,end:end};}/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with "Object expected" in some scenarios.
// (For instance: TinyMCE editor used in a list component that supports pasting to add more,
// fails when pasting 100+ items)
if(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
// Flip backward selections, so we can set with a single range.
if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return!!(outerNode.compareDocumentPosition(innerNode)&16);}else{return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser
// to throw, e.g. if it has a cross-origin src attribute.
// Safari will show an error in the console when the access results in "Blocked a frame with origin". e.g:
// iframe.contentDocument.defaultView;
// A safety way is to access one of the cross origin properties: Window or Location
// Which might result in "SecurityError" DOM Exception and it is compatible to Safari.
// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl
return typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else{return element;}element=getActiveElement(win.document);}return element;}/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */ /**
 * @hasSelectionCapabilities: we get the element types that support selection
 * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`
 * and `selectionEnd` rows.
 */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection$1(focusedElem):null};}/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */function getSelection$1(input){var selection=void 0;if('selectionStart'in input){// Modern browser with input or textarea.
selection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.
selection=getOffsets(input);}return selection||{start:0,end:0};}/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */function setSelection(input,offsets){var start=offsets.start,end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;var eventTypes$3={select:{phasedRegistrationNames:{bubbled:'onSelect',captured:'onSelectCapture'},dependencies:[TOP_BLUR,TOP_CONTEXT_MENU,TOP_DRAG_END,TOP_FOCUS,TOP_KEY_DOWN,TOP_KEY_UP,TOP_MOUSE_DOWN,TOP_MOUSE_UP,TOP_SELECTION_CHANGE]}};var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */function getSelection(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else{var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
 * Get document associated with the event target.
 *
 * @param {object} nativeEventTarget
 * @return {Document}
 */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @param {object} nativeEventTarget
 * @return {?SyntheticEvent}
 */function constructSelectEvent(nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
// selection (this matches native `select` event behavior). In HTML5, select
// fires only on input and textarea thus if there's no focused element we
// won't dispatch.
var doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return null;}// Only fire when selection has actually changed.
var currentSelection=getSelection(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var syntheticEvent=SyntheticEvent.getPooled(eventTypes$3.select,activeElementInst$1,nativeEvent,nativeEventTarget);syntheticEvent.type='select';syntheticEvent.target=activeElement$1;accumulateTwoPhaseDispatches(syntheticEvent);return syntheticEvent;}return null;}/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */var SelectEventPlugin={eventTypes:eventTypes$3,extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){var doc=getEventTargetDocument(nativeEventTarget);// Track whether all listeners exists for this plugin. If none exist, we do
// not extract events. See #3639.
if(!doc||!isListeningToAllDependencies('onSelect',doc)){return null;}var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;switch(topLevelType){// Track the input node that has focus.
case TOP_FOCUS:if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case TOP_BLUR:activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
// semantics of the native select event.
case TOP_MOUSE_DOWN:mouseDown=true;break;case TOP_CONTEXT_MENU:case TOP_MOUSE_UP:case TOP_DRAG_END:mouseDown=false;return constructSelectEvent(nativeEvent,nativeEventTarget);// Chrome and IE fire non-standard event when selection is changed (and
// sometimes when it hasn't). IE's event fires out of order with respect
// to key and input events on deletion, so we discard it.
//
// Firefox doesn't support selectionchange, so check selection status
// after each key entry. The selection changes after keydown and before
// keyup, but we check on keydown as well in the case of holding down a
// key, when multiple keydown events are fired but only one keyup is.
// This is also our approach for IE handling, for the reason above.
case TOP_SELECTION_CHANGE:if(skipSelectionChangeEvent){break;}// falls through
case TOP_KEY_DOWN:case TOP_KEY_UP:return constructSelectEvent(nativeEvent,nativeEventTarget);}return null;}};/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */injection.injectEventPluginOrder(DOMEventPluginOrder);setComponentTree(getFiberCurrentPropsFromNode$1,getInstanceFromNode$1,getNodeFromInstance$1);/**
 * Some important event plugins included by default (without having to require
 * them).
 */injection.injectEventPluginsByName({SimpleEventPlugin:SimpleEventPlugin,EnterLeaveEventPlugin:EnterLeaveEventPlugin,ChangeEventPlugin:ChangeEventPlugin,SelectEventPlugin:SelectEventPlugin,BeforeInputEventPlugin:BeforeInputEventPlugin});var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;function flattenChildren(children){var content='';// Flatten children. We'll warn if they are invalid
// during validateProps() which runs for hydration too.
// Note that this would throw on non-element objects.
// Elements are stringified (which is normally irrelevant
// but matters for <fbt>).
React.Children.forEach(children,function(child){if(child==null){return;}content+=child;// Note: we don't warn about invalid children here.
// Instead, this is done separately below so that
// it happens during the hydration codepath too.
});return content;}/**
 * Implements an <option> host component that warns when `selected` is set.
 */function validateProps(element,props){{// This mirrors the codepath above, but runs for hydration too.
// Warn about invalid children here so that client and hydration are consistent.
// TODO: this seems like it could cause a DEV-only throw for hydration
// if children contains a non-element object. We should try to avoid that.
if(typeof props.children==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(typeof child.type!=='string'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;warning$1(false,'Only strings and numbers are supported as <option> children.');}});}// TODO: Remove support for `selected` in <option>.
if(props.selected!=null&&!didWarnSelectedSetOnOption){warning$1(false,'Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
if(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}function getHostProps$1(element,props){var hostProps=_assign({children:undefined},props);var content=flattenChildren(props.children);if(content){hostProps.children=content;}return hostProps;}// TODO: direct imports like some-package/src/* are bad. Fix me.
var didWarnValueDefaultValue$1=void 0;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return'\n\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**
 * Validation function for `value` and `defaultValue`.
 */function checkSelectPropTypes(props){ReactControlledValuePropTypes.checkPropTypes('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var isArray=Array.isArray(props[propName]);if(props.multiple&&!isArray){warning$1(false,'The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&isArray){warning$1(false,'The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all
// browsers for all cases.
var _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */function getHostProps$2(element,props){return _assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){warning$1(false,'Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.
updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$2(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */function getHostProps$3(element,props){var node=element;!(props.dangerouslySetInnerHTML==null)?invariant(false,'`dangerouslySetInnerHTML` does not make sense on <textarea>.'):void 0;// Always set children to the same thing. In IE9, the selection range will
// get reset if `textContent` is mutated.  We could add a check in setTextContent
// to only set the value if/when the value differs from the node value (which would
// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
// solution. The value can be a boolean or object so that's why it's forced
// to be a string.
var hostProps=_assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{ReactControlledValuePropTypes.checkPropTypes('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){warning$1(false,'%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it
if(initialValue==null){var defaultValue=props.defaultValue;// TODO (yungsters): Remove support for children content in <textarea>.
var children=props.children;if(children!=null){{warning$1(false,'Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}!(defaultValue==null)?invariant(false,'If you supply `defaultValue` on a <textarea>, do not pass children.'):void 0;if(Array.isArray(children)){!(children.length<=1)?invariant(false,'<textarea> can only have at most one child.'):void 0;children=children[0];}defaultValue=children;}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
var newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed
if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
// available until after the component has mounted.
var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
// initial value. In IE10/IE11 there is a bug where the placeholder attribute
// will populate textContent as well.
// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
if(textContent===node._wrapperState.initialValue){node.value=textContent;}}function restoreControlledState$3(element,props){// DOM component is still mounted; update
updateWrapper$1(element,props);}var HTML_NAMESPACE$1='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var Namespaces={html:HTML_NAMESPACE$1,mathml:MATH_NAMESPACE,svg:SVG_NAMESPACE};// Assumes there is no parent namespace.
function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE$1;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE$1){// No (or default) parent namespace: potential entry point.
return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
return HTML_NAMESPACE$1;}// By default, pass namespace below.
return parentNamespace;}/* globals MSApp */ /**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */var createMicrosoftUnsafeLocalFunction=function(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};// SVG temp container for IE lacking innerHTML
var reusableSVGContainer=void 0;/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){// IE does not have innerHTML for SVG nodes, so instead we inject the
// new markup in a temp node and then move the child nodes across into
// the target node
if(node.namespaceURI===Namespaces.svg&&!('innerHTML'in node)){reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}}else{node.innerHTML=html;}});/**
 * Set the textContent property of a node. For text updates, it's faster
 * to set the `nodeValue` of the Text node directly instead of using
 * `.textContent` which will remove the existing node and create a new one.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */var setTextContent=function(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// List derived from Gecko source code:
// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js
var shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**
 * CSS properties which accept numbers but are not in units of "px".
 */var isUnitlessNumber={animationIterationCount:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
// whole string will be escaped when the attribute is injected into
// the markup. If you provide unsafe user data here they can inject
// arbitrary CSS which may be problematic (I couldn't repro this):
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
// This is not an XSS hole but instead a potential CSS injection issue
// which has lead to a greater discussion about how we're going to
// trust URLs moving forward. See #2115901
var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
}return(''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function(){};{// 'msTransform' is correct, but the other prefixes should be capitalized
var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon
var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning$1(false,'Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests
// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
// is converted to lowercase `ms`.
camelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning$1(false,'Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;warning$1(false,"Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;warning$1(false,'`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;warning$1(false,'`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**
 * Operations for dealing with CSS properties.
 */ /**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+hyphenateStyleName(styleName)+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**
 * Given {color: 'red', overflow: 'hidden'} returns {
 *   color: 'color',
 *   overflowX: 'overflow',
 *   overflowY: 'overflow',
 * }. This can be read as "the overflowY property was set by the overflow
 * shorthand". That is, the values are the property that each was derived from.
 */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**
 * When mixing shorthand and longhand property names, we warn during updates if
 * we expect an incorrect result to occur. In particular, we warn for:
 *
 * Updating a shorthand property (longhand gets overwritten):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}
 *   becomes .style.font = 'baz'
 * Removing a shorthand property (longhand gets lost too):
 *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}
 *   becomes .style.font = ''
 * Removing a longhand property (should revert to shorthand; doesn't):
 *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}
 *   becomes .style.fontVariant = ''
 */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){if(!warnAboutShorthandPropertyCollision){return;}if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;warning$1(false,'%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+"avoid this, don't mix shorthand and non-shorthand properties "+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.
var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.
};// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.
var voidElementTags=_assign({menuitem:true},omittedCloseTags);// TODO: We can remove this if we add invariantWithStack()
// or add stack by default to invariants where possible.
var HTML$1='__html';var ReactDebugCurrentFrame$2=null;{ReactDebugCurrentFrame$2=ReactSharedInternals.ReactDebugCurrentFrame;}function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.
if(voidElementTags[tag]){!(props.children==null&&props.dangerouslySetInnerHTML==null)?invariant(false,'%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s',tag,ReactDebugCurrentFrame$2.getStackAddendum()):void 0;}if(props.dangerouslySetInnerHTML!=null){!(props.children==null)?invariant(false,'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'):void 0;!(typeof props.dangerouslySetInnerHTML==='object'&&HTML$1 in props.dangerouslySetInnerHTML)?invariant(false,'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.'):void 0;}{!(props.suppressContentEditableWarning||!props.contentEditable||props.children==null)?warning$1(false,'A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.'):void 0;}!(props.style==null||typeof props.style==='object')?invariant(false,'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s',ReactDebugCurrentFrame$2.getStackAddendum()):void 0;}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
// We don't mind this whitelist too much because we expect it to never grow.
// The alternative is to track the namespace in a few places which is convoluted.
// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames={// HTML
accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',class:'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',default:'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',download:'download',draggable:'draggable',enctype:'encType',for:'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',in:'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',typeof:'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state
'aria-details':0,'aria-disabled':0,// state
'aria-hidden':0,// state
'aria-invalid':0,// state
'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty$2=Object.prototype.hasOwnProperty;function validateProperty(tagName,name){if(hasOwnProperty$2.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(correctName==null){warning$1(false,'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==correctName){warning$1(false,'Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==standardName){warning$1(false,'Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}return true;}function warnInvalidARIAProps(type,props){var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){warning$1(false,'Invalid aria prop %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop',unknownPropString,type);}else if(invalidProps.length>1){warning$1(false,'Invalid aria props %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop',unknownPropString,type);}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){warning$1(false,'`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else{warning$1(false,'`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}var validateProperty$1=function(){};{var warnedProperties$1={};var _hasOwnProperty=Object.prototype.hasOwnProperty;var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function(tagName,name,value,canUseEventSystem){if(_hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){warning$1(false,'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.
if(canUseEventSystem){if(registrationNameModules.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){warning$1(false,'Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){warning$1(false,'Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.
// So we can't tell if the event name is correct for sure, but we can filter
// out known bad ones like `onclick`. We can't suggest a specific replacement though.
if(INVALID_EVENT_NAME_REGEX.test(name)){warning$1(false,'Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){warning$1(false,'Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){warning$1(false,'The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){warning$1(false,'Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',typeof value);warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){warning$1(false,'Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.
if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){warning$1(false,'Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
// will be cased anyway with server rendering.
warning$1(false,'React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){warning$1(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.',value,name,name,value,name);}else{warning$1(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
// data types for reserved props
if(isReserved){return true;}// Warn when a known attribute is a bad type
if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop
if((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){warning$1(false,'Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string "false".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function(type,props,canUseEventSystem){var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],canUseEventSystem);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){warning$1(false,'Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://fb.me/react-attribute-behavior',unknownPropString,type);}else if(unknownProps.length>1){warning$1(false,'Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://fb.me/react-attribute-behavior',unknownPropString,type);}};function validateProperties$2(type,props,canUseEventSystem){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,canUseEventSystem);}// TODO: direct imports like some-package/src/* are bad. Fix me.
var didWarnInvalidHydration=false;var didWarnShadyDOM=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE$1='style';var HTML='__html';var HTML_NAMESPACE=Namespaces.html;var warnedUnknownTags=void 0;var suppressHydrationWarning=void 0;var validatePropertiesInDevelopment=void 0;var warnForTextDifference=void 0;var warnForPropDifference=void 0;var warnForExtraAttributes=void 0;var warnForInvalidEventListener=void 0;var canDiffStyleForHydrationWarning=void 0;var normalizeMarkupForTextOrAttribute=void 0;var normalizeHTML=void 0;{warnedUnknownTags={// Chrome is the only major browser not shipping <time>. But as of July
// 2017 it intends to ship it due to widespread usage. We intentionally
// *don't* warn for <time> even if it's unrecognized by Chrome because
// it soon will be, and many apps have been using it anyway.
time:true,// There are working polyfills for <dialog>. Let people use it.
dialog:true,// Electron ships a custom <webview> tag to display external web content in
// an isolated frame and process.
// This tag is not present in non Electron environments such as JSDom which
// is often used for testing purposes.
// @see https://electronjs.org/docs/api/webview-tag
webview:true};validatePropertiesInDevelopment=function(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,/* canUseEventSystem */true);};// IE 11 parses & normalizes the style attribute as opposed to other
// browsers. It adds spaces and sorts the properties in some
// non-alphabetical order. Handling that would require sorting CSS
// properties in the client & server versions or applying
// `expectedStyle` to a temporary DOM node to read its `style` attribute
// normalized. Since it only affects IE, we're skipping style warnings
// in that browser completely in favor of doing all that work.
// See https://github.com/facebook/react/issues/11807
canDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;// HTML parsing normalizes CR and CRLF to LF.
// It also can turn \u0000 into \uFFFD inside attributes.
// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
// If we have a mismatch, it might be caused by that.
// We will still patch up in this case but not fire the warning.
var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;normalizeMarkupForTextOrAttribute=function(markup){var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');};warnForTextDifference=function(serverText,clientText){if(didWarnInvalidHydration){return;}var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}didWarnInvalidHydration=true;warningWithoutStack$1(false,'Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);};warnForPropDifference=function(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;warningWithoutStack$1(false,'Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});warningWithoutStack$1(false,'Extra attributes from the server: %s',names);};warnForInvalidEventListener=function(registrationName,listener){if(listener===false){warning$1(false,'Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else{warning$1(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener);}};// Parse the HTML and read it back to normalize the HTML string so that it
// can be used for comparison.
normalizeHTML=function(parent,html){// We could have created a separate document here to avoid
// re-initializing custom elements if they exist. But this breaks
// how <noscript> is being handled. So we use the same document.
// See the discussion in https://github.com/facebook/react/pull/11157.
var testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}function ensureListeningTo(rootContainerElement,registrationName){var isDocumentOrFragment=rootContainerElement.nodeType===DOCUMENT_NODE||rootContainerElement.nodeType===DOCUMENT_FRAGMENT_NODE;var doc=isDocumentOrFragment?rootContainerElement:rootContainerElement.ownerDocument;listenTo(registrationName,doc);}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
// non-interactive elements, which means delegated click listeners do not
// fire. The workaround for this bug involves attaching an empty click
// listener on the target node.
// http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
// Just set it using the onclick property so that we don't have to manage any
// bookkeeping for it. Not sure if we need to clear it when the listener is
// removed.
// TODO: Only do this for the relevant Safaris maybe?
node.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE$1){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
setValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
// textContent on a <textarea> will cause the placeholder to not
// show within the <textarea> until it has been focused and blurred again.
// https://github.com/facebook/react/issues/6731#issuecomment-254874553
var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// We polyfill it separately on the client during commit.
// We could have excluded it in the property list instead of
// adding a special case here, but then it wouldn't be emitted
// on server rendering (but we *do* want to emit it in SSR).
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if( true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE$1){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else{setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag=void 0;// We create tags in the namespace of their parent container, except HTML
// tags get no namespace.
var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement=void 0;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
// allow <SVG> or <mATH>.
!(isCustomComponentTag||type===type.toLowerCase())?warning$1(false,'<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type):void 0;}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
// set to true and it does not execute
var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
// This is guaranteed to yield a script element.
var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
domElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
// See discussion in https://github.com/facebook/react/pull/6896
// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
domElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`
// attributes on `select`s needs to be added before `option`s are inserted.
// This prevents:
// - a bug where the `select` does not scroll to the correct option because singular
//  `select` elements automatically pick the first item #13222
// - a bug where the `select` set the first item as selected despite the `size` attribute #14239
// See https://github.com/facebook/react/issues/13222
// and https://github.com/facebook/react/issues/14239
if(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where
// it is possible that no option is selected.
//
// This is only necessary when a select in "single selection mode".
node.size=props.size;}}}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!Object.prototype.hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;warning$1(false,'The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning$1(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
var props=void 0;switch(tag){case'iframe':case'object':trapBubbledEvent(TOP_LOAD,domElement);props=rawProps;break;case'video':case'audio':// Create listener for each media event
for(var i=0;i<mediaEventTypes.length;i++){trapBubbledEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':trapBubbledEvent(TOP_ERROR,domElement);props=rawProps;break;case'img':case'image':case'link':trapBubbledEvent(TOP_ERROR,domElement);trapBubbledEvent(TOP_LOAD,domElement);props=rawProps;break;case'form':trapBubbledEvent(TOP_RESET,domElement);trapBubbledEvent(TOP_SUBMIT,domElement);props=rawProps;break;case'details':trapBubbledEvent(TOP_TOGGLE,domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);props=getHostProps$1(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$2(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$3(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
function diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps=void 0;var nextProps=void 0;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'option':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$3(domElement,lastRawProps);nextProps=getHostProps$3(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey=void 0;var styleName=void 0;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE$1){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN){// Noop. This is handled by the clear text mechanism.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// Noop. It doesn't work on updates anyway.
}else if(registrationNameModules.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
// that the "current" fiber pointer gets updated so we need a commit
// to update this element.
if(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use
// the whitelist in the commit phase instead.
(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE$1){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.
if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;var lastHtml=lastProp?lastProp[HTML]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,''+nextHtml);}}else{// TODO: It might be too late to clear this if we have children
// inserted already.
}}else if(propKey===CHILDREN){if(lastProp!==nextProp&&(typeof nextProp==='string'||typeof nextProp==='number')){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
if( true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
// that the "current" props pointer gets updated so we need a commit
// to update this element.
updatePayload=[];}}else{// For any other property we always add it to the queue and then we
// filter it out using the whitelist during the commit.
(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE$1]);}(updatePayload=updatePayload||[]).push(STYLE$1,styleUpdates);}return updatePayload;}// Apply the diff.
function updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.
// In the middle of an update, it is possible to have multiple checked.
// When a checked radio tries to change name, browser makes another radio's checked false.
if(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
// changed.
switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
// happen after `updateDOMProperties`. Otherwise HTML5 input validations
// raise warnings and prevent the new value from being assigned.
updateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
// reconciliation
postUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}return null;}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement){var isCustomComponentTag=void 0;var extraAttributeNames=void 0;{suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING$1]===true;isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning$1(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
switch(tag){case'iframe':case'object':trapBubbledEvent(TOP_LOAD,domElement);break;case'video':case'audio':// Create listener for each media event
for(var i=0;i<mediaEventTypes.length;i++){trapBubbledEvent(mediaEventTypes[i],domElement);}break;case'source':trapBubbledEvent(TOP_ERROR,domElement);break;case'img':case'image':case'link':trapBubbledEvent(TOP_ERROR,domElement);trapBubbledEvent(TOP_LOAD,domElement);break;case'form':trapBubbledEvent(TOP_RESET,domElement);trapBubbledEvent(TOP_SUBMIT,domElement);break;case'details':trapBubbledEvent(TOP_TOGGLE,domElement);break;case'input':initWrapperState(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);trapBubbledEvent(TOP_INVALID,domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Built-in SSR attribute is whitelisted
case'data-reactroot':break;// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
// See discussion in https://github.com/facebook/react/pull/10676.
extraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
// might match additional HTML that is hidden when we read it using
// textContent. E.g. "foo" will match "f<span>oo</span>" but that still
// satisfies our requirement. Our requirement is not to produce perfect
// HTML and attributes. Ideally we should preserve structure but it's
// ok not to if the visible content is still enough to indicate what
// even listeners these nodes might be wired up to.
// TODO: Warn if there is more than a single textNode as a child.
// TODO: Should we use domElement.firstChild.nodeValue to compare?
if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if( true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if( true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if( true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if( true&&// Convince Flow we've calculated it (it's DEV-only in this method.)
typeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.
var serverValue=void 0;var propertyInfo=getPropertyInfo(propKey);if(suppressHydrationWarning){// Don't bother comparing. We're ignoring all these warnings.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1||// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
propKey==='value'||propKey==='checked'||propKey==='selected'){// Noop
}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML]:undefined;var expectedHTML=normalizeHTML(domElement,nextHtml!=null?nextHtml:'');if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}else if(propKey===STYLE$1){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey.toLowerCase());}else{var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will
// be successfully parsed from HTML, but will produce a mismatch
// (and would be incorrectly rendered on the client).
// However, we already warn about bad casing elsewhere.
// So we'll skip the misleading extra mismatch warning in this case.
isMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(standardName);}// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames.delete(propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}if(nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{// $FlowFixMe - Should be inferred as not undefined.
if(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.
warnForExtraAttributes(extraAttributeNames);}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'select':case'option':// For input and textarea we current always set the value property at
// post mount to force it to diverge from attributes. However, for
// option and select we don't quite do the same thing and select
// is not resilient to the DOM state changing so we don't do that here.
// TODO: Consider not doing this for input and textarea.
break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForUnmatchedText(textNode,text){{warnForTextDifference(textNode.nodeValue,text);}}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warningWithoutStack$1(false,'Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warningWithoutStack$1(false,'Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warningWithoutStack$1(false,'Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
// the HTML.
// TODO: Remove this special case if we can just avoid inserting empty
// text nodes.
return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warningWithoutStack$1(false,'Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$1(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$3(domElement,props);return;case'select':restoreControlledState$2(domElement,props);return;}}// TODO: direct imports like some-package/src/* are bad. Fix me.
var validateDOMNesting=function(){};var updatedAncestorInfo=function(){};{// This validation code was written based on the HTML5 parsing spec:
// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
//
// Note: this does not catch all invalid nesting, nor does it try to (as it's
// not clear what practical benefit doing so provides); instead, we warn only
// for cases where the parser will give a parse tree differing from what React
// intended. For example, <b><div></div></b> is invalid but we don't warn
// because it still parses correctly; we do warn for other cases like nested
// <p> tags where the beginning of the second element implicitly closes the
// first, causing a confusing mess.
// https://html.spec.whatwg.org/multipage/syntax.html#special
var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
// TODO: Distinguish by namespace here -- for <title>, including it here
// errs on the side of fewer warnings
'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function(oldInfo,tag){var ancestorInfo=_assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
   * Returns whether
   */var isTagValidWithParent=function(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
// but
case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
// No special behavior since these rules fall back to "in body" mode for
// all except special table nodes which cause bad parsing behavior anyway.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
case'html':return tag==='head'||tag==='body';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
// where the parsing rules cause implicit opens or closes to be added.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
// parsing rules -- if we're down here, then none of those matched and
// so we allow it only if we don't know what the parent is, as all other
// cases are invalid.
return parentTag==null;}return true;};/**
   * Returns whether
   */var findInvalidAncestorForTag=function(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
// equivalent to this check.
return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn={};validateDOMNesting=function(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){!(childTag==null)?warningWithoutStack$1(false,'validateDOMNesting: when childText is passed, childTag should be null'):void 0;childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var addendum=getCurrentFiberStackInDev();var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag+'|'+addendum;if(didWarn[warnKey]){return;}didWarn[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody> to your code to match the DOM tree generated by '+'the browser.';}warningWithoutStack$1(false,'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info,addendum);}else{warningWithoutStack$1(false,'validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.%s',tagDisplayName,ancestorTag,addendum);}};}// Renderers that don't support persistence
// can re-export everything from this module.
function shim(){invariant(false,'The current renderer does not support persistence. This error is likely caused by a bug in React. Please file an issue.');}// Persistence (when unsupported)
var supportsPersistence=false;var cloneInstance=shim;var createContainerChildSet=shim;var appendChildToContainerChildSet=shim;var finalizeContainerChildren=shim;var replaceContainerChildren=shim;var cloneHiddenInstance=shim;var cloneUnhiddenInstance=shim;var createHiddenTextInstance=shim;var SUPPRESS_HYDRATION_WARNING=void 0;{SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';}var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var STYLE='style';var eventsEnabled=null;var selectionInformation=null;function shouldAutoFocusHostComponent(type,props){switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;}return false;}function getRootHostContext(rootContainerInstance){var type=void 0;var namespace=void 0;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var _ancestorInfo=updatedAncestorInfo(null,validatedTag);return{namespace:namespace,ancestorInfo:_ancestorInfo};}return namespace;}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var _namespace=getChildNamespace(parentHostContextDev.namespace,type);var _ancestorInfo2=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return{namespace:_namespace,ancestorInfo:_ancestorInfo2};}var parentNamespace=parentHostContext;return getChildNamespace(parentNamespace,type);}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();setEnabled(false);}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);selectionInformation=null;setEnabled(eventsEnabled);eventsEnabled=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace=void 0;{// TODO: take namespace into account when validating.
var hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);return shouldAutoFocusHostComponent(type,props);}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(typeof newProps.children!==typeof oldProps.children&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps,rootContainerInstance);}function shouldSetTextContent(type,props){return type==='textarea'||type==='option'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||typeof props.dangerouslySetInnerHTML==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function shouldDeprioritizeSubtree(type,props){return!!props.hidden;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}var isPrimaryRenderer=true;// This initialization code may run even on server environments
// if a component just imports ReactDOM (e.g. for findDOMNode).
// Some environments might not have setTimeout or clearTimeout.
var scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;var schedulePassiveEffects=scheduler.unstable_scheduleCallback;var cancelPassiveEffects=scheduler.unstable_cancelCallback;// -------------------
//     Mutation
// -------------------
var supportsMutation=true;function commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only
// fires if there is an `Update` effect scheduled during mounting.
// This happens if `finalizeInitialChildren` returns `true` (which it
// does to implement the `autoFocus` attribute on the client). But
// there are also other cases when this might happen (such as patching
// up text content during hydration mismatch). So we'll check this again.
if(shouldAutoFocusHostComponent(type,newProps)){domElement.focus();}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Update the props handle so that we know which props are the ones with
// with current event handlers.
updateFiberProps(domElement,newProps);// Apply the diff to the DOM node.
updateProperties(domElement,updatePayload,type,oldProps,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode=void 0;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else{parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.
// If something inside a portal is clicked, that click should bubble
// through the React tree. However, on Mobile Safari the click would
// never bubble through the *DOM* tree unless an ancestor with onclick
// event exists. So we wouldn't see it and dispatch it.
// This is why we ensure that non React root containers have inline onclick
// defined.
// https://github.com/facebook/react/issues/11918
var reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}function clearSuspenseBoundary(parentInstance,suspenseInstance){var node=suspenseInstance;// Delete all nodes within this suspense boundary.
// There might be nested nodes so we need to keep track of how
// deep we are and only break out when we're back on top.
var depth=0;do{var nextNode=node.nextSibling;parentInstance.removeChild(node);if(nextNode&&nextNode.nodeType===COMMENT_NODE){var data=nextNode.data;if(data===SUSPENSE_END_DATA){if(depth===0){parentInstance.removeChild(nextNode);return;}else{depth--;}}else if(data===SUSPENSE_START_DATA){depth++;}}node=nextNode;}while(node);// TODO: Warn, we didn't find the end comment boundary.
}function clearSuspenseBoundaryFromContainer(container,suspenseInstance){if(container.nodeType===COMMENT_NODE){clearSuspenseBoundary(container.parentNode,suspenseInstance);}else if(container.nodeType===ELEMENT_NODE){clearSuspenseBoundary(container,suspenseInstance);}else{// Document nodes should never contain suspense boundaries.
}}function hideInstance(instance){// TODO: Does this work for all element types? What about MathML? Should we
// pass host context to this method?
instance=instance;instance.style.display='none';}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}// -------------------
//     Hydration
// -------------------
var supportsHydration=true;function canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.
return instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a text node.
return instance;}function canHydrateSuspenseInstance(instance){if(instance.nodeType!==COMMENT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a suspense node.
return instance;}function getNextHydratableSibling(instance){var node=instance.nextSibling;// Skip non-hydratable nodes.
while(node&&node.nodeType!==ELEMENT_NODE&&node.nodeType!==TEXT_NODE&&(!enableSuspenseServerRenderer||node.nodeType!==COMMENT_NODE||node.data!==SUSPENSE_START_DATA)){node=node.nextSibling;}return node;}function getFirstHydratableChild(parentInstance){var next=parentInstance.firstChild;// Skip non-hydratable nodes.
while(next&&next.nodeType!==ELEMENT_NODE&&next.nodeType!==TEXT_NODE&&(!enableSuspenseServerRenderer||next.nodeType!==COMMENT_NODE||next.data!==SUSPENSE_START_DATA)){next=next.nextSibling;}return next;}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
// get attached.
updateFiberProps(instance,props);var parentNamespace=void 0;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance);}function hydrateTextInstance(textInstance,text,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,textInstance);return diffHydratedText(textInstance,text);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.
// There might be nested nodes so we need to keep track of how
// deep we are and only break out when we're back on top.
var depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else{depth--;}}else if(data===SUSPENSE_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.
return null;}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text){{warnForUnmatchedText(textInstance,text);}}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text){if( true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForUnmatchedText(textInstance,text);}}function didNotHydrateContainerInstance(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE){// TODO: warnForDeletedHydratableSuspenseBoundary
}else{warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance){if( true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE){// TODO: warnForDeletedHydratableSuspenseBoundary
}else{warnForDeletedHydratableText(parentInstance,instance);}}}function didNotFindHydratableContainerInstance(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type,props);}}function didNotFindHydratableContainerTextInstance(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props){if( true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedElement(parentInstance,type,props);}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text){if( true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedText(parentInstance,text);}}function didNotFindHydratableSuspenseInstance(parentType,parentProps,parentInstance){if( true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){// TODO: warnForInsertedHydratedSuspense(parentInstance);
}}// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji='\u269B';var warningEmoji='\u26D4';var supportsUserTiming=typeof performance!=='undefined'&&typeof performance.mark==='function'&&typeof performance.clearMarks==='function'&&typeof performance.measure==='function'&&typeof performance.clearMeasures==='function';// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber=null;// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase=null;var currentPhaseFiber=null;// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting=false;var hasScheduledUpdateInCurrentCommit=false;var hasScheduledUpdateInCurrentPhase=false;var commitCountInCurrentWorkLoop=0;var effectCountInCurrentCommit=0;var isWaitingForCallback=false;// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit=new Set();var formatMarkName=function(markName){return reactEmoji+' '+markName;};var formatLabel=function(label,warning){var prefix=warning?warningEmoji+' ':reactEmoji+' ';var suffix=warning?' Warning: '+warning:'';return''+prefix+label+suffix;};var beginMark=function(markName){performance.mark(formatMarkName(markName));};var clearMark=function(markName){performance.clearMarks(formatMarkName(markName));};var endMark=function(label,markName,warning){var formattedMarkName=formatMarkName(markName);var formattedLabel=formatLabel(label,warning);try{performance.measure(formattedLabel,formattedMarkName);}catch(err){}// If previous mark was missing for some reason, this will throw.
// This could only happen if React crashed in an unexpected place earlier.
// Don't pile on with more errors.
// Clear marks immediately to avoid growing buffer.
performance.clearMarks(formattedMarkName);performance.clearMeasures(formattedLabel);};var getFiberMarkName=function(label,debugID){return label+' (#'+debugID+')';};var getFiberLabel=function(componentName,isMounted,phase){if(phase===null){// These are composite component total time measurements.
return componentName+' ['+(isMounted?'update':'mount')+']';}else{// Composite component methods.
return componentName+'.'+phase;}};var beginFiberMark=function(fiber,phase){var componentName=getComponentName(fiber.type)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);if(isCommitting&&labelsInCurrentCommit.has(label)){// During the commit phase, we don't show duplicate labels because
// there is a fixed overhead for every measurement, and we don't
// want to stretch the commit phase beyond necessary.
return false;}labelsInCurrentCommit.add(label);var markName=getFiberMarkName(label,debugID);beginMark(markName);return true;};var clearFiberMark=function(fiber,phase){var componentName=getComponentName(fiber.type)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);clearMark(markName);};var endFiberMark=function(fiber,phase,warning){var componentName=getComponentName(fiber.type)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);endMark(label,markName,warning);};var shouldIgnoreFiber=function(fiber){// Host components should be skipped in the timeline.
// We could check typeof fiber.type, but does this work with RN?
switch(fiber.tag){case HostRoot:case HostComponent:case HostText:case HostPortal:case Fragment:case ContextProvider:case ContextConsumer:case Mode:return true;default:return false;}};var clearPendingPhaseMeasurement=function(){if(currentPhase!==null&&currentPhaseFiber!==null){clearFiberMark(currentPhaseFiber,currentPhase);}currentPhaseFiber=null;currentPhase=null;hasScheduledUpdateInCurrentPhase=false;};var pauseTimers=function(){// Stops all currently active measurements so that they can be resumed
// if we continue in a later deferred loop from the same unit of work.
var fiber=currentFiber;while(fiber){if(fiber._debugIsCurrentlyTiming){endFiberMark(fiber,null,null);}fiber=fiber.return;}};var resumeTimersRecursively=function(fiber){if(fiber.return!==null){resumeTimersRecursively(fiber.return);}if(fiber._debugIsCurrentlyTiming){beginFiberMark(fiber,null);}};var resumeTimers=function(){// Resumes all measurements that were active during the last deferred loop.
if(currentFiber!==null){resumeTimersRecursively(currentFiber);}};function recordEffect(){if(enableUserTimingAPI){effectCountInCurrentCommit++;}}function recordScheduleUpdate(){if(enableUserTimingAPI){if(isCommitting){hasScheduledUpdateInCurrentCommit=true;}if(currentPhase!==null&&currentPhase!=='componentWillMount'&&currentPhase!=='componentWillReceiveProps'){hasScheduledUpdateInCurrentPhase=true;}}}function startRequestCallbackTimer(){if(enableUserTimingAPI){if(supportsUserTiming&&!isWaitingForCallback){isWaitingForCallback=true;beginMark('(Waiting for async callback...)');}}}function stopRequestCallbackTimer(didExpire,expirationTime){if(enableUserTimingAPI){if(supportsUserTiming){isWaitingForCallback=false;var warning=didExpire?'React was blocked by main thread':null;endMark('(Waiting for async callback... will force flush in '+expirationTime+' ms)','(Waiting for async callback...)',warning);}}}function startWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, this is the fiber to unwind from.
currentFiber=fiber;if(!beginFiberMark(fiber,null)){return;}fiber._debugIsCurrentlyTiming=true;}}function cancelWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// Remember we shouldn't complete measurement for this fiber.
// Otherwise flamechart will be deep even for small updates.
fiber._debugIsCurrentlyTiming=false;clearFiberMark(fiber,null);}}function stopWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber.return;if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;endFiberMark(fiber,null,null);}}function stopFailedWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber.return;if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;var warning=fiber.tag===SuspenseComponent||fiber.tag===DehydratedSuspenseComponent?'Rendering was suspended':'An error was thrown inside this error boundary';endFiberMark(fiber,null,warning);}}function startPhaseTimer(fiber,phase){if(enableUserTimingAPI){if(!supportsUserTiming){return;}clearPendingPhaseMeasurement();if(!beginFiberMark(fiber,phase)){return;}currentPhaseFiber=fiber;currentPhase=phase;}}function stopPhaseTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}if(currentPhase!==null&&currentPhaseFiber!==null){var warning=hasScheduledUpdateInCurrentPhase?'Scheduled a cascading update':null;endFiberMark(currentPhaseFiber,currentPhase,warning);}currentPhase=null;currentPhaseFiber=null;}}function startWorkLoopTimer(nextUnitOfWork){if(enableUserTimingAPI){currentFiber=nextUnitOfWork;if(!supportsUserTiming){return;}commitCountInCurrentWorkLoop=0;// This is top level call.
// Any other measurements are performed within.
beginMark('(React Tree Reconciliation)');// Resume any measurements that were in progress during the last loop.
resumeTimers();}}function stopWorkLoopTimer(interruptedBy,didCompleteRoot){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning=null;if(interruptedBy!==null){if(interruptedBy.tag===HostRoot){warning='A top-level update interrupted the previous render';}else{var componentName=getComponentName(interruptedBy.type)||'Unknown';warning='An update to '+componentName+' interrupted the previous render';}}else if(commitCountInCurrentWorkLoop>1){warning='There were cascading updates';}commitCountInCurrentWorkLoop=0;var label=didCompleteRoot?'(React Tree Reconciliation: Completed Root)':'(React Tree Reconciliation: Yielded)';// Pause any measurements until the next loop.
pauseTimers();endMark(label,'(React Tree Reconciliation)',warning);}}function startCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}isCommitting=true;hasScheduledUpdateInCurrentCommit=false;labelsInCurrentCommit.clear();beginMark('(Committing Changes)');}}function stopCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning=null;if(hasScheduledUpdateInCurrentCommit){warning='Lifecycle hook scheduled a cascading update';}else if(commitCountInCurrentWorkLoop>0){warning='Caused by a cascading update in earlier commit';}hasScheduledUpdateInCurrentCommit=false;commitCountInCurrentWorkLoop++;isCommitting=false;labelsInCurrentCommit.clear();endMark('(Committing Changes)','(Committing Changes)',warning);}}function startCommitSnapshotEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Snapshot Effects)');}}function stopCommitSnapshotEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Snapshot Effects: '+count+' Total)','(Committing Snapshot Effects)',null);}}function startCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Host Effects)');}}function stopCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Host Effects: '+count+' Total)','(Committing Host Effects)',null);}}function startCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Calling Lifecycle Methods)');}}function stopCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Calling Lifecycle Methods: '+count+' Total)','(Calling Lifecycle Methods)',null);}}var valueStack=[];var fiberStack=void 0;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{warningWithoutStack$1(false,'Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){warningWithoutStack$1(false,'Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}function checkThatStackIsEmpty(){{if(index!==-1){warningWithoutStack$1(false,'Expected an empty stack. Something was not reset properly.');}}}function resetStackAfterFatalErrorInDev(){{index=-1;valueStack.length=0;fiberStack.length=0;}}var warnedAboutMissingGetChildContext=void 0;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.
var contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context
// we may have already pushed its own child context on the stack. A context
// provider should not "see" its own child context. Therefore we read the
// previous (parent) context instead for a context provider.
return previousContext;}return contextStackCursor.current;}function cacheContext(workInProgress,unmaskedContext,maskedContext){var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}function getMaskedContext(workInProgress,unmaskedContext){var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.
// Failing to do this will result in unnecessary calls to componentWillReceiveProps.
// This may trigger infinite loops if componentWillReceiveProps calls setState.
var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentName(type)||'Unknown';checkPropTypes(contextTypes,context,'context',name,getCurrentFiberStackInDev);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// Context is created before the class component is instantiated so check for instance.
if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}function hasContextChanged(){return didPerformWorkStackCursor.current;}function isContextProvider(type){var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}function popContext(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function pushTopLevelContextObject(fiber,context,didChange){!(contextStackCursor.current===emptyContextObject)?invariant(false,'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'):void 0;push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}function processChildContext(fiber,type,parentContext){var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
// It has only been added in Fiber to match the (unintentional) behavior in Stack.
if(typeof instance.getChildContext!=='function'){{var componentName=getComponentName(type)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;warningWithoutStack$1(false,'%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=void 0;{setCurrentPhase('getChildContext');}startPhaseTimer(fiber,'getChildContext');childContext=instance.getChildContext();stopPhaseTimer();{setCurrentPhase(null);}for(var contextKey in childContext){!(contextKey in childContextTypes)?invariant(false,'%s.getChildContext(): key "%s" is not defined in childContextTypes.',getComponentName(type)||'Unknown',contextKey):void 0;}{var name=getComponentName(type)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name,// In practice, there is one case in which we won't get a stack. It's when
// somebody calls unstable_renderSubtreeIntoContainer() and we process
// context from the parent component instance. The stack will be missing
// because it's outside of the reconciliation, and so the pointer has not
// been set. This is rare and doesn't matter. We'll also remove that API.
getCurrentFiberStackInDev);}return _assign({},parentContext,childContext);}function pushContextProvider(workInProgress){var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
// If the instance does not exist yet, we will push null at first,
// and replace it on the stack later when invalidating the context.
var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.
// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}function invalidateContextProvider(workInProgress,type,didChange){var instance=workInProgress.stateNode;!instance?invariant(false,'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didChange){// Merge parent and own context.
// Skip this if we're not updating due to sCU.
// This avoids unnecessarily recomputing memoized values.
var mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
// It is important to unwind the context in the reverse order.
pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}function findCurrentUnmaskedContext(fiber){// Currently this is only used with renderSubtreeIntoContainer; not sure if it
// makes sense elsewhere
!(isFiberMounted(fiber)&&fiber.tag===ClassComponent)?invariant(false,'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'):void 0;var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node.return;}while(node!==null);invariant(false,'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.');}var onCommitFiberRoot=null;var onCommitFiberUnmount=null;var hasLoggedError=false;function catchErrors(fn){return function(arg){try{return fn(arg);}catch(err){if( true&&!hasLoggedError){hasLoggedError=true;warningWithoutStack$1(false,'React DevTools encountered an error: %s',err);}}};}var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
// of DevTools integration and associated warnings and logs.
// https://github.com/facebook/react/issues/3877
return true;}if(!hook.supportsFiber){{warningWithoutStack$1(false,'The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://fb.me/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
return true;}try{var rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
onCommitFiberRoot=catchErrors(function(root){return hook.onCommitFiberRoot(rendererID,root);});onCommitFiberUnmount=catchErrors(function(fiber){return hook.onCommitFiberUnmount(rendererID,fiber);});}catch(err){// Catch all errors because it is unsafe to throw during initialization.
{warningWithoutStack$1(false,'React DevTools encountered an error: %s.',err);}}// DevTools exists
return true;}function onCommitRoot(root){if(typeof onCommitFiberRoot==='function'){onCommitFiberRoot(root);}}function onCommitUnmount(fiber){if(typeof onCommitFiberUnmount==='function'){onCommitFiberUnmount(fiber);}}// Max 31 bit integer. The max integer size in V8 for 32-bit systems.
// Math.pow(2, 30) - 1
// 0b111111111111111111111111111111
var maxSigned31BitInt=1073741823;var NoWork=0;var Never=1;var Sync=maxSigned31BitInt;var UNIT_SIZE=10;var MAGIC_NUMBER_OFFSET=maxSigned31BitInt-1;// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms){// Always add an offset so that we don't clash with the magic number for NoWork.
return MAGIC_NUMBER_OFFSET-(ms/UNIT_SIZE|0);}function expirationTimeToMs(expirationTime){return(MAGIC_NUMBER_OFFSET-expirationTime)*UNIT_SIZE;}function ceiling(num,precision){return((num/precision|0)+1)*precision;}function computeExpirationBucket(currentTime,expirationInMs,bucketSizeMs){return MAGIC_NUMBER_OFFSET-ceiling(MAGIC_NUMBER_OFFSET-currentTime+expirationInMs/UNIT_SIZE,bucketSizeMs/UNIT_SIZE);}var LOW_PRIORITY_EXPIRATION=5000;var LOW_PRIORITY_BATCH_SIZE=250;function computeAsyncExpiration(currentTime){return computeExpirationBucket(currentTime,LOW_PRIORITY_EXPIRATION,LOW_PRIORITY_BATCH_SIZE);}// We intentionally set a higher expiration time for interactive updates in
// dev than in production.
//
// If the main thread is being blocked so long that you hit the expiration,
// it's a problem that could be solved with better scheduling.
//
// People will be more likely to notice this and fix it with the long
// expiration time in development.
//
// In production we opt for better UX at the risk of masking scheduling
// problems, by expiring fast.
var HIGH_PRIORITY_EXPIRATION=500;var HIGH_PRIORITY_BATCH_SIZE=100;function computeInteractiveExpiration(currentTime){return computeExpirationBucket(currentTime,HIGH_PRIORITY_EXPIRATION,HIGH_PRIORITY_BATCH_SIZE);}var NoContext=0;var ConcurrentMode=1;var StrictMode=2;var ProfileMode=4;var hasBadMapPolyfill=void 0;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});var testMap=new Map([[nonExtensibleObject,null]]);var testSet=new Set([nonExtensibleObject]);// This is necessary for Rollup to not consider these unused.
// https://github.com/rollup/rollup/issues/1771
// TODO: we can remove these if Rollup fixes the bug.
testMap.set(0,0);testSet.add(0);}catch(e){// TODO: Consider warning about bad polyfills
hasBadMapPolyfill=true;}}// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.
var debugCounter=void 0;{debugCounter=1;}function FiberNode(tag,pendingProps,key,mode){// Instance
this.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber
this.return=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.contextDependencies=null;this.mode=mode;// Effects
this.effectTag=NoEffect;this.nextEffect=null;this.firstEffect=null;this.lastEffect=null;this.expirationTime=NoWork;this.childExpirationTime=NoWork;this.alternate=null;if(enableProfilerTimer){// Note: The following is done to avoid a v8 performance cliff.
//
// Initializing the fields below to smis and later updating them with
// double values will cause Fibers to end up having separate shapes.
// This behavior/bug has something to do with Object.preventExtension().
// Fortunately this only impacts DEV builds.
// Unfortunately it makes React unusably slow for some applications.
// To work around this, initialize the fields below with doubles.
//
// Learn more about this here:
// https://github.com/facebook/react/issues/14365
// https://bugs.chromium.org/p/v8/issues/detail?id=8538
this.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.
// This won't trigger the performance cliff mentioned above,
// and it simplifies other profiler code (including DevTools).
this.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{this._debugID=debugCounter++;this._debugSource=null;this._debugOwner=null;this._debugIsCurrentlyTiming=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber=function(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
return new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current,pendingProps,expirationTime){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
workInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
workInProgress._debugID=current._debugID;workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else{workInProgress.pendingProps=pendingProps;// We already have an alternate.
// Reset the effect tag.
workInProgress.effectTag=NoEffect;// The effect list is no longer valid.
workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;if(enableProfilerTimer){// We intentionally reset, rather than copy, actualDuration & actualStartTime.
// This prevents time from endlessly accumulating in new commits.
// This has the downside of resetting values for different priority renders,
// But works for yielding (the common case) and should support resuming.
workInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}workInProgress.childExpirationTime=current.childExpirationTime;workInProgress.expirationTime=current.expirationTime;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;workInProgress.contextDependencies=current.contextDependencies;// These will be overridden during the parent's reconciliation
workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;if(enableProfilerTimer){workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}return workInProgress;}function createHostRootFiber(isConcurrent){var mode=isConcurrent?ConcurrentMode|StrictMode:NoContext;if(enableProfilerTimer&&isDevToolsPresent){// Always collect profile timings when DevTools are present.
// This enables DevTools to start capturing timing at any point–
// Without some nodes in the tree having empty base times.
mode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType
key,pendingProps,owner,mode,expirationTime){var fiber=void 0;var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.
var resolvedType=type;if(typeof type==='function'){if(shouldConstruct(type)){fiberTag=ClassComponent;}}else if(typeof type==='string'){fiberTag=HostComponent;}else{getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,expirationTime,key);case REACT_CONCURRENT_MODE_TYPE:return createFiberFromMode(pendingProps,mode|ConcurrentMode|StrictMode,expirationTime,key);case REACT_STRICT_MODE_TYPE:return createFiberFromMode(pendingProps,mode|StrictMode,expirationTime,key);case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,expirationTime,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,expirationTime,key);default:{if(typeof type==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer
fiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;}}var info='';{if(type===undefined||typeof type==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in, or you might have mixed up default and "+'named imports.';}var ownerName=owner?getComponentName(owner.type):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}invariant(false,'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',type==null?type:typeof type,info);}}}fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromElement(element,mode,expirationTime){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,expirationTime);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,expirationTime,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromProfiler(pendingProps,mode,expirationTime,key){{if(typeof pendingProps.id!=='string'||typeof pendingProps.onRender!=='function'){warningWithoutStack$1(false,'Profiler must specify an "id" string and "onRender" function as props');}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);// TODO: The Profiler fiber shouldn't have a type. It has a tag.
fiber.elementType=REACT_PROFILER_TYPE;fiber.type=REACT_PROFILER_TYPE;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromMode(pendingProps,mode,expirationTime,key){var fiber=createFiber(Mode,pendingProps,key,mode);// TODO: The Mode fiber shouldn't have a type. It has a tag.
var type=(mode&ConcurrentMode)===NoContext?REACT_STRICT_MODE_TYPE:REACT_CONCURRENT_MODE_TYPE;fiber.elementType=type;fiber.type=type;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromSuspense(pendingProps,mode,expirationTime,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);// TODO: The SuspenseComponent fiber shouldn't have a type. It has a tag.
var type=REACT_SUSPENSE_TYPE;fiber.elementType=type;fiber.type=type;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromText(content,mode,expirationTime){var fiber=createFiber(HostText,content,null,mode);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoContext);// TODO: These should not need a type.
fiber.elementType='DELETED';fiber.type='DELETED';return fiber;}function createFiberFromPortal(portal,mode,expirationTime){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.expirationTime=expirationTime;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
implementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.
function assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.
// We only use a Fiber to ensure the same hidden class so DEV isn't slow.
target=createFiber(IndeterminateComponent,null,null,NoContext);}// This is intentionally written as a list of all properties.
// We tried to use Object.assign() instead but this is called in
// the hottest path, and Object.assign() was too slow:
// https://github.com/facebook/react/issues/12502
// This code is DEV-only so size is not a concern.
target.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target.return=source.return;target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.contextDependencies=source.contextDependencies;target.mode=source.mode;target.effectTag=source.effectTag;target.nextEffect=source.nextEffect;target.firstEffect=source.firstEffect;target.lastEffect=source.lastEffect;target.expirationTime=source.expirationTime;target.childExpirationTime=source.childExpirationTime;target.alternate=source.alternate;if(enableProfilerTimer){target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugID=source._debugID;target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugIsCurrentlyTiming=source._debugIsCurrentlyTiming;target._debugHookTypes=source._debugHookTypes;return target;}// TODO: This should be lifted into the renderer.
// The following attributes are only used by interaction tracing builds.
// They enable interactions to be associated with their async work,
// And expose interaction metadata to the React DevTools Profiler plugin.
// Note that these attributes are only defined when the enableSchedulerTracing flag is enabled.
// Exported FiberRoot type includes all properties,
// To avoid requiring potentially error-prone :any casts throughout the project.
// Profiling properties are only safe to access in profiling builds (when enableSchedulerTracing is true).
// The types are defined separately within this file to ensure they stay in sync.
// (We don't have to use an inline :any cast when enableSchedulerTracing is disabled.)
function createFiberRoot(containerInfo,isConcurrent,hydrate){// Cyclic construction. This cheats the type system right now because
// stateNode is any.
var uninitializedFiber=createHostRootFiber(isConcurrent);var root=void 0;if(enableSchedulerTracing){root={current:uninitializedFiber,containerInfo:containerInfo,pendingChildren:null,earliestPendingTime:NoWork,latestPendingTime:NoWork,earliestSuspendedTime:NoWork,latestSuspendedTime:NoWork,latestPingedTime:NoWork,pingCache:null,didError:false,pendingCommitExpirationTime:NoWork,finishedWork:null,timeoutHandle:noTimeout,context:null,pendingContext:null,hydrate:hydrate,nextExpirationTimeToWorkOn:NoWork,expirationTime:NoWork,firstBatch:null,nextScheduledRoot:null,interactionThreadID:tracing.unstable_getThreadID(),memoizedInteractions:new Set(),pendingInteractionMap:new Map()};}else{root={current:uninitializedFiber,containerInfo:containerInfo,pendingChildren:null,pingCache:null,earliestPendingTime:NoWork,latestPendingTime:NoWork,earliestSuspendedTime:NoWork,latestSuspendedTime:NoWork,latestPingedTime:NoWork,didError:false,pendingCommitExpirationTime:NoWork,finishedWork:null,timeoutHandle:noTimeout,context:null,pendingContext:null,hydrate:hydrate,nextExpirationTimeToWorkOn:NoWork,expirationTime:NoWork,firstBatch:null,nextScheduledRoot:null};}uninitializedFiber.stateNode=root;// The reason for the way the Flow types are structured in this file,
// Is to avoid needing :any casts everywhere interaction tracing fields are used.
// Unfortunately that requires an :any cast for non-interaction tracing capable builds.
// $FlowFixMe Remove this :any cast and replace it with something better.
return root;}/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var lowPriorityWarning=function(){};{var printWarning=function(format){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var argIndex=0;var message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});if(typeof console!=='undefined'){console.warn(message);}try{// --- Welcome to debugging React ---
// This error was thrown as a convenience so that you can use this stack
// to find the callsite that caused this warning to fire.
throw new Error(message);}catch(x){}};lowPriorityWarning=function(condition,format){if(format===undefined){throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning '+'message argument');}if(!condition){for(var _len2=arguments.length,args=Array(_len2>2?_len2-2:0),_key2=2;_key2<_len2;_key2++){args[_key2-2]=arguments[_key2];}printWarning.apply(undefined,[format].concat(args));}};}var lowPriorityWarning$1=lowPriorityWarning;var ReactStrictModeWarnings={discardPendingWarnings:function(){},flushPendingDeprecationWarnings:function(){},flushPendingUnsafeLifecycleWarnings:function(){},recordDeprecationWarnings:function(fiber,instance){},recordUnsafeLifecycleWarnings:function(fiber,instance){},recordLegacyContextWarning:function(fiber,instance){},flushLegacyContextWarning:function(){}};{var LIFECYCLE_SUGGESTIONS={UNSAFE_componentWillMount:'componentDidMount',UNSAFE_componentWillReceiveProps:'static getDerivedStateFromProps',UNSAFE_componentWillUpdate:'componentDidUpdate'};var pendingComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUnsafeLifecycleWarnings=new Map();var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.
var didWarnAboutDeprecatedLifecycles=new Set();var didWarnAboutUnsafeLifecycles=new Set();var didWarnAboutLegacyContext=new Set();var setToSortedString=function(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUnsafeLifecycleWarnings=new Map();pendingLegacyContextWarning=new Map();};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){pendingUnsafeLifecycleWarnings.forEach(function(lifecycleWarningsMap,strictRoot){var lifecyclesWarningMessages=[];Object.keys(lifecycleWarningsMap).forEach(function(lifecycle){var lifecycleWarnings=lifecycleWarningsMap[lifecycle];if(lifecycleWarnings.length>0){var componentNames=new Set();lifecycleWarnings.forEach(function(fiber){componentNames.add(getComponentName(fiber.type)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});var formatted=lifecycle.replace('UNSAFE_','');var suggestion=LIFECYCLE_SUGGESTIONS[lifecycle];var sortedComponentNames=setToSortedString(componentNames);lifecyclesWarningMessages.push(formatted+': Please update the following components to use '+(suggestion+' instead: '+sortedComponentNames));}});if(lifecyclesWarningMessages.length>0){var strictRootComponentStack=getStackByFiberInDevAndProd(strictRoot);warningWithoutStack$1(false,'Unsafe lifecycle methods were found within a strict-mode tree:%s'+'\n\n%s'+'\n\nLearn more about this warning here:'+'\nhttps://fb.me/react-strict-mode-warnings',strictRootComponentStack,lifecyclesWarningMessages.join('\n\n'));}});pendingUnsafeLifecycleWarnings=new Map();};var findStrictRoot=function(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictMode){maybeStrictRoot=node;}node=node.return;}return maybeStrictRoot;};ReactStrictModeWarnings.flushPendingDeprecationWarnings=function(){if(pendingComponentWillMountWarnings.length>0){var uniqueNames=new Set();pendingComponentWillMountWarnings.forEach(function(fiber){uniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutDeprecatedLifecycles.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);lowPriorityWarning$1(false,'componentWillMount is deprecated and will be removed in the next major version. '+'Use componentDidMount instead. As a temporary workaround, '+'you can rename to UNSAFE_componentWillMount.'+'\n\nPlease update the following components: %s'+'\n\nLearn more about this warning here:'+'\nhttps://fb.me/react-async-component-lifecycle-hooks',sortedNames);pendingComponentWillMountWarnings=[];}if(pendingComponentWillReceivePropsWarnings.length>0){var _uniqueNames=new Set();pendingComponentWillReceivePropsWarnings.forEach(function(fiber){_uniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutDeprecatedLifecycles.add(fiber.type);});var _sortedNames=setToSortedString(_uniqueNames);lowPriorityWarning$1(false,'componentWillReceiveProps is deprecated and will be removed in the next major version. '+'Use static getDerivedStateFromProps instead.'+'\n\nPlease update the following components: %s'+'\n\nLearn more about this warning here:'+'\nhttps://fb.me/react-async-component-lifecycle-hooks',_sortedNames);pendingComponentWillReceivePropsWarnings=[];}if(pendingComponentWillUpdateWarnings.length>0){var _uniqueNames2=new Set();pendingComponentWillUpdateWarnings.forEach(function(fiber){_uniqueNames2.add(getComponentName(fiber.type)||'Component');didWarnAboutDeprecatedLifecycles.add(fiber.type);});var _sortedNames2=setToSortedString(_uniqueNames2);lowPriorityWarning$1(false,'componentWillUpdate is deprecated and will be removed in the next major version. '+'Use componentDidUpdate instead. As a temporary workaround, '+'you can rename to UNSAFE_componentWillUpdate.'+'\n\nPlease update the following components: %s'+'\n\nLearn more about this warning here:'+'\nhttps://fb.me/react-async-component-lifecycle-hooks',_sortedNames2);pendingComponentWillUpdateWarnings=[];}};ReactStrictModeWarnings.recordDeprecationWarnings=function(fiber,instance){// Dedup strategy: Warn once per component.
if(didWarnAboutDeprecatedLifecycles.has(fiber.type)){return;}// Don't warn about react-lifecycles-compat polyfilled components.
if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){warningWithoutStack$1(false,'Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.
// This is difficult to track any other way since component names
// are often vague and are likely to collide between 3rd party libraries.
// An expand property is probably okay to use here since it's DEV-only,
// and will only be set in the event of serious warnings.
if(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}var warningsForRoot=void 0;if(!pendingUnsafeLifecycleWarnings.has(strictRoot)){warningsForRoot={UNSAFE_componentWillMount:[],UNSAFE_componentWillReceiveProps:[],UNSAFE_componentWillUpdate:[]};pendingUnsafeLifecycleWarnings.set(strictRoot,warningsForRoot);}else{warningsForRoot=pendingUnsafeLifecycleWarnings.get(strictRoot);}var unsafeLifecycles=[];if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true||typeof instance.UNSAFE_componentWillMount==='function'){unsafeLifecycles.push('UNSAFE_componentWillMount');}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true||typeof instance.UNSAFE_componentWillReceiveProps==='function'){unsafeLifecycles.push('UNSAFE_componentWillReceiveProps');}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true||typeof instance.UNSAFE_componentWillUpdate==='function'){unsafeLifecycles.push('UNSAFE_componentWillUpdate');}if(unsafeLifecycles.length>0){unsafeLifecycles.forEach(function(lifecycle){warningsForRoot[lifecycle].push(fiber);});}};ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){warningWithoutStack$1(false,'Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.
if(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentName(fiber.type)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);var strictRootComponentStack=getStackByFiberInDevAndProd(strictRoot);warningWithoutStack$1(false,'Legacy context API has been detected within a strict-mode tree: %s'+'\n\nPlease update the following components: %s'+'\n\nLearn more about this warning here:'+'\nhttps://fb.me/react-strict-mode-warnings',strictRootComponentStack,sortedNames);});};}// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation={debugTool:null};var ReactFiberInstrumentation_1=ReactFiberInstrumentation;// TODO: Offscreen updates should never suspend. However, a promise that
// suspended inside an offscreen subtree should be able to ping at the priority
// of the outer render.
function markPendingPriorityLevel(root,expirationTime){// If there's a gap between completing a failed root and retrying it,
// additional updates may be scheduled. Clear `didError`, in case the update
// is sufficient to fix the error.
root.didError=false;// Update the latest and earliest pending times
var earliestPendingTime=root.earliestPendingTime;if(earliestPendingTime===NoWork){// No other pending updates.
root.earliestPendingTime=root.latestPendingTime=expirationTime;}else{if(earliestPendingTime<expirationTime){// This is the earliest pending update.
root.earliestPendingTime=expirationTime;}else{var latestPendingTime=root.latestPendingTime;if(latestPendingTime>expirationTime){// This is the latest pending update
root.latestPendingTime=expirationTime;}}}findNextExpirationTimeToWorkOn(expirationTime,root);}function markCommittedPriorityLevels(root,earliestRemainingTime){root.didError=false;if(earliestRemainingTime===NoWork){// Fast path. There's no remaining work. Clear everything.
root.earliestPendingTime=NoWork;root.latestPendingTime=NoWork;root.earliestSuspendedTime=NoWork;root.latestSuspendedTime=NoWork;root.latestPingedTime=NoWork;findNextExpirationTimeToWorkOn(NoWork,root);return;}if(earliestRemainingTime<root.latestPingedTime){root.latestPingedTime=NoWork;}// Let's see if the previous latest known pending level was just flushed.
var latestPendingTime=root.latestPendingTime;if(latestPendingTime!==NoWork){if(latestPendingTime>earliestRemainingTime){// We've flushed all the known pending levels.
root.earliestPendingTime=root.latestPendingTime=NoWork;}else{var earliestPendingTime=root.earliestPendingTime;if(earliestPendingTime>earliestRemainingTime){// We've flushed the earliest known pending level. Set this to the
// latest pending time.
root.earliestPendingTime=root.latestPendingTime;}}}// Now let's handle the earliest remaining level in the whole tree. We need to
// decide whether to treat it as a pending level or as suspended. Check
// it falls within the range of known suspended levels.
var earliestSuspendedTime=root.earliestSuspendedTime;if(earliestSuspendedTime===NoWork){// There's no suspended work. Treat the earliest remaining level as a
// pending level.
markPendingPriorityLevel(root,earliestRemainingTime);findNextExpirationTimeToWorkOn(NoWork,root);return;}var latestSuspendedTime=root.latestSuspendedTime;if(earliestRemainingTime<latestSuspendedTime){// The earliest remaining level is later than all the suspended work. That
// means we've flushed all the suspended work.
root.earliestSuspendedTime=NoWork;root.latestSuspendedTime=NoWork;root.latestPingedTime=NoWork;// There's no suspended work. Treat the earliest remaining level as a
// pending level.
markPendingPriorityLevel(root,earliestRemainingTime);findNextExpirationTimeToWorkOn(NoWork,root);return;}if(earliestRemainingTime>earliestSuspendedTime){// The earliest remaining time is earlier than all the suspended work.
// Treat it as a pending update.
markPendingPriorityLevel(root,earliestRemainingTime);findNextExpirationTimeToWorkOn(NoWork,root);return;}// The earliest remaining time falls within the range of known suspended
// levels. We should treat this as suspended work.
findNextExpirationTimeToWorkOn(NoWork,root);}function hasLowerPriorityWork(root,erroredExpirationTime){var latestPendingTime=root.latestPendingTime;var latestSuspendedTime=root.latestSuspendedTime;var latestPingedTime=root.latestPingedTime;return latestPendingTime!==NoWork&&latestPendingTime<erroredExpirationTime||latestSuspendedTime!==NoWork&&latestSuspendedTime<erroredExpirationTime||latestPingedTime!==NoWork&&latestPingedTime<erroredExpirationTime;}function isPriorityLevelSuspended(root,expirationTime){var earliestSuspendedTime=root.earliestSuspendedTime;var latestSuspendedTime=root.latestSuspendedTime;return earliestSuspendedTime!==NoWork&&expirationTime<=earliestSuspendedTime&&expirationTime>=latestSuspendedTime;}function markSuspendedPriorityLevel(root,suspendedTime){root.didError=false;clearPing(root,suspendedTime);// First, check the known pending levels and update them if needed.
var earliestPendingTime=root.earliestPendingTime;var latestPendingTime=root.latestPendingTime;if(earliestPendingTime===suspendedTime){if(latestPendingTime===suspendedTime){// Both known pending levels were suspended. Clear them.
root.earliestPendingTime=root.latestPendingTime=NoWork;}else{// The earliest pending level was suspended. Clear by setting it to the
// latest pending level.
root.earliestPendingTime=latestPendingTime;}}else if(latestPendingTime===suspendedTime){// The latest pending level was suspended. Clear by setting it to the
// latest pending level.
root.latestPendingTime=earliestPendingTime;}// Finally, update the known suspended levels.
var earliestSuspendedTime=root.earliestSuspendedTime;var latestSuspendedTime=root.latestSuspendedTime;if(earliestSuspendedTime===NoWork){// No other suspended levels.
root.earliestSuspendedTime=root.latestSuspendedTime=suspendedTime;}else{if(earliestSuspendedTime<suspendedTime){// This is the earliest suspended level.
root.earliestSuspendedTime=suspendedTime;}else if(latestSuspendedTime>suspendedTime){// This is the latest suspended level
root.latestSuspendedTime=suspendedTime;}}findNextExpirationTimeToWorkOn(suspendedTime,root);}function markPingedPriorityLevel(root,pingedTime){root.didError=false;// TODO: When we add back resuming, we need to ensure the progressed work
// is thrown out and not reused during the restarted render. One way to
// invalidate the progressed work is to restart at expirationTime + 1.
var latestPingedTime=root.latestPingedTime;if(latestPingedTime===NoWork||latestPingedTime>pingedTime){root.latestPingedTime=pingedTime;}findNextExpirationTimeToWorkOn(pingedTime,root);}function clearPing(root,completedTime){var latestPingedTime=root.latestPingedTime;if(latestPingedTime>=completedTime){root.latestPingedTime=NoWork;}}function findEarliestOutstandingPriorityLevel(root,renderExpirationTime){var earliestExpirationTime=renderExpirationTime;var earliestPendingTime=root.earliestPendingTime;var earliestSuspendedTime=root.earliestSuspendedTime;if(earliestPendingTime>earliestExpirationTime){earliestExpirationTime=earliestPendingTime;}if(earliestSuspendedTime>earliestExpirationTime){earliestExpirationTime=earliestSuspendedTime;}return earliestExpirationTime;}function didExpireAtExpirationTime(root,currentTime){var expirationTime=root.expirationTime;if(expirationTime!==NoWork&&currentTime<=expirationTime){// The root has expired. Flush all work up to the current time.
root.nextExpirationTimeToWorkOn=currentTime;}}function findNextExpirationTimeToWorkOn(completedExpirationTime,root){var earliestSuspendedTime=root.earliestSuspendedTime;var latestSuspendedTime=root.latestSuspendedTime;var earliestPendingTime=root.earliestPendingTime;var latestPingedTime=root.latestPingedTime;// Work on the earliest pending time. Failing that, work on the latest
// pinged time.
var nextExpirationTimeToWorkOn=earliestPendingTime!==NoWork?earliestPendingTime:latestPingedTime;// If there is no pending or pinged work, check if there's suspended work
// that's lower priority than what we just completed.
if(nextExpirationTimeToWorkOn===NoWork&&(completedExpirationTime===NoWork||latestSuspendedTime<completedExpirationTime)){// The lowest priority suspended work is the work most likely to be
// committed next. Let's start rendering it again, so that if it times out,
// it's ready to commit.
nextExpirationTimeToWorkOn=latestSuspendedTime;}var expirationTime=nextExpirationTimeToWorkOn;if(expirationTime!==NoWork&&earliestSuspendedTime>expirationTime){// Expire using the earliest known expiration time.
expirationTime=earliestSuspendedTime;}root.nextExpirationTimeToWorkOn=nextExpirationTimeToWorkOn;root.expirationTime=expirationTime;}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement
var props=_assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}function readLazyComponentType(lazyComponent){var status=lazyComponent._status;var result=lazyComponent._result;switch(status){case Resolved:{var Component=result;return Component;}case Rejected:{var error=result;throw error;}case Pending:{var thenable=result;throw thenable;}default:{lazyComponent._status=Pending;var ctor=lazyComponent._ctor;var _thenable=ctor();_thenable.then(function(moduleObject){if(lazyComponent._status===Pending){var defaultExport=moduleObject.default;{if(defaultExport===undefined){warning$1(false,'lazy: Expected the result of a dynamic import() call. '+'Instead received: %s\n\nYour code should look like: \n  '+"const MyComponent = lazy(() => import('./MyComponent'))",moduleObject);}}lazyComponent._status=Resolved;lazyComponent._result=defaultExport;}},function(error){if(lazyComponent._status===Pending){lazyComponent._status=Rejected;lazyComponent._result=error;}});// Handle synchronous thenables.
switch(lazyComponent._status){case Resolved:return lazyComponent._result;case Rejected:throw lazyComponent._result;}lazyComponent._result=_thenable;throw _thenable;}}}var fakeInternalInstance={};var isArray$1=Array.isArray;// React.Component uses a shared frozen object by default.
// We'll use it to determine whether we need to initialize legacy refs.
var emptyRefsObject=new React.Component().refs;var didWarnAboutStateAssignmentForComponent=void 0;var didWarnAboutUninitializedState=void 0;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=void 0;var didWarnAboutLegacyLifecyclesAndDerivedState=void 0;var didWarnAboutUndefinedDerivedState=void 0;var warnOnUndefinedDerivedState=void 0;var warnOnInvalidCallback$1=void 0;var didWarnAboutDirectlyAssigningPropsToState=void 0;var didWarnAboutContextTypeAndContextTypes=void 0;var didWarnAboutInvalidateContextType=void 0;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback$1=function(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);warningWithoutStack$1(false,'%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function(type,partialState){if(partialState===undefined){var componentName=getComponentName(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);warningWithoutStack$1(false,'%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if
// it causes problems. This is meant to give a nicer error message for
// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
// ...)) which otherwise throws a "_processChildContext is not a function"
// exception.
Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function(){invariant(false,'_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;{if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){// Invoke the function an extra time to help detect side-effects.
getDerivedStateFromProps(nextProps,prevState);}}var partialState=getDerivedStateFromProps(nextProps,prevState);{warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.
var memoizedState=partialState===null||partialState===undefined?prevState:_assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the
// base state.
var updateQueue=workInProgress.updateQueue;if(updateQueue!==null&&workInProgress.expirationTime===NoWork){updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function(inst,payload,callback){var fiber=get(inst);var currentTime=requestCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,fiber);var update=createUpdate(expirationTime);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback$1(callback,'setState');}update.callback=callback;}flushPassiveEffects();enqueueUpdate(fiber,update);scheduleWork(fiber,expirationTime);},enqueueReplaceState:function(inst,payload,callback){var fiber=get(inst);var currentTime=requestCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,fiber);var update=createUpdate(expirationTime);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback$1(callback,'replaceState');}update.callback=callback;}flushPassiveEffects();enqueueUpdate(fiber,update);scheduleWork(fiber,expirationTime);},enqueueForceUpdate:function(inst,callback){var fiber=get(inst);var currentTime=requestCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,fiber);var update=createUpdate(expirationTime);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback$1(callback,'forceUpdate');}update.callback=callback;}flushPassiveEffects();enqueueUpdate(fiber,update);scheduleWork(fiber,expirationTime);}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){startPhaseTimer(workInProgress,'shouldComponentUpdate');var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);stopPhaseTimer();{!(shouldUpdate!==undefined)?warningWithoutStack$1(false,'%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentName(ctor)||'Component'):void 0;}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentName(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){warningWithoutStack$1(false,'%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{warningWithoutStack$1(false,'%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}var noGetInitialStateOnES6=!instance.getInitialState||instance.getInitialState.isReactClassApproved||instance.state;!noGetInitialStateOnES6?warningWithoutStack$1(false,'getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name):void 0;var noGetDefaultPropsOnES6=!instance.getDefaultProps||instance.getDefaultProps.isReactClassApproved;!noGetDefaultPropsOnES6?warningWithoutStack$1(false,'getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name):void 0;var noInstancePropTypes=!instance.propTypes;!noInstancePropTypes?warningWithoutStack$1(false,'propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name):void 0;var noInstanceContextType=!instance.contextType;!noInstanceContextType?warningWithoutStack$1(false,'contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name):void 0;var noInstanceContextTypes=!instance.contextTypes;!noInstanceContextTypes?warningWithoutStack$1(false,'contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name):void 0;if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);warningWithoutStack$1(false,'%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}var noComponentShouldUpdate=typeof instance.componentShouldUpdate!=='function';!noComponentShouldUpdate?warningWithoutStack$1(false,'%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name):void 0;if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){warningWithoutStack$1(false,'%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentName(ctor)||'A pure component');}var noComponentDidUnmount=typeof instance.componentDidUnmount!=='function';!noComponentDidUnmount?warningWithoutStack$1(false,'%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name):void 0;var noComponentDidReceiveProps=typeof instance.componentDidReceiveProps!=='function';!noComponentDidReceiveProps?warningWithoutStack$1(false,'%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name):void 0;var noComponentWillRecieveProps=typeof instance.componentWillRecieveProps!=='function';!noComponentWillRecieveProps?warningWithoutStack$1(false,'%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name):void 0;var noUnsafeComponentWillRecieveProps=typeof instance.UNSAFE_componentWillRecieveProps!=='function';!noUnsafeComponentWillRecieveProps?warningWithoutStack$1(false,'%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name):void 0;var hasMutatedProps=instance.props!==newProps;!(instance.props===undefined||!hasMutatedProps)?warningWithoutStack$1(false,'%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name):void 0;var noInstanceDefaultProps=!instance.defaultProps;!noInstanceDefaultProps?warningWithoutStack$1(false,'Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name):void 0;if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);warningWithoutStack$1(false,'%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentName(ctor));}var noInstanceGetDerivedStateFromProps=typeof instance.getDerivedStateFromProps!=='function';!noInstanceGetDerivedStateFromProps?warningWithoutStack$1(false,'%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name):void 0;var noInstanceGetDerivedStateFromCatch=typeof instance.getDerivedStateFromError!=='function';!noInstanceGetDerivedStateFromCatch?warningWithoutStack$1(false,'%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name):void 0;var noStaticGetSnapshotBeforeUpdate=typeof ctor.getSnapshotBeforeUpdate!=='function';!noStaticGetSnapshotBeforeUpdate?warningWithoutStack$1(false,'%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name):void 0;var _state=instance.state;if(_state&&(typeof _state!=='object'||isArray$1(_state))){warningWithoutStack$1(false,'%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'){!(typeof ctor.childContextTypes==='object')?warningWithoutStack$1(false,'%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name):void 0;}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props,renderExpirationTime){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=null;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration
contextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>
if(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if(typeof contextType!=='object'){addendum=' However, it is set to a '+typeof contextType+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>
addendum=' Did you accidentally pass the Context.Consumer instead?';}else{addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}warningWithoutStack$1(false,'%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentName(ctor)||'Component',addendum);}}}if(typeof contextType==='object'&&contextType!==null){context=readContext(contextType);}else{unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}// Instantiate twice to help detect side-effects.
{if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){new ctor(props,context);// eslint-disable-line no-new
}}var instance=new ctor(props,context);var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentName(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);warningWithoutStack$1(false,'`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, "unsafe" lifecycles won't be called.
// Warn about these lifecycles if they are present.
// Don't warn about react-lifecycles-compat polyfilled methods though.
if(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentName(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);warningWithoutStack$1(false,'Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n'+'The above lifecycles should be removed. Learn more about this warning here:\n'+'https://fb.me/react-async-component-lifecycle-hooks',_componentName,newApiName,foundWillMountName!==null?'\n  '+foundWillMountName:'',foundWillReceivePropsName!==null?'\n  '+foundWillReceivePropsName:'',foundWillUpdateName!==null?'\n  '+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// ReactFiberContext usually updates this cache but can't for newly-created instances.
if(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){startPhaseTimer(workInProgress,'componentWillMount');var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}stopPhaseTimer();if(oldState!==instance.state){{warningWithoutStack$1(false,'%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentName(workInProgress.type)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;startPhaseTimer(workInProgress,'componentWillReceiveProps');if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}stopPhaseTimer();if(instance.state!==oldState){{var componentName=getComponentName(workInProgress.type)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);warningWithoutStack$1(false,'%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress,ctor,newProps,renderExpirationTime){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs=emptyRefsObject;var contextType=ctor.contextType;if(typeof contextType==='object'&&contextType!==null){instance.context=readContext(contextType);}else{var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentName(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);warningWithoutStack$1(false,'%s: It is not recommended to assign props directly to state '+"because updates to props won't be reflected in state. "+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictMode){ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}if(warnAboutDeprecatedLifecycles){ReactStrictModeWarnings.recordDeprecationWarnings(workInProgress,instance);}}var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){processUpdateQueue(workInProgress,updateQueue,newProps,instance,renderExpirationTime);instance.state=workInProgress.memoizedState;}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
// process them now.
updateQueue=workInProgress.updateQueue;if(updateQueue!==null){processUpdateQueue(workInProgress,updateQueue,newProps,instance,renderExpirationTime);instance.state=workInProgress.memoizedState;}}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderExpirationTime){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=void 0;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else{var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){processUpdateQueue(workInProgress,updateQueue,newProps,instance,renderExpirationTime);newState=workInProgress.memoizedState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){startPhaseTimer(workInProgress,'componentWillMount');if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}stopPhaseTimer();}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}// If shouldComponentUpdate returned false, we should still update the
// memoized state to indicate that this work can be reused.
workInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current,workInProgress,ctor,newProps,renderExpirationTime){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=workInProgress.type===workInProgress.elementType?oldProps:resolveDefaultProps(workInProgress.type,oldProps);var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=void 0;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else{var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){processUpdateQueue(workInProgress,updateQueue,newProps,instance,renderExpirationTime);newState=workInProgress.memoizedState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,
// Unsafe lifecycles should not be invoked for components using the new APIs.
if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){startPhaseTimer(workInProgress,'componentWillUpdate');if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}stopPhaseTimer();}if(typeof instance.componentDidUpdate==='function'){workInProgress.effectTag|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.effectTag|=Snapshot;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the
// memoized props/state to indicate that this work can be reused.
workInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}var didWarnAboutMaps=void 0;var didWarnAboutGenerators=void 0;var didWarnAboutStringRefInStrictMode=void 0;var ownerHasKeyUseWarning=void 0;var ownerHasFunctionTypeWarning=void 0;var warnForMissingKey=function(child){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefInStrictMode={};/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function(child){if(child===null||typeof child!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}!(typeof child._store==='object')?invariant(false,'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'):void 0;child._store.validated=true;var currentComponentErrorInfo='Each child in a list should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.'+getCurrentFiberStackInDev();if(ownerHasKeyUseWarning[currentComponentErrorInfo]){return;}ownerHasKeyUseWarning[currentComponentErrorInfo]=true;warning$1(false,'Each child in a list should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.');};}var isArray=Array.isArray;function coerceRef(returnFiber,current$$1,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&typeof mixedRef!=='object'){{if(returnFiber.mode&StrictMode){var componentName=getComponentName(returnFiber.type)||'Component';if(!didWarnAboutStringRefInStrictMode[componentName]){warningWithoutStack$1(false,'A string ref, "%s", has been found within a strict mode tree. '+'String refs are a source of potential bugs and should be avoided. '+'We recommend using createRef() instead.'+'\n%s'+'\n\nLearn more about using refs safely here:'+'\nhttps://fb.me/react-strict-mode-string-ref',mixedRef,getStackByFiberInDevAndProd(returnFiber));didWarnAboutStringRefInStrictMode[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst=void 0;if(owner){var ownerFiber=owner;!(ownerFiber.tag===ClassComponent)?invariant(false,'Function components cannot have refs. Did you mean to use React.forwardRef()?'):void 0;inst=ownerFiber.stateNode;}!inst?invariant(false,'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.',mixedRef):void 0;var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
if(current$$1!==null&&current$$1.ref!==null&&typeof current$$1.ref==='function'&&current$$1.ref._stringRef===stringRef){return current$$1.ref;}var ref=function(value){var refs=inst.refs;if(refs===emptyRefsObject){// This is a lazy pooled frozen object, so we need to initialize.
refs=inst.refs={};}if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{!(typeof mixedRef==='string')?invariant(false,'Expected ref to be a function, a string, an object returned by React.createRef(), or null.'):void 0;!element._owner?invariant(false,'Element ref was specified as a string (%s) but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component\'s render method\n3. You have multiple copies of React loaded\nSee https://fb.me/react-refs-must-have-owner for more information.',mixedRef):void 0;}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){if(returnFiber.type!=='textarea'){var addendum='';{addendum=' If you meant to render a collection of children, use an array '+'instead.'+getCurrentFiberStackInDev();}invariant(false,'Objects are not valid as a React child (found: %s).%s',Object.prototype.toString.call(newChild)==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':newChild,addendum);}}function warnOnFunctionType(){var currentComponentErrorInfo='Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.'+getCurrentFiberStackInDev();if(ownerHasFunctionTypeWarning[currentComponentErrorInfo]){return;}ownerHasFunctionTypeWarning[currentComponentErrorInfo]=true;warning$1(false,'Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
return;}// Deletions are added in reversed order so we add it to the front.
// At this point, the return fiber's effect list is empty except for
// deletions, so we can just append the deletion to the list. The remaining
// effects aren't added until the complete phase. Once we implement
// resuming, this may not be true.
var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}childToDelete.nextEffect=null;childToDelete.effectTag=Deletion;}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
// assuming that after the first child we've already added everything.
var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
// keys quickly. Implicit (null) keys get added to this set with their index
var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps,expirationTime){// We currently set sibling to null and index to 0 here because it is easy
// to forget to do before returning it. E.g. for the single child case.
var clone=createWorkInProgress(fiber,pendingProps,expirationTime);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// Noop.
return lastPlacedIndex;}var current$$1=newFiber.alternate;if(current$$1!==null){var oldIndex=current$$1.index;if(oldIndex<lastPlacedIndex){// This is a move.
newFiber.effectTag=Placement;return lastPlacedIndex;}else{// This item can stay in place.
return oldIndex;}}else{// This is an insertion.
newFiber.effectTag=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.effectTag=Placement;}return newFiber;}function updateTextNode(returnFiber,current$$1,textContent,expirationTime){if(current$$1===null||current$$1.tag!==HostText){// Insert
var created=createFiberFromText(textContent,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}else{// Update
var existing=useFiber(current$$1,textContent,expirationTime);existing.return=returnFiber;return existing;}}function updateElement(returnFiber,current$$1,element,expirationTime){if(current$$1!==null&&current$$1.elementType===element.type){// Move based on index
var existing=useFiber(current$$1,element.props,expirationTime);existing.ref=coerceRef(returnFiber,current$$1,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{// Insert
var created=createFiberFromElement(element,returnFiber.mode,expirationTime);created.ref=coerceRef(returnFiber,current$$1,element);created.return=returnFiber;return created;}}function updatePortal(returnFiber,current$$1,portal,expirationTime){if(current$$1===null||current$$1.tag!==HostPortal||current$$1.stateNode.containerInfo!==portal.containerInfo||current$$1.stateNode.implementation!==portal.implementation){// Insert
var created=createFiberFromPortal(portal,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}else{// Update
var existing=useFiber(current$$1,portal.children||[],expirationTime);existing.return=returnFiber;return existing;}}function updateFragment(returnFiber,current$$1,fragment,expirationTime,key){if(current$$1===null||current$$1.tag!==Fragment){// Insert
var created=createFiberFromFragment(fragment,returnFiber.mode,expirationTime,key);created.return=returnFiber;return created;}else{// Update
var existing=useFiber(current$$1,fragment,expirationTime);existing.return=returnFiber;return existing;}}function createChild(returnFiber,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
var created=createFiberFromText(''+newChild,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,expirationTime);_created.ref=coerceRef(returnFiber,null,newChild);_created.return=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,expirationTime);_created2.return=returnFiber;return _created2;}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,expirationTime,null);_created3.return=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateSlot(returnFiber,oldFiber,newChild,expirationTime){// Update the fiber if the keys match, otherwise return null.
var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,expirationTime);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,oldFiber,newChild.props.children,expirationTime,key);}return updateElement(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}}if(isArray(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
// new node for the key. If both are text nodes, they match.
var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,expirationTime);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,_matchedFiber,newChild.props.children,expirationTime,newChild.key);}return updateElement(returnFiber,_matchedFiber,newChild,expirationTime);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,expirationTime);}}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}/**
   * Warns if there is a duplicate or missing key
   */function warnOnInvalidKey(child,knownKeys){{if(typeof child!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}warning$1(false,'Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.',key);break;default:break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,expirationTime){// This algorithm can't optimize by searching from both ends since we
// don't have backpointers on fibers. I'm trying to see how far we can get
// with that model. If it ends up not being worth the tradeoffs, we can
// add it later.
// Even with a two ended optimization, we'd want to optimize for the case
// where there are few changes and brute force the comparison instead of
// going for the Map. It'd like to explore hitting that path first in
// forward-only mode and only go for the Map once we notice that we need
// lots of look ahead. This doesn't handle reversal as well as two ended
// search but that's unusual. Besides, for the two ended optimization to
// work on Iterables, we'd need to copy the whole set.
// In this first iteration, we'll just live with hitting the bad case
// (adding everything to a Map) in for every insert/move.
// If you change this code, also update reconcileChildrenIterator() which
// uses the same algorithm.
{// First, validate keys.
var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],expirationTime);if(!_newFiber){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],expirationTime);if(_newFiber2){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,expirationTime){// This is the same implementation as reconcileChildrenArray(),
// but using the iterator instead.
var iteratorFn=getIteratorFn(newChildrenIterable);!(typeof iteratorFn==='function')?invariant(false,'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'):void 0;{// We don't support rendering Generators because it's a mutation.
// See https://github.com/facebook/react/issues/12995
if(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag
newChildrenIterable[Symbol.toStringTag]==='Generator'){!didWarnAboutGenerators?warning$1(false,'Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.'):void 0;didWarnAboutGenerators=true;}// Warn about using Maps as children
if(newChildrenIterable.entries===iteratorFn){!didWarnAboutMaps?warning$1(false,'Using Maps as children is unsupported and will likely yield '+'unexpected results. Convert it to a sequence/iterable of keyed '+'ReactElements instead.'):void 0;didWarnAboutMaps=true;}// First, validate keys.
// We'll get a different iterator later for the main pass.
var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys);}}}var newChildren=iteratorFn.call(newChildrenIterable);!(newChildren!=null)?invariant(false,'An iterable object provided no iterator.'):void 0;var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(!oldFiber){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,expirationTime);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,expirationTime);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,expirationTime){// There's no need to check for keys on text nodes since we don't have a
// way to define them.
if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
// the rest.
deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent,expirationTime);existing.return=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
// and delete the existing ones.
deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,expirationTime){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===Fragment?element.type===REACT_FRAGMENT_TYPE:child.elementType===element.type){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.type===REACT_FRAGMENT_TYPE?element.props.children:element.props,expirationTime);existing.ref=coerceRef(returnFiber,child,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,expirationTime,element.key);created.return=returnFiber;return created;}else{var _created4=createFiberFromElement(element,returnFiber.mode,expirationTime);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4.return=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,expirationTime){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[],expirationTime);existing.return=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,expirationTime);created.return=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers(returnFiber,currentFirstChild,newChild,expirationTime){// This function is not recursive.
// If the top level item is an array, we treat it as a set of children,
// not as a fragment. Nested arrays on the other hand will be treated as
// fragment nodes. Recursion happens at the normal flow.
// Handle top level unkeyed fragments as if they were arrays.
// This leads to an ambiguity between <>{[...]}</> and <>...</>.
// We treat the ambiguous cases above the same.
var isUnkeyedTopLevelFragment=typeof newChild==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types
var isObject=typeof newChild==='object'&&newChild!==null;if(isObject){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,expirationTime));}}if(typeof newChild==='string'||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,expirationTime));}if(isArray(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,expirationTime);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,expirationTime);}if(isObject){throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}if(typeof newChild==='undefined'&&!isUnkeyedTopLevelFragment){// If the new child is undefined, and the return fiber is a composite
// component, throw an error. If Fiber return types are disabled,
// we already threw above.
switch(returnFiber.tag){case ClassComponent:{{var instance=returnFiber.stateNode;if(instance.render._isMockFunction){// We allow auto-mocks to proceed as if they're returning null.
break;}}}// Intentionally fall through to the next case, which handles both
// functions and classes
// eslint-disable-next-lined no-fallthrough
case FunctionComponent:{var Component=returnFiber.type;invariant(false,'%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.',Component.displayName||Component.name||'Component');}}}// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current$$1,workInProgress){!(current$$1===null||workInProgress.child===current$$1.child)?invariant(false,'Resuming work not yet implemented.'):void 0;if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);workInProgress.child=newChild;newChild.return=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);newChild.return=workInProgress;}newChild.sibling=null;}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){!(c!==NO_CONTEXT)?invariant(false,'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'):void 0;return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
// This allows us to reset root when portals are popped.
push(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.
// However, we can't just call getRootHostContext() and push it because
// we'd have a different number of entries on the stack depending on
// whether getRootHostContext() throws somewhere in renderer code or not.
// So we push an empty value first. This lets us safely unwind on errors.
push(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.
pop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type,rootInstance);// Don't push this Fiber's context unless it's unique.
if(context===nextContext){return;}// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
// pushHostContext() only pushes Fibers that provide unique contexts.
if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var NoEffect$1=/*             */0;var UnmountSnapshot=/*      */2;var UnmountMutation=/*      */4;var MountMutation=/*        */8;var UnmountLayout=/*        */16;var MountLayout=/*          */32;var MountPassive=/*         */64;var UnmountPassive=/*       */128;var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher;var didWarnAboutMismatchedHooksForComponent=void 0;{didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.
var renderExpirationTime=NoWork;// The work-in-progress fiber. I've named it differently to distinguish it from
// the work-in-progress hook.
var currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The
// current hook list is the list that belongs to the current fiber. The
// work-in-progress hook list is a new list that will be added to the
// work-in-progress fiber.
var currentHook=null;var nextCurrentHook=null;var firstWorkInProgressHook=null;var workInProgressHook=null;var nextWorkInProgressHook=null;var remainingExpirationTime=NoWork;var componentUpdateQueue=null;var sideEffectTag=0;// Updates scheduled during render will trigger an immediate re-render at the
// end of the current pass. We can't store these updates on the normal queue,
// because if the work is aborted, they should be discarded. Because this is
// a relatively rare case, we also don't want to add an additional field to
// either the hook or queue object types. So we store them in a lazily create
// map of queue -> render-phase updates, which are discarded once the component
// completes without re-rendering.
// Whether an update was scheduled during the currently executing render pass.
var didScheduleRenderPhaseUpdate=false;// Lazily created map of render-phase updates
var renderPhaseUpdates=null;// Counter to prevent infinite loops.
var numberOfReRenders=0;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook
var currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.
// The list stores the order of hooks used during the initial render (mount).
// Subsequent renders (updates) reference this list.
var hookTypesDev=null;var hookTypesUpdateIndexDev=-1;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else{hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentName(currentlyRenderingFiber$1.type);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+'. '+oldHookName;// Extra space so second column lines up
// lol @ IE not supporting String#repeat
while(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\n';table+=row;}warning$1(false,'React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\n\n'+'   Previous render            Next render\n'+'   ------------------------------------------------------\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n',componentName,table);}}}}function throwInvalidHookError(){invariant(false,'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.');}function areHookInputsEqual(nextDeps,prevDeps){if(prevDeps===null){{warning$1(false,'%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be
// passed inline.
if(nextDeps.length!==prevDeps.length){warning$1(false,'The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\n\n'+'Previous: %s\n'+'Incoming: %s',currentHookNameInDev,'['+nextDeps.join(', ')+']','['+prevDeps.join(', ')+']');}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(is(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,refOrContext,nextRenderExpirationTime){renderExpirationTime=nextRenderExpirationTime;currentlyRenderingFiber$1=workInProgress;nextCurrentHook=current!==null?current.memoizedState:null;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;}// The following should have already been reset
// currentHook = null;
// workInProgressHook = null;
// remainingExpirationTime = NoWork;
// componentUpdateQueue = null;
// didScheduleRenderPhaseUpdate = false;
// renderPhaseUpdates = null;
// numberOfReRenders = 0;
// sideEffectTag = 0;
// TODO Warn if no hooks are used at all during mount, then some are used during update.
// Currently we will identify the update render as a mount because nextCurrentHook === null.
// This is tricky because it's valid for certain types of components (e.g. React.lazy)
// Using nextCurrentHook to differentiate between mount/update only works if at least one stateful hook is used.
// Non-stateful hooks (e.g. context) don't get added to memoizedState,
// so nextCurrentHook would be null during updates and mounts.
{if(nextCurrentHook!==null){ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,
// but no stateful hooks have been used.
// We want to match the production code behavior (which will use HooksDispatcherOnMount),
// but with the extra DEV validation to ensure hooks ordering hasn't changed.
// This dispatcher does that.
ReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV;}else{ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,refOrContext);if(didScheduleRenderPhaseUpdate){do{didScheduleRenderPhaseUpdate=false;numberOfReRenders+=1;// Start over from the beginning of the list
nextCurrentHook=current!==null?current.memoizedState:null;nextWorkInProgressHook=firstWorkInProgressHook;currentHook=null;workInProgressHook=null;componentUpdateQueue=null;{// Also validate hook order for cascading updates.
hookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;children=Component(props,refOrContext);}while(didScheduleRenderPhaseUpdate);renderPhaseUpdates=null;numberOfReRenders=0;}// We can assume the previous dispatcher is always this one, since we set it
// at the beginning of the render phase and there's no re-entrancy.
ReactCurrentDispatcher$1.current=ContextOnlyDispatcher;var renderedWork=currentlyRenderingFiber$1;renderedWork.memoizedState=firstWorkInProgressHook;renderedWork.expirationTime=remainingExpirationTime;renderedWork.updateQueue=componentUpdateQueue;renderedWork.effectTag|=sideEffectTag;{renderedWork._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.
// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.
var didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderExpirationTime=NoWork;currentlyRenderingFiber$1=null;currentHook=null;nextCurrentHook=null;firstWorkInProgressHook=null;workInProgressHook=null;nextWorkInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;}remainingExpirationTime=NoWork;componentUpdateQueue=null;sideEffectTag=0;// These were reset above
// didScheduleRenderPhaseUpdate = false;
// renderPhaseUpdates = null;
// numberOfReRenders = 0;
!!didRenderTooFewHooks?invariant(false,'Rendered fewer hooks than expected. This may be caused by an accidental early return statement.'):void 0;return children;}function bailoutHooks(current,workInProgress,expirationTime){workInProgress.updateQueue=current.updateQueue;workInProgress.effectTag&=~(Passive|Update);if(current.expirationTime<=expirationTime){current.expirationTime=NoWork;}}function resetHooks(){// We can assume the previous dispatcher is always this one, since we set it
// at the beginning of the render phase and there's no re-entrancy.
ReactCurrentDispatcher$1.current=ContextOnlyDispatcher;// This is used to reset the state of this module when a component throws.
// It's also called inside mountIndeterminateComponent if we determine the
// component is a module-style component.
renderExpirationTime=NoWork;currentlyRenderingFiber$1=null;currentHook=null;nextCurrentHook=null;firstWorkInProgressHook=null;workInProgressHook=null;nextWorkInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;}remainingExpirationTime=NoWork;componentUpdateQueue=null;sideEffectTag=0;didScheduleRenderPhaseUpdate=false;renderPhaseUpdates=null;numberOfReRenders=0;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,queue:null,baseUpdate:null,next:null};if(workInProgressHook===null){// This is the first hook in the list
firstWorkInProgressHook=workInProgressHook=hook;}else{// Append to the end of the list
workInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a
// render phase update. It assumes there is either a current hook we can
// clone, or a work-in-progress hook from a previous render pass that we can
// use as a base. When we reach the end of the base list, we must switch to
// the dispatcher used for mounts.
if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.
workInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;nextCurrentHook=currentHook!==null?currentHook.next:null;}else{// Clone from the current hook.
!(nextCurrentHook!==null)?invariant(false,'Rendered more hooks than during the previous render.'):void 0;currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,queue:currentHook.queue,baseUpdate:currentHook.baseUpdate,next:null};if(workInProgressHook===null){// This is the first hook in the list.
workInProgressHook=firstWorkInProgressHook=newHook;}else{// Append to the end of the list.
workInProgressHook=workInProgressHook.next=newHook;}nextCurrentHook=currentHook.next;}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return{lastEffect:null};}function basicStateReducer(state,action){return typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState=void 0;if(init!==undefined){initialState=init(initialArg);}else{initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue=hook.queue={last:null,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};var dispatch=queue.dispatch=dispatchAction.bind(null,// Flow doesn't know this is non-null, but we do.
currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;!(queue!==null)?invariant(false,'Should have a queue. This is likely a bug in React. Please file an issue.'):void 0;queue.lastRenderedReducer=reducer;if(numberOfReRenders>0){// This is a re-render. Apply the new render phase updates to the previous
var _dispatch=queue.dispatch;if(renderPhaseUpdates!==null){// Render phase updates are stored in a map of queue -> linked list
var firstRenderPhaseUpdate=renderPhaseUpdates.get(queue);if(firstRenderPhaseUpdate!==undefined){renderPhaseUpdates.delete(queue);var newState=hook.memoizedState;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the
// priority because it will always be the same as the current
// render's.
var _action=update.action;newState=reducer(newState,_action);update=update.next;}while(update!==null);// Mark that the fiber performed work, but only if the new state is
// different from the current state.
if(!is(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumlated from the render phase updates to
// the base state unless the queue is empty.
// TODO: Not sure if this is the desired semantics, but it's what we
// do for gDSFP. I can't remember why.
if(hook.baseUpdate===queue.last){hook.baseState=newState;}queue.lastRenderedState=newState;return[newState,_dispatch];}}return[hook.memoizedState,_dispatch];}// The last update in the entire queue
var last=queue.last;// The last update that is part of the base state.
var baseUpdate=hook.baseUpdate;var baseState=hook.baseState;// Find the first unprocessed update.
var first=void 0;if(baseUpdate!==null){if(last!==null){// For the first update, the queue is a circular linked list where
// `queue.last.next = queue.first`. Once the first update commits, and
// the `baseUpdate` is no longer empty, we can unravel the list.
last.next=null;}first=baseUpdate.next;}else{first=last!==null?last.next:null;}if(first!==null){var _newState=baseState;var newBaseState=null;var newBaseUpdate=null;var prevUpdate=baseUpdate;var _update=first;var didSkip=false;do{var updateExpirationTime=_update.expirationTime;if(updateExpirationTime<renderExpirationTime){// Priority is insufficient. Skip this update. If this is the first
// skipped update, the previous update/state is the new base
// update/state.
if(!didSkip){didSkip=true;newBaseUpdate=prevUpdate;newBaseState=_newState;}// Update the remaining priority in the queue.
if(updateExpirationTime>remainingExpirationTime){remainingExpirationTime=updateExpirationTime;}}else{// Process this update.
if(_update.eagerReducer===reducer){// If this update was processed eagerly, and its reducer matches the
// current reducer, we can use the eagerly computed state.
_newState=_update.eagerState;}else{var _action2=_update.action;_newState=reducer(_newState,_action2);}}prevUpdate=_update;_update=_update.next;}while(_update!==null&&_update!==first);if(!didSkip){newBaseUpdate=prevUpdate;newBaseState=_newState;}// Mark that the fiber performed work, but only if the new state is
// different from the current state.
if(!is(_newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=_newState;hook.baseUpdate=newBaseUpdate;hook.baseState=newBaseState;queue.lastRenderedState=_newState;}var dispatch=queue.dispatch;return[hook.memoizedState,dispatch];}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){initialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue=hook.queue={last:null,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};var dispatch=queue.dispatch=dispatchAction.bind(null,// Flow doesn't know this is non-null, but we do.
currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer,initialState);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular
next:null};if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();componentUpdateQueue.lastEffect=effect.next=effect;}else{var _lastEffect=componentUpdateQueue.lastEffect;if(_lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else{var firstEffect=_lastEffect.next;_lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();var ref={current:initialValue};{Object.seal(ref);}hook.memoizedState=ref;return ref;}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberEffectTag,hookEffectTag,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;sideEffectTag|=fiberEffectTag;hook.memoizedState=pushEffect(hookEffectTag,create,undefined,nextDeps);}function updateEffectImpl(fiberEffectTag,hookEffectTag,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){pushEffect(NoEffect$1,create,destroy,nextDeps);return;}}}sideEffectTag|=fiberEffectTag;hook.memoizedState=pushEffect(hookEffectTag,create,destroy,nextDeps);}function mountEffect(create,deps){return mountEffectImpl(Update|Passive,UnmountPassive|MountPassive,create,deps);}function updateEffect(create,deps){return updateEffectImpl(Update|Passive,UnmountPassive|MountPassive,create,deps);}function mountLayoutEffect(create,deps){return mountEffectImpl(Update,UnmountMutation|MountLayout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,UnmountMutation|MountLayout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{!refObject.hasOwnProperty('current')?warning$1(false,'Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}'):void 0;}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{!(typeof create==='function')?warning$1(false,'Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null'):void 0;}// TODO: If deps are provided, should we skip comparing the ref itself?
var effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return mountEffectImpl(Update,UnmountMutation|MountLayout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{!(typeof create==='function')?warning$1(false,'Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null'):void 0;}// TODO: If deps are provided, should we skip comparing the ref itself?
var effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,UnmountMutation|MountLayout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.
// The react-debug-hooks package injects its own implementation
// so that e.g. DevTools can display custom hook values.
}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.
if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}// in a test-like environment, we want to warn if dispatchAction()
// is called outside of a batchedUpdates/TestUtils.act(...) call.
var shouldWarnForUnbatchedSetState=false;{// jest isn't a 'global', it's just exposed to tests via a wrapped function
// further, this isn't a test file, so flow doesn't recognize the symbol. So...
// $FlowExpectedError - because requirements don't give a damn about your type sigs.
if('undefined'!==typeof jest){shouldWarnForUnbatchedSetState=true;}}function dispatchAction(fiber,queue,action){!(numberOfReRenders<RE_RENDER_LIMIT)?invariant(false,'Too many re-renders. React limits the number of renders to prevent an infinite loop.'):void 0;{!(arguments.length<=3)?warning$1(false,"State updates from the useState() and useReducer() Hooks don't support the "+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().'):void 0;}var alternate=fiber.alternate;if(fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1){// This is a render phase update. Stash it in a lazily-created map of
// queue -> linked list of updates. After this render pass, we'll restart
// and apply the stashed updates on top of the work-in-progress hook.
didScheduleRenderPhaseUpdate=true;var update={expirationTime:renderExpirationTime,action:action,eagerReducer:null,eagerState:null,next:null};if(renderPhaseUpdates===null){renderPhaseUpdates=new Map();}var firstRenderPhaseUpdate=renderPhaseUpdates.get(queue);if(firstRenderPhaseUpdate===undefined){renderPhaseUpdates.set(queue,update);}else{// Append the update to the end of the list.
var lastRenderPhaseUpdate=firstRenderPhaseUpdate;while(lastRenderPhaseUpdate.next!==null){lastRenderPhaseUpdate=lastRenderPhaseUpdate.next;}lastRenderPhaseUpdate.next=update;}}else{flushPassiveEffects();var currentTime=requestCurrentTime();var _expirationTime=computeExpirationForFiber(currentTime,fiber);var _update2={expirationTime:_expirationTime,action:action,eagerReducer:null,eagerState:null,next:null};// Append the update to the end of the list.
var _last=queue.last;if(_last===null){// This is the first update. Create a circular list.
_update2.next=_update2;}else{var first=_last.next;if(first!==null){// Still circular.
_update2.next=first;}_last.next=_update2;}queue.last=_update2;if(fiber.expirationTime===NoWork&&(alternate===null||alternate.expirationTime===NoWork)){// The queue is currently empty, which means we can eagerly compute the
// next state before entering the render phase. If the new state is the
// same as the current state, we may be able to bail out entirely.
var _lastRenderedReducer=queue.lastRenderedReducer;if(_lastRenderedReducer!==null){var prevDispatcher=void 0;{prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var _eagerState=_lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute
// it, on the update object. If the reducer hasn't changed by the
// time we enter the render phase, then the eager state can be used
// without calling the reducer again.
_update2.eagerReducer=_lastRenderedReducer;_update2.eagerState=_eagerState;if(is(_eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.
// It's still possible that we'll need to rebase this update later,
// if the component re-renders for a different reason and by that
// time the reducer has changed.
return;}}catch(error){// Suppress the error. It will throw again in the render phase.
}finally{{ReactCurrentDispatcher$1.current=prevDispatcher;}}}}{if(shouldWarnForUnbatchedSetState===true){warnIfNotCurrentlyBatchingInDev(fiber);}}scheduleWork(fiber,_expirationTime);}}var ContextOnlyDispatcher={readContext:readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;{var warnInvalidContextAccess=function(){warning$1(false,'Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function(){warning$1(false,'Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://fb.me/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function(context,observedBits){return readContext(context,observedBits);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();return mountCallback(callback,deps);},useContext:function(context,observedBits){currentHookNameInDev='useContext';mountHookTypesDev();return readContext(context,observedBits);},useEffect:function(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue(value,formatterFn);}};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function(context,observedBits){return readContext(context,observedBits);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function(context,observedBits){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context,observedBits);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue(value,formatterFn);}};HooksDispatcherOnUpdateInDEV={readContext:function(context,observedBits){return readContext(context,observedBits);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context,observedBits){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context,observedBits);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue(value,formatterFn);}};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function(context,observedBits){warnInvalidContextAccess();return readContext(context,observedBits);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function(context,observedBits){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return readContext(context,observedBits);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue(value,formatterFn);}};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function(context,observedBits){warnInvalidContextAccess();return readContext(context,observedBits);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context,observedBits){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context,observedBits);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue(value,formatterFn);}};}var commitTime=0;var profilerStartTime=-1;function getCommitTime(){return commitTime;}function recordCommitTime(){if(!enableProfilerTimer){return;}commitTime=scheduler.unstable_now();}function startProfilerTimer(fiber){if(!enableProfilerTimer){return;}profilerStartTime=scheduler.unstable_now();if(fiber.actualStartTime<0){fiber.actualStartTime=scheduler.unstable_now();}}function stopProfilerTimerIfRunning(fiber){if(!enableProfilerTimer){return;}profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(!enableProfilerTimer){return;}if(profilerStartTime>=0){var elapsedTime=scheduler.unstable_now()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}// The deepest Fiber on the stack involved in a hydration context.
// This may have been an insertion or a hydration.
var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;function enterHydrationState(fiber){if(!supportsHydration){return false;}var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChild(parentInstance);hydrationParentFiber=fiber;isHydrating=true;return true;}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber){if(!supportsHydration){return false;}var suspenseInstance=fiber.stateNode;nextHydratableInstance=getNextHydratableSibling(suspenseInstance);popToNextHostParent(fiber);isHydrating=true;return true;}function deleteHydratableInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;}}var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete.return=returnFiber;childToDelete.effectTag=Deletion;// This might seem like it belongs on progressedFirstDeletion. However,
// these children are not part of the reconciliation list of children.
// Even if we abort and rereconcile the children, that will try to hydrate
// again and the nodes are still in the host tree so these will be
// recreated.
if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}}function insertNonHydratedInstance(returnFiber,fiber){fiber.effectTag|=Placement;{switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableContainerInstance(parentContainer,type,props);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableContainerTextInstance(parentContainer,text);break;case SuspenseComponent:break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;var _props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;case SuspenseComponent:didNotFindHydratableSuspenseInstance(parentType,parentProps,parentInstance);break;}break;}default:return;}}}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type,props);if(instance!==null){fiber.stateNode=instance;return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;return true;}return false;}case SuspenseComponent:{if(enableSuspenseServerRenderer){var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){// Downgrade the tag to a dehydrated component until we've hydrated it.
fiber.tag=DehydratedSuspenseComponent;fiber.stateNode=suspenseInstance;return true;}}return false;}default:return false;}}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){// If we can't hydrate this instance let's try the next one.
// We use this as a heuristic. It's based on intuition and not data so it
// might be flawed or unnecessary.
nextInstance=getNextHydratableSibling(firstAttemptedInstance);if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
// superfluous and we'll delete it. Since we can't eagerly delete it
// we'll have to schedule a deletion. To do that, this node needs a dummy
// fiber associated with it.
deleteHydratableInstance(hydrationParentFiber,firstAttemptedInstance);}hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(nextInstance);}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){if(!supportsHydration){invariant(false,'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');}var instance=fiber.stateNode;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);// TODO: Type this specific to this type of component.
fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update.
if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){if(!supportsHydration){invariant(false,'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');}var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);{if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
// hydration parent is the parent host component of this host text.
var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent);break;}}}}}return shouldUpdate;}function skipPastDehydratedSuspenseInstance(fiber){if(!supportsHydration){invariant(false,'Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');}var suspenseInstance=fiber.stateNode;!suspenseInstance?invariant(false,'Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.'):void 0;nextHydratableInstance=getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber.return;while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==DehydratedSuspenseComponent){parent=parent.return;}hydrationParentFiber=parent;}function popHydrationState(fiber){if(!supportsHydration){return false;}if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
// tree.
return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
// we were an insertion and now need to pop up reenter hydration of our
// siblings.
popToNextHostParent(fiber);isHydrating=true;return false;}var type=fiber.type;// If we have any remaining hydratable nodes, we need to delete them now.
// We only do this deeper than head and body since they tend to have random
// other nodes in them. We also ignore components with pure text content in
// side of them.
// TODO: Better heuristic.
if(fiber.tag!==HostComponent||type!=='head'&&type!=='body'&&!shouldSetTextContent(type,fiber.memoizedProps)){var nextInstance=nextHydratableInstance;while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}popToNextHostParent(fiber);nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;return true;}function resetHydrationState(){if(!supportsHydration){return;}hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass=void 0;var didWarnAboutContextTypeOnFunctionComponent=void 0;var didWarnAboutGetDerivedStateOnFunctionComponent=void 0;var didWarnAboutFunctionRefs=void 0;var didWarnAboutReassigningProps=void 0;{didWarnAboutBadClass={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;}function reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime){if(current$$1===null){// If this is a fresh new component that hasn't been rendered yet, we
// won't update its child set by applying minimal side-effects. Instead,
// we will add them all to the child before it gets rendered. That means
// we can optimize this reconciliation pass by not tracking side-effects.
workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else{// If the current child is the same as the work in progress, it means that
// we haven't yet started any work on these children. Therefore, we use
// the clone algorithm to create a copy of all the current children.
// If we had any progressed work already, that is invalid at this point so
// let's throw it out.
workInProgress.child=reconcileChildFibers(workInProgress,current$$1.child,nextChildren,renderExpirationTime);}}function forceUnmountCurrentAndReconcile(current$$1,workInProgress,nextChildren,renderExpirationTime){// This function is fork of reconcileChildren. It's used in cases where we
// want to reconcile without matching against the existing set. This has the
// effect of all current children being unmounted; even if the type and key
// are the same, the old child is unmounted and a new child is created.
//
// To do this, we're going to go through the reconcile algorithm twice. In
// the first pass, we schedule a deletion for all the current children by
// passing null.
workInProgress.child=reconcileChildFibers(workInProgress,current$$1.child,null,renderExpirationTime);// In the second pass, we mount the new children. The trick here is that we
// pass null in place of where we usually pass the current child set. This has
// the effect of remounting all children regardless of whether their their
// identity matches.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}function updateForwardRef(current$$1,workInProgress,Component,nextProps,renderExpirationTime){// TODO: current can be non-null here even if the component
// hasn't yet mounted. This happens after the first render suspends.
// We'll need to figure out if this is fine or can cause issues.
{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentName(Component),getCurrentFiberStackInDev);}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent
var nextChildren=void 0;prepareToReadContext(workInProgress,renderExpirationTime);{ReactCurrentOwner$3.current=workInProgress;setCurrentPhase('render');nextChildren=renderWithHooks(current$$1,workInProgress,render,nextProps,ref,renderExpirationTime);if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){// Only double-render components with Hooks
if(workInProgress.memoizedState!==null){nextChildren=renderWithHooks(current$$1,workInProgress,render,nextProps,ref,renderExpirationTime);}}setCurrentPhase(null);}if(current$$1!==null&&!didReceiveUpdate){bailoutHooks(current$$1,workInProgress,renderExpirationTime);return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}function updateMemoComponent(current$$1,workInProgress,Component,nextProps,updateExpirationTime,renderExpirationTime){if(current$$1===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.
Component.defaultProps===undefined){// If this is a plain function component without default props,
// and with only the default shallow comparison, we upgrade it
// to a SimpleMemoComponent to allow fast path updates.
workInProgress.tag=SimpleMemoComponent;workInProgress.type=type;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current$$1,workInProgress,type,nextProps,updateExpirationTime,renderExpirationTime);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.
// We could move it there, but we'd still need this for lazy code path.
checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentName(type),getCurrentFiberStackInDev);}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,null,workInProgress.mode,renderExpirationTime);child.ref=workInProgress.ref;child.return=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.
// We could move it there, but we'd still need this for lazy code path.
checkPropTypes(_innerPropTypes,nextProps,// Resolved props
'prop',getComponentName(_type),getCurrentFiberStackInDev);}}var currentChild=current$$1.child;// This is always exactly one child
if(updateExpirationTime<renderExpirationTime){// This will be the props with resolved defaultProps,
// unlike current.memoizedProps which will be the unresolved ones.
var prevProps=currentChild.memoizedProps;// Default to shallow comparison
var compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current$$1.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps,renderExpirationTime);newChild.ref=workInProgress.ref;newChild.return=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current$$1,workInProgress,Component,nextProps,updateExpirationTime,renderExpirationTime){// TODO: current can be non-null here even if the component
// hasn't yet mounted. This happens when the inner render suspends.
// We'll need to figure out if this is fine or can cause issues.
{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()
// so let's just skip over it to find memo() outer wrapper.
// Inner props for memo are validated later.
outerMemoType=refineResolvedLazyComponent(outerMemoType);}var outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)
'prop',getComponentName(outerMemoType),getCurrentFiberStackInDev);}// Inner propTypes will be validated in the function component path.
}}if(current$$1!==null){var prevProps=current$$1.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current$$1.ref===workInProgress.ref){didReceiveUpdate=false;if(updateExpirationTime<renderExpirationTime){return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}}}return updateFunctionComponent(current$$1,workInProgress,Component,nextProps,renderExpirationTime);}function updateFragment(current$$1,workInProgress,renderExpirationTime){var nextChildren=workInProgress.pendingProps;reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}function updateMode(current$$1,workInProgress,renderExpirationTime){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}function updateProfiler(current$$1,workInProgress,renderExpirationTime){if(enableProfilerTimer){workInProgress.effectTag|=Update;}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}function markRef(current$$1,workInProgress){var ref=workInProgress.ref;if(current$$1===null&&ref!==null||current$$1!==null&&current$$1.ref!==ref){// Schedule a Ref effect
workInProgress.effectTag|=Ref;}}function updateFunctionComponent(current$$1,workInProgress,Component,nextProps,renderExpirationTime){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentName(Component),getCurrentFiberStackInDev);}}}var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);var context=getMaskedContext(workInProgress,unmaskedContext);var nextChildren=void 0;prepareToReadContext(workInProgress,renderExpirationTime);{ReactCurrentOwner$3.current=workInProgress;setCurrentPhase('render');nextChildren=renderWithHooks(current$$1,workInProgress,Component,nextProps,context,renderExpirationTime);if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){// Only double-render components with Hooks
if(workInProgress.memoizedState!==null){nextChildren=renderWithHooks(current$$1,workInProgress,Component,nextProps,context,renderExpirationTime);}}setCurrentPhase(null);}if(current$$1!==null&&!didReceiveUpdate){bailoutHooks(current$$1,workInProgress,renderExpirationTime);return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}function updateClassComponent(current$$1,workInProgress,Component,nextProps,renderExpirationTime){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement
// because they're only guaranteed to be resolved here.
var innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props
'prop',getComponentName(Component),getCurrentFiberStackInDev);}}}// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=void 0;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderExpirationTime);var instance=workInProgress.stateNode;var shouldUpdate=void 0;if(instance===null){if(current$$1!==null){// An class component without an instance only mounts if it suspended
// inside a non- concurrent tree, in an inconsistent state. We want to
// tree it like a new mount, even though an empty version of it already
// committed. Disconnect the alternate pointers.
current$$1.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.effectTag|=Placement;}// In the initial pass we might need to construct the instance.
constructClassInstance(workInProgress,Component,nextProps,renderExpirationTime);mountClassInstance(workInProgress,Component,nextProps,renderExpirationTime);shouldUpdate=true;}else if(current$$1===null){// In a resume, we'll already have an instance we can reuse.
shouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderExpirationTime);}else{shouldUpdate=updateClassInstance(current$$1,workInProgress,Component,nextProps,renderExpirationTime);}var nextUnitOfWork=finishClassComponent(current$$1,workInProgress,Component,shouldUpdate,hasContext,renderExpirationTime);{var inst=workInProgress.stateNode;if(inst.props!==nextProps){!didWarnAboutReassigningProps?warning$1(false,'It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentName(workInProgress.type)||'a component'):void 0;didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current$$1,workInProgress,Component,shouldUpdate,hasContext,renderExpirationTime){// Refs should update even if shouldComponentUpdate returns false
markRef(current$$1,workInProgress);var didCaptureError=(workInProgress.effectTag&DidCapture)!==NoEffect;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering
if(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}var instance=workInProgress.stateNode;// Rerender
ReactCurrentOwner$3.current=workInProgress;var nextChildren=void 0;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFrom catch is not defined,
// unmount all the children. componentDidCatch will schedule an update to
// re-render a fallback. This is temporary until we migrate everyone to
// the new API.
// TODO: Warn in a future release.
nextChildren=null;if(enableProfilerTimer){stopProfilerTimerIfRunning(workInProgress);}}else{{setCurrentPhase('render');nextChildren=instance.render();if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){instance.render();}setCurrentPhase(null);}}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;if(current$$1!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of
// the existing children. Conceptually, the normal children and the children
// that are shown on error are two different sets, so we shouldn't reuse
// normal children even if their identities match.
forceUnmountCurrentAndReconcile(current$$1,workInProgress,nextChildren,renderExpirationTime);}else{reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);}// Memoize state using the values we just used to render.
// TODO: Restructure so we never read values from the instance.
workInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.
if(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current$$1,workInProgress,renderExpirationTime){pushHostRootContext(workInProgress);var updateQueue=workInProgress.updateQueue;!(updateQueue!==null)?invariant(false,'If the root does not have an updateQueue, we should have already bailed out. This error is likely caused by a bug in React. Please file an issue.'):void 0;var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState!==null?prevState.element:null;processUpdateQueue(workInProgress,updateQueue,nextProps,null,renderExpirationTime);var nextState=workInProgress.memoizedState;// Caution: React DevTools currently depends on this property
// being called "element".
var nextChildren=nextState.element;if(nextChildren===prevChildren){// If the state is the same as before, that's a bailout because we had
// no work that expires at this time.
resetHydrationState();return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}var root=workInProgress.stateNode;if((current$$1===null||current$$1.child===null)&&root.hydrate&&enterHydrationState(workInProgress)){// If we don't have any current children this might be the first pass.
// We always try to hydrate. If this isn't a hydration pass there won't
// be any children to hydrate which is effectively the same thing as
// not hydrating.
// This is a bit of a hack. We track the host root as a placement to
// know that we're currently in a mounting state. That way isMounted
// works as expected. We must reset this before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag|=Placement;// Ensure that children mount into this root without tracking
// side-effects. This ensures that we don't store Placement effects on
// nodes that will be hydrated.
workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else{// Otherwise reset hydration state in case we aborted and resumed another
// root.
reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);resetHydrationState();}return workInProgress.child;}function updateHostComponent(current$$1,workInProgress,renderExpirationTime){pushHostContext(workInProgress);if(current$$1===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current$$1!==null?current$$1.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
// case. We won't handle it as a reified child. We will instead handle
// this in the host environment that also have access to this prop. That
// avoids allocating another HostText fiber and traversing it.
nextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
// empty, we need to schedule the text content to be reset.
workInProgress.effectTag|=ContentReset;}markRef(current$$1,workInProgress);// Check the host config to see if the children are offscreen/hidden.
if(renderExpirationTime!==Never&&workInProgress.mode&ConcurrentMode&&shouldDeprioritizeSubtree(type,nextProps)){// Schedule this fiber to re-render at offscreen priority. Then bailout.
workInProgress.expirationTime=workInProgress.childExpirationTime=Never;return null;}reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);return workInProgress.child;}function updateHostText(current$$1,workInProgress){if(current$$1===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step
// immediately after.
return null;}function mountLazyComponent(_current,workInProgress,elementType,updateExpirationTime,renderExpirationTime){if(_current!==null){// An lazy component only mounts if it suspended inside a non-
// concurrent tree, in an inconsistent state. We want to treat it like
// a new mount, even though an empty version of it already committed.
// Disconnect the alternate pointers.
_current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.effectTag|=Placement;}var props=workInProgress.pendingProps;// We can't start a User Timing measurement with correct label yet.
// Cancel and resume right after we know the tag.
cancelWorkTimer(workInProgress);var Component=readLazyComponentType(elementType);// Store the unwrapped component in the type.
workInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);startWorkTimer(workInProgress);var resolvedProps=resolveDefaultProps(Component,props);var child=void 0;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderExpirationTime);break;}case ClassComponent:{child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderExpirationTime);break;}case ForwardRef:{child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderExpirationTime);break;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only
'prop',getComponentName(Component),getCurrentFiberStackInDev);}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too
updateExpirationTime,renderExpirationTime);break;}default:{var hint='';{if(Component!==null&&typeof Component==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent
// because the fact that it's a separate type of work is an
// implementation detail.
invariant(false,'Element type is invalid. Received a promise that resolves to: %s. Lazy element type must resolve to a class or function.%s',Component,hint);}}return child;}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderExpirationTime){if(_current!==null){// An incomplete component only mounts if it suspended inside a non-
// concurrent tree, in an inconsistent state. We want to treat it like
// a new mount, even though an empty version of it already committed.
// Disconnect the alternate pointers.
_current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.effectTag|=Placement;}// Promote the fiber to a class and try rendering again.
workInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`
// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=void 0;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}prepareToReadContext(workInProgress,renderExpirationTime);constructClassInstance(workInProgress,Component,nextProps,renderExpirationTime);mountClassInstance(workInProgress,Component,nextProps,renderExpirationTime);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderExpirationTime);}function mountIndeterminateComponent(_current,workInProgress,Component,renderExpirationTime){if(_current!==null){// An indeterminate component only mounts if it suspended inside a non-
// concurrent tree, in an inconsistent state. We want to treat it like
// a new mount, even though an empty version of it already committed.
// Disconnect the alternate pointers.
_current.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect
workInProgress.effectTag|=Placement;}var props=workInProgress.pendingProps;var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);var context=getMaskedContext(workInProgress,unmaskedContext);prepareToReadContext(workInProgress,renderExpirationTime);var value=void 0;{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentName(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){warningWithoutStack$1(false,"The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}ReactCurrentOwner$3.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderExpirationTime);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;if(typeof value==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){// Proceed under the assumption that this is a class instance
workInProgress.tag=ClassComponent;// Throw out any hooks that were used.
resetHooks();// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else{hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;var getDerivedStateFromProps=Component.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,Component,getDerivedStateFromProps,props);}adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderExpirationTime);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderExpirationTime);}else{// Proceed under the assumption that this is a function component
workInProgress.tag=FunctionComponent;{if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){// Only double-render components with Hooks
if(workInProgress.memoizedState!==null){value=renderWithHooks(null,workInProgress,Component,props,context,renderExpirationTime);}}}reconcileChildren(null,workInProgress,value,renderExpirationTime);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){if(Component){!!Component.childContextTypes?warningWithoutStack$1(false,'%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component'):void 0;}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||workInProgress._debugID||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;warning$1(false,'Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(typeof Component.getDerivedStateFromProps==='function'){var componentName=getComponentName(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[componentName]){warningWithoutStack$1(false,'%s: Function components do not support getDerivedStateFromProps.',componentName);didWarnAboutGetDerivedStateOnFunctionComponent[componentName]=true;}}if(typeof Component.contextType==='object'&&Component.contextType!==null){var _componentName=getComponentName(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName]){warningWithoutStack$1(false,'%s: Function components do not support contextType.',_componentName);didWarnAboutContextTypeOnFunctionComponent[_componentName]=true;}}}function updateSuspenseComponent(current$$1,workInProgress,renderExpirationTime){var mode=workInProgress.mode;var nextProps=workInProgress.pendingProps;// We should attempt to render the primary children unless this boundary
// already suspended during this render (`alreadyCaptured` is true).
var nextState=workInProgress.memoizedState;var nextDidTimeout=void 0;if((workInProgress.effectTag&DidCapture)===NoEffect){// This is the first attempt.
nextState=null;nextDidTimeout=false;}else{// Something in this boundary's subtree already suspended. Switch to
// rendering the fallback children.
nextState={timedOutAt:nextState!==null?nextState.timedOutAt:NoWork};nextDidTimeout=true;workInProgress.effectTag&=~DidCapture;}// This next part is a bit confusing. If the children timeout, we switch to
// showing the fallback children in place of the "primary" children.
// However, we don't want to delete the primary children because then their
// state will be lost (both the React state and the host state, e.g.
// uncontrolled form inputs). Instead we keep them mounted and hide them.
// Both the fallback children AND the primary children are rendered at the
// same time. Once the primary children are un-suspended, we can delete
// the fallback children — don't need to preserve their state.
//
// The two sets of children are siblings in the host environment, but
// semantically, for purposes of reconciliation, they are two separate sets.
// So we store them using two fragment fibers.
//
// However, we want to avoid allocating extra fibers for every placeholder.
// They're only necessary when the children time out, because that's the
// only time when both sets are mounted.
//
// So, the extra fragment fibers are only used if the children time out.
// Otherwise, we render the primary children directly. This requires some
// custom reconciliation logic to preserve the state of the primary
// children. It's essentially a very basic form of re-parenting.
// `child` points to the child fiber. In the normal case, this is the first
// fiber of the primary children set. In the timed-out case, it's a
// a fragment fiber containing the primary children.
var child=void 0;// `next` points to the next fiber React should render. In the normal case,
// it's the same as `child`: the first fiber of the primary children set.
// In the timed-out case, it's a fragment fiber containing the *fallback*
// children -- we skip over the primary children entirely.
var next=void 0;if(current$$1===null){if(enableSuspenseServerRenderer){// If we're currently hydrating, try to hydrate this boundary.
// But only if this has a fallback.
if(nextProps.fallback!==undefined){tryToClaimNextHydratableInstance(workInProgress);// This could've changed the tag if this was a dehydrated suspense component.
if(workInProgress.tag===DehydratedSuspenseComponent){return updateDehydratedSuspenseComponent(null,workInProgress,renderExpirationTime);}}}// This is the initial mount. This branch is pretty simple because there's
// no previous state that needs to be preserved.
if(nextDidTimeout){// Mount separate fragments for primary and fallback children.
var nextFallbackChildren=nextProps.fallback;var primaryChildFragment=createFiberFromFragment(null,mode,NoWork,null);if((workInProgress.mode&ConcurrentMode)===NoContext){// Outside of concurrent mode, we commit the effects from the
var progressedState=workInProgress.memoizedState;var progressedPrimaryChild=progressedState!==null?workInProgress.child.child:workInProgress.child;primaryChildFragment.child=progressedPrimaryChild;}var fallbackChildFragment=createFiberFromFragment(nextFallbackChildren,mode,renderExpirationTime,null);primaryChildFragment.sibling=fallbackChildFragment;child=primaryChildFragment;// Skip the primary children, and continue working on the
// fallback children.
next=fallbackChildFragment;child.return=next.return=workInProgress;}else{// Mount the primary children without an intermediate fragment fiber.
var nextPrimaryChildren=nextProps.children;child=next=mountChildFibers(workInProgress,null,nextPrimaryChildren,renderExpirationTime);}}else{// This is an update. This branch is more complicated because we need to
// ensure the state of the primary children is preserved.
var prevState=current$$1.memoizedState;var prevDidTimeout=prevState!==null;if(prevDidTimeout){// The current tree already timed out. That means each child set is
var currentPrimaryChildFragment=current$$1.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;if(nextDidTimeout){// Still timed out. Reuse the current primary children by cloning
// its fragment. We're going to skip over these entirely.
var _nextFallbackChildren=nextProps.fallback;var _primaryChildFragment=createWorkInProgress(currentPrimaryChildFragment,currentPrimaryChildFragment.pendingProps,NoWork);if((workInProgress.mode&ConcurrentMode)===NoContext){// Outside of concurrent mode, we commit the effects from the
var _progressedState=workInProgress.memoizedState;var _progressedPrimaryChild=_progressedState!==null?workInProgress.child.child:workInProgress.child;if(_progressedPrimaryChild!==currentPrimaryChildFragment.child){_primaryChildFragment.child=_progressedPrimaryChild;}}// Because primaryChildFragment is a new fiber that we're inserting as the
// parent of a new tree, we need to set its treeBaseDuration.
if(enableProfilerTimer&&workInProgress.mode&ProfileMode){// treeBaseDuration is the sum of all the child tree base durations.
var treeBaseDuration=0;var hiddenChild=_primaryChildFragment.child;while(hiddenChild!==null){treeBaseDuration+=hiddenChild.treeBaseDuration;hiddenChild=hiddenChild.sibling;}_primaryChildFragment.treeBaseDuration=treeBaseDuration;}// Clone the fallback child fragment, too. These we'll continue
// working on.
var _fallbackChildFragment=_primaryChildFragment.sibling=createWorkInProgress(currentFallbackChildFragment,_nextFallbackChildren,currentFallbackChildFragment.expirationTime);child=_primaryChildFragment;_primaryChildFragment.childExpirationTime=NoWork;// Skip the primary children, and continue working on the
// fallback children.
next=_fallbackChildFragment;child.return=next.return=workInProgress;}else{// No longer suspended. Switch back to showing the primary children,
// and remove the intermediate fragment fiber.
var _nextPrimaryChildren=nextProps.children;var currentPrimaryChild=currentPrimaryChildFragment.child;var primaryChild=reconcileChildFibers(workInProgress,currentPrimaryChild,_nextPrimaryChildren,renderExpirationTime);// If this render doesn't suspend, we need to delete the fallback
// children. Wait until the complete phase, after we've confirmed the
// fallback is no longer needed.
// TODO: Would it be better to store the fallback fragment on
// the stateNode?
// Continue rendering the children, like we normally do.
child=next=primaryChild;}}else{// The current tree has not already timed out. That means the primary
// children are not wrapped in a fragment fiber.
var _currentPrimaryChild=current$$1.child;if(nextDidTimeout){// Timed out. Wrap the children in a fragment fiber to keep them
// separate from the fallback children.
var _nextFallbackChildren2=nextProps.fallback;var _primaryChildFragment2=createFiberFromFragment(// It shouldn't matter what the pending props are because we aren't
// going to render this fragment.
null,mode,NoWork,null);_primaryChildFragment2.child=_currentPrimaryChild;// Even though we're creating a new fiber, there are no new children,
// because we're reusing an already mounted tree. So we don't need to
// schedule a placement.
// primaryChildFragment.effectTag |= Placement;
if((workInProgress.mode&ConcurrentMode)===NoContext){// Outside of concurrent mode, we commit the effects from the
var _progressedState2=workInProgress.memoizedState;var _progressedPrimaryChild2=_progressedState2!==null?workInProgress.child.child:workInProgress.child;_primaryChildFragment2.child=_progressedPrimaryChild2;}// Because primaryChildFragment is a new fiber that we're inserting as the
// parent of a new tree, we need to set its treeBaseDuration.
if(enableProfilerTimer&&workInProgress.mode&ProfileMode){// treeBaseDuration is the sum of all the child tree base durations.
var _treeBaseDuration=0;var _hiddenChild=_primaryChildFragment2.child;while(_hiddenChild!==null){_treeBaseDuration+=_hiddenChild.treeBaseDuration;_hiddenChild=_hiddenChild.sibling;}_primaryChildFragment2.treeBaseDuration=_treeBaseDuration;}// Create a fragment from the fallback children, too.
var _fallbackChildFragment2=_primaryChildFragment2.sibling=createFiberFromFragment(_nextFallbackChildren2,mode,renderExpirationTime,null);_fallbackChildFragment2.effectTag|=Placement;child=_primaryChildFragment2;_primaryChildFragment2.childExpirationTime=NoWork;// Skip the primary children, and continue working on the
// fallback children.
next=_fallbackChildFragment2;child.return=next.return=workInProgress;}else{// Still haven't timed out.  Continue rendering the children, like we
// normally do.
var _nextPrimaryChildren2=nextProps.children;next=child=reconcileChildFibers(workInProgress,_currentPrimaryChild,_nextPrimaryChildren2,renderExpirationTime);}}workInProgress.stateNode=current$$1.stateNode;}workInProgress.memoizedState=nextState;workInProgress.child=child;return next;}function updateDehydratedSuspenseComponent(current$$1,workInProgress,renderExpirationTime){if(current$$1===null){// During the first pass, we'll bail out and not drill into the children.
// Instead, we'll leave the content in place and try to hydrate it later.
workInProgress.expirationTime=Never;return null;}// We use childExpirationTime to indicate that a child might depend on context, so if
// any context has changed, we need to treat is as if the input might have changed.
var hasContextChanged$$1=current$$1.childExpirationTime>=renderExpirationTime;if(didReceiveUpdate||hasContextChanged$$1){// This boundary has changed since the first render. This means that we are now unable to
// hydrate it. We might still be able to hydrate it using an earlier expiration time but
// during this render we can't. Instead, we're going to delete the whole subtree and
// instead inject a new real Suspense boundary to take its place, which may render content
// or fallback. The real Suspense boundary will suspend for a while so we have some time
// to ensure it can produce real content, but all state and pending events will be lost.
// Detach from the current dehydrated boundary.
current$$1.alternate=null;workInProgress.alternate=null;// Insert a deletion in the effect list.
var returnFiber=workInProgress.return;!(returnFiber!==null)?invariant(false,'Suspense boundaries are never on the root. This is probably a bug in React.'):void 0;var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=current$$1;returnFiber.lastEffect=current$$1;}else{returnFiber.firstEffect=returnFiber.lastEffect=current$$1;}current$$1.nextEffect=null;current$$1.effectTag=Deletion;// Upgrade this work in progress to a real Suspense component.
workInProgress.tag=SuspenseComponent;workInProgress.stateNode=null;workInProgress.memoizedState=null;// This is now an insertion.
workInProgress.effectTag|=Placement;// Retry as a real Suspense component.
return updateSuspenseComponent(null,workInProgress,renderExpirationTime);}if((workInProgress.effectTag&DidCapture)===NoEffect){// This is the first attempt.
reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress);var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);return workInProgress.child;}else{// Something suspended. Leave the existing children in place.
// TODO: In non-concurrent mode, should we commit the nodes we have hydrated so far?
workInProgress.child=null;return null;}}function updatePortalComponent(current$$1,workInProgress,renderExpirationTime){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current$$1===null){// Portals are special because we don't append the children during mount
// but at commit. Therefore we need to track insertions which the normal
// flow doesn't do during mount. This doesn't happen at the root because
// the root always starts with a "current" with a null child.
// TODO: Consider unifying this with how the root works.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else{reconcileChildren(current$$1,workInProgress,nextChildren,renderExpirationTime);}return workInProgress.child;}function updateContextProvider(current$$1,workInProgress,renderExpirationTime){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider',getCurrentFiberStackInDev);}}pushProvider(workInProgress,newValue);if(oldProps!==null){var oldValue=oldProps.value;var changedBits=calculateChangedBits(context,newValue,oldValue);if(changedBits===0){// No change. Bailout early if children are the same.
if(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}}else{// The context value changed. Search for matching consumers and schedule
// them to update.
propagateContextChange(workInProgress,context,changedBits,renderExpirationTime);}}var newChildren=newProps.children;reconcileChildren(current$$1,workInProgress,newChildren,renderExpirationTime);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current$$1,workInProgress,renderExpirationTime){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In
// DEV mode, we create a separate object for Context.Consumer that acts
// like a proxy to Context. This proxy object adds unnecessary code in PROD
// so we use the old behaviour (Context.Consumer references Context) to
// reduce size and overhead. The separate object references context via
// a property called "_context", which also gives us the ability to check
// in DEV mode if this property exists or not and warn if it does not.
{if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).
// Or it may be because it's older React where they're the same thing.
// We only want to warn if we're sure it's a new React.
if(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;warning$1(false,'Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else{context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{!(typeof render==='function')?warningWithoutStack$1(false,'A context consumer was rendered with multiple children, or a child '+"that isn't a function. A context consumer expects a single child "+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.'):void 0;}prepareToReadContext(workInProgress,renderExpirationTime);var newValue=readContext(context,newProps.unstable_observedBits);var newChildren=void 0;{ReactCurrentOwner$3.current=workInProgress;setCurrentPhase('render');newChildren=render(newValue);setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current$$1,workInProgress,newChildren,renderExpirationTime);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime){cancelWorkTimer(workInProgress);if(current$$1!==null){// Reuse previous context list
workInProgress.contextDependencies=current$$1.contextDependencies;}if(enableProfilerTimer){// Don't update "base" render times for bailouts.
stopProfilerTimerIfRunning(workInProgress);}// Check if the children have any pending work.
var childExpirationTime=workInProgress.childExpirationTime;if(childExpirationTime<renderExpirationTime){// The children don't have any work either. We can skip them.
// TODO: Once we add back resuming, we should check if the children are
// a work-in-progress set. If so, we need to transfer their effects.
return null;}else{// This fiber doesn't have work, but its subtree does. Clone the child
// fibers and continue.
cloneChildFibers(current$$1,workInProgress);return workInProgress.child;}}function beginWork(current$$1,workInProgress,renderExpirationTime){var updateExpirationTime=workInProgress.expirationTime;if(current$$1!==null){var oldProps=current$$1.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()){// If props or context changed, mark the fiber as having performed work.
// This may be unset if the props are determined to be equal later (memo).
didReceiveUpdate=true;}else if(updateExpirationTime<renderExpirationTime){didReceiveUpdate=false;// This fiber does not have any pending work. Bailout without entering
// the begin phase. There's still some bookkeeping we that needs to be done
// in this optimized path, mostly pushing stuff onto the stack.
switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;pushProvider(workInProgress,newValue);break;}case Profiler:if(enableProfilerTimer){workInProgress.effectTag|=Update;}break;case SuspenseComponent:{var state=workInProgress.memoizedState;var didTimeout=state!==null;if(didTimeout){// If this boundary is currently timed out, we need to decide
// whether to retry the primary children, or to skip over it and
// go straight to the fallback. Check the priority of the primary
var primaryChildFragment=workInProgress.child;var primaryChildExpirationTime=primaryChildFragment.childExpirationTime;if(primaryChildExpirationTime!==NoWork&&primaryChildExpirationTime>=renderExpirationTime){// The primary children have pending work. Use the normal path
// to attempt to render the primary children again.
return updateSuspenseComponent(current$$1,workInProgress,renderExpirationTime);}else{// The primary children do not have pending work with sufficient
// priority. Bailout.
var child=bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);if(child!==null){// The fallback children have pending work. Skip over the
// primary children and work on the fallback.
return child.sibling;}else{return null;}}}break;}case DehydratedSuspenseComponent:{if(enableSuspenseServerRenderer){// We know that this component will suspend again because if it has
// been unsuspended it has committed as a regular Suspense component.
// If it needs to be retried, it should have work scheduled on it.
workInProgress.effectTag|=DidCapture;break;}}}return bailoutOnAlreadyFinishedWork(current$$1,workInProgress,renderExpirationTime);}}else{didReceiveUpdate=false;}// Before entering the begin phase, clear the expiration time.
workInProgress.expirationTime=NoWork;switch(workInProgress.tag){case IndeterminateComponent:{var elementType=workInProgress.elementType;return mountIndeterminateComponent(current$$1,workInProgress,elementType,renderExpirationTime);}case LazyComponent:{var _elementType=workInProgress.elementType;return mountLazyComponent(current$$1,workInProgress,_elementType,updateExpirationTime,renderExpirationTime);}case FunctionComponent:{var _Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===_Component?unresolvedProps:resolveDefaultProps(_Component,unresolvedProps);return updateFunctionComponent(current$$1,workInProgress,_Component,resolvedProps,renderExpirationTime);}case ClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component2?_unresolvedProps:resolveDefaultProps(_Component2,_unresolvedProps);return updateClassComponent(current$$1,workInProgress,_Component2,_resolvedProps,renderExpirationTime);}case HostRoot:return updateHostRoot(current$$1,workInProgress,renderExpirationTime);case HostComponent:return updateHostComponent(current$$1,workInProgress,renderExpirationTime);case HostText:return updateHostText(current$$1,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current$$1,workInProgress,renderExpirationTime);case HostPortal:return updatePortalComponent(current$$1,workInProgress,renderExpirationTime);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current$$1,workInProgress,type,_resolvedProps2,renderExpirationTime);}case Fragment:return updateFragment(current$$1,workInProgress,renderExpirationTime);case Mode:return updateMode(current$$1,workInProgress,renderExpirationTime);case Profiler:return updateProfiler(current$$1,workInProgress,renderExpirationTime);case ContextProvider:return updateContextProvider(current$$1,workInProgress,renderExpirationTime);case ContextConsumer:return updateContextConsumer(current$$1,workInProgress,renderExpirationTime);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.
var _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only
'prop',getComponentName(_type2),getCurrentFiberStackInDev);}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current$$1,workInProgress,_type2,_resolvedProps3,updateExpirationTime,renderExpirationTime);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current$$1,workInProgress,workInProgress.type,workInProgress.pendingProps,updateExpirationTime,renderExpirationTime);}case IncompleteClassComponent:{var _Component3=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component3?_unresolvedProps4:resolveDefaultProps(_Component3,_unresolvedProps4);return mountIncompleteClassComponent(current$$1,workInProgress,_Component3,_resolvedProps4,renderExpirationTime);}case DehydratedSuspenseComponent:{if(enableSuspenseServerRenderer){return updateDehydratedSuspenseComponent(current$$1,workInProgress,renderExpirationTime);}break;}}invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}var valueCursor=createCursor(null);var rendererSigil=void 0;{// Use this to detect multiple renderers using the same context
rendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastContextWithAllBitsObserved=null;var isDisallowedContextReadInDEV=false;function resetContextDependences(){// This is called right before React yields execution, to ensure `readContext`
// cannot be called outside the render phase.
currentlyRenderingFiber=null;lastContextDependency=null;lastContextWithAllBitsObserved=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,nextValue){var context=providerFiber.type._context;if(isPrimaryRenderer){push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{!(context._currentRenderer===undefined||context._currentRenderer===null||context._currentRenderer===rendererSigil)?warningWithoutStack$1(false,'Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.'):void 0;context._currentRenderer=rendererSigil;}}else{push(valueCursor,context._currentValue2,providerFiber);context._currentValue2=nextValue;{!(context._currentRenderer2===undefined||context._currentRenderer2===null||context._currentRenderer2===rendererSigil)?warningWithoutStack$1(false,'Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.'):void 0;context._currentRenderer2=rendererSigil;}}}function popProvider(providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);var context=providerFiber.type._context;if(isPrimaryRenderer){context._currentValue=currentValue;}else{context._currentValue2=currentValue;}}function calculateChangedBits(context,newValue,oldValue){if(is(oldValue,newValue)){// No change
return 0;}else{var changedBits=typeof context._calculateChangedBits==='function'?context._calculateChangedBits(oldValue,newValue):maxSigned31BitInt;{!((changedBits&maxSigned31BitInt)===changedBits)?warning$1(false,'calculateChangedBits: Expected the return value to be a '+'31-bit integer. Instead received: %s',changedBits):void 0;}return changedBits|0;}}function scheduleWorkOnParentPath(parent,renderExpirationTime){// Update the child expiration time of all the ancestors, including
// the alternates.
var node=parent;while(node!==null){var alternate=node.alternate;if(node.childExpirationTime<renderExpirationTime){node.childExpirationTime=renderExpirationTime;if(alternate!==null&&alternate.childExpirationTime<renderExpirationTime){alternate.childExpirationTime=renderExpirationTime;}}else if(alternate!==null&&alternate.childExpirationTime<renderExpirationTime){alternate.childExpirationTime=renderExpirationTime;}else{// Neither alternate was updated, which means the rest of the
// ancestor path already has sufficient priority.
break;}node=node.return;}}function propagateContextChange(workInProgress,context,changedBits,renderExpirationTime){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.
fiber.return=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.
var list=fiber.contextDependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.first;while(dependency!==null){// Check if the context matches.
if(dependency.context===context&&(dependency.observedBits&changedBits)!==0){// Match! Schedule an update on this fiber.
if(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.
var update=createUpdate(renderExpirationTime);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the
// update to the current fiber, too, which means it will persist even if
// this render is thrown away. Since it's a race condition, not sure it's
// worth fixing.
enqueueUpdate(fiber,update);}if(fiber.expirationTime<renderExpirationTime){fiber.expirationTime=renderExpirationTime;}var alternate=fiber.alternate;if(alternate!==null&&alternate.expirationTime<renderExpirationTime){alternate.expirationTime=renderExpirationTime;}scheduleWorkOnParentPath(fiber.return,renderExpirationTime);// Mark the expiration time on the list, too.
if(list.expirationTime<renderExpirationTime){list.expirationTime=renderExpirationTime;}// Since we already found a match, we can stop traversing the
// dependency list.
break;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider
nextFiber=fiber.type===workInProgress.type?null:fiber.child;}else if(enableSuspenseServerRenderer&&fiber.tag===DehydratedSuspenseComponent){// If a dehydrated suspense component is in this subtree, we don't know
// if it will have any context consumers in it. The best we can do is
// mark it as having updates on its children.
if(fiber.expirationTime<renderExpirationTime){fiber.expirationTime=renderExpirationTime;}var _alternate=fiber.alternate;if(_alternate!==null&&_alternate.expirationTime<renderExpirationTime){_alternate.expirationTime=renderExpirationTime;}// This is intentionally passing this fiber as the parent
// because we want to schedule this fiber as having work
// on its children. We'll use the childExpirationTime on
// this fiber to indicate that a context has changed.
scheduleWorkOnParentPath(fiber,renderExpirationTime);nextFiber=fiber.sibling;}else{// Traverse down.
nextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.
nextFiber.return=fiber;}else{// No child. Traverse to next sibling.
nextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.
nextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.
sibling.return=nextFiber.return;nextFiber=sibling;break;}// No more siblings. Traverse up.
nextFiber=nextFiber.return;}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderExpirationTime){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastContextWithAllBitsObserved=null;var currentDependencies=workInProgress.contextDependencies;if(currentDependencies!==null&&currentDependencies.expirationTime>=renderExpirationTime){// Context list has a pending update. Mark that this fiber performed work.
markWorkInProgressReceivedUpdate();}// Reset the work-in-progress list
workInProgress.contextDependencies=null;}function readContext(context,observedBits){{// This warning would fire if you read context inside a Hook like useMemo.
// Unlike the class check below, it's not enforced in production for perf.
!!isDisallowedContextReadInDEV?warning$1(false,'Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().'):void 0;}if(lastContextWithAllBitsObserved===context){// Nothing to do. We already observe everything in this context.
}else if(observedBits===false||observedBits===0){// Do not observe any updates.
}else{var resolvedObservedBits=void 0;// Avoid deopting on observable arguments or heterogeneous types.
if(typeof observedBits!=='number'||observedBits===maxSigned31BitInt){// Observe all updates.
lastContextWithAllBitsObserved=context;resolvedObservedBits=maxSigned31BitInt;}else{resolvedObservedBits=observedBits;}var contextItem={context:context,observedBits:resolvedObservedBits,next:null};if(lastContextDependency===null){!(currentlyRenderingFiber!==null)?invariant(false,'Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().'):void 0;// This is the first dependency for this component. Create a new list.
lastContextDependency=contextItem;currentlyRenderingFiber.contextDependencies={first:contextItem,expirationTime:NoWork};}else{// Append a new context item.
lastContextDependency=lastContextDependency.next=contextItem;}}return isPrimaryRenderer?context._currentValue:context._currentValue2;}// UpdateQueue is a linked list of prioritized updates.
//
// Like fibers, update queues come in pairs: a current queue, which represents
// the visible state of the screen, and a work-in-progress queue, which can be
// mutated and processed asynchronously before it is committed — a form of
// double buffering. If a work-in-progress render is discarded before finishing,
// we create a new work-in-progress by cloning the current queue.
//
// Both queues share a persistent, singly-linked list structure. To schedule an
// update, we append it to the end of both queues. Each queue maintains a
// pointer to first update in the persistent list that hasn't been processed.
// The work-in-progress pointer always has a position equal to or greater than
// the current queue, since we always work on that one. The current queue's
// pointer is only updated during the commit phase, when we swap in the
// work-in-progress.
//
// For example:
//
//   Current pointer:           A - B - C - D - E - F
//   Work-in-progress pointer:              D - E - F
//                                          ^
//                                          The work-in-progress queue has
//                                          processed more updates than current.
//
// The reason we append to both queues is because otherwise we might drop
// updates without ever processing them. For example, if we only add updates to
// the work-in-progress queue, some updates could be lost whenever a work-in
// -progress render restarts by cloning from current. Similarly, if we only add
// updates to the current queue, the updates will be lost whenever an already
// in-progress queue commits and swaps with the current queue. However, by
// adding to both queues, we guarantee that the update will be part of the next
// work-in-progress. (And because the work-in-progress queue becomes the
// current queue once it commits, there's no danger of applying the same
// update twice.)
//
// Prioritization
// --------------
//
// Updates are not sorted by priority, but by insertion; new updates are always
// appended to the end of the list.
//
// The priority is still important, though. When processing the update queue
// during the render phase, only the updates with sufficient priority are
// included in the result. If we skip an update because it has insufficient
// priority, it remains in the queue to be processed later, during a lower
// priority render. Crucially, all updates subsequent to a skipped update also
// remain in the queue *regardless of their priority*. That means high priority
// updates are sometimes processed twice, at two separate priorities. We also
// keep track of a base state, that represents the state before the first
// update in the queue is applied.
//
// For example:
//
//   Given a base state of '', and the following queue of updates
//
//     A1 - B2 - C1 - D2
//
//   where the number indicates the priority, and the update is applied to the
//   previous state by appending a letter, React will process these updates as
//   two separate renders, one per distinct priority level:
//
//   First render, at priority 1:
//     Base state: ''
//     Updates: [A1, C1]
//     Result state: 'AC'
//
//   Second render, at priority 2:
//     Base state: 'A'            <-  The base state does not include C1,
//                                    because B2 was skipped.
//     Updates: [B2, C1, D2]      <-  C1 was rebased on top of B2
//     Result state: 'ABCD'
//
// Because we process updates in insertion order, and rebase high priority
// updates when preceding updates are skipped, the final result is deterministic
// regardless of priority. Intermediate state may vary according to system
// resources, but the final state is always the same.
var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.
// It should only be read right after calling `processUpdateQueue`, via
// `checkHasForceUpdateAfterProcessing`.
var hasForceUpdate=false;var didWarnUpdateInsideUpdate=void 0;var currentlyProcessingQueue=void 0;var resetCurrentlyProcessingQueue=void 0;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;resetCurrentlyProcessingQueue=function(){currentlyProcessingQueue=null;};}function createUpdateQueue(baseState){var queue={baseState:baseState,firstUpdate:null,lastUpdate:null,firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null};return queue;}function cloneUpdateQueue(currentQueue){var queue={baseState:currentQueue.baseState,firstUpdate:currentQueue.firstUpdate,lastUpdate:currentQueue.lastUpdate,// TODO: With resuming, if we bail out and resuse the child tree, we should
// keep these effects.
firstCapturedUpdate:null,lastCapturedUpdate:null,firstEffect:null,lastEffect:null,firstCapturedEffect:null,lastCapturedEffect:null};return queue;}function createUpdate(expirationTime){return{expirationTime:expirationTime,tag:UpdateState,payload:null,callback:null,next:null,nextEffect:null};}function appendUpdateToQueue(queue,update){// Append the update to the end of the list.
if(queue.lastUpdate===null){// Queue is empty
queue.firstUpdate=queue.lastUpdate=update;}else{queue.lastUpdate.next=update;queue.lastUpdate=update;}}function enqueueUpdate(fiber,update){// Update queues are created lazily.
var alternate=fiber.alternate;var queue1=void 0;var queue2=void 0;if(alternate===null){// There's only one fiber.
queue1=fiber.updateQueue;queue2=null;if(queue1===null){queue1=fiber.updateQueue=createUpdateQueue(fiber.memoizedState);}}else{// There are two owners.
queue1=fiber.updateQueue;queue2=alternate.updateQueue;if(queue1===null){if(queue2===null){// Neither fiber has an update queue. Create new ones.
queue1=fiber.updateQueue=createUpdateQueue(fiber.memoizedState);queue2=alternate.updateQueue=createUpdateQueue(alternate.memoizedState);}else{// Only one fiber has an update queue. Clone to create a new one.
queue1=fiber.updateQueue=cloneUpdateQueue(queue2);}}else{if(queue2===null){// Only one fiber has an update queue. Clone to create a new one.
queue2=alternate.updateQueue=cloneUpdateQueue(queue1);}else{// Both owners have an update queue.
}}}if(queue2===null||queue1===queue2){// There's only a single queue.
appendUpdateToQueue(queue1,update);}else{// There are two queues. We need to append the update to both queues,
// while accounting for the persistent structure of the list — we don't
// want the same update to be added multiple times.
if(queue1.lastUpdate===null||queue2.lastUpdate===null){// One of the queues is not empty. We must add the update to both queues.
appendUpdateToQueue(queue1,update);appendUpdateToQueue(queue2,update);}else{// Both queues are non-empty. The last update is the same in both lists,
// because of structural sharing. So, only append to one of the lists.
appendUpdateToQueue(queue1,update);// But we still need to update the `lastUpdate` pointer of queue2.
queue2.lastUpdate=update;}}{if(fiber.tag===ClassComponent&&(currentlyProcessingQueue===queue1||queue2!==null&&currentlyProcessingQueue===queue2)&&!didWarnUpdateInsideUpdate){warningWithoutStack$1(false,'An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}}function enqueueCapturedUpdate(workInProgress,update){// Captured updates go into a separate list, and only on the work-in-
// progress queue.
var workInProgressQueue=workInProgress.updateQueue;if(workInProgressQueue===null){workInProgressQueue=workInProgress.updateQueue=createUpdateQueue(workInProgress.memoizedState);}else{// TODO: I put this here rather than createWorkInProgress so that we don't
// clone the queue unnecessarily. There's probably a better way to
// structure this.
workInProgressQueue=ensureWorkInProgressQueueIsAClone(workInProgress,workInProgressQueue);}// Append the update to the end of the list.
if(workInProgressQueue.lastCapturedUpdate===null){// This is the first render phase update
workInProgressQueue.firstCapturedUpdate=workInProgressQueue.lastCapturedUpdate=update;}else{workInProgressQueue.lastCapturedUpdate.next=update;workInProgressQueue.lastCapturedUpdate=update;}}function ensureWorkInProgressQueueIsAClone(workInProgress,queue){var current=workInProgress.alternate;if(current!==null){// If the work-in-progress queue is equal to the current queue,
// we need to clone it first.
if(queue===current.updateQueue){queue=workInProgress.updateQueue=cloneUpdateQueue(queue);}}return queue;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var _payload=update.payload;if(typeof _payload==='function'){// Updater function
{enterDisallowedContextReadInDEV();if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){_payload.call(instance,prevState,nextProps);}}var nextState=_payload.call(instance,prevState,nextProps);{exitDisallowedContextReadInDEV();}return nextState;}// State object
return _payload;}case CaptureUpdate:{workInProgress.effectTag=workInProgress.effectTag&~ShouldCapture|DidCapture;}// Intentional fallthrough
case UpdateState:{var _payload2=update.payload;var partialState=void 0;if(typeof _payload2==='function'){// Updater function
{enterDisallowedContextReadInDEV();if(debugRenderPhaseSideEffects||debugRenderPhaseSideEffectsForStrictMode&&workInProgress.mode&StrictMode){_payload2.call(instance,prevState,nextProps);}}partialState=_payload2.call(instance,prevState,nextProps);{exitDisallowedContextReadInDEV();}}else{// Partial state object
partialState=_payload2;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.
return prevState;}// Merge the partial state and the previous state.
return _assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,queue,props,instance,renderExpirationTime){hasForceUpdate=false;queue=ensureWorkInProgressQueueIsAClone(workInProgress,queue);{currentlyProcessingQueue=queue;}// These values may change as we process the queue.
var newBaseState=queue.baseState;var newFirstUpdate=null;var newExpirationTime=NoWork;// Iterate through the list of updates to compute the result.
var update=queue.firstUpdate;var resultState=newBaseState;while(update!==null){var updateExpirationTime=update.expirationTime;if(updateExpirationTime<renderExpirationTime){// This update does not have sufficient priority. Skip it.
if(newFirstUpdate===null){// This is the first skipped update. It will be the first update in
// the new list.
newFirstUpdate=update;// Since this is the first update that was skipped, the current result
// is the new base state.
newBaseState=resultState;}// Since this update will remain in the list, update the remaining
// expiration time.
if(newExpirationTime<updateExpirationTime){newExpirationTime=updateExpirationTime;}}else{// This update does have sufficient priority. Process it and compute
// a new result.
resultState=getStateFromUpdate(workInProgress,queue,update,resultState,props,instance);var _callback=update.callback;if(_callback!==null){workInProgress.effectTag|=Callback;// Set this to null, in case it was mutated during an aborted render.
update.nextEffect=null;if(queue.lastEffect===null){queue.firstEffect=queue.lastEffect=update;}else{queue.lastEffect.nextEffect=update;queue.lastEffect=update;}}}// Continue to the next update.
update=update.next;}// Separately, iterate though the list of captured updates.
var newFirstCapturedUpdate=null;update=queue.firstCapturedUpdate;while(update!==null){var _updateExpirationTime=update.expirationTime;if(_updateExpirationTime<renderExpirationTime){// This update does not have sufficient priority. Skip it.
if(newFirstCapturedUpdate===null){// This is the first skipped captured update. It will be the first
// update in the new list.
newFirstCapturedUpdate=update;// If this is the first update that was skipped, the current result is
// the new base state.
if(newFirstUpdate===null){newBaseState=resultState;}}// Since this update will remain in the list, update the remaining
// expiration time.
if(newExpirationTime<_updateExpirationTime){newExpirationTime=_updateExpirationTime;}}else{// This update does have sufficient priority. Process it and compute
// a new result.
resultState=getStateFromUpdate(workInProgress,queue,update,resultState,props,instance);var _callback2=update.callback;if(_callback2!==null){workInProgress.effectTag|=Callback;// Set this to null, in case it was mutated during an aborted render.
update.nextEffect=null;if(queue.lastCapturedEffect===null){queue.firstCapturedEffect=queue.lastCapturedEffect=update;}else{queue.lastCapturedEffect.nextEffect=update;queue.lastCapturedEffect=update;}}}update=update.next;}if(newFirstUpdate===null){queue.lastUpdate=null;}if(newFirstCapturedUpdate===null){queue.lastCapturedUpdate=null;}else{workInProgress.effectTag|=Callback;}if(newFirstUpdate===null&&newFirstCapturedUpdate===null){// We processed every update, without skipping. That means the new base
// state is the same as the result state.
newBaseState=resultState;}queue.baseState=newBaseState;queue.firstUpdate=newFirstUpdate;queue.firstCapturedUpdate=newFirstCapturedUpdate;// Set the remaining expiration time to be whatever is remaining in the queue.
// This should be fine because the only two other things that contribute to
// expiration time are props and context. We're already in the middle of the
// begin phase by the time we start processing the queue, so we've already
// dealt with the props. Context in components that specify
// shouldComponentUpdate is tricky; but we'll have to account for
// that regardless.
workInProgress.expirationTime=newExpirationTime;workInProgress.memoizedState=resultState;{currentlyProcessingQueue=null;}}function callCallback(callback,context){!(typeof callback==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',callback):void 0;callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance,renderExpirationTime){// If the finished render included captured updates, and there are still
// lower priority updates left over, we need to keep the captured updates
// in the queue so that they are rebased and not dropped once we process the
// queue again at the lower priority.
if(finishedQueue.firstCapturedUpdate!==null){// Join the captured update list to the end of the normal list.
if(finishedQueue.lastUpdate!==null){finishedQueue.lastUpdate.next=finishedQueue.firstCapturedUpdate;finishedQueue.lastUpdate=finishedQueue.lastCapturedUpdate;}// Clear the list of captured updates.
finishedQueue.firstCapturedUpdate=finishedQueue.lastCapturedUpdate=null;}// Commit the effects
commitUpdateEffects(finishedQueue.firstEffect,instance);finishedQueue.firstEffect=finishedQueue.lastEffect=null;commitUpdateEffects(finishedQueue.firstCapturedEffect,instance);finishedQueue.firstCapturedEffect=finishedQueue.lastCapturedEffect=null;}function commitUpdateEffects(effect,instance){while(effect!==null){var _callback3=effect.callback;if(_callback3!==null){effect.callback=null;callCallback(_callback3,instance);}effect=effect.nextEffect;}}function createCapturedValue(value,source){// If the value is an error, call this function immediately after it is thrown
// so the stack is accurate.
return{value:value,source:source,stack:getStackByFiberInDevAndProd(source)};}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
// a PlacementAndUpdate.
workInProgress.effectTag|=Update;}function markRef$1(workInProgress){workInProgress.effectTag|=Ref;}var appendAllChildren=void 0;var updateHostContainer=void 0;var updateHostComponent$1=void 0;var updateHostText$1=void 0;if(supportsMutation){// Mutation mode
appendAllChildren=function(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};updateHostContainer=function(workInProgress){// Noop
};updateHostComponent$1=function(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to
// schedule a side-effect to do the updates.
var oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because
// we won't touch this node even if children changed.
return;}// If we get updated because one of our children updated, we don't
// have newProps so we'll have to reuse them.
// TODO: Split the update API as separate for the props vs. children.
// Even better would be if children weren't special cased at all tho.
var instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host
// component is hitting the resume path. Figure out why. Possibly
// related to `hidden`.
var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.
workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update. All the work is done in commitWork.
if(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
if(oldText!==newText){markUpdate(workInProgress);}};}else if(supportsPersistence){// Persistent host tree mode
appendAllChildren=function(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){// eslint-disable-next-line no-labels
branches:if(node.tag===HostComponent){var instance=node.stateNode;if(needsVisibilityToggle){var props=node.memoizedProps;var type=node.type;if(isHidden){// This child is inside a timed out tree. Hide it.
instance=cloneHiddenInstance(instance,type,props,node);}else{// This child was previously inside a timed out tree. If it was not
// updated during this render, it may need to be unhidden. Clone
// again to be sure.
instance=cloneUnhiddenInstance(instance,type,props,node);}node.stateNode=instance;}appendInitialChild(parent,instance);}else if(node.tag===HostText){var _instance=node.stateNode;if(needsVisibilityToggle){var text=node.memoizedProps;var rootContainerInstance=getRootHostContainer();var currentHostContext=getHostContext();if(isHidden){_instance=createHiddenTextInstance(text,rootContainerInstance,currentHostContext,workInProgress);}else{_instance=createTextInstance(text,rootContainerInstance,currentHostContext,workInProgress);}node.stateNode=_instance;}appendInitialChild(parent,_instance);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.tag===SuspenseComponent){var current=node.alternate;if(current!==null){var oldState=current.memoizedState;var newState=node.memoizedState;var oldIsHidden=oldState!==null;var newIsHidden=newState!==null;if(oldIsHidden!==newIsHidden){// The placeholder either just timed out or switched back to the normal
// children after having previously timed out. Toggle the visibility of
// the direct host children.
var primaryChildParent=newIsHidden?node.child:node;if(primaryChildParent!==null){appendAllChildren(parent,primaryChildParent,true,newIsHidden);}// eslint-disable-next-line no-labels
break branches;}}if(node.child!==null){// Continue traversing like normal
node.child.return=node;node=node.child;continue;}}else if(node.child!==null){node.child.return=node;node=node.child;continue;}// $FlowFixMe This is correct but Flow is confused by the labeled break.
node=node;if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};// An unfortunate fork of appendAllChildren because we have two different parent types.
var appendAllChildrenToContainer=function(containerChildSet,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){// eslint-disable-next-line no-labels
branches:if(node.tag===HostComponent){var instance=node.stateNode;if(needsVisibilityToggle){var props=node.memoizedProps;var type=node.type;if(isHidden){// This child is inside a timed out tree. Hide it.
instance=cloneHiddenInstance(instance,type,props,node);}else{// This child was previously inside a timed out tree. If it was not
// updated during this render, it may need to be unhidden. Clone
// again to be sure.
instance=cloneUnhiddenInstance(instance,type,props,node);}node.stateNode=instance;}appendChildToContainerChildSet(containerChildSet,instance);}else if(node.tag===HostText){var _instance2=node.stateNode;if(needsVisibilityToggle){var text=node.memoizedProps;var rootContainerInstance=getRootHostContainer();var currentHostContext=getHostContext();if(isHidden){_instance2=createHiddenTextInstance(text,rootContainerInstance,currentHostContext,workInProgress);}else{_instance2=createTextInstance(text,rootContainerInstance,currentHostContext,workInProgress);}node.stateNode=_instance2;}appendChildToContainerChildSet(containerChildSet,_instance2);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.tag===SuspenseComponent){var current=node.alternate;if(current!==null){var oldState=current.memoizedState;var newState=node.memoizedState;var oldIsHidden=oldState!==null;var newIsHidden=newState!==null;if(oldIsHidden!==newIsHidden){// The placeholder either just timed out or switched back to the normal
// children after having previously timed out. Toggle the visibility of
// the direct host children.
var primaryChildParent=newIsHidden?node.child:node;if(primaryChildParent!==null){appendAllChildrenToContainer(containerChildSet,primaryChildParent,true,newIsHidden);}// eslint-disable-next-line no-labels
break branches;}}if(node.child!==null){// Continue traversing like normal
node.child.return=node;node=node.child;continue;}}else if(node.child!==null){node.child.return=node;node=node.child;continue;}// $FlowFixMe This is correct but Flow is confused by the labeled break.
node=node;if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};updateHostContainer=function(workInProgress){var portalOrRoot=workInProgress.stateNode;var childrenUnchanged=workInProgress.firstEffect===null;if(childrenUnchanged){// No changes, just reuse the existing instance.
}else{var container=portalOrRoot.containerInfo;var newChildSet=createContainerChildSet(container);// If children might have changed, we have to add them all to the set.
appendAllChildrenToContainer(newChildSet,workInProgress,false,false);portalOrRoot.pendingChildren=newChildSet;// Schedule an update on the container to swap out the container.
markUpdate(workInProgress);finalizeContainerChildren(container,newChildSet);}};updateHostComponent$1=function(current,workInProgress,type,newProps,rootContainerInstance){var currentInstance=current.stateNode;var oldProps=current.memoizedProps;// If there are no effects associated with this node, then none of our children had any updates.
// This guarantees that we can reuse all of them.
var childrenUnchanged=workInProgress.firstEffect===null;if(childrenUnchanged&&oldProps===newProps){// No changes, just reuse the existing instance.
// Note that this might release a previous clone.
workInProgress.stateNode=currentInstance;return;}var recyclableInstance=workInProgress.stateNode;var currentHostContext=getHostContext();var updatePayload=null;if(oldProps!==newProps){updatePayload=prepareUpdate(recyclableInstance,type,oldProps,newProps,rootContainerInstance,currentHostContext);}if(childrenUnchanged&&updatePayload===null){// No changes, just reuse the existing instance.
// Note that this might release a previous clone.
workInProgress.stateNode=currentInstance;return;}var newInstance=cloneInstance(currentInstance,updatePayload,type,oldProps,newProps,workInProgress,childrenUnchanged,recyclableInstance);if(finalizeInitialChildren(newInstance,type,newProps,rootContainerInstance,currentHostContext)){markUpdate(workInProgress);}workInProgress.stateNode=newInstance;if(childrenUnchanged){// If there are no other effects in this tree, we need to flag this node as having one.
// Even though we're not going to use it for anything.
// Otherwise parents won't know that there are new children to propagate upwards.
markUpdate(workInProgress);}else{// If children might have changed, we have to add them all to the set.
appendAllChildren(newInstance,workInProgress,false,false);}};updateHostText$1=function(current,workInProgress,oldText,newText){if(oldText!==newText){// If the text content differs, we'll create a new text instance for it.
var rootContainerInstance=getRootHostContainer();var currentHostContext=getHostContext();workInProgress.stateNode=createTextInstance(newText,rootContainerInstance,currentHostContext,workInProgress);// We'll have to mark it as having an effect, even though we won't use the effect for anything.
// This lets the parents know that at least one of their children has changed.
markUpdate(workInProgress);}};}else{// No host operations
updateHostContainer=function(workInProgress){// Noop
};updateHostComponent$1=function(current,workInProgress,type,newProps,rootContainerInstance){// Noop
};updateHostText$1=function(current,workInProgress,oldText,newText){// Noop
};}function completeWork(current,workInProgress,renderExpirationTime){var newProps=workInProgress.pendingProps;switch(workInProgress.tag){case IndeterminateComponent:break;case LazyComponent:break;case SimpleMemoComponent:case FunctionComponent:break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}break;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var fiberRoot=workInProgress.stateNode;if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
// that weren't hydrated.
popHydrationState(workInProgress);// This resets the hacky state to fix isMounted before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag&=~Placement;}updateHostContainer(workInProgress);break;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else{if(!newProps){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
break;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
// "stack" as the parent. Then append children as we go in beginWork
// or completeWork depending on we want to add then top->down or
// bottom->up. Top->down is faster in IE11.
var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// TODO: Move this and createInstance step into the beginPhase
// to consolidate.
if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node needs to be applied at the
// commit-phase we mark this as such.
markUpdate(workInProgress);}}else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if(finalizeInitialChildren(instance,type,newProps,rootContainerInstance,currentHostContext)){markUpdate(workInProgress);}workInProgress.stateNode=instance;}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
markRef$1(workInProgress);}}break;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
// to schedule a side-effect to do the updates.
updateHostText$1(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}break;}case ForwardRef:break;case SuspenseComponent:{var nextState=workInProgress.memoizedState;if((workInProgress.effectTag&DidCapture)!==NoEffect){// Something suspended. Re-render with the fallback children.
workInProgress.expirationTime=renderExpirationTime;// Do not reset the effect list.
return workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=current!==null&&current.memoizedState!==null;if(current!==null&&!nextDidTimeout&&prevDidTimeout){// We just switched from the fallback to the normal children. Delete
// the fallback.
// TODO: Would it be better to store the fallback fragment on
var currentFallbackChild=current.child.sibling;if(currentFallbackChild!==null){// Deletions go at the beginning of the return fiber's effect list
var first=workInProgress.firstEffect;if(first!==null){workInProgress.firstEffect=currentFallbackChild;currentFallbackChild.nextEffect=first;}else{workInProgress.firstEffect=workInProgress.lastEffect=currentFallbackChild;currentFallbackChild.nextEffect=null;}currentFallbackChild.effectTag=Deletion;}}if(nextDidTimeout||prevDidTimeout){// If the children are hidden, or if they were previous hidden, schedule
// an effect to toggle their visibility. This is also used to attach a
// retry listener to the promise.
workInProgress.effectTag|=Update;}break;}case Fragment:break;case Mode:break;case Profiler:break;case HostPortal:popHostContainer(workInProgress);updateHostContainer(workInProgress);break;case ContextProvider:// Pop provider fiber
popProvider(workInProgress);break;case ContextConsumer:break;case MemoComponent:break;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are
// sequential to ensure this switch is compiled to a jump table.
var _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}break;}case DehydratedSuspenseComponent:{if(enableSuspenseServerRenderer){if(current===null){var _wasHydrated2=popHydrationState(workInProgress);!_wasHydrated2?invariant(false,'A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.'):void 0;skipPastDehydratedSuspenseInstance(workInProgress);}else if((workInProgress.effectTag&DidCapture)===NoEffect){// This boundary did not suspend so it's now hydrated.
// To handle any future suspense cases, we're going to now upgrade it
// to a Suspense component. We detach it from the existing current fiber.
current.alternate=null;workInProgress.alternate=null;workInProgress.tag=SuspenseComponent;workInProgress.memoizedState=null;workInProgress.stateNode=null;}}break;}default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}return null;}function shouldCaptureSuspense(workInProgress){// In order to capture, the Suspense component must have a fallback prop.
if(workInProgress.memoizedProps.fallback===undefined){return false;}// If it was the primary children that just suspended, capture and render the
// fallback. Otherwise, don't capture and bubble to the next boundary.
var nextState=workInProgress.memoizedState;return nextState===null;}// This module is forked in different environments.
// By default, return `true` to log errors to the console.
// Forks can return `false` if this isn't desirable.
function showErrorDialog(capturedError){return true;}function logCapturedError(capturedError){var logError=showErrorDialog(capturedError);// Allow injected showErrorDialog() to prevent default console.error logging.
// This enables renderers like ReactNative to better manage redbox behavior.
if(logError===false){return;}var error=capturedError.error;{var componentName=capturedError.componentName,componentStack=capturedError.componentStack,errorBoundaryName=capturedError.errorBoundaryName,errorBoundaryFound=capturedError.errorBoundaryFound,willRetry=capturedError.willRetry;// Browsers support silencing uncaught errors by calling
// `preventDefault()` in window `error` handler.
// We record this information as an expando on the error.
if(error!=null&&error._suppressLogging){if(errorBoundaryFound&&willRetry){// The error is recoverable and was silenced.
// Ignore it and don't print the stack addendum.
// This is handy for testing error boundaries without noise.
return;}// The error is fatal. Since the silencing might have
// been accidental, we'll surface it anyway.
// However, the browser would have silenced the original error
// so we'll print it first, and then print the stack addendum.
console.error(error);// For a more detailed description of this block, see:
// https://github.com/facebook/react/pull/13384
}var componentNameMessage=componentName?'The above error occurred in the <'+componentName+'> component:':'The above error occurred in one of your React components:';var errorBoundaryMessage=void 0;// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
if(errorBoundaryFound&&errorBoundaryName){if(willRetry){errorBoundaryMessage='React will try to recreate this component tree from scratch '+('using the error boundary you provided, '+errorBoundaryName+'.');}else{errorBoundaryMessage='This error was initially handled by the error boundary '+errorBoundaryName+'.\n'+'Recreating the tree from scratch failed so React will unmount the tree.';}}else{errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';}var combinedMessage=''+componentNameMessage+componentStack+'\n\n'+(''+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
// We don't include the original error message and JS stack because the browser
// has already printed it. Even if the application swallows the error, it is still
// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
console.error(combinedMessage);}}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}var PossiblyWeakSet$1=typeof WeakSet==='function'?WeakSet:Set;function logError(boundary,errorInfo){var source=errorInfo.source;var stack=errorInfo.stack;if(stack===null&&source!==null){stack=getStackByFiberInDevAndProd(source);}var capturedError={componentName:source!==null?getComponentName(source.type):null,componentStack:stack!==null?stack:'',error:errorInfo.value,errorBoundary:null,errorBoundaryName:null,errorBoundaryFound:false,willRetry:false};if(boundary!==null&&boundary.tag===ClassComponent){capturedError.errorBoundary=boundary.stateNode;capturedError.errorBoundaryName=getComponentName(boundary.type);capturedError.errorBoundaryFound=true;capturedError.willRetry=true;}try{logCapturedError(capturedError);}catch(e){// This method must not throw, or React internal state will get messed up.
// If console.error is overridden, or logCapturedError() shows a dialog that throws,
// we want to report this error outside of the normal stack as a last resort.
// https://github.com/facebook/react/issues/13188
setTimeout(function(){throw e;});}}var callComponentWillUnmountWithTimer=function(current$$1,instance){startPhaseTimer(current$$1,'componentWillUnmount');instance.props=current$$1.memoizedProps;instance.state=current$$1.memoizedState;instance.componentWillUnmount();stopPhaseTimer();};// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current$$1,instance){{invokeGuardedCallback(null,callComponentWillUnmountWithTimer,null,current$$1,instance);if(hasCaughtError()){var unmountError=clearCaughtError();captureCommitPhaseError(current$$1,unmountError);}}}function safelyDetachRef(current$$1){var ref=current$$1.ref;if(ref!==null){if(typeof ref==='function'){{invokeGuardedCallback(null,ref,null,null);if(hasCaughtError()){var refError=clearCaughtError();captureCommitPhaseError(current$$1,refError);}}}else{ref.current=null;}}}function safelyCallDestroy(current$$1,destroy){{invokeGuardedCallback(null,destroy,null);if(hasCaughtError()){var error=clearCaughtError();captureCommitPhaseError(current$$1,error);}}}function commitBeforeMutationLifeCycles(current$$1,finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{commitHookEffectList(UnmountSnapshot,NoEffect$1,finishedWork);return;}case ClassComponent:{if(finishedWork.effectTag&Snapshot){if(current$$1!==null){var prevProps=current$$1.memoizedProps;var prevState=current$$1.memoizedState;startPhaseTimer(finishedWork,'getSnapshotBeforeUpdate');var instance=finishedWork.stateNode;// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){!(instance.props===finishedWork.memoizedProps)?warning$1(false,'Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance'):void 0;!(instance.state===finishedWork.memoizedState)?warning$1(false,'Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance'):void 0;}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);warningWithoutStack$1(false,'%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentName(finishedWork.type));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;stopPhaseTimer();}}return;}case HostRoot:case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types
return;default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitHookEffectList(unmountTag,mountTag,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&unmountTag)!==NoEffect$1){// Unmount
var destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){destroy();}}if((effect.tag&mountTag)!==NoEffect$1){// Mount
var create=effect.create;effect.destroy=create();{var _destroy=effect.destroy;if(_destroy!==undefined&&typeof _destroy!=='function'){var addendum=void 0;if(_destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof _destroy.then==='function'){addendum='\n\nIt looks like you wrote useEffect(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\n\n'+'useEffect(() => {\n'+'  async function fetchData() {\n'+'    // You can await here\n'+'    const response = await MyAPI.getData(someId);\n'+'    // ...\n'+'  }\n'+'  fetchData();\n'+'}, [someId]); // Or [] if effect doesn\'t need props or state\n\n'+'Learn more about data fetching with Hooks: https://fb.me/react-hooks-data-fetching';}else{addendum=' You returned: '+_destroy;}warningWithoutStack$1(false,'An effect function must not return anything besides a function, '+'which is used for clean-up.%s%s',addendum,getStackByFiberInDevAndProd(finishedWork));}}}effect=effect.next;}while(effect!==firstEffect);}}function commitPassiveHookEffects(finishedWork){commitHookEffectList(UnmountPassive,NoEffect$1,finishedWork);commitHookEffectList(NoEffect$1,MountPassive,finishedWork);}function commitLifeCycles(finishedRoot,current$$1,finishedWork,committedExpirationTime){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{commitHookEffectList(UnmountLayout,MountLayout,finishedWork);break;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.effectTag&Update){if(current$$1===null){startPhaseTimer(finishedWork,'componentDidMount');// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){!(instance.props===finishedWork.memoizedProps)?warning$1(false,'Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance'):void 0;!(instance.state===finishedWork.memoizedState)?warning$1(false,'Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance'):void 0;}}instance.componentDidMount();stopPhaseTimer();}else{var prevProps=finishedWork.elementType===finishedWork.type?current$$1.memoizedProps:resolveDefaultProps(finishedWork.type,current$$1.memoizedProps);var prevState=current$$1.memoizedState;startPhaseTimer(finishedWork,'componentDidUpdate');// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){!(instance.props===finishedWork.memoizedProps)?warning$1(false,'Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance'):void 0;!(instance.state===finishedWork.memoizedState)?warning$1(false,'Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance'):void 0;}}instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);stopPhaseTimer();}}var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){!(instance.props===finishedWork.memoizedProps)?warning$1(false,'Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance'):void 0;!(instance.state===finishedWork.memoizedState)?warning$1(false,'Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentName(finishedWork.type)||'instance'):void 0;}}// We could update instance props and state here,
// but instead we rely on them being set during last render.
// TODO: revisit this when we implement resuming.
commitUpdateQueue(finishedWork,updateQueue,instance,committedExpirationTime);}return;}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance,committedExpirationTime);}return;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
// (eg DOM renderer may schedule auto-focus for inputs and form controls).
// These effects should only be committed when components are first mounted,
// aka when there is no current/alternate.
if(current$$1===null&&finishedWork.effectTag&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props,finishedWork);}return;}case HostText:{// We have no life-cycles associated with text.
return;}case HostPortal:{// We have no life-cycles associated with portals.
return;}case Profiler:{if(enableProfilerTimer){var onRender=finishedWork.memoizedProps.onRender;if(enableSchedulerTracing){onRender(finishedWork.memoizedProps.id,current$$1===null?'mount':'update',finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,getCommitTime(),finishedRoot.memoizedInteractions);}else{onRender(finishedWork.memoizedProps.id,current$$1===null?'mount':'update',finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,getCommitTime());}}return;}case SuspenseComponent:break;case IncompleteClassComponent:break;default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function hideOrUnhideAllChildren(finishedWork,isHidden){if(supportsMutation){// We only have the top Fiber that was inserted but we need to recurse down its
var node=finishedWork;while(true){if(node.tag===HostComponent){var instance=node.stateNode;if(isHidden){hideInstance(instance);}else{unhideInstance(node.stateNode,node.memoizedProps);}}else if(node.tag===HostText){var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else{unhideTextInstance(_instance3,node.memoizedProps);}}else if(node.tag===SuspenseComponent&&node.memoizedState!==null){// Found a nested Suspense component that timed out. Skip over the
var fallbackChildFragment=node.child.sibling;fallbackChildFragment.return=node;node=fallbackChildFragment;continue;}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse=void 0;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}if(typeof ref==='function'){ref(instanceToUse);}else{{if(!ref.hasOwnProperty('current')){warningWithoutStack$1(false,'Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().%s',getComponentName(finishedWork.type),getStackByFiberInDevAndProd(finishedWork));}}ref.current=instanceToUse;}}}function commitDetachRef(current$$1){var currentRef=current$$1.ref;if(currentRef!==null){if(typeof currentRef==='function'){currentRef(null);}else{currentRef.current=null;}}}// User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay
function commitUnmount(current$$1){onCommitUnmount(current$$1);switch(current$$1.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{var updateQueue=current$$1.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var destroy=effect.destroy;if(destroy!==undefined){safelyCallDestroy(current$$1,destroy);}effect=effect.next;}while(effect!==firstEffect);}}break;}case ClassComponent:{safelyDetachRef(current$$1);var instance=current$$1.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current$$1,instance);}return;}case HostComponent:{safelyDetachRef(current$$1);return;}case HostPortal:{// TODO: this is recursive.
// We are also not using this parent because
// the portal will get pushed immediately.
if(supportsMutation){unmountHostComponents(current$$1);}else if(supportsPersistence){emptyPortalContainer(current$$1);}return;}}}function commitNestedUnmounts(root){// While we're inside a removed host node we don't want to call
// removeChild on the inner nodes because they're removed by the top
// call anyway. We also want to call componentWillUnmount on all
// composites before this host node is removed from the tree. Therefore
var node=root;while(true){commitUnmount(node);// Visit children because they may contain more composite or host nodes.
// Skip portals because commitUnmount() currently visits them recursively.
if(node.child!==null&&(// If we use mutation we drill down into portals using commitUnmount above.
// If we don't use mutation we drill down into portals here instead.
!supportsMutation||node.tag!==HostPortal)){node.child.return=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node.return===null||node.return===root){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function detachFiber(current$$1){// Cut off the return pointers to disconnect it from the tree. Ideally, we
// should clear the child pointer of the parent alternate to let this
// get GC:ed but we don't know which for sure which parent is the current
// one so we'll settle for GC:ing the subtree of this child. This child
// itself will be GC:ed when the parent updates the next time.
current$$1.return=null;current$$1.child=null;current$$1.memoizedState=null;current$$1.updateQueue=null;var alternate=current$$1.alternate;if(alternate!==null){alternate.return=null;alternate.child=null;alternate.memoizedState=null;alternate.updateQueue=null;}}function emptyPortalContainer(current$$1){if(!supportsPersistence){return;}var portal=current$$1.stateNode;var containerInfo=portal.containerInfo;var emptyChildSet=createContainerChildSet(containerInfo);replaceContainerChildren(containerInfo,emptyChildSet);}function commitContainer(finishedWork){if(!supportsPersistence){return;}switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{return;}case HostText:{return;}case HostRoot:case HostPortal:{var portalOrRoot=finishedWork.stateNode;var containerInfo=portalOrRoot.containerInfo,_pendingChildren=portalOrRoot.pendingChildren;replaceContainerChildren(containerInfo,_pendingChildren);return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function getHostParentFiber(fiber){var parent=fiber.return;while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent.return;}invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
// node. Unfortunately, if multiple insertions are done in a row we have to
// search past them. This leads to exponential search for the next sibling.
var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
while(node.sibling===null){if(node.return===null||isHostParent(node.return)){// If we pop out of the root or hit the parent the fiber we are the
// last sibling.
return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedSuspenseComponent){// If it is not host node and, we might have a host node inside it.
// Try to search down until we find one.
if(node.effectTag&Placement){// If we don't have a child, try the siblings instead.
continue siblings;}// If we don't have a child, try the siblings instead.
// We also skip portals because they are not part of this host tree.
if(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child.return=node;node=node.child;}}// Check if this host node is stable or about to be placed.
if(!(node.effectTag&Placement)){// Found it!
return node.stateNode;}}}function commitPlacement(finishedWork){if(!supportsMutation){return;}// Recursively insert all host nodes into the parent.
var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.
var parent=void 0;var isContainer=void 0;switch(parentFiber.tag){case HostComponent:parent=parentFiber.stateNode;isContainer=false;break;case HostRoot:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;case HostPortal:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;default:invariant(false,'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');}if(parentFiber.effectTag&ContentReset){// Reset the text content of the parent before doing any insertions
resetTextContent(parent);// Clear ContentReset from the effect tag
parentFiber.effectTag&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its
// children to find all the terminal nodes.
var node=finishedWork;while(true){if(node.tag===HostComponent||node.tag===HostText){if(before){if(isContainer){insertInContainerBefore(parent,node.stateNode,before);}else{insertBefore(parent,node.stateNode,before);}}else{if(isContainer){appendChildToContainer(parent,node.stateNode);}else{appendChild(parent,node.stateNode);}}}else if(node.tag===HostPortal){// If the insertion itself is a portal, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function unmountHostComponents(current$$1){// We only have the top Fiber that was deleted but we need to recurse down its
var node=current$$1;// Each iteration, currentParent is populated with node's host parent if not
// currentParentIsValid.
var currentParentIsValid=false;// Note: these two variables *must* always be updated together.
var currentParent=void 0;var currentParentIsContainer=void 0;while(true){if(!currentParentIsValid){var parent=node.return;findParent:while(true){!(parent!==null)?invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(parent.tag){case HostComponent:currentParent=parent.stateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent.return;}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(node);// After all the children have unmounted, it is now safe to remove the
// node from the tree.
if(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else{removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.
}else if(enableSuspenseServerRenderer&&node.tag===DehydratedSuspenseComponent){// Delete the dehydrated suspense boundary and all of its content.
if(currentParentIsContainer){clearSuspenseBoundaryFromContainer(currentParent,node.stateNode);}else{clearSuspenseBoundary(currentParent,node.stateNode);}}else if(node.tag===HostPortal){if(node.child!==null){// When we go into a portal, it becomes the parent to remove from.
// We will reassign it back when we pop the portal on the way up.
currentParent=node.stateNode.containerInfo;currentParentIsContainer=true;// Visit children because portals might contain host components.
node.child.return=node;node=node.child;continue;}}else{commitUnmount(node);// Visit children because we may find more host components below.
if(node.child!==null){node.child.return=node;node=node.child;continue;}}if(node===current$$1){return;}while(node.sibling===null){if(node.return===null||node.return===current$$1){return;}node=node.return;if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.
// Since we don't keep a stack of them, we will search for it.
currentParentIsValid=false;}}node.sibling.return=node.return;node=node.sibling;}}function commitDeletion(current$$1){if(supportsMutation){// Recursively delete all host nodes from the parent.
// Detach refs and call componentWillUnmount() on the whole subtree.
unmountHostComponents(current$$1);}else{// Detach refs and call componentWillUnmount() on the whole subtree.
commitNestedUnmounts(current$$1);}detachFiber(current$$1);}function commitWork(current$$1,finishedWork){if(!supportsMutation){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{// Note: We currently never use MountMutation, but useLayout uses
// UnmountMutation.
commitHookEffectList(UnmountMutation,MountMutation,finishedWork);return;}}commitContainer(finishedWork);return;}switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{// Note: We currently never use MountMutation, but useLayout uses
// UnmountMutation.
commitHookEffectList(UnmountMutation,MountMutation,finishedWork);return;}case ClassComponent:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.
var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldProps=current$$1!==null?current$$1.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps,finishedWork);}}return;}case HostText:{!(finishedWork.stateNode!==null)?invariant(false,'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'):void 0;var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldText=current$$1!==null?current$$1.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{return;}case Profiler:{return;}case SuspenseComponent:{var newState=finishedWork.memoizedState;var newDidTimeout=void 0;var primaryChildParent=finishedWork;if(newState===null){newDidTimeout=false;}else{newDidTimeout=true;primaryChildParent=finishedWork.child;if(newState.timedOutAt===NoWork){// If the children had not already timed out, record the time.
// This is used to compute the elapsed time during subsequent
// attempts to render the children.
newState.timedOutAt=requestCurrentTime();}}if(primaryChildParent!==null){hideOrUnhideAllChildren(primaryChildParent,newDidTimeout);}// If this boundary just timed out, then it will have a set of thenables.
// For each thenable, attach a listener so that when it resolves, React
// attempts to re-render the boundary in the primary (pre-timeout) state.
var thenables=finishedWork.updateQueue;if(thenables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet$1();}thenables.forEach(function(thenable){// Memoize using the boundary fiber to prevent redundant listeners.
var retry=retryTimedOutBoundary.bind(null,finishedWork,thenable);if(enableSchedulerTracing){retry=tracing.unstable_wrap(retry);}if(!retryCache.has(thenable)){retryCache.add(thenable);thenable.then(retry,retry);}});}return;}case IncompleteClassComponent:{return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitResetTextContent(current$$1){if(!supportsMutation){return;}resetTextContent(current$$1.stateNode);}var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,expirationTime){var update=createUpdate(expirationTime);// Unmount the root by rendering null.
update.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property
// being called "element".
update.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,expirationTime){var update=createUpdate(expirationTime);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,
// we keep track of which ones already failed during this batch.
// This gets reset before we yield back to the browser.
// TODO: Warn in strict mode if getDerivedStateFromError is
// not defined.
markLegacyErrorBoundaryAsFailed(this);}var error=errorInfo.value;var stack=errorInfo.stack;logError(fiber,errorInfo);this.componentDidCatch(error,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,
// then it needs to call setState to recover from errors.
// If no state update is scheduled then the boundary will swallow the error.
!(fiber.expirationTime===Sync)?warningWithoutStack$1(false,'%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentName(fiber.type)||'Unknown'):void 0;}}};}return update;}function attachPingListener(root,renderExpirationTime,thenable){// Attach a listener to the promise to "ping" the root and retry. But
// only if one does not already exist for the current render expiration
// time (which acts like a "thread ID" here).
var pingCache=root.pingCache;var threadIDs=void 0;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap();threadIDs=new Set();pingCache.set(thenable,threadIDs);}else{threadIDs=pingCache.get(thenable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(thenable,threadIDs);}}if(!threadIDs.has(renderExpirationTime)){// Memoize using the thread ID to prevent redundant listeners.
threadIDs.add(renderExpirationTime);var ping=pingSuspendedRoot.bind(null,root,thenable,renderExpirationTime);if(enableSchedulerTracing){ping=tracing.unstable_wrap(ping);}thenable.then(ping,ping);}}function throwException(root,returnFiber,sourceFiber,value,renderExpirationTime){// The source fiber did not complete.
sourceFiber.effectTag|=Incomplete;// Its effect list is no longer valid.
sourceFiber.firstEffect=sourceFiber.lastEffect=null;if(value!==null&&typeof value==='object'&&typeof value.then==='function'){// This is a thenable.
var thenable=value;// Find the earliest timeout threshold of all the placeholders in the
// ancestor path. We could avoid this traversal by storing the thresholds on
// the stack, but we choose not to because we only hit this path if we're
// IO-bound (i.e. if something suspends). Whereas the stack is used even in
// the non-IO- bound case.
var _workInProgress=returnFiber;var earliestTimeoutMs=-1;var startTimeMs=-1;do{if(_workInProgress.tag===SuspenseComponent){var current$$1=_workInProgress.alternate;if(current$$1!==null){var currentState=current$$1.memoizedState;if(currentState!==null){// Reached a boundary that already timed out. Do not search
// any further.
var timedOutAt=currentState.timedOutAt;startTimeMs=expirationTimeToMs(timedOutAt);// Do not search any further.
break;}}var timeoutPropMs=_workInProgress.pendingProps.maxDuration;if(typeof timeoutPropMs==='number'){if(timeoutPropMs<=0){earliestTimeoutMs=0;}else if(earliestTimeoutMs===-1||timeoutPropMs<earliestTimeoutMs){earliestTimeoutMs=timeoutPropMs;}}}// If there is a DehydratedSuspenseComponent we don't have to do anything because
// if something suspends inside it, we will simply leave that as dehydrated. It
// will never timeout.
_workInProgress=_workInProgress.return;}while(_workInProgress!==null);// Schedule the nearest Suspense to re-render the timed out view.
_workInProgress=returnFiber;do{if(_workInProgress.tag===SuspenseComponent&&shouldCaptureSuspense(_workInProgress)){// Found the nearest boundary.
// Stash the promise on the boundary fiber. If the boundary times out, we'll
var thenables=_workInProgress.updateQueue;if(thenables===null){var updateQueue=new Set();updateQueue.add(thenable);_workInProgress.updateQueue=updateQueue;}else{thenables.add(thenable);}// If the boundary is outside of concurrent mode, we should *not*
// suspend the commit. Pretend as if the suspended component rendered
// null and keep rendering. In the commit phase, we'll schedule a
// subsequent synchronous update to re-render the Suspense.
//
// Note: It doesn't matter whether the component that suspended was
// inside a concurrent mode tree. If the Suspense is outside of it, we
// should *not* suspend the commit.
if((_workInProgress.mode&ConcurrentMode)===NoEffect){_workInProgress.effectTag|=DidCapture;// We're going to commit this fiber even though it didn't complete.
// But we shouldn't call any lifecycle methods or callbacks. Remove
// all lifecycle effect tags.
sourceFiber.effectTag&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a
// completed class component. For example, we should not call
// componentWillUnmount if it is deleted.
sourceFiber.tag=IncompleteClassComponent;}else{// When we try rendering again, we should not reuse the current fiber,
// since it's known to be in an inconsistent state. Use a force updte to
// prevent a bail out.
var update=createUpdate(Sync);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update);}}// The source fiber did not complete. Mark it with Sync priority to
// indicate that it still has pending work.
sourceFiber.expirationTime=Sync;// Exit without suspending.
return;}// Confirmed that the boundary is in a concurrent mode tree. Continue
// with the normal suspend path.
attachPingListener(root,renderExpirationTime,thenable);var absoluteTimeoutMs=void 0;if(earliestTimeoutMs===-1){// If no explicit threshold is given, default to an arbitrarily large
// value. The actual size doesn't matter because the threshold for the
// whole tree will be clamped to the expiration time.
absoluteTimeoutMs=maxSigned31BitInt;}else{if(startTimeMs===-1){// This suspend happened outside of any already timed-out
// placeholders. We don't know exactly when the update was
// scheduled, but we can infer an approximate start time from the
// expiration time. First, find the earliest uncommitted expiration
// time in the tree, including work that is suspended. Then subtract
// the offset used to compute an async update's expiration time.
// This will cause high priority (interactive) work to expire
// earlier than necessary, but we can account for this by adjusting
// for the Just Noticeable Difference.
var earliestExpirationTime=findEarliestOutstandingPriorityLevel(root,renderExpirationTime);var earliestExpirationTimeMs=expirationTimeToMs(earliestExpirationTime);startTimeMs=earliestExpirationTimeMs-LOW_PRIORITY_EXPIRATION;}absoluteTimeoutMs=startTimeMs+earliestTimeoutMs;}// Mark the earliest timeout in the suspended fiber's ancestor path.
// After completing the root, we'll take the largest of all the
// suspended fiber's timeouts and use it to compute a timeout for the
// whole tree.
renderDidSuspend(root,absoluteTimeoutMs,renderExpirationTime);_workInProgress.effectTag|=ShouldCapture;_workInProgress.expirationTime=renderExpirationTime;return;}else if(enableSuspenseServerRenderer&&_workInProgress.tag===DehydratedSuspenseComponent){attachPingListener(root,renderExpirationTime,thenable);// Since we already have a current fiber, we can eagerly add a retry listener.
var retryCache=_workInProgress.memoizedState;if(retryCache===null){retryCache=_workInProgress.memoizedState=new PossiblyWeakSet();var _current=_workInProgress.alternate;!_current?invariant(false,'A dehydrated suspense boundary must commit before trying to render. This is probably a bug in React.'):void 0;_current.memoizedState=retryCache;}// Memoize using the boundary fiber to prevent redundant listeners.
if(!retryCache.has(thenable)){retryCache.add(thenable);var retry=retryTimedOutBoundary.bind(null,_workInProgress,thenable);if(enableSchedulerTracing){retry=tracing.unstable_wrap(retry);}thenable.then(retry,retry);}_workInProgress.effectTag|=ShouldCapture;_workInProgress.expirationTime=renderExpirationTime;return;}// This boundary already captured during this render. Continue to the next
// boundary.
_workInProgress=_workInProgress.return;}while(_workInProgress!==null);// No boundary was found. Fallthrough to error mode.
// TODO: Use invariant so the message is stripped in prod?
value=new Error((getComponentName(sourceFiber.type)||'A React component')+' suspended while rendering, but no fallback UI was specified.\n'+'\n'+'Add a <Suspense fallback=...> component higher in the tree to '+'provide a loading indicator or placeholder to display.'+getStackByFiberInDevAndProd(sourceFiber));}// We didn't find a boundary that could handle this type of exception. Start
// over and traverse parent path again, this time treating the exception
// as an error.
renderDidError();value=createCapturedValue(value,sourceFiber);var workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.effectTag|=ShouldCapture;workInProgress.expirationTime=renderExpirationTime;var _update=createRootErrorUpdate(workInProgress,_errorInfo,renderExpirationTime);enqueueCapturedUpdate(workInProgress,_update);return;}case ClassComponent:// Capture and retry
var errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.effectTag&DidCapture)===NoEffect&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.effectTag|=ShouldCapture;workInProgress.expirationTime=renderExpirationTime;// Schedule the error boundary to re-render using updated state
var _update2=createClassErrorUpdate(workInProgress,errorInfo,renderExpirationTime);enqueueCapturedUpdate(workInProgress,_update2);return;}break;default:break;}workInProgress=workInProgress.return;}while(workInProgress!==null);}function unwindWork(workInProgress,renderExpirationTime){switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var effectTag=workInProgress.effectTag;if(effectTag&ShouldCapture){workInProgress.effectTag=effectTag&~ShouldCapture|DidCapture;return workInProgress;}return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var _effectTag=workInProgress.effectTag;!((_effectTag&DidCapture)===NoEffect)?invariant(false,'The root failed to unmount after an error. This is likely a bug in React. Please file an issue.'):void 0;workInProgress.effectTag=_effectTag&~ShouldCapture|DidCapture;return workInProgress;}case HostComponent:{// TODO: popHydrationState
popHostContext(workInProgress);return null;}case SuspenseComponent:{var _effectTag2=workInProgress.effectTag;if(_effectTag2&ShouldCapture){workInProgress.effectTag=_effectTag2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.
return workInProgress;}return null;}case DehydratedSuspenseComponent:{if(enableSuspenseServerRenderer){// TODO: popHydrationState
var _effectTag3=workInProgress.effectTag;if(_effectTag3&ShouldCapture){workInProgress.effectTag=_effectTag3&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.
return workInProgress;}}return null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:popProvider(workInProgress);return null;default:return null;}}function unwindInterruptedWork(interruptedWork){switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case ContextProvider:popProvider(interruptedWork);break;default:break;}}var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;var ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner;var didWarnAboutStateTransition=void 0;var didWarnSetStateChildContext=void 0;var warnAboutUpdateOnUnmounted=void 0;var warnAboutInvalidUpdates=void 0;if(enableSchedulerTracing){// Provide explicit error message when production+profiling bundle of e.g. react-dom
// is used with production (non-profiling) bundle of scheduler/tracing
!(tracing.__interactionsRef!=null&&tracing.__interactionsRef.current!=null)?invariant(false,'It is not supported to run the profiling version of a renderer (for example, `react-dom/profiling`) without also replacing the `scheduler/tracing` module with `scheduler/tracing-profiling`. Your bundler might have a setting for aliasing both modules. Learn more at http://fb.me/react-profiling'):void 0;}{didWarnAboutStateTransition=false;didWarnSetStateChildContext=false;var didWarnStateUpdateForUnmountedComponent={};warnAboutUpdateOnUnmounted=function(fiber,isClass){// We show the whole stack but dedupe on the top component's name because
// the problematic code almost always lies inside that component.
var componentName=getComponentName(fiber.type)||'ReactComponent';if(didWarnStateUpdateForUnmountedComponent[componentName]){return;}warningWithoutStack$1(false,"Can't perform a React state update on an unmounted component. This "+'is a no-op, but it indicates a memory leak in your application. To '+'fix, cancel all subscriptions and asynchronous tasks in %s.%s',isClass?'the componentWillUnmount method':'a useEffect cleanup function',getStackByFiberInDevAndProd(fiber));didWarnStateUpdateForUnmountedComponent[componentName]=true;};warnAboutInvalidUpdates=function(instance){switch(phase){case'getChildContext':if(didWarnSetStateChildContext){return;}warningWithoutStack$1(false,'setState(...): Cannot call setState() inside getChildContext()');didWarnSetStateChildContext=true;break;case'render':if(didWarnAboutStateTransition){return;}warningWithoutStack$1(false,'Cannot update during an existing state transition (such as within '+'`render`). Render methods should be a pure function of props and state.');didWarnAboutStateTransition=true;break;}};}// Used to ensure computeUniqueAsyncExpiration is monotonically decreasing.
var lastUniqueAsyncExpiration=Sync-1;var isWorking=false;// The next work in progress fiber that we're currently working on.
var nextUnitOfWork=null;var nextRoot=null;// The time at which we're currently rendering work.
var nextRenderExpirationTime=NoWork;var nextLatestAbsoluteTimeoutMs=-1;var nextRenderDidError=false;// The next fiber with an effect that we're currently committing.
var nextEffect=null;var isCommitting$1=false;var rootWithPendingPassiveEffects=null;var passiveEffectCallbackHandle=null;var passiveEffectCallback=null;var legacyErrorBoundariesThatAlreadyFailed=null;// Used for performance tracking.
var interruptedBy=null;var stashedWorkInProgressProperties=void 0;var replayUnitOfWork=void 0;var mayReplayFailedUnitOfWork=void 0;var isReplayingFailedUnitOfWork=void 0;var originalReplayError=void 0;var rethrowOriginalError=void 0;if( true&&replayFailedUnitOfWorkWithInvokeGuardedCallback){stashedWorkInProgressProperties=null;mayReplayFailedUnitOfWork=true;isReplayingFailedUnitOfWork=false;originalReplayError=null;replayUnitOfWork=function(failedUnitOfWork,thrownValue,isYieldy){if(thrownValue!==null&&typeof thrownValue==='object'&&typeof thrownValue.then==='function'){// Don't replay promises. Treat everything else like an error.
// TODO: Need to figure out a different strategy if/when we add
// support for catching other types.
return;}// Restore the original state of the work-in-progress
if(stashedWorkInProgressProperties===null){// This should never happen. Don't throw because this code is DEV-only.
warningWithoutStack$1(false,'Could not replay rendering after an error. This is likely a bug in React. '+'Please file an issue.');return;}assignFiberPropertiesInDEV(failedUnitOfWork,stashedWorkInProgressProperties);switch(failedUnitOfWork.tag){case HostRoot:popHostContainer(failedUnitOfWork);popTopLevelContextObject(failedUnitOfWork);break;case HostComponent:popHostContext(failedUnitOfWork);break;case ClassComponent:{var Component=failedUnitOfWork.type;if(isContextProvider(Component)){popContext(failedUnitOfWork);}break;}case HostPortal:popHostContainer(failedUnitOfWork);break;case ContextProvider:popProvider(failedUnitOfWork);break;}// Replay the begin phase.
isReplayingFailedUnitOfWork=true;originalReplayError=thrownValue;invokeGuardedCallback(null,workLoop,null,isYieldy);isReplayingFailedUnitOfWork=false;originalReplayError=null;if(hasCaughtError()){var replayError=clearCaughtError();if(replayError!=null&&thrownValue!=null){try{// Reading the expando property is intentionally
// inside `try` because it might be a getter or Proxy.
if(replayError._suppressLogging){// Also suppress logging for the original error.
thrownValue._suppressLogging=true;}}catch(inner){// Ignore.
}}}else{// If the begin phase did not fail the second time, set this pointer
// back to the original value.
nextUnitOfWork=failedUnitOfWork;}};rethrowOriginalError=function(){throw originalReplayError;};}function resetStack(){if(nextUnitOfWork!==null){var interruptedWork=nextUnitOfWork.return;while(interruptedWork!==null){unwindInterruptedWork(interruptedWork);interruptedWork=interruptedWork.return;}}{ReactStrictModeWarnings.discardPendingWarnings();checkThatStackIsEmpty();}nextRoot=null;nextRenderExpirationTime=NoWork;nextLatestAbsoluteTimeoutMs=-1;nextRenderDidError=false;nextUnitOfWork=null;}function commitAllHostEffects(){while(nextEffect!==null){{setCurrentFiber(nextEffect);}recordEffect();var effectTag=nextEffect.effectTag;if(effectTag&ContentReset){commitResetTextContent(nextEffect);}if(effectTag&Ref){var current$$1=nextEffect.alternate;if(current$$1!==null){commitDetachRef(current$$1);}}// The following switch statement is only concerned about placement,
// updates, and deletions. To avoid needing to add a case for every
// possible bitmap value, we remove the secondary effects from the
// effect tag and switch on that value.
var primaryEffectTag=effectTag&(Placement|Update|Deletion);switch(primaryEffectTag){case Placement:{commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
// TODO: findDOMNode doesn't rely on this any more but isMounted
// does and isMounted is deprecated anyway so we should be able
// to kill this.
nextEffect.effectTag&=~Placement;break;}case PlacementAndUpdate:{// Placement
commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
nextEffect.effectTag&=~Placement;// Update
var _current=nextEffect.alternate;commitWork(_current,nextEffect);break;}case Update:{var _current2=nextEffect.alternate;commitWork(_current2,nextEffect);break;}case Deletion:{commitDeletion(nextEffect);break;}}nextEffect=nextEffect.nextEffect;}{resetCurrentFiber();}}function commitBeforeMutationLifecycles(){while(nextEffect!==null){{setCurrentFiber(nextEffect);}var effectTag=nextEffect.effectTag;if(effectTag&Snapshot){recordEffect();var current$$1=nextEffect.alternate;commitBeforeMutationLifeCycles(current$$1,nextEffect);}nextEffect=nextEffect.nextEffect;}{resetCurrentFiber();}}function commitAllLifeCycles(finishedRoot,committedExpirationTime){{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();ReactStrictModeWarnings.flushLegacyContextWarning();if(warnAboutDeprecatedLifecycles){ReactStrictModeWarnings.flushPendingDeprecationWarnings();}}while(nextEffect!==null){{setCurrentFiber(nextEffect);}var effectTag=nextEffect.effectTag;if(effectTag&(Update|Callback)){recordEffect();var current$$1=nextEffect.alternate;commitLifeCycles(finishedRoot,current$$1,nextEffect,committedExpirationTime);}if(effectTag&Ref){recordEffect();commitAttachRef(nextEffect);}if(effectTag&Passive){rootWithPendingPassiveEffects=finishedRoot;}nextEffect=nextEffect.nextEffect;}{resetCurrentFiber();}}function commitPassiveEffects(root,firstEffect){rootWithPendingPassiveEffects=null;passiveEffectCallbackHandle=null;passiveEffectCallback=null;// Set this to true to prevent re-entrancy
var previousIsRendering=isRendering;isRendering=true;var effect=firstEffect;do{{setCurrentFiber(effect);}if(effect.effectTag&Passive){var didError=false;var error=void 0;{invokeGuardedCallback(null,commitPassiveHookEffects,null,effect);if(hasCaughtError()){didError=true;error=clearCaughtError();}}if(didError){captureCommitPhaseError(effect,error);}}effect=effect.nextEffect;}while(effect!==null);{resetCurrentFiber();}isRendering=previousIsRendering;// Check if work was scheduled by one of the effects
var rootExpirationTime=root.expirationTime;if(rootExpirationTime!==NoWork){requestWork(root,rootExpirationTime);}// Flush any sync work that was scheduled by effects
if(!isBatchingUpdates&&!isRendering){performSyncWork();}}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else{legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function flushPassiveEffects(){if(passiveEffectCallbackHandle!==null){cancelPassiveEffects(passiveEffectCallbackHandle);}if(passiveEffectCallback!==null){// We call the scheduled callback instead of commitPassiveEffects directly
// to ensure tracing works correctly.
passiveEffectCallback();}}function commitRoot(root,finishedWork){isWorking=true;isCommitting$1=true;startCommitTimer();!(root.current!==finishedWork)?invariant(false,'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.'):void 0;var committedExpirationTime=root.pendingCommitExpirationTime;!(committedExpirationTime!==NoWork)?invariant(false,'Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.'):void 0;root.pendingCommitExpirationTime=NoWork;// Update the pending priority levels to account for the work that we are
// about to commit. This needs to happen before calling the lifecycles, since
// they may schedule additional updates.
var updateExpirationTimeBeforeCommit=finishedWork.expirationTime;var childExpirationTimeBeforeCommit=finishedWork.childExpirationTime;var earliestRemainingTimeBeforeCommit=childExpirationTimeBeforeCommit>updateExpirationTimeBeforeCommit?childExpirationTimeBeforeCommit:updateExpirationTimeBeforeCommit;markCommittedPriorityLevels(root,earliestRemainingTimeBeforeCommit);var prevInteractions=null;if(enableSchedulerTracing){// Restore any pending interactions at this point,
// So that cascading work triggered during the render phase will be accounted for.
prevInteractions=tracing.__interactionsRef.current;tracing.__interactionsRef.current=root.memoizedInteractions;}// Reset this to null before calling lifecycles
ReactCurrentOwner$2.current=null;var firstEffect=void 0;if(finishedWork.effectTag>PerformedWork){// A fiber's effect list consists only of its children, not itself. So if
// the root has an effect, we need to add it to the end of the list. The
// resulting list is the set that would belong to the root's parent, if
// it had one; that is, all the effects in the tree including the root.
if(finishedWork.lastEffect!==null){finishedWork.lastEffect.nextEffect=finishedWork;firstEffect=finishedWork.firstEffect;}else{firstEffect=finishedWork;}}else{// There is no effect on the root.
firstEffect=finishedWork.firstEffect;}prepareForCommit(root.containerInfo);// Invoke instances of getSnapshotBeforeUpdate before mutation.
nextEffect=firstEffect;startCommitSnapshotEffectsTimer();while(nextEffect!==null){var didError=false;var error=void 0;{invokeGuardedCallback(null,commitBeforeMutationLifecycles,null);if(hasCaughtError()){didError=true;error=clearCaughtError();}}if(didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureCommitPhaseError(nextEffect,error);// Clean-up
if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitSnapshotEffectsTimer();if(enableProfilerTimer){// Mark the current commit time to be shared by all Profilers in this batch.
// This enables them to be grouped later.
recordCommitTime();}// Commit all the side-effects within a tree. We'll do this in two passes.
// The first pass performs all the host insertions, updates, deletions and
// ref unmounts.
nextEffect=firstEffect;startCommitHostEffectsTimer();while(nextEffect!==null){var _didError=false;var _error=void 0;{invokeGuardedCallback(null,commitAllHostEffects,null);if(hasCaughtError()){_didError=true;_error=clearCaughtError();}}if(_didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureCommitPhaseError(nextEffect,_error);// Clean-up
if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitHostEffectsTimer();resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after
// the first pass of the commit phase, so that the previous tree is still
// current during componentWillUnmount, but before the second pass, so that
// the finished work is current during componentDidMount/Update.
root.current=finishedWork;// In the second pass we'll perform all life-cycles and ref callbacks.
// Life-cycles happen as a separate pass so that all placements, updates,
// and deletions in the entire tree have already been invoked.
// This pass also triggers any renderer-specific initial effects.
nextEffect=firstEffect;startCommitLifeCyclesTimer();while(nextEffect!==null){var _didError2=false;var _error2=void 0;{invokeGuardedCallback(null,commitAllLifeCycles,null,root,committedExpirationTime);if(hasCaughtError()){_didError2=true;_error2=clearCaughtError();}}if(_didError2){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureCommitPhaseError(nextEffect,_error2);if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}if(firstEffect!==null&&rootWithPendingPassiveEffects!==null){// This commit included a passive effect. These do not need to fire until
// after the next paint. Schedule an callback to fire them in an async
// event. To ensure serial execution, the callback will be flushed early if
// we enter rootWithPendingPassiveEffects commit phase before then.
var callback=commitPassiveEffects.bind(null,root,firstEffect);if(enableSchedulerTracing){// TODO: Avoid this extra callback by mutating the tracing ref directly,
// like we do at the beginning of commitRoot. I've opted not to do that
// here because that code is still in flux.
callback=tracing.unstable_wrap(callback);}passiveEffectCallbackHandle=scheduler.unstable_runWithPriority(scheduler.unstable_NormalPriority,function(){return schedulePassiveEffects(callback);});passiveEffectCallback=callback;}isCommitting$1=false;isWorking=false;stopCommitLifeCyclesTimer();stopCommitTimer();onCommitRoot(finishedWork.stateNode);if( true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);}var updateExpirationTimeAfterCommit=finishedWork.expirationTime;var childExpirationTimeAfterCommit=finishedWork.childExpirationTime;var earliestRemainingTimeAfterCommit=childExpirationTimeAfterCommit>updateExpirationTimeAfterCommit?childExpirationTimeAfterCommit:updateExpirationTimeAfterCommit;if(earliestRemainingTimeAfterCommit===NoWork){// If there's no remaining work, we can clear the set of already failed
// error boundaries.
legacyErrorBoundariesThatAlreadyFailed=null;}onCommit(root,earliestRemainingTimeAfterCommit);if(enableSchedulerTracing){tracing.__interactionsRef.current=prevInteractions;var subscriber=void 0;try{subscriber=tracing.__subscriberRef.current;if(subscriber!==null&&root.memoizedInteractions.size>0){var threadID=computeThreadID(committedExpirationTime,root.interactionThreadID);subscriber.onWorkStopped(root.memoizedInteractions,threadID);}}catch(error){// It's not safe for commitRoot() to throw.
// Store the error for now and we'll re-throw in finishRendering().
if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}finally{// Clear completed interactions from the pending Map.
// Unless the render was suspended or cascading work was scheduled,
// In which case– leave pending interactions until the subsequent render.
var pendingInteractionMap=root.pendingInteractionMap;pendingInteractionMap.forEach(function(scheduledInteractions,scheduledExpirationTime){// Only decrement the pending interaction count if we're done.
// If there's still work at the current priority,
// That indicates that we are waiting for suspense data.
if(scheduledExpirationTime>earliestRemainingTimeAfterCommit){pendingInteractionMap.delete(scheduledExpirationTime);scheduledInteractions.forEach(function(interaction){interaction.__count--;if(subscriber!==null&&interaction.__count===0){try{subscriber.onInteractionScheduledWorkCompleted(interaction);}catch(error){// It's not safe for commitRoot() to throw.
// Store the error for now and we'll re-throw in finishRendering().
if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}}});}});}}}function resetChildExpirationTime(workInProgress,renderTime){if(renderTime!==Never&&workInProgress.childExpirationTime===Never){// The children of this component are hidden. Don't bubble their
// expiration times.
return;}var newChildExpirationTime=NoWork;// Bubble up the earliest expiration time.
if(enableProfilerTimer&&workInProgress.mode&ProfileMode){// We're in profiling mode.
// Let's use this same traversal to update the render durations.
var actualDuration=workInProgress.actualDuration;var treeBaseDuration=workInProgress.selfBaseDuration;// When a fiber is cloned, its actualDuration is reset to 0.
// This value will only be updated if work is done on the fiber (i.e. it doesn't bailout).
// When work is done, it should bubble to the parent's actualDuration.
// If the fiber has not been cloned though, (meaning no work was done),
// Then this value will reflect the amount of time spent working on a previous render.
// In that case it should not bubble.
// We determine whether it was cloned by comparing the child pointer.
var shouldBubbleActualDurations=workInProgress.alternate===null||workInProgress.child!==workInProgress.alternate.child;var child=workInProgress.child;while(child!==null){var childUpdateExpirationTime=child.expirationTime;var childChildExpirationTime=child.childExpirationTime;if(childUpdateExpirationTime>newChildExpirationTime){newChildExpirationTime=childUpdateExpirationTime;}if(childChildExpirationTime>newChildExpirationTime){newChildExpirationTime=childChildExpirationTime;}if(shouldBubbleActualDurations){actualDuration+=child.actualDuration;}treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}workInProgress.actualDuration=actualDuration;workInProgress.treeBaseDuration=treeBaseDuration;}else{var _child=workInProgress.child;while(_child!==null){var _childUpdateExpirationTime=_child.expirationTime;var _childChildExpirationTime=_child.childExpirationTime;if(_childUpdateExpirationTime>newChildExpirationTime){newChildExpirationTime=_childUpdateExpirationTime;}if(_childChildExpirationTime>newChildExpirationTime){newChildExpirationTime=_childChildExpirationTime;}_child=_child.sibling;}}workInProgress.childExpirationTime=newChildExpirationTime;}function completeUnitOfWork(workInProgress){// Attempt to complete the current unit of work, then move to the
// next sibling. If there are no more siblings, return to the
// parent fiber.
while(true){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current$$1=workInProgress.alternate;{setCurrentFiber(workInProgress);}var returnFiber=workInProgress.return;var siblingFiber=workInProgress.sibling;if((workInProgress.effectTag&Incomplete)===NoEffect){if( true&&replayFailedUnitOfWorkWithInvokeGuardedCallback){// Don't replay if it fails during completion phase.
mayReplayFailedUnitOfWork=false;}// This fiber completed.
// Remember we're completing this unit so we can find a boundary if it fails.
nextUnitOfWork=workInProgress;if(enableProfilerTimer){if(workInProgress.mode&ProfileMode){startProfilerTimer(workInProgress);}nextUnitOfWork=completeWork(current$$1,workInProgress,nextRenderExpirationTime);if(workInProgress.mode&ProfileMode){// Update render duration assuming we didn't error.
stopProfilerTimerIfRunningAndRecordDelta(workInProgress,false);}}else{nextUnitOfWork=completeWork(current$$1,workInProgress,nextRenderExpirationTime);}if( true&&replayFailedUnitOfWorkWithInvokeGuardedCallback){// We're out of completion phase so replaying is fine now.
mayReplayFailedUnitOfWork=true;}stopWorkTimer(workInProgress);resetChildExpirationTime(workInProgress,nextRenderExpirationTime);{resetCurrentFiber();}if(nextUnitOfWork!==null){// Completing this fiber spawned new work. Work on that next.
return nextUnitOfWork;}if(returnFiber!==null&&// Do not append effects to parents if a sibling failed to complete
(returnFiber.effectTag&Incomplete)===NoEffect){// Append all the effects of the subtree and this fiber onto the effect
// list of the parent. The completion order of the children affects the
// side-effect order.
if(returnFiber.firstEffect===null){returnFiber.firstEffect=workInProgress.firstEffect;}if(workInProgress.lastEffect!==null){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress.firstEffect;}returnFiber.lastEffect=workInProgress.lastEffect;}// If this fiber had side-effects, we append it AFTER the children's
// side-effects. We can perform certain side-effects earlier if
// needed, by doing multiple passes over the effect list. We don't want
// to schedule our own side-effect on our own list because if end up
// reusing children we'll schedule this effect onto itself since we're
// at the end.
var effectTag=workInProgress.effectTag;// Skip both NoWork and PerformedWork tags when creating the effect list.
// PerformedWork effect is read by React DevTools but shouldn't be committed.
if(effectTag>PerformedWork){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress;}else{returnFiber.firstEffect=workInProgress;}returnFiber.lastEffect=workInProgress;}}if( true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
return siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.
workInProgress=returnFiber;continue;}else{// We've reached the root.
return null;}}else{if(enableProfilerTimer&&workInProgress.mode&ProfileMode){// Record the render duration for the fiber that errored.
stopProfilerTimerIfRunningAndRecordDelta(workInProgress,false);// Include the time spent working on failed children before continuing.
var actualDuration=workInProgress.actualDuration;var child=workInProgress.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}workInProgress.actualDuration=actualDuration;}// This fiber did not complete because something threw. Pop values off
// the stack without entering the complete phase. If this is a boundary,
// capture values if possible.
var next=unwindWork(workInProgress,nextRenderExpirationTime);// Because this fiber did not complete, don't reset its expiration time.
if(workInProgress.effectTag&DidCapture){// Restarting an error boundary
stopFailedWorkTimer(workInProgress);}else{stopWorkTimer(workInProgress);}{resetCurrentFiber();}if(next!==null){stopWorkTimer(workInProgress);if( true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}// If completing this work spawned new work, do that next. We'll come
// back here again.
// Since we're restarting, remove anything that is not a host effect
// from the effect tag.
next.effectTag&=HostEffectMask;return next;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its effect list.
returnFiber.firstEffect=returnFiber.lastEffect=null;returnFiber.effectTag|=Incomplete;}if( true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
return siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.
workInProgress=returnFiber;continue;}else{return null;}}}// Without this explicit null return Flow complains of invalid return type
// TODO Remove the above while(true) loop
// eslint-disable-next-line no-unreachable
return null;}function performUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current$$1=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{setCurrentFiber(workInProgress);}if( true&&replayFailedUnitOfWorkWithInvokeGuardedCallback){stashedWorkInProgressProperties=assignFiberPropertiesInDEV(stashedWorkInProgressProperties,workInProgress);}var next=void 0;if(enableProfilerTimer){if(workInProgress.mode&ProfileMode){startProfilerTimer(workInProgress);}next=beginWork(current$$1,workInProgress,nextRenderExpirationTime);workInProgress.memoizedProps=workInProgress.pendingProps;if(workInProgress.mode&ProfileMode){// Record the render duration assuming we didn't bailout (or error).
stopProfilerTimerIfRunningAndRecordDelta(workInProgress,true);}}else{next=beginWork(current$$1,workInProgress,nextRenderExpirationTime);workInProgress.memoizedProps=workInProgress.pendingProps;}{resetCurrentFiber();if(isReplayingFailedUnitOfWork){// Currently replaying a failed unit of work. This should be unreachable,
// because the render phase is meant to be idempotent, and it should
// have thrown again. Since it didn't, rethrow the original error, so
// React's internal stack is not misaligned.
rethrowOriginalError();}}if( true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner$2.current=null;return next;}function workLoop(isYieldy){if(!isYieldy){// Flush work without yielding
while(nextUnitOfWork!==null){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}else{// Flush asynchronous work until there's a higher priority event
while(nextUnitOfWork!==null&&!shouldYieldToRenderer()){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}function renderRoot(root,isYieldy){!!isWorking?invariant(false,'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;flushPassiveEffects();isWorking=true;var previousDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=ContextOnlyDispatcher;var expirationTime=root.nextExpirationTimeToWorkOn;// Check if we're starting from a fresh stack, or if we're resuming from
// previously yielded work.
if(expirationTime!==nextRenderExpirationTime||root!==nextRoot||nextUnitOfWork===null){// Reset the stack and start working from the root.
resetStack();nextRoot=root;nextRenderExpirationTime=expirationTime;nextUnitOfWork=createWorkInProgress(nextRoot.current,null,nextRenderExpirationTime);root.pendingCommitExpirationTime=NoWork;if(enableSchedulerTracing){// Determine which interactions this batch of work currently includes,
// So that we can accurately attribute time spent working on it,
var interactions=new Set();root.pendingInteractionMap.forEach(function(scheduledInteractions,scheduledExpirationTime){if(scheduledExpirationTime>=expirationTime){scheduledInteractions.forEach(function(interaction){return interactions.add(interaction);});}});// Store the current set of interactions on the FiberRoot for a few reasons:
// We can re-use it in hot functions like renderRoot() without having to recalculate it.
// We will also use it in commitWork() to pass to any Profiler onRender() hooks.
// This also provides DevTools with a way to access it when the onCommitRoot() hook is called.
root.memoizedInteractions=interactions;if(interactions.size>0){var subscriber=tracing.__subscriberRef.current;if(subscriber!==null){var threadID=computeThreadID(expirationTime,root.interactionThreadID);try{subscriber.onWorkStarted(interactions,threadID);}catch(error){// Work thrown by an interaction tracing subscriber should be rethrown,
// But only once it's safe (to avoid leaving the scheduler in an invalid state).
// Store the error for now and we'll re-throw in finishRendering().
if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}}}}}var prevInteractions=null;if(enableSchedulerTracing){// We're about to start new traced work.
// Restore pending interactions so cascading work triggered during the render phase will be accounted for.
prevInteractions=tracing.__interactionsRef.current;tracing.__interactionsRef.current=root.memoizedInteractions;}var didFatal=false;startWorkLoopTimer(nextUnitOfWork);do{try{workLoop(isYieldy);}catch(thrownValue){resetContextDependences();resetHooks();// Reset in case completion throws.
// This is only used in DEV and when replaying is on.
var mayReplay=void 0;if( true&&replayFailedUnitOfWorkWithInvokeGuardedCallback){mayReplay=mayReplayFailedUnitOfWork;mayReplayFailedUnitOfWork=true;}if(nextUnitOfWork===null){// This is a fatal error.
didFatal=true;onUncaughtError(thrownValue);}else{if(enableProfilerTimer&&nextUnitOfWork.mode&ProfileMode){// Record the time spent rendering before an error was thrown.
// This avoids inaccurate Profiler durations in the case of a suspended render.
stopProfilerTimerIfRunningAndRecordDelta(nextUnitOfWork,true);}{// Reset global debug state
// We assume this is defined in DEV
resetCurrentlyProcessingQueue();}if( true&&replayFailedUnitOfWorkWithInvokeGuardedCallback){if(mayReplay){var failedUnitOfWork=nextUnitOfWork;replayUnitOfWork(failedUnitOfWork,thrownValue,isYieldy);}}// TODO: we already know this isn't true in some cases.
// At least this shows a nicer error message until we figure out the cause.
// https://github.com/facebook/react/issues/12449#issuecomment-386727431
!(nextUnitOfWork!==null)?invariant(false,'Failed to replay rendering after an error. This is likely caused by a bug in React. Please file an issue with a reproducing case to help us find it.'):void 0;var sourceFiber=nextUnitOfWork;var returnFiber=sourceFiber.return;if(returnFiber===null){// This is the root. The root could capture its own errors. However,
// we don't know if it errors before or after we pushed the host
// context. This information is needed to avoid a stack mismatch.
// Because we're not sure, treat this as a fatal error. We could track
// which phase it fails in, but doesn't seem worth it. At least
// for now.
didFatal=true;onUncaughtError(thrownValue);}else{throwException(root,returnFiber,sourceFiber,thrownValue,nextRenderExpirationTime);nextUnitOfWork=completeUnitOfWork(sourceFiber);continue;}}}break;}while(true);if(enableSchedulerTracing){// Traced work is done for now; restore the previous interactions.
tracing.__interactionsRef.current=prevInteractions;}// We're done performing work. Time to clean up.
isWorking=false;ReactCurrentDispatcher.current=previousDispatcher;resetContextDependences();resetHooks();// Yield back to main thread.
if(didFatal){var _didCompleteRoot=false;stopWorkLoopTimer(interruptedBy,_didCompleteRoot);interruptedBy=null;// There was a fatal error.
{resetStackAfterFatalErrorInDev();}// `nextRoot` points to the in-progress root. A non-null value indicates
// that we're in the middle of an async render. Set it to null to indicate
// there's no more work to be done in the current batch.
nextRoot=null;onFatal(root);return;}if(nextUnitOfWork!==null){// There's still remaining async work in this tree, but we ran out of time
// in the current frame. Yield back to the renderer. Unless we're
// interrupted by a higher priority update, we'll continue later from where
// we left off.
var _didCompleteRoot2=false;stopWorkLoopTimer(interruptedBy,_didCompleteRoot2);interruptedBy=null;onYield(root);return;}// We completed the whole tree.
var didCompleteRoot=true;stopWorkLoopTimer(interruptedBy,didCompleteRoot);var rootWorkInProgress=root.current.alternate;!(rootWorkInProgress!==null)?invariant(false,'Finished root should have a work-in-progress. This error is likely caused by a bug in React. Please file an issue.'):void 0;// `nextRoot` points to the in-progress root. A non-null value indicates
// that we're in the middle of an async render. Set it to null to indicate
// there's no more work to be done in the current batch.
nextRoot=null;interruptedBy=null;if(nextRenderDidError){// There was an error
if(hasLowerPriorityWork(root,expirationTime)){// There's lower priority work. If so, it may have the effect of fixing
// the exception that was just thrown. Exit without committing. This is
// similar to a suspend, but without a timeout because we're not waiting
// for a promise to resolve. React will restart at the lower
// priority level.
markSuspendedPriorityLevel(root,expirationTime);var suspendedExpirationTime=expirationTime;var rootExpirationTime=root.expirationTime;onSuspend(root,rootWorkInProgress,suspendedExpirationTime,rootExpirationTime,-1// Indicates no timeout
);return;}else if(// There's no lower priority work, but we're rendering asynchronously.
// Synchronously attempt to render the same level one more time. This is
// similar to a suspend, but without a timeout because we're not waiting
// for a promise to resolve.
!root.didError&&isYieldy){root.didError=true;var _suspendedExpirationTime=root.nextExpirationTimeToWorkOn=expirationTime;var _rootExpirationTime=root.expirationTime=Sync;onSuspend(root,rootWorkInProgress,_suspendedExpirationTime,_rootExpirationTime,-1// Indicates no timeout
);return;}}if(isYieldy&&nextLatestAbsoluteTimeoutMs!==-1){// The tree was suspended.
var _suspendedExpirationTime2=expirationTime;markSuspendedPriorityLevel(root,_suspendedExpirationTime2);// Find the earliest uncommitted expiration time in the tree, including
// work that is suspended. The timeout threshold cannot be longer than
// the overall expiration.
var earliestExpirationTime=findEarliestOutstandingPriorityLevel(root,expirationTime);var earliestExpirationTimeMs=expirationTimeToMs(earliestExpirationTime);if(earliestExpirationTimeMs<nextLatestAbsoluteTimeoutMs){nextLatestAbsoluteTimeoutMs=earliestExpirationTimeMs;}// Subtract the current time from the absolute timeout to get the number
// of milliseconds until the timeout. In other words, convert an absolute
// timestamp to a relative time. This is the value that is passed
// to `setTimeout`.
var currentTimeMs=expirationTimeToMs(requestCurrentTime());var msUntilTimeout=nextLatestAbsoluteTimeoutMs-currentTimeMs;msUntilTimeout=msUntilTimeout<0?0:msUntilTimeout;// TODO: Account for the Just Noticeable Difference
var _rootExpirationTime2=root.expirationTime;onSuspend(root,rootWorkInProgress,_suspendedExpirationTime2,_rootExpirationTime2,msUntilTimeout);return;}// Ready to commit.
onComplete(root,rootWorkInProgress,expirationTime);}function captureCommitPhaseError(sourceFiber,value){var expirationTime=Sync;var fiber=sourceFiber.return;while(fiber!==null){switch(fiber.tag){case ClassComponent:var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValue(value,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,expirationTime);enqueueUpdate(fiber,update);scheduleWork(fiber,expirationTime);return;}break;case HostRoot:{var _errorInfo=createCapturedValue(value,sourceFiber);var _update=createRootErrorUpdate(fiber,_errorInfo,expirationTime);enqueueUpdate(fiber,_update);scheduleWork(fiber,expirationTime);return;}}fiber=fiber.return;}if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root
// itself should capture it.
var rootFiber=sourceFiber;var _errorInfo2=createCapturedValue(value,rootFiber);var _update2=createRootErrorUpdate(rootFiber,_errorInfo2,expirationTime);enqueueUpdate(rootFiber,_update2);scheduleWork(rootFiber,expirationTime);}}function computeThreadID(expirationTime,interactionThreadID){// Interaction threads are unique per root and expiration time.
return expirationTime*1000+interactionThreadID;}// Creates a unique async expiration time.
function computeUniqueAsyncExpiration(){var currentTime=requestCurrentTime();var result=computeAsyncExpiration(currentTime);if(result>=lastUniqueAsyncExpiration){// Since we assume the current time monotonically increases, we only hit
// this branch when computeUniqueAsyncExpiration is fired multiple times
// within a 200ms window (or whatever the async bucket size is).
result=lastUniqueAsyncExpiration-1;}lastUniqueAsyncExpiration=result;return lastUniqueAsyncExpiration;}function computeExpirationForFiber(currentTime,fiber){var priorityLevel=scheduler.unstable_getCurrentPriorityLevel();var expirationTime=void 0;if((fiber.mode&ConcurrentMode)===NoContext){// Outside of concurrent mode, updates are always synchronous.
expirationTime=Sync;}else if(isWorking&&!isCommitting$1){// During render phase, updates expire during as the current render.
expirationTime=nextRenderExpirationTime;}else{switch(priorityLevel){case scheduler.unstable_ImmediatePriority:expirationTime=Sync;break;case scheduler.unstable_UserBlockingPriority:expirationTime=computeInteractiveExpiration(currentTime);break;case scheduler.unstable_NormalPriority:// This is a normal, concurrent update
expirationTime=computeAsyncExpiration(currentTime);break;case scheduler.unstable_LowPriority:case scheduler.unstable_IdlePriority:expirationTime=Never;break;default:invariant(false,'Unknown priority level. This error is likely caused by a bug in React. Please file an issue.');}// If we're in the middle of rendering a tree, do not update at the same
// expiration time that is already rendering.
if(nextRoot!==null&&expirationTime===nextRenderExpirationTime){expirationTime-=1;}}// Keep track of the lowest pending interactive expiration time. This
// allows us to synchronously flush all interactive updates
// when needed.
// TODO: Move this to renderer?
if(priorityLevel===scheduler.unstable_UserBlockingPriority&&(lowestPriorityPendingInteractiveExpirationTime===NoWork||expirationTime<lowestPriorityPendingInteractiveExpirationTime)){lowestPriorityPendingInteractiveExpirationTime=expirationTime;}return expirationTime;}function renderDidSuspend(root,absoluteTimeoutMs,suspendedTime){// Schedule the timeout.
if(absoluteTimeoutMs>=0&&nextLatestAbsoluteTimeoutMs<absoluteTimeoutMs){nextLatestAbsoluteTimeoutMs=absoluteTimeoutMs;}}function renderDidError(){nextRenderDidError=true;}function pingSuspendedRoot(root,thenable,pingTime){// A promise that previously suspended React from committing has resolved.
// If React is still suspended, try again at the previous level (pingTime).
var pingCache=root.pingCache;if(pingCache!==null){// The thenable resolved, so we no longer need to memoize, because it will
// never be thrown again.
pingCache.delete(thenable);}if(nextRoot!==null&&nextRenderExpirationTime===pingTime){// Received a ping at the same priority level at which we're currently
// rendering. Restart from the root.
nextRoot=null;}else{// Confirm that the root is still suspended at this level. Otherwise exit.
if(isPriorityLevelSuspended(root,pingTime)){// Ping at the original level
markPingedPriorityLevel(root,pingTime);var rootExpirationTime=root.expirationTime;if(rootExpirationTime!==NoWork){requestWork(root,rootExpirationTime);}}}}function retryTimedOutBoundary(boundaryFiber,thenable){// The boundary fiber (a Suspense component) previously timed out and was
// rendered in its fallback state. One of the promises that suspended it has
// resolved, which means at least part of the tree was likely unblocked. Try
var retryCache=void 0;if(enableSuspenseServerRenderer){switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;break;case DehydratedSuspenseComponent:retryCache=boundaryFiber.memoizedState;break;default:invariant(false,'Pinged unknown suspense boundary type. This is probably a bug in React.');}}else{retryCache=boundaryFiber.stateNode;}if(retryCache!==null){// The thenable resolved, so we no longer need to memoize, because it will
// never be thrown again.
retryCache.delete(thenable);}var currentTime=requestCurrentTime();var retryTime=computeExpirationForFiber(currentTime,boundaryFiber);var root=scheduleWorkToRoot(boundaryFiber,retryTime);if(root!==null){markPendingPriorityLevel(root,retryTime);var rootExpirationTime=root.expirationTime;if(rootExpirationTime!==NoWork){requestWork(root,rootExpirationTime);}}}function scheduleWorkToRoot(fiber,expirationTime){recordScheduleUpdate();{if(fiber.tag===ClassComponent){var instance=fiber.stateNode;warnAboutInvalidUpdates(instance);}}// Update the source fiber's expiration time
if(fiber.expirationTime<expirationTime){fiber.expirationTime=expirationTime;}var alternate=fiber.alternate;if(alternate!==null&&alternate.expirationTime<expirationTime){alternate.expirationTime=expirationTime;}// Walk the parent path to the root and update the child expiration time.
var node=fiber.return;var root=null;if(node===null&&fiber.tag===HostRoot){root=fiber.stateNode;}else{while(node!==null){alternate=node.alternate;if(node.childExpirationTime<expirationTime){node.childExpirationTime=expirationTime;if(alternate!==null&&alternate.childExpirationTime<expirationTime){alternate.childExpirationTime=expirationTime;}}else if(alternate!==null&&alternate.childExpirationTime<expirationTime){alternate.childExpirationTime=expirationTime;}if(node.return===null&&node.tag===HostRoot){root=node.stateNode;break;}node=node.return;}}if(enableSchedulerTracing){if(root!==null){var interactions=tracing.__interactionsRef.current;if(interactions.size>0){var pendingInteractionMap=root.pendingInteractionMap;var pendingInteractions=pendingInteractionMap.get(expirationTime);if(pendingInteractions!=null){interactions.forEach(function(interaction){if(!pendingInteractions.has(interaction)){// Update the pending async work count for previously unscheduled interaction.
interaction.__count++;}pendingInteractions.add(interaction);});}else{pendingInteractionMap.set(expirationTime,new Set(interactions));// Update the pending async work count for the current interactions.
interactions.forEach(function(interaction){interaction.__count++;});}var subscriber=tracing.__subscriberRef.current;if(subscriber!==null){var threadID=computeThreadID(expirationTime,root.interactionThreadID);subscriber.onWorkScheduled(interactions,threadID);}}}}return root;}function warnIfNotCurrentlyBatchingInDev(fiber){{if(isRendering===false&&isBatchingUpdates===false){warningWithoutStack$1(false,'An update to %s inside a test was not wrapped in act(...).\n\n'+'When testing, code that causes React state updates should be wrapped into act(...):\n\n'+'act(() => {\n'+'  /* fire events that update state */\n'+'});\n'+'/* assert on the output */\n\n'+"This ensures that you're testing the behavior the user would see in the browser."+' Learn more at https://fb.me/react-wrap-tests-with-act'+'%s',getComponentName(fiber.type),getStackByFiberInDevAndProd(fiber));}}}function scheduleWork(fiber,expirationTime){var root=scheduleWorkToRoot(fiber,expirationTime);if(root===null){{switch(fiber.tag){case ClassComponent:warnAboutUpdateOnUnmounted(fiber,true);break;case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:warnAboutUpdateOnUnmounted(fiber,false);break;}}return;}if(!isWorking&&nextRenderExpirationTime!==NoWork&&expirationTime>nextRenderExpirationTime){// This is an interruption. (Used for performance tracking.)
interruptedBy=fiber;resetStack();}markPendingPriorityLevel(root,expirationTime);if(// If we're in the render phase, we don't need to schedule this root
// for an update, because we'll do it before we exit...
!isWorking||isCommitting$1||// ...unless this is a different root than the one we're rendering.
nextRoot!==root){var rootExpirationTime=root.expirationTime;requestWork(root,rootExpirationTime);}if(nestedUpdateCount>NESTED_UPDATE_LIMIT){// Reset this back to zero so subsequent updates don't throw.
nestedUpdateCount=0;invariant(false,'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');}}function syncUpdates(fn,a,b,c,d){return scheduler.unstable_runWithPriority(scheduler.unstable_ImmediatePriority,function(){return fn(a,b,c,d);});}// TODO: Everything below this is written as if it has been lifted to the
// renderers. I'll do this in a follow-up.
// Linked-list of roots
var firstScheduledRoot=null;var lastScheduledRoot=null;var callbackExpirationTime=NoWork;var callbackID=void 0;var isRendering=false;var nextFlushedRoot=null;var nextFlushedExpirationTime=NoWork;var lowestPriorityPendingInteractiveExpirationTime=NoWork;var hasUnhandledError=false;var unhandledError=null;var isBatchingUpdates=false;var isUnbatchingUpdates=false;var completedBatches=null;var originalStartTimeMs=scheduler.unstable_now();var currentRendererTime=msToExpirationTime(originalStartTimeMs);var currentSchedulerTime=currentRendererTime;// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var lastCommittedRootDuringThisBatch=null;function recomputeCurrentRendererTime(){var currentTimeMs=scheduler.unstable_now()-originalStartTimeMs;currentRendererTime=msToExpirationTime(currentTimeMs);}function scheduleCallbackWithExpirationTime(root,expirationTime){if(callbackExpirationTime!==NoWork){// A callback is already scheduled. Check its expiration time (timeout).
if(expirationTime<callbackExpirationTime){// Existing callback has sufficient timeout. Exit.
return;}else{if(callbackID!==null){// Existing callback has insufficient timeout. Cancel and schedule a
// new one.
scheduler.unstable_cancelCallback(callbackID);}}// The request callback timer is already running. Don't start a new one.
}else{startRequestCallbackTimer();}callbackExpirationTime=expirationTime;var currentMs=scheduler.unstable_now()-originalStartTimeMs;var expirationTimeMs=expirationTimeToMs(expirationTime);var timeout=expirationTimeMs-currentMs;callbackID=scheduler.unstable_scheduleCallback(performAsyncWork,{timeout:timeout});}// For every call to renderRoot, one of onFatal, onComplete, onSuspend, and
// onYield is called upon exiting. We use these in lieu of returning a tuple.
// I've also chosen not to inline them into renderRoot because these will
// eventually be lifted into the renderer.
function onFatal(root){root.finishedWork=null;}function onComplete(root,finishedWork,expirationTime){root.pendingCommitExpirationTime=expirationTime;root.finishedWork=finishedWork;}function onSuspend(root,finishedWork,suspendedExpirationTime,rootExpirationTime,msUntilTimeout){root.expirationTime=rootExpirationTime;if(msUntilTimeout===0&&!shouldYieldToRenderer()){// Don't wait an additional tick. Commit the tree immediately.
root.pendingCommitExpirationTime=suspendedExpirationTime;root.finishedWork=finishedWork;}else if(msUntilTimeout>0){// Wait `msUntilTimeout` milliseconds before committing.
root.timeoutHandle=scheduleTimeout(onTimeout.bind(null,root,finishedWork,suspendedExpirationTime),msUntilTimeout);}}function onYield(root){root.finishedWork=null;}function onTimeout(root,finishedWork,suspendedExpirationTime){// The root timed out. Commit it.
root.pendingCommitExpirationTime=suspendedExpirationTime;root.finishedWork=finishedWork;// Read the current time before entering the commit phase. We can be
// certain this won't cause tearing related to batching of event updates
// because we're at the top of a timer event.
recomputeCurrentRendererTime();currentSchedulerTime=currentRendererTime;flushRoot(root,suspendedExpirationTime);}function onCommit(root,expirationTime){root.expirationTime=expirationTime;root.finishedWork=null;}function requestCurrentTime(){// requestCurrentTime is called by the scheduler to compute an expiration
// time.
//
// Expiration times are computed by adding to the current time (the start
// time). However, if two updates are scheduled within the same event, we
// should treat their start times as simultaneous, even if the actual clock
// time has advanced between the first and second call.
// In other words, because expiration times determine how updates are batched,
// we want all updates of like priority that occur within the same event to
// receive the same expiration time. Otherwise we get tearing.
//
// We keep track of two separate times: the current "renderer" time and the
// current "scheduler" time. The renderer time can be updated whenever; it
// only exists to minimize the calls performance.now.
//
// But the scheduler time can only be updated if there's no pending work, or
// if we know for certain that we're not in the middle of an event.
if(isRendering){// We're already rendering. Return the most recently read time.
return currentSchedulerTime;}// Check if there's pending work.
findHighestPriorityRoot();if(nextFlushedExpirationTime===NoWork||nextFlushedExpirationTime===Never){// If there's no pending work, or if the pending work is offscreen, we can
// read the current time without risk of tearing.
recomputeCurrentRendererTime();currentSchedulerTime=currentRendererTime;return currentSchedulerTime;}// There's already pending work. We might be in the middle of a browser
// event. If we were to read the current time, it could cause multiple updates
// within the same event to receive different expiration times, leading to
// tearing. Return the last read time. During the next idle callback, the
// time will be updated.
return currentSchedulerTime;}// requestWork is called by the scheduler whenever a root receives an update.
// It's up to the renderer to call renderRoot at some point in the future.
function requestWork(root,expirationTime){addRootToSchedule(root,expirationTime);if(isRendering){// Prevent reentrancy. Remaining work will be scheduled at the end of
// the currently rendering batch.
return;}if(isBatchingUpdates){// Flush work at the end of the batch.
if(isUnbatchingUpdates){// ...unless we're inside unbatchedUpdates, in which case we should
// flush it now.
nextFlushedRoot=root;nextFlushedExpirationTime=Sync;performWorkOnRoot(root,Sync,false);}return;}// TODO: Get rid of Sync and use current time?
if(expirationTime===Sync){performSyncWork();}else{scheduleCallbackWithExpirationTime(root,expirationTime);}}function addRootToSchedule(root,expirationTime){// Add the root to the schedule.
// Check if this root is already part of the schedule.
if(root.nextScheduledRoot===null){// This root is not already scheduled. Add it.
root.expirationTime=expirationTime;if(lastScheduledRoot===null){firstScheduledRoot=lastScheduledRoot=root;root.nextScheduledRoot=root;}else{lastScheduledRoot.nextScheduledRoot=root;lastScheduledRoot=root;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;}}else{// This root is already scheduled, but its priority may have increased.
var remainingExpirationTime=root.expirationTime;if(expirationTime>remainingExpirationTime){// Update the priority.
root.expirationTime=expirationTime;}}}function findHighestPriorityRoot(){var highestPriorityWork=NoWork;var highestPriorityRoot=null;if(lastScheduledRoot!==null){var previousScheduledRoot=lastScheduledRoot;var root=firstScheduledRoot;while(root!==null){var remainingExpirationTime=root.expirationTime;if(remainingExpirationTime===NoWork){// This root no longer has work. Remove it from the scheduler.
// TODO: This check is redudant, but Flow is confused by the branch
// below where we set lastScheduledRoot to null, even though we break
// from the loop right after.
!(previousScheduledRoot!==null&&lastScheduledRoot!==null)?invariant(false,'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(root===root.nextScheduledRoot){// This is the only root in the list.
root.nextScheduledRoot=null;firstScheduledRoot=lastScheduledRoot=null;break;}else if(root===firstScheduledRoot){// This is the first root in the list.
var next=root.nextScheduledRoot;firstScheduledRoot=next;lastScheduledRoot.nextScheduledRoot=next;root.nextScheduledRoot=null;}else if(root===lastScheduledRoot){// This is the last root in the list.
lastScheduledRoot=previousScheduledRoot;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;root.nextScheduledRoot=null;break;}else{previousScheduledRoot.nextScheduledRoot=root.nextScheduledRoot;root.nextScheduledRoot=null;}root=previousScheduledRoot.nextScheduledRoot;}else{if(remainingExpirationTime>highestPriorityWork){// Update the priority, if it's higher
highestPriorityWork=remainingExpirationTime;highestPriorityRoot=root;}if(root===lastScheduledRoot){break;}if(highestPriorityWork===Sync){// Sync is highest priority by definition so
// we can stop searching.
break;}previousScheduledRoot=root;root=root.nextScheduledRoot;}}}nextFlushedRoot=highestPriorityRoot;nextFlushedExpirationTime=highestPriorityWork;}// TODO: This wrapper exists because many of the older tests (the ones that use
// flushDeferredPri) rely on the number of times `shouldYield` is called. We
// should get rid of it.
var didYield=false;function shouldYieldToRenderer(){if(didYield){return true;}if(scheduler.unstable_shouldYield()){didYield=true;return true;}return false;}function performAsyncWork(){try{if(!shouldYieldToRenderer()){// The callback timed out. That means at least one update has expired.
// Iterate through the root schedule. If they contain expired work, set
// the next render expiration time to the current time. This has the effect
// of flushing all expired work in a single batch, instead of flushing each
// level one at a time.
if(firstScheduledRoot!==null){recomputeCurrentRendererTime();var root=firstScheduledRoot;do{didExpireAtExpirationTime(root,currentRendererTime);// The root schedule is circular, so this is never null.
root=root.nextScheduledRoot;}while(root!==firstScheduledRoot);}}performWork(NoWork,true);}finally{didYield=false;}}function performSyncWork(){performWork(Sync,false);}function performWork(minExpirationTime,isYieldy){// Keep working on roots until there's no more work, or until there's a higher
// priority event.
findHighestPriorityRoot();if(isYieldy){recomputeCurrentRendererTime();currentSchedulerTime=currentRendererTime;if(enableUserTimingAPI){var didExpire=nextFlushedExpirationTime>currentRendererTime;var timeout=expirationTimeToMs(nextFlushedExpirationTime);stopRequestCallbackTimer(didExpire,timeout);}while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&minExpirationTime<=nextFlushedExpirationTime&&!(didYield&&currentRendererTime>nextFlushedExpirationTime)){performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime,currentRendererTime>nextFlushedExpirationTime);findHighestPriorityRoot();recomputeCurrentRendererTime();currentSchedulerTime=currentRendererTime;}}else{while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&minExpirationTime<=nextFlushedExpirationTime){performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime,false);findHighestPriorityRoot();}}// We're done flushing work. Either we ran out of time in this callback,
// or there's no more work left with sufficient priority.
// If we're inside a callback, set this to false since we just completed it.
if(isYieldy){callbackExpirationTime=NoWork;callbackID=null;}// If there's work left over, schedule a new callback.
if(nextFlushedExpirationTime!==NoWork){scheduleCallbackWithExpirationTime(nextFlushedRoot,nextFlushedExpirationTime);}// Clean-up.
finishRendering();}function flushRoot(root,expirationTime){!!isRendering?invariant(false,'work.commit(): Cannot commit while already rendering. This likely means you attempted to commit from inside a lifecycle method.'):void 0;// Perform work on root as if the given expiration time is the current time.
// This has the effect of synchronously flushing all work up to and
// including the given time.
nextFlushedRoot=root;nextFlushedExpirationTime=expirationTime;performWorkOnRoot(root,expirationTime,false);// Flush any sync work that was scheduled by lifecycles
performSyncWork();}function finishRendering(){nestedUpdateCount=0;lastCommittedRootDuringThisBatch=null;if(completedBatches!==null){var batches=completedBatches;completedBatches=null;for(var i=0;i<batches.length;i++){var batch=batches[i];try{batch._onComplete();}catch(error){if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}}}if(hasUnhandledError){var error=unhandledError;unhandledError=null;hasUnhandledError=false;throw error;}}function performWorkOnRoot(root,expirationTime,isYieldy){!!isRendering?invariant(false,'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isRendering=true;// Check if this is async work or sync/expired work.
if(!isYieldy){// Flush work without yielding.
// TODO: Non-yieldy work does not necessarily imply expired work. A renderer
// may want to perform some work without yielding, but also without
// requiring the root to complete (by triggering placeholders).
var finishedWork=root.finishedWork;if(finishedWork!==null){// This root is already complete. We can commit it.
completeRoot(root,finishedWork,expirationTime);}else{root.finishedWork=null;// If this root previously suspended, clear its existing timeout, since
// we're about to try rendering again.
var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){root.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
cancelTimeout(timeoutHandle);}renderRoot(root,isYieldy);finishedWork=root.finishedWork;if(finishedWork!==null){// We've completed the root. Commit it.
completeRoot(root,finishedWork,expirationTime);}}}else{// Flush async work.
var _finishedWork=root.finishedWork;if(_finishedWork!==null){// This root is already complete. We can commit it.
completeRoot(root,_finishedWork,expirationTime);}else{root.finishedWork=null;// If this root previously suspended, clear its existing timeout, since
// we're about to try rendering again.
var _timeoutHandle=root.timeoutHandle;if(_timeoutHandle!==noTimeout){root.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
cancelTimeout(_timeoutHandle);}renderRoot(root,isYieldy);_finishedWork=root.finishedWork;if(_finishedWork!==null){// We've completed the root. Check the if we should yield one more time
// before committing.
if(!shouldYieldToRenderer()){// Still time left. Commit the root.
completeRoot(root,_finishedWork,expirationTime);}else{// There's no time left. Mark this root as complete. We'll come
// back and commit it later.
root.finishedWork=_finishedWork;}}}}isRendering=false;}function completeRoot(root,finishedWork,expirationTime){// Check if there's a batch that matches this expiration time.
var firstBatch=root.firstBatch;if(firstBatch!==null&&firstBatch._expirationTime>=expirationTime){if(completedBatches===null){completedBatches=[firstBatch];}else{completedBatches.push(firstBatch);}if(firstBatch._defer){// This root is blocked from committing by a batch. Unschedule it until
// we receive another update.
root.finishedWork=finishedWork;root.expirationTime=NoWork;return;}}// Commit the root.
root.finishedWork=null;// Check if this is a nested update (a sync update scheduled during the
// commit phase).
if(root===lastCommittedRootDuringThisBatch){// If the next root is the same as the previous root, this is a nested
// update. To prevent an infinite loop, increment the nested update count.
nestedUpdateCount++;}else{// Reset whenever we switch roots.
lastCommittedRootDuringThisBatch=root;nestedUpdateCount=0;}scheduler.unstable_runWithPriority(scheduler.unstable_ImmediatePriority,function(){commitRoot(root,finishedWork);});}function onUncaughtError(error){!(nextFlushedRoot!==null)?invariant(false,'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.'):void 0;// Unschedule this root so we don't work on it again until there's
// another update.
nextFlushedRoot.expirationTime=NoWork;if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function batchedUpdates$1(fn,a){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return fn(a);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performSyncWork();}}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function unbatchedUpdates(fn,a){if(isBatchingUpdates&&!isUnbatchingUpdates){isUnbatchingUpdates=true;try{return fn(a);}finally{isUnbatchingUpdates=false;}}return fn(a);}// TODO: Batching should be implemented at the renderer level, not within
// the reconciler.
function flushSync(fn,a){!!isRendering?invariant(false,'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.'):void 0;var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return syncUpdates(fn,a);}finally{isBatchingUpdates=previousIsBatchingUpdates;performSyncWork();}}function interactiveUpdates$1(fn,a,b){// If there are any pending interactive updates, synchronously flush them.
// This needs to happen before we read any handlers, because the effect of
// the previous event may influence which handlers are called during
// this event.
if(!isBatchingUpdates&&!isRendering&&lowestPriorityPendingInteractiveExpirationTime!==NoWork){// Synchronously flush pending interactive updates.
performWork(lowestPriorityPendingInteractiveExpirationTime,false);lowestPriorityPendingInteractiveExpirationTime=NoWork;}var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return scheduler.unstable_runWithPriority(scheduler.unstable_UserBlockingPriority,function(){return fn(a,b);});}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performSyncWork();}}}function flushInteractiveUpdates$1(){if(!isRendering&&lowestPriorityPendingInteractiveExpirationTime!==NoWork){// Synchronously flush pending interactive updates.
performWork(lowestPriorityPendingInteractiveExpirationTime,false);lowestPriorityPendingInteractiveExpirationTime=NoWork;}}function flushControlled(fn){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{syncUpdates(fn);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performSyncWork();}}}// 0 is PROD, 1 is DEV.
// Might add PROFILE later.
var didWarnAboutNestedUpdates=void 0;var didWarnAboutFindNodeInStrictMode=void 0;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function scheduleRootUpdate(current$$1,element,expirationTime,callback){{if(phase==='render'&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;warningWithoutStack$1(false,'Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentName(current.type)||'Unknown');}}var update=createUpdate(expirationTime);// Caution: React DevTools currently depends on this property
// being called "element".
update.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){!(typeof callback==='function')?warningWithoutStack$1(false,'render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback):void 0;update.callback=callback;}flushPassiveEffects();enqueueUpdate(current$$1,update);scheduleWork(current$$1,expirationTime);return expirationTime;}function updateContainerAtExpirationTime(element,container,parentComponent,expirationTime,callback){// TODO: If this is a nested container, this won't be the root.
var current$$1=container.current;{if(ReactFiberInstrumentation_1.debugTool){if(current$$1.alternate===null){ReactFiberInstrumentation_1.debugTool.onMountContainer(container);}else if(element===null){ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);}else{ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);}}}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}return scheduleRootUpdate(current$$1,element,expirationTime,callback);}function findHostInstance(component){var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){invariant(false,'Unable to find node on an unmounted component.');}else{invariant(false,'Argument appears to not be a ReactComponent. Keys: %s',Object.keys(component));}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){invariant(false,'Unable to find node on an unmounted component.');}else{invariant(false,'Argument appears to not be a ReactComponent. Keys: %s',Object.keys(component));}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictMode){var componentName=getComponentName(fiber.type)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;if(fiber.mode&StrictMode){warningWithoutStack$1(false,'%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference.'+'\n%s'+'\n\nLearn more about using refs safely here:'+'\nhttps://fb.me/react-strict-mode-find-node',methodName,methodName,componentName,getStackByFiberInDevAndProd(hostFiber));}else{warningWithoutStack$1(false,'%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference.'+'\n%s'+'\n\nLearn more about using refs safely here:'+'\nhttps://fb.me/react-strict-mode-find-node',methodName,methodName,componentName,getStackByFiberInDevAndProd(hostFiber));}}}return hostFiber.stateNode;}return findHostInstance(component);}function createContainer(containerInfo,isConcurrent,hydrate){return createFiberRoot(containerInfo,isConcurrent,hydrate);}function updateContainer(element,container,parentComponent,callback){var current$$1=container.current;var currentTime=requestCurrentTime();var expirationTime=computeExpirationForFiber(currentTime,current$$1);return updateContainerAtExpirationTime(element,container,parentComponent,expirationTime,callback);}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}var overrideProps=null;{var copyWithSetImpl=function(obj,path,idx,value){if(idx>=path.length){return value;}var key=path[idx];var updated=Array.isArray(obj)?obj.slice():_assign({},obj);// $FlowFixMe number or string is fine here
updated[key]=copyWithSetImpl(obj[key],path,idx+1,value);return updated;};var copyWithSet=function(obj,path,value){return copyWithSetImpl(obj,path,0,value);};// Support DevTools props for function components, forwardRef, memo, host components, etc.
overrideProps=function(fiber,path,value){flushPassiveEffects();fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}scheduleWork(fiber,Sync);};}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals(_assign({},devToolsConfig,{overrideProps:overrideProps,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:function(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;},findFiberByHostInstance:function(instance){if(!findFiberByHostInstance){// Might not be implemented by the renderer.
return null;}return findFiberByHostInstance(instance);}}));}// This file intentionally does *not* have the Flow annotation.
// Don't add it. See `./inline-typed.js` for an explanation.
function createPortal$1(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return{// This tag allow us to uniquely identify this as a React Portal
$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}// TODO: this is special because it gets imported during build.
var ReactVersion='16.8.6';// TODO: This type is shared between the reconciler and ReactDOM, but will
// eventually be lifted out to the renderer.
var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings=void 0;var warnOnInvalidCallback=void 0;var didWarnAboutUnstableCreatePortal=false;{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype
Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype
Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){warningWithoutStack$1(false,'React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://fb.me/react-polyfills');}topLevelUpdateWarnings=function(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer._internalRoot.current);if(hostInstance){!(hostInstance.parentNode===container)?warningWithoutStack$1(false,'render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.'):void 0;}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode$1(rootEl));!(!hasNonRootReactChild||isRootRenderedBySomeReact)?warningWithoutStack$1(false,'render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.'):void 0;!(container.nodeType!==ELEMENT_NODE||!container.tagName||container.tagName.toUpperCase()!=='BODY')?warningWithoutStack$1(false,'render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.'):void 0;};warnOnInvalidCallback=function(callback,callerName){!(callback===null||typeof callback==='function')?warningWithoutStack$1(false,'%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback):void 0;};}setRestoreImplementation(restoreControlledState$1);function ReactBatch(root){var expirationTime=computeUniqueAsyncExpiration();this._expirationTime=expirationTime;this._root=root;this._next=null;this._callbacks=null;this._didComplete=false;this._hasChildren=false;this._children=null;this._defer=true;}ReactBatch.prototype.render=function(children){!this._defer?invariant(false,'batch.render: Cannot render a batch that already committed.'):void 0;this._hasChildren=true;this._children=children;var internalRoot=this._root._internalRoot;var expirationTime=this._expirationTime;var work=new ReactWork();updateContainerAtExpirationTime(children,internalRoot,null,expirationTime,work._onCommit);return work;};ReactBatch.prototype.then=function(onComplete){if(this._didComplete){onComplete();return;}var callbacks=this._callbacks;if(callbacks===null){callbacks=this._callbacks=[];}callbacks.push(onComplete);};ReactBatch.prototype.commit=function(){var internalRoot=this._root._internalRoot;var firstBatch=internalRoot.firstBatch;!(this._defer&&firstBatch!==null)?invariant(false,'batch.commit: Cannot commit a batch multiple times.'):void 0;if(!this._hasChildren){// This batch is empty. Return.
this._next=null;this._defer=false;return;}var expirationTime=this._expirationTime;// Ensure this is the first batch in the list.
if(firstBatch!==this){// This batch is not the earliest batch. We need to move it to the front.
// Update its expiration time to be the expiration time of the earliest
// batch, so that we can flush it without flushing the other batches.
if(this._hasChildren){expirationTime=this._expirationTime=firstBatch._expirationTime;// Rendering this batch again ensures its children will be the final state
// when we flush (updates are processed in insertion order: last
// update wins).
// TODO: This forces a restart. Should we print a warning?
this.render(this._children);}// Remove the batch from the list.
var previous=null;var batch=firstBatch;while(batch!==this){previous=batch;batch=batch._next;}!(previous!==null)?invariant(false,'batch.commit: Cannot commit a batch multiple times.'):void 0;previous._next=batch._next;// Add it to the front.
this._next=firstBatch;firstBatch=internalRoot.firstBatch=this;}// Synchronously flush all the work up to this batch's expiration time.
this._defer=false;flushRoot(internalRoot,expirationTime);// Pop the batch from the list.
var next=this._next;this._next=null;firstBatch=internalRoot.firstBatch=next;// Append the next earliest batch's children to the update queue.
if(firstBatch!==null&&firstBatch._hasChildren){firstBatch.render(firstBatch._children);}};ReactBatch.prototype._onComplete=function(){if(this._didComplete){return;}this._didComplete=true;var callbacks=this._callbacks;if(callbacks===null){return;}// TODO: Error handling.
for(var i=0;i<callbacks.length;i++){var _callback=callbacks[i];_callback();}};function ReactWork(){this._callbacks=null;this._didCommit=false;// TODO: Avoid need to bind by replacing callbacks in the update queue with
// list of Work objects.
this._onCommit=this._onCommit.bind(this);}ReactWork.prototype.then=function(onCommit){if(this._didCommit){onCommit();return;}var callbacks=this._callbacks;if(callbacks===null){callbacks=this._callbacks=[];}callbacks.push(onCommit);};ReactWork.prototype._onCommit=function(){if(this._didCommit){return;}this._didCommit=true;var callbacks=this._callbacks;if(callbacks===null){return;}// TODO: Error handling.
for(var i=0;i<callbacks.length;i++){var _callback2=callbacks[i];!(typeof _callback2==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',_callback2):void 0;_callback2();}};function ReactRoot(container,isConcurrent,hydrate){var root=createContainer(container,isConcurrent,hydrate);this._internalRoot=root;}ReactRoot.prototype.render=function(children,callback){var root=this._internalRoot;var work=new ReactWork();callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'render');}if(callback!==null){work.then(callback);}updateContainer(children,root,null,work._onCommit);return work;};ReactRoot.prototype.unmount=function(callback){var root=this._internalRoot;var work=new ReactWork();callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'render');}if(callback!==null){work.then(callback);}updateContainer(null,root,null,work._onCommit);return work;};ReactRoot.prototype.legacy_renderSubtreeIntoContainer=function(parentComponent,children,callback){var root=this._internalRoot;var work=new ReactWork();callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'render');}if(callback!==null){work.then(callback);}updateContainer(children,root,parentComponent,work._onCommit);return work;};ReactRoot.prototype.createBatch=function(){var batch=new ReactBatch(this);var expirationTime=batch._expirationTime;var internalRoot=this._internalRoot;var firstBatch=internalRoot.firstBatch;if(firstBatch===null){internalRoot.firstBatch=batch;batch._next=null;}else{// Insert sorted by expiration time then insertion order
var insertAfter=null;var insertBefore=firstBatch;while(insertBefore!==null&&insertBefore._expirationTime>=expirationTime){insertAfter=insertBefore;insertBefore=insertBefore._next;}batch._next=insertBefore;if(insertAfter!==null){insertAfter._next=batch;}}return batch;};/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function shouldHydrateDueToLegacyHeuristic(container){var rootElement=getReactRootElementInContainer(container);return!!(rootElement&&rootElement.nodeType===ELEMENT_NODE&&rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));}setBatchingImplementation(batchedUpdates$1,interactiveUpdates$1,flushInteractiveUpdates$1);var warnedAboutHydrateAPI=false;function legacyCreateRootFromDOMContainer(container,forceHydrate){var shouldHydrate=forceHydrate||shouldHydrateDueToLegacyHeuristic(container);// First clear any existing content.
if(!shouldHydrate){var warned=false;var rootSibling=void 0;while(rootSibling=container.lastChild){{if(!warned&&rootSibling.nodeType===ELEMENT_NODE&&rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)){warned=true;warningWithoutStack$1(false,'render(): Target node has markup rendered by React, but there '+'are unrelated nodes as well. This is most commonly caused by '+'white-space inserted around server-rendered markup.');}}container.removeChild(rootSibling);}}{if(shouldHydrate&&!forceHydrate&&!warnedAboutHydrateAPI){warnedAboutHydrateAPI=true;lowPriorityWarning$1(false,'render(): Calling ReactDOM.render() to hydrate server-rendered markup '+'will stop working in React v17. Replace the ReactDOM.render() call '+'with ReactDOM.hydrate() if you want React to attach to the server HTML.');}}// Legacy roots are not async by default.
var isConcurrent=false;return new ReactRoot(container,isConcurrent,shouldHydrate);}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);}// TODO: Without `any` type, Flow says "Property cannot be accessed on any
// member of intersection type." Whyyyyyy.
var root=container._reactRootContainer;if(!root){// Initial mount
root=container._reactRootContainer=legacyCreateRootFromDOMContainer(container,forceHydrate);if(typeof callback==='function'){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root._internalRoot);originalCallback.call(instance);};}// Initial mount should not be batched.
unbatchedUpdates(function(){if(parentComponent!=null){root.legacy_renderSubtreeIntoContainer(parentComponent,children,callback);}else{root.render(children,callback);}});}else{if(typeof callback==='function'){var _originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root._internalRoot);_originalCallback.call(instance);};}// Update
if(parentComponent!=null){root.legacy_renderSubtreeIntoContainer(parentComponent,children,callback);}else{root.render(children,callback);}}return getPublicRootInstance(root._internalRoot);}function createPortal$$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;// TODO: pass ReactDOM portal implementation as third argument
return createPortal$1(children,container,null,key);}var ReactDOM={createPortal:createPortal$$1,findDOMNode:function(componentOrElement){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;!warnedAboutRefsInRender?warningWithoutStack$1(false,'%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(owner.type)||'A component'):void 0;owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}return findHostInstance(componentOrElement);},hydrate:function(element,container,callback){!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;{!!container._reactHasBeenPassedToCreateRootDEV?warningWithoutStack$1(false,'You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOM.%s(). This is not supported. '+'Did you mean to call createRoot(container, {hydrate: true}).render(element)?',enableStableConcurrentModeAPIs?'createRoot':'unstable_createRoot'):void 0;}// TODO: throw or warn if we couldn't hydrate?
return legacyRenderSubtreeIntoContainer(null,element,container,true,callback);},render:function(element,container,callback){!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;{!!container._reactHasBeenPassedToCreateRootDEV?warningWithoutStack$1(false,'You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOM.%s(). This is not supported. '+'Did you mean to call root.render(element)?',enableStableConcurrentModeAPIs?'createRoot':'unstable_createRoot'):void 0;}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);},unstable_renderSubtreeIntoContainer:function(parentComponent,element,containerNode,callback){!isValidContainer(containerNode)?invariant(false,'Target container is not a DOM element.'):void 0;!(parentComponent!=null&&has(parentComponent))?invariant(false,'parentComponent must be a valid React Component'):void 0;return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);},unmountComponentAtNode:function(container){!isValidContainer(container)?invariant(false,'unmountComponentAtNode(...): Target container is not a DOM element.'):void 0;{!!container._reactHasBeenPassedToCreateRootDEV?warningWithoutStack$1(false,'You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOM.%s(). This is not supported. Did you mean to call root.unmount()?',enableStableConcurrentModeAPIs?'createRoot':'unstable_createRoot'):void 0;}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode$1(rootEl);!!renderedByDifferentReact?warningWithoutStack$1(false,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.'):void 0;}// Unmount should not be batched.
unbatchedUpdates(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){container._reactRootContainer=null;});});// If you call unmountComponentAtNode twice in quick succession, you'll
// get `true` twice. That's probably fine?
return true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode$1(_rootEl));// Check if the container itself is a React root node.
var isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainer(container.parentNode)&&!!container.parentNode._reactRootContainer;!!hasNonRootReactChild?warningWithoutStack$1(false,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.'):void 0;}return false;}},// Temporary alias since we already shipped React 16 RC with it.
// TODO: remove in React 17.
unstable_createPortal:function(){if(!didWarnAboutUnstableCreatePortal){didWarnAboutUnstableCreatePortal=true;lowPriorityWarning$1(false,'The ReactDOM.unstable_createPortal() alias has been deprecated, '+'and will be removed in React 17+. Update your code to use '+'ReactDOM.createPortal() instead. It has the exact same API, '+'but without the "unstable_" prefix.');}return createPortal$$1.apply(undefined,arguments);},unstable_batchedUpdates:batchedUpdates$1,unstable_interactiveUpdates:interactiveUpdates$1,flushSync:flushSync,unstable_createRoot:createRoot,unstable_flushControlled:flushControlled,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{// Keep in sync with ReactDOMUnstableNativeDependencies.js
// and ReactTestUtils.js. This is an array for better minification.
Events:[getInstanceFromNode$1,getNodeFromInstance$1,getFiberCurrentPropsFromNode$1,injection.injectEventPluginsByName,eventNameDispatchConfigs,accumulateTwoPhaseDispatches,accumulateDirectDispatches,enqueueStateRestore,restoreStateIfNeeded,dispatchEvent,runEventsInBatch]}};function createRoot(container,options){var functionName=enableStableConcurrentModeAPIs?'createRoot':'unstable_createRoot';!isValidContainer(container)?invariant(false,'%s(...): Target container is not a DOM element.',functionName):void 0;{!!container._reactRootContainer?warningWithoutStack$1(false,'You are calling ReactDOM.%s() on a container that was previously '+'passed to ReactDOM.render(). This is not supported.',enableStableConcurrentModeAPIs?'createRoot':'unstable_createRoot'):void 0;container._reactHasBeenPassedToCreateRootDEV=true;}var hydrate=options!=null&&options.hydrate===true;return new ReactRoot(container,true,hydrate);}if(enableStableConcurrentModeAPIs){ReactDOM.createRoot=createRoot;ReactDOM.unstable_createRoot=undefined;}var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
if(/^(https?|file):$/.test(protocol)){console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://fb.me/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://fb.me/react-devtools-faq':''),'font-weight:bold');}}}}var ReactDOM$2=Object.freeze({default:ReactDOM});var ReactDOM$3=ReactDOM$2&&ReactDOM||ReactDOM$2;// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom=ReactDOM$3.default||ReactDOM$3;module.exports=reactDom;})();}

/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!*****************************************!*\
  !*** ./node_modules/react-dom/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }

  if (true) {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }

  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-dom.development.js */ "./node_modules/react-dom/cjs/react-dom.development.js");
}

/***/ }),

/***/ "./node_modules/react/cjs/react.development.js":
/*!*****************************************************!*\
  !*** ./node_modules/react/cjs/react.development.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.8.6
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


if (true) {
  (function () {
    'use strict';

    var _assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

    var checkPropTypes = __webpack_require__(/*! prop-types/checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js"); // TODO: this is special because it gets imported during build.


    var ReactVersion = '16.8.6'; // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.

    var hasSymbol = typeof Symbol === 'function' && Symbol.for;
    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
    var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
    var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
    var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
    var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace;
    var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
    var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
    var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable !== 'object') {
        return null;
      }

      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }

      return null;
    }
    /**
     * Use invariant() to assert state which your program assumes to be true.
     *
     * Provide sprintf-style format (only %s is supported) and arguments
     * to provide information about what broke and what you were
     * expecting.
     *
     * The invariant message will be stripped in production, but the invariant
     * will remain to ensure logic does not differ in production.
     */


    var validateFormat = function () {};

    {
      validateFormat = function (format) {
        if (format === undefined) {
          throw new Error('invariant requires an error message argument');
        }
      };
    }

    function invariant(condition, format, a, b, c, d, e, f) {
      validateFormat(format);

      if (!condition) {
        var error = void 0;

        if (format === undefined) {
          error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(format.replace(/%s/g, function () {
            return args[argIndex++];
          }));
          error.name = 'Invariant Violation';
        }

        error.framesToPop = 1; // we don't care about invariant's own frame

        throw error;
      }
    } // Relying on the `invariant()` implementation lets us
    // preserve the format and params in the www builds.

    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */


    var lowPriorityWarning = function () {};

    {
      var printWarning = function (format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });

        if (typeof console !== 'undefined') {
          console.warn(message);
        }

        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function (condition, format) {
        if (format === undefined) {
          throw new Error('`lowPriorityWarning(condition, format, ...args)` requires a warning ' + 'message argument');
        }

        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }
    var lowPriorityWarning$1 = lowPriorityWarning;
    /**
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var warningWithoutStack = function () {};

    {
      warningWithoutStack = function (condition, format) {
        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        if (format === undefined) {
          throw new Error('`warningWithoutStack(condition, format, ...args)` requires a warning ' + 'message argument');
        }

        if (args.length > 8) {
          // Check before the condition to catch violations early.
          throw new Error('warningWithoutStack() currently supports at most 8 arguments.');
        }

        if (condition) {
          return;
        }

        if (typeof console !== 'undefined') {
          var argsWithFormat = args.map(function (item) {
            return '' + item;
          });
          argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
          // breaks IE9: https://github.com/facebook/react/issues/13610

          Function.prototype.apply.call(console.error, console, argsWithFormat);
        }

        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          var argIndex = 0;
          var message = 'Warning: ' + format.replace(/%s/g, function () {
            return args[argIndex++];
          });
          throw new Error(message);
        } catch (x) {}
      };
    }
    var warningWithoutStack$1 = warningWithoutStack;
    var didWarnStateUpdateForUnmountedComponent = {};

    function warnNoop(publicInstance, callerName) {
      {
        var _constructor = publicInstance.constructor;
        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';
        var warningKey = componentName + '.' + callerName;

        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          return;
        }

        warningWithoutStack$1(false, "Can't call %s on a component that is not yet mounted. " + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
      }
    }
    /**
     * This is the abstract API for an update queue.
     */


    var ReactNoopUpdateQueue = {
      /**
       * Checks whether or not this composite component is mounted.
       * @param {ReactClass} publicInstance The instance we want to test.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function (publicInstance) {
        return false;
      },

      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueForceUpdate: function (publicInstance, callback, callerName) {
        warnNoop(publicInstance, 'forceUpdate');
      },

      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} completeState Next state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
        warnNoop(publicInstance, 'replaceState');
      },

      /**
       * Sets a subset of the state. This only exists because _pendingState is
       * internal. This provides a merging strategy that is not available to deep
       * properties which is confusing. TODO: Expose pendingState or don't use it
       * during the merge.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} Name of the calling function in the public API.
       * @internal
       */
      enqueueSetState: function (publicInstance, partialState, callback, callerName) {
        warnNoop(publicInstance, 'setState');
      }
    };
    var emptyObject = {};
    {
      Object.freeze(emptyObject);
    }
    /**
     * Base class helpers for the updating state of a component.
     */

    function Component(props, context, updater) {
      this.props = props;
      this.context = context; // If a component has string refs, we will assign a different object later.

      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
      // renderer.

      this.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};
    /**
     * Sets a subset of the state. Always use this to mutate
     * state. You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * There is no guarantee that calls to `setState` will run synchronously,
     * as they may eventually be batched together.  You can provide an optional
     * callback that will be executed when the call to setState is actually
     * completed.
     *
     * When a function is provided to setState, it will be called at some point in
     * the future (not synchronously). It will be called with the up to date
     * component arguments (state, props, context). These values can be different
     * from this.* because your function may be called after receiveProps but before
     * shouldComponentUpdate, and this new state, props, and context will not yet be
     * assigned to this.
     *
     * @param {object|function} partialState Next partial state or function to
     *        produce next partial state to be merged with current state.
     * @param {?function} callback Called after state is updated.
     * @final
     * @protected
     */

    Component.prototype.setState = function (partialState, callback) {
      !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
      this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };
    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {?function} callback Called after update is complete.
     * @final
     * @protected
     */


    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };
    /**
     * Deprecated APIs. These APIs used to exist on classic React classes but since
     * we would like to deprecate them, we're not going to move them over to this
     * modern base class. Instead, we define a getter that warns if it's accessed.
     */


    {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };

      var defineDeprecationWarning = function (methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function () {
            lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
            return undefined;
          }
        });
      };

      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }

    function ComponentDummy() {}

    ComponentDummy.prototype = Component.prototype;
    /**
     * Convenience component with default shallow equality check for sCU.
     */

    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context; // If a component has string refs, we will assign a different object later.

      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }

    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

    _assign(pureComponentPrototype, Component.prototype);

    pureComponentPrototype.isPureReactComponent = true; // an immutable object with a single mutable value

    function createRef() {
      var refObject = {
        current: null
      };
      {
        Object.seal(refObject);
      }
      return refObject;
    }
    /**
     * Keeps track of the current dispatcher.
     */


    var ReactCurrentDispatcher = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };
    /**
     * Keeps track of the current owner.
     *
     * The current owner is the component who should own any components that are
     * currently being constructed.
     */

    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };
    var BEFORE_SLASH_RE = /^(.*)[\\\/]/;

    var describeComponentFrame = function (name, source, ownerName) {
      var sourceInfo = '';

      if (source) {
        var path = source.fileName;
        var fileName = path.replace(BEFORE_SLASH_RE, '');
        {
          // In DEV, include code for a common special case:
          // prefer "folder/index.js" instead of just "index.js".
          if (/^index\./.test(fileName)) {
            var match = path.match(BEFORE_SLASH_RE);

            if (match) {
              var pathBeforeSlash = match[1];

              if (pathBeforeSlash) {
                var folderName = pathBeforeSlash.replace(BEFORE_SLASH_RE, '');
                fileName = folderName + '/' + fileName;
              }
            }
          }
        }
        sourceInfo = ' (at ' + fileName + ':' + source.lineNumber + ')';
      } else if (ownerName) {
        sourceInfo = ' (created by ' + ownerName + ')';
      }

      return '\n    in ' + (name || 'Unknown') + sourceInfo;
    };

    var Resolved = 1;

    function refineResolvedLazyComponent(lazyComponent) {
      return lazyComponent._status === Resolved ? lazyComponent._result : null;
    }

    function getWrappedName(outerType, innerType, wrapperName) {
      var functionName = innerType.displayName || innerType.name || '';
      return outerType.displayName || (functionName !== '' ? wrapperName + '(' + functionName + ')' : wrapperName);
    }

    function getComponentName(type) {
      if (type == null) {
        // Host root, text node or just invalid type.
        return null;
      }

      {
        if (typeof type.tag === 'number') {
          warningWithoutStack$1(false, 'Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');
        }
      }

      if (typeof type === 'function') {
        return type.displayName || type.name || null;
      }

      if (typeof type === 'string') {
        return type;
      }

      switch (type) {
        case REACT_CONCURRENT_MODE_TYPE:
          return 'ConcurrentMode';

        case REACT_FRAGMENT_TYPE:
          return 'Fragment';

        case REACT_PORTAL_TYPE:
          return 'Portal';

        case REACT_PROFILER_TYPE:
          return 'Profiler';

        case REACT_STRICT_MODE_TYPE:
          return 'StrictMode';

        case REACT_SUSPENSE_TYPE:
          return 'Suspense';
      }

      if (typeof type === 'object') {
        switch (type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            return 'Context.Consumer';

          case REACT_PROVIDER_TYPE:
            return 'Context.Provider';

          case REACT_FORWARD_REF_TYPE:
            return getWrappedName(type, type.render, 'ForwardRef');

          case REACT_MEMO_TYPE:
            return getComponentName(type.type);

          case REACT_LAZY_TYPE:
            {
              var thenable = type;
              var resolvedThenable = refineResolvedLazyComponent(thenable);

              if (resolvedThenable) {
                return getComponentName(resolvedThenable);
              }
            }
        }
      }

      return null;
    }

    var ReactDebugCurrentFrame = {};
    var currentlyValidatingElement = null;

    function setCurrentlyValidatingElement(element) {
      {
        currentlyValidatingElement = element;
      }
    }

    {
      // Stack implementation injected by the current renderer.
      ReactDebugCurrentFrame.getCurrentStack = null;

      ReactDebugCurrentFrame.getStackAddendum = function () {
        var stack = ''; // Add an extra top frame while an element is being validated

        if (currentlyValidatingElement) {
          var name = getComponentName(currentlyValidatingElement.type);
          var owner = currentlyValidatingElement._owner;
          stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner.type));
        } // Delegate to the injected renderer-specific implementation


        var impl = ReactDebugCurrentFrame.getCurrentStack;

        if (impl) {
          stack += impl() || '';
        }

        return stack;
      };
    }
    var ReactSharedInternals = {
      ReactCurrentDispatcher: ReactCurrentDispatcher,
      ReactCurrentOwner: ReactCurrentOwner,
      // Used by renderers to avoid bundling object-assign twice in UMD bundles:
      assign: _assign
    };
    {
      _assign(ReactSharedInternals, {
        // These should not be included in production.
        ReactDebugCurrentFrame: ReactDebugCurrentFrame,
        // Shim for React DOM 16.0.0 which still destructured (but not used) this.
        // TODO: remove in React 17.0.
        ReactComponentTreeHook: {}
      });
    }
    /**
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var warning = warningWithoutStack$1;
    {
      warning = function (condition, format) {
        if (condition) {
          return;
        }

        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        var stack = ReactDebugCurrentFrame.getStackAddendum(); // eslint-disable-next-line react-internal/warning-and-invariant-args

        for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        warningWithoutStack$1.apply(undefined, [false, format + '%s'].concat(args, [stack]));
      };
    }
    var warning$1 = warning;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var specialPropKeyWarningShown = void 0;
    var specialPropRefWarningShown = void 0;

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }

    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function () {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          warningWithoutStack$1(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };

      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }

    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function () {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          warningWithoutStack$1(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };

      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }
    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, no instanceof check
     * will work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} key
     * @param {string|object} ref
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @param {*} owner
     * @param {*} props
     * @internal
     */


    var ReactElement = function (type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,
        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,
        // Record the component responsible for creating this element.
        _owner: owner
      };
      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.

        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        }); // self and source are DEV only properties.

        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.

        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });

        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }
      return element;
    };
    /**
     * Create and return a new ReactElement of the given type.
     * See https://reactjs.org/docs/react-api.html#createelement
     */


    function createElement(type, config, children) {
      var propName = void 0; // Reserved names are extracted

      var props = {};
      var key = null;
      var ref = null;
      var self = null;
      var source = null;

      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }

        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      } // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.


      var childrenLength = arguments.length - 2;

      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);

        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }

        {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      } // Resolve default props


      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;

        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }

      {
        if (key || ref) {
          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

          if (key) {
            defineKeyPropWarningGetter(props, displayName);
          }

          if (ref) {
            defineRefPropWarningGetter(props, displayName);
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }
    /**
     * Return a function that produces ReactElements of a given type.
     * See https://reactjs.org/docs/react-api.html#createfactory
     */


    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
      return newElement;
    }
    /**
     * Clone and return a new ReactElement using element as the starting point.
     * See https://reactjs.org/docs/react-api.html#cloneelement
     */


    function cloneElement(element, config, children) {
      !!(element === null || element === undefined) ? invariant(false, 'React.cloneElement(...): The argument must be a React element, but you passed %s.', element) : void 0;
      var propName = void 0; // Original props are copied

      var props = _assign({}, element.props); // Reserved names are extracted


      var key = element.key;
      var ref = element.ref; // Self is preserved since the owner is preserved.

      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
      // transpiler, and the original source is probably a better indicator of the
      // true owner.

      var source = element._source; // Owner will be preserved, unless ref is overridden

      var owner = element._owner;

      if (config != null) {
        if (hasValidRef(config)) {
          // Silently steal the ref from the parent.
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }

        if (hasValidKey(config)) {
          key = '' + config.key;
        } // Remaining properties override existing props


        var defaultProps = void 0;

        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              // Resolve default props
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      } // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.


      var childrenLength = arguments.length - 2;

      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);

        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }

        props.children = childArray;
      }

      return ReactElement(element.type, key, ref, self, source, owner, props);
    }
    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a ReactElement.
     * @final
     */


    function isValidElement(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    /**
     * Escape and wrap key so it is safe to use as a reactid
     *
     * @param {string} key to be escaped.
     * @return {string} the escaped key.
     */

    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = {
        '=': '=0',
        ':': '=2'
      };
      var escapedString = ('' + key).replace(escapeRegex, function (match) {
        return escaperLookup[match];
      });
      return '$' + escapedString;
    }
    /**
     * TODO: Test that a single child and an array with one item have the same key
     * pattern.
     */


    var didWarnAboutMaps = false;
    var userProvidedKeyEscapeRegex = /\/+/g;

    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
    }

    var POOL_SIZE = 10;
    var traverseContextPool = [];

    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
      if (traverseContextPool.length) {
        var traverseContext = traverseContextPool.pop();
        traverseContext.result = mapResult;
        traverseContext.keyPrefix = keyPrefix;
        traverseContext.func = mapFunction;
        traverseContext.context = mapContext;
        traverseContext.count = 0;
        return traverseContext;
      } else {
        return {
          result: mapResult,
          keyPrefix: keyPrefix,
          func: mapFunction,
          context: mapContext,
          count: 0
        };
      }
    }

    function releaseTraverseContext(traverseContext) {
      traverseContext.result = null;
      traverseContext.keyPrefix = null;
      traverseContext.func = null;
      traverseContext.context = null;
      traverseContext.count = 0;

      if (traverseContextPool.length < POOL_SIZE) {
        traverseContextPool.push(traverseContext);
      }
    }
    /**
     * @param {?*} children Children tree container.
     * @param {!string} nameSoFar Name of the key path so far.
     * @param {!function} callback Callback to invoke with each child found.
     * @param {?*} traverseContext Used to pass information throughout the traversal
     * process.
     * @return {!number} The number of children in this subtree.
     */


    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children;

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      var invokeCallback = false;

      if (children === null) {
        invokeCallback = true;
      } else {
        switch (type) {
          case 'string':
          case 'number':
            invokeCallback = true;
            break;

          case 'object':
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
            }

        }
      }

      if (invokeCallback) {
        callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array
        // so that it's consistent if the number of children grows.
        nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }

      var child = void 0;
      var nextName = void 0;
      var subtreeCount = 0; // Count of children found in the current subtree.

      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);

        if (typeof iteratorFn === 'function') {
          {
            // Warn about using Maps as children
            if (iteratorFn === children.entries) {
              !didWarnAboutMaps ? warning$1(false, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.') : void 0;
              didWarnAboutMaps = true;
            }
          }
          var iterator = iteratorFn.call(children);
          var step = void 0;
          var ii = 0;

          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else if (type === 'object') {
          var addendum = '';
          {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
          }
          var childrenString = '' + children;
          invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
        }
      }

      return subtreeCount;
    }
    /**
     * Traverses children that are typically specified as `props.children`, but
     * might also be specified through attributes:
     *
     * - `traverseAllChildren(this.props.children, ...)`
     * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
     *
     * The `traverseContext` is an optional argument that is passed through the
     * entire traversal. It can be used to store accumulations or anything else that
     * the callback might find relevant.
     *
     * @param {?*} children Children tree object.
     * @param {!function} callback To invoke upon traversing each child.
     * @param {?*} traverseContext Context for traversal.
     * @return {!number} The number of children in this subtree.
     */


    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }

      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }
    /**
     * Generate a key string that identifies a component within a set.
     *
     * @param {*} component A component that could contain a manual key.
     * @param {number} index Index that is used if a manual key is not provided.
     * @return {string}
     */


    function getComponentKey(component, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if (typeof component === 'object' && component !== null && component.key != null) {
        // Explicit key
        return escape(component.key);
      } // Implicit key determined by the index in the set


      return index.toString(36);
    }

    function forEachSingleChild(bookKeeping, child, name) {
      var func = bookKeeping.func,
          context = bookKeeping.context;
      func.call(context, child, bookKeeping.count++);
    }
    /**
     * Iterates through children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach
     *
     * The provided forEachFunc(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} forEachFunc
     * @param {*} forEachContext Context for forEachContext.
     */


    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }

      var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
      var result = bookKeeping.result,
          keyPrefix = bookKeeping.keyPrefix,
          func = bookKeeping.func,
          context = bookKeeping.context;
      var mappedChild = func.call(context, child, bookKeeping.count++);

      if (Array.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, function (c) {
          return c;
        });
      } else if (mappedChild != null) {
        if (isValidElement(mappedChild)) {
          mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
          // traverseAllChildren used to do for objects as children
          keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
        }

        result.push(mappedChild);
      }
    }

    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
      var escapedPrefix = '';

      if (prefix != null) {
        escapedPrefix = escapeUserProvidedKey(prefix) + '/';
      }

      var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      releaseTraverseContext(traverseContext);
    }
    /**
     * Maps children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrenmap
     *
     * The provided mapFunction(child, key, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} func The map function.
     * @param {*} context Context for mapFunction.
     * @return {object} Object containing the ordered map of results.
     */


    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }

      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, func, context);
      return result;
    }
    /**
     * Count the number of children that are typically specified as
     * `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrencount
     *
     * @param {?*} children Children tree container.
     * @return {number} The number of children.
     */


    function countChildren(children) {
      return traverseAllChildren(children, function () {
        return null;
      }, null);
    }
    /**
     * Flatten a children object (typically specified as `props.children`) and
     * return an array with appropriately re-keyed children.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray
     */


    function toArray(children) {
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, function (child) {
        return child;
      });
      return result;
    }
    /**
     * Returns the first child in a collection of children and verifies that there
     * is only one child in the collection.
     *
     * See https://reactjs.org/docs/react-api.html#reactchildrenonly
     *
     * The current implementation of this function assumes that a single child gets
     * passed without a wrapper, but the purpose of this helper function is to
     * abstract away the particular structure of children.
     *
     * @param {?object} children Child collection structure.
     * @return {ReactElement} The first and only `ReactElement` contained in the
     * structure.
     */


    function onlyChild(children) {
      !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
      return children;
    }

    function createContext(defaultValue, calculateChangedBits) {
      if (calculateChangedBits === undefined) {
        calculateChangedBits = null;
      } else {
        {
          !(calculateChangedBits === null || typeof calculateChangedBits === 'function') ? warningWithoutStack$1(false, 'createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits) : void 0;
        }
      }

      var context = {
        $$typeof: REACT_CONTEXT_TYPE,
        _calculateChangedBits: calculateChangedBits,
        // As a workaround to support multiple concurrent renderers, we categorize
        // some renderers as primary and others as secondary. We only expect
        // there to be two concurrent renderers at most: React Native (primary) and
        // Fabric (secondary); React DOM (primary) and React ART (secondary).
        // Secondary renderers store their context values on separate fields.
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        // Used to track how many concurrent renderers this context currently
        // supports within in a single renderer. Such as parallel server rendering.
        _threadCount: 0,
        // These are circular
        Provider: null,
        Consumer: null
      };
      context.Provider = {
        $$typeof: REACT_PROVIDER_TYPE,
        _context: context
      };
      var hasWarnedAboutUsingNestedContextConsumers = false;
      var hasWarnedAboutUsingConsumerProvider = false;
      {
        // A separate object, but proxies back to the original context object for
        // backwards compatibility. It has a different $$typeof, so we can properly
        // warn for the incorrect usage of Context as a Consumer.
        var Consumer = {
          $$typeof: REACT_CONTEXT_TYPE,
          _context: context,
          _calculateChangedBits: context._calculateChangedBits
        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here

        Object.defineProperties(Consumer, {
          Provider: {
            get: function () {
              if (!hasWarnedAboutUsingConsumerProvider) {
                hasWarnedAboutUsingConsumerProvider = true;
                warning$1(false, 'Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');
              }

              return context.Provider;
            },
            set: function (_Provider) {
              context.Provider = _Provider;
            }
          },
          _currentValue: {
            get: function () {
              return context._currentValue;
            },
            set: function (_currentValue) {
              context._currentValue = _currentValue;
            }
          },
          _currentValue2: {
            get: function () {
              return context._currentValue2;
            },
            set: function (_currentValue2) {
              context._currentValue2 = _currentValue2;
            }
          },
          _threadCount: {
            get: function () {
              return context._threadCount;
            },
            set: function (_threadCount) {
              context._threadCount = _threadCount;
            }
          },
          Consumer: {
            get: function () {
              if (!hasWarnedAboutUsingNestedContextConsumers) {
                hasWarnedAboutUsingNestedContextConsumers = true;
                warning$1(false, 'Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');
              }

              return context.Consumer;
            }
          }
        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty

        context.Consumer = Consumer;
      }
      {
        context._currentRenderer = null;
        context._currentRenderer2 = null;
      }
      return context;
    }

    function lazy(ctor) {
      var lazyType = {
        $$typeof: REACT_LAZY_TYPE,
        _ctor: ctor,
        // React uses these fields to store the result.
        _status: -1,
        _result: null
      };
      {
        // In production, this would just set it on the object.
        var defaultProps = void 0;
        var propTypes = void 0;
        Object.defineProperties(lazyType, {
          defaultProps: {
            configurable: true,
            get: function () {
              return defaultProps;
            },
            set: function (newDefaultProps) {
              warning$1(false, 'React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
              defaultProps = newDefaultProps; // Match production behavior more closely:

              Object.defineProperty(lazyType, 'defaultProps', {
                enumerable: true
              });
            }
          },
          propTypes: {
            configurable: true,
            get: function () {
              return propTypes;
            },
            set: function (newPropTypes) {
              warning$1(false, 'React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');
              propTypes = newPropTypes; // Match production behavior more closely:

              Object.defineProperty(lazyType, 'propTypes', {
                enumerable: true
              });
            }
          }
        });
      }
      return lazyType;
    }

    function forwardRef(render) {
      {
        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
          warningWithoutStack$1(false, 'forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');
        } else if (typeof render !== 'function') {
          warningWithoutStack$1(false, 'forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);
        } else {
          !( // Do not warn for 0 arguments because it could be due to usage of the 'arguments' object
          render.length === 0 || render.length === 2) ? warningWithoutStack$1(false, 'forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.') : void 0;
        }

        if (render != null) {
          !(render.defaultProps == null && render.propTypes == null) ? warningWithoutStack$1(false, 'forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?') : void 0;
        }
      }
      return {
        $$typeof: REACT_FORWARD_REF_TYPE,
        render: render
      };
    }

    function isValidElementType(type) {
      return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE);
    }

    function memo(type, compare) {
      {
        if (!isValidElementType(type)) {
          warningWithoutStack$1(false, 'memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);
        }
      }
      return {
        $$typeof: REACT_MEMO_TYPE,
        type: type,
        compare: compare === undefined ? null : compare
      };
    }

    function resolveDispatcher() {
      var dispatcher = ReactCurrentDispatcher.current;
      !(dispatcher !== null) ? invariant(false, 'Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://fb.me/react-invalid-hook-call for tips about how to debug and fix this problem.') : void 0;
      return dispatcher;
    }

    function useContext(Context, unstable_observedBits) {
      var dispatcher = resolveDispatcher();
      {
        !(unstable_observedBits === undefined) ? warning$1(false, 'useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\n\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://fb.me/rules-of-hooks' : '') : void 0; // TODO: add a more generic warning for invalid values.

        if (Context._context !== undefined) {
          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs
          // and nobody should be using this in existing code.

          if (realContext.Consumer === Context) {
            warning$1(false, 'Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');
          } else if (realContext.Provider === Context) {
            warning$1(false, 'Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');
          }
        }
      }
      return dispatcher.useContext(Context, unstable_observedBits);
    }

    function useState(initialState) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useState(initialState);
    }

    function useReducer(reducer, initialArg, init) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useReducer(reducer, initialArg, init);
    }

    function useRef(initialValue) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useRef(initialValue);
    }

    function useEffect(create, inputs) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useEffect(create, inputs);
    }

    function useLayoutEffect(create, inputs) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useLayoutEffect(create, inputs);
    }

    function useCallback(callback, inputs) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useCallback(callback, inputs);
    }

    function useMemo(create, inputs) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useMemo(create, inputs);
    }

    function useImperativeHandle(ref, create, inputs) {
      var dispatcher = resolveDispatcher();
      return dispatcher.useImperativeHandle(ref, create, inputs);
    }

    function useDebugValue(value, formatterFn) {
      {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDebugValue(value, formatterFn);
      }
    }
    /**
     * ReactElementValidator provides a wrapper around a element factory
     * which validates the props passed to the element. This is intended to be
     * used only in DEV and could be replaced by a static type checker for languages
     * that support it.
     */


    var propTypesMisspellWarningShown = void 0;
    {
      propTypesMisspellWarningShown = false;
    }

    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = getComponentName(ReactCurrentOwner.current.type);

        if (name) {
          return '\n\nCheck the render method of `' + name + '`.';
        }
      }

      return '';
    }

    function getSourceInfoErrorAddendum(elementProps) {
      if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
        var source = elementProps.__source;
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
      }

      return '';
    }
    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */


    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();

      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

        if (parentName) {
          info = '\n\nCheck the top-level render call using <' + parentName + '>.';
        }
      }

      return info;
    }
    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */


    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }

      element._store.validated = true;
      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }

      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
      // property, it may be the creator of the child that's responsible for
      // assigning it a key.

      var childOwner = '';

      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        // Give the component that originally created this child.
        childOwner = ' It was passed a child from ' + getComponentName(element._owner.type) + '.';
      }

      setCurrentlyValidatingElement(element);
      {
        warning$1(false, 'Each child in a list should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.', currentComponentErrorInfo, childOwner);
      }
      setCurrentlyValidatingElement(null);
    }
    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */


    function validateChildKeys(node, parentType) {
      if (typeof node !== 'object') {
        return;
      }

      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];

          if (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (isValidElement(node)) {
        // This element was passed in a valid location.
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);

        if (typeof iteratorFn === 'function') {
          // Entry iterators used to provide implicit keys,
          // but now we print a separate warning for them later.
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step = void 0;

            while (!(step = iterator.next()).done) {
              if (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }
    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */


    function validatePropTypes(element) {
      var type = element.type;

      if (type === null || type === undefined || typeof type === 'string') {
        return;
      }

      var name = getComponentName(type);
      var propTypes = void 0;

      if (typeof type === 'function') {
        propTypes = type.propTypes;
      } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
      // Inner props are checked in the reconciler.
      type.$$typeof === REACT_MEMO_TYPE)) {
        propTypes = type.propTypes;
      } else {
        return;
      }

      if (propTypes) {
        setCurrentlyValidatingElement(element);
        checkPropTypes(propTypes, element.props, 'prop', name, ReactDebugCurrentFrame.getStackAddendum);
        setCurrentlyValidatingElement(null);
      } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
        propTypesMisspellWarningShown = true;
        warningWithoutStack$1(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
      }

      if (typeof type.getDefaultProps === 'function') {
        !type.getDefaultProps.isReactClassApproved ? warningWithoutStack$1(false, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
      }
    }
    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */


    function validateFragmentProps(fragment) {
      setCurrentlyValidatingElement(fragment);
      var keys = Object.keys(fragment.props);

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];

        if (key !== 'children' && key !== 'key') {
          warning$1(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);
          break;
        }
      }

      if (fragment.ref !== null) {
        warning$1(false, 'Invalid attribute `ref` supplied to `React.Fragment`.');
      }

      setCurrentlyValidatingElement(null);
    }

    function createElementWithValidation(type, props, children) {
      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.

      if (!validType) {
        var info = '';

        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);

        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        var typeString = void 0;

        if (type === null) {
          typeString = 'null';
        } else if (Array.isArray(type)) {
          typeString = 'array';
        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
          typeString = '<' + (getComponentName(type.type) || 'Unknown') + ' />';
          info = ' Did you accidentally export a JSX literal instead of a component?';
        } else {
          typeString = typeof type;
        }

        warning$1(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);
      }

      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.

      if (element == null) {
        return element;
      } // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)


      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      if (type === REACT_FRAGMENT_TYPE) {
        validateFragmentProps(element);
      } else {
        validatePropTypes(element);
      }

      return element;
    }

    function createFactoryWithValidation(type) {
      var validatedFactory = createElementWithValidation.bind(null, type);
      validatedFactory.type = type; // Legacy hook: remove it

      {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
      return validatedFactory;
    }

    function cloneElementWithValidation(element, props, children) {
      var newElement = cloneElement.apply(this, arguments);

      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }

      validatePropTypes(newElement);
      return newElement;
    } // Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
    // In some cases, StrictMode should also double-render lifecycles.
    // This can be confusing for tests though,
    // And it can be bad for performance in production.
    // This feature flag can be used to control the behavior:
    // To preserve the "Pause on caught exceptions" behavior of the debugger, we
    // replay the begin phase of a failed component inside invokeGuardedCallback.
    // Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:
    // Gather advanced timing metrics for Profiler subtrees.
    // Trace which interactions trigger each commit.
    // Only used in www builds.
    // TODO: true? Here it might just be false.
    // Only used in www builds.
    // Only used in www builds.
    // React Fire: prevent the value and checked attributes from syncing
    // with their related DOM properties
    // These APIs will no longer be "unstable" in the upcoming 16.7 release,
    // Control this behavior with a flag to support 16.6 minor releases in the meanwhile.


    var enableStableConcurrentModeAPIs = false;
    var React = {
      Children: {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
      },
      createRef: createRef,
      Component: Component,
      PureComponent: PureComponent,
      createContext: createContext,
      forwardRef: forwardRef,
      lazy: lazy,
      memo: memo,
      useCallback: useCallback,
      useContext: useContext,
      useEffect: useEffect,
      useImperativeHandle: useImperativeHandle,
      useDebugValue: useDebugValue,
      useLayoutEffect: useLayoutEffect,
      useMemo: useMemo,
      useReducer: useReducer,
      useRef: useRef,
      useState: useState,
      Fragment: REACT_FRAGMENT_TYPE,
      StrictMode: REACT_STRICT_MODE_TYPE,
      Suspense: REACT_SUSPENSE_TYPE,
      createElement: createElementWithValidation,
      cloneElement: cloneElementWithValidation,
      createFactory: createFactoryWithValidation,
      isValidElement: isValidElement,
      version: ReactVersion,
      unstable_ConcurrentMode: REACT_CONCURRENT_MODE_TYPE,
      unstable_Profiler: REACT_PROFILER_TYPE,
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals
    }; // Note: some APIs are added with feature flags.
    // Make sure that stable builds for open source
    // don't modify the React object to avoid deopts.
    // Also let's not expose their names in stable builds.

    if (enableStableConcurrentModeAPIs) {
      React.ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
      React.Profiler = REACT_PROFILER_TYPE;
      React.unstable_ConcurrentMode = undefined;
      React.unstable_Profiler = undefined;
    }

    var React$2 = Object.freeze({
      default: React
    });
    var React$3 = React$2 && React || React$2; // TODO: decide on the top-level export form.
    // This is hacky but makes it work with both Rollup and Jest.

    var react = React$3.default || React$3;
    module.exports = react;
  })();
}

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*************************************!*\
  !*** ./node_modules/react/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react.development.js */ "./node_modules/react/cjs/react.development.js");
}

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler-tracing.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler-tracing.development.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v0.13.6
 * scheduler-tracing.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


if (true) {
  (function () {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true
    }); // Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
    // In some cases, StrictMode should also double-render lifecycles.
    // This can be confusing for tests though,
    // And it can be bad for performance in production.
    // This feature flag can be used to control the behavior:
    // To preserve the "Pause on caught exceptions" behavior of the debugger, we
    // replay the begin phase of a failed component inside invokeGuardedCallback.
    // Warn about deprecated, async-unsafe lifecycles; relates to RFC #6:
    // Gather advanced timing metrics for Profiler subtrees.
    // Trace which interactions trigger each commit.

    var enableSchedulerTracing = true; // Only used in www builds.
    // TODO: true? Here it might just be false.
    // Only used in www builds.
    // Only used in www builds.
    // React Fire: prevent the value and checked attributes from syncing
    // with their related DOM properties
    // These APIs will no longer be "unstable" in the upcoming 16.7 release,
    // Control this behavior with a flag to support 16.6 minor releases in the meanwhile.

    var DEFAULT_THREAD_ID = 0; // Counters used to generate unique IDs.

    var interactionIDCounter = 0;
    var threadIDCounter = 0; // Set of currently traced interactions.
    // Interactions "stack"–
    // Meaning that newly traced interactions are appended to the previously active set.
    // When an interaction goes out of scope, the previous set (if any) is restored.

    exports.__interactionsRef = null; // Listener(s) to notify when interactions begin and end.

    exports.__subscriberRef = null;

    if (enableSchedulerTracing) {
      exports.__interactionsRef = {
        current: new Set()
      };
      exports.__subscriberRef = {
        current: null
      };
    }

    function unstable_clear(callback) {
      if (!enableSchedulerTracing) {
        return callback();
      }

      var prevInteractions = exports.__interactionsRef.current;
      exports.__interactionsRef.current = new Set();

      try {
        return callback();
      } finally {
        exports.__interactionsRef.current = prevInteractions;
      }
    }

    function unstable_getCurrent() {
      if (!enableSchedulerTracing) {
        return null;
      } else {
        return exports.__interactionsRef.current;
      }
    }

    function unstable_getThreadID() {
      return ++threadIDCounter;
    }

    function unstable_trace(name, timestamp, callback) {
      var threadID = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_THREAD_ID;

      if (!enableSchedulerTracing) {
        return callback();
      }

      var interaction = {
        __count: 1,
        id: interactionIDCounter++,
        name: name,
        timestamp: timestamp
      };
      var prevInteractions = exports.__interactionsRef.current; // Traced interactions should stack/accumulate.
      // To do that, clone the current interactions.
      // The previous set will be restored upon completion.

      var interactions = new Set(prevInteractions);
      interactions.add(interaction);
      exports.__interactionsRef.current = interactions;
      var subscriber = exports.__subscriberRef.current;
      var returnValue = void 0;

      try {
        if (subscriber !== null) {
          subscriber.onInteractionTraced(interaction);
        }
      } finally {
        try {
          if (subscriber !== null) {
            subscriber.onWorkStarted(interactions, threadID);
          }
        } finally {
          try {
            returnValue = callback();
          } finally {
            exports.__interactionsRef.current = prevInteractions;

            try {
              if (subscriber !== null) {
                subscriber.onWorkStopped(interactions, threadID);
              }
            } finally {
              interaction.__count--; // If no async work was scheduled for this interaction,
              // Notify subscribers that it's completed.

              if (subscriber !== null && interaction.__count === 0) {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              }
            }
          }
        }
      }

      return returnValue;
    }

    function unstable_wrap(callback) {
      var threadID = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_THREAD_ID;

      if (!enableSchedulerTracing) {
        return callback;
      }

      var wrappedInteractions = exports.__interactionsRef.current;
      var subscriber = exports.__subscriberRef.current;

      if (subscriber !== null) {
        subscriber.onWorkScheduled(wrappedInteractions, threadID);
      } // Update the pending async work count for the current interactions.
      // Update after calling subscribers in case of error.


      wrappedInteractions.forEach(function (interaction) {
        interaction.__count++;
      });
      var hasRun = false;

      function wrapped() {
        var prevInteractions = exports.__interactionsRef.current;
        exports.__interactionsRef.current = wrappedInteractions;
        subscriber = exports.__subscriberRef.current;

        try {
          var returnValue = void 0;

          try {
            if (subscriber !== null) {
              subscriber.onWorkStarted(wrappedInteractions, threadID);
            }
          } finally {
            try {
              returnValue = callback.apply(undefined, arguments);
            } finally {
              exports.__interactionsRef.current = prevInteractions;

              if (subscriber !== null) {
                subscriber.onWorkStopped(wrappedInteractions, threadID);
              }
            }
          }

          return returnValue;
        } finally {
          if (!hasRun) {
            // We only expect a wrapped function to be executed once,
            // But in the event that it's executed more than once–
            // Only decrement the outstanding interaction counts once.
            hasRun = true; // Update pending async counts for all wrapped interactions.
            // If this was the last scheduled async work for any of them,
            // Mark them as completed.

            wrappedInteractions.forEach(function (interaction) {
              interaction.__count--;

              if (subscriber !== null && interaction.__count === 0) {
                subscriber.onInteractionScheduledWorkCompleted(interaction);
              }
            });
          }
        }
      }

      wrapped.cancel = function cancel() {
        subscriber = exports.__subscriberRef.current;

        try {
          if (subscriber !== null) {
            subscriber.onWorkCanceled(wrappedInteractions, threadID);
          }
        } finally {
          // Update pending async counts for all wrapped interactions.
          // If this was the last scheduled async work for any of them,
          // Mark them as completed.
          wrappedInteractions.forEach(function (interaction) {
            interaction.__count--;

            if (subscriber && interaction.__count === 0) {
              subscriber.onInteractionScheduledWorkCompleted(interaction);
            }
          });
        }
      };

      return wrapped;
    }

    var subscribers = null;

    if (enableSchedulerTracing) {
      subscribers = new Set();
    }

    function unstable_subscribe(subscriber) {
      if (enableSchedulerTracing) {
        subscribers.add(subscriber);

        if (subscribers.size === 1) {
          exports.__subscriberRef.current = {
            onInteractionScheduledWorkCompleted: onInteractionScheduledWorkCompleted,
            onInteractionTraced: onInteractionTraced,
            onWorkCanceled: onWorkCanceled,
            onWorkScheduled: onWorkScheduled,
            onWorkStarted: onWorkStarted,
            onWorkStopped: onWorkStopped
          };
        }
      }
    }

    function unstable_unsubscribe(subscriber) {
      if (enableSchedulerTracing) {
        subscribers.delete(subscriber);

        if (subscribers.size === 0) {
          exports.__subscriberRef.current = null;
        }
      }
    }

    function onInteractionTraced(interaction) {
      var didCatchError = false;
      var caughtError = null;
      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onInteractionTraced(interaction);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onInteractionScheduledWorkCompleted(interaction) {
      var didCatchError = false;
      var caughtError = null;
      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onInteractionScheduledWorkCompleted(interaction);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onWorkScheduled(interactions, threadID) {
      var didCatchError = false;
      var caughtError = null;
      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onWorkScheduled(interactions, threadID);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onWorkStarted(interactions, threadID) {
      var didCatchError = false;
      var caughtError = null;
      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onWorkStarted(interactions, threadID);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onWorkStopped(interactions, threadID) {
      var didCatchError = false;
      var caughtError = null;
      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onWorkStopped(interactions, threadID);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    function onWorkCanceled(interactions, threadID) {
      var didCatchError = false;
      var caughtError = null;
      subscribers.forEach(function (subscriber) {
        try {
          subscriber.onWorkCanceled(interactions, threadID);
        } catch (error) {
          if (!didCatchError) {
            didCatchError = true;
            caughtError = error;
          }
        }
      });

      if (didCatchError) {
        throw caughtError;
      }
    }

    exports.unstable_clear = unstable_clear;
    exports.unstable_getCurrent = unstable_getCurrent;
    exports.unstable_getThreadID = unstable_getThreadID;
    exports.unstable_trace = unstable_trace;
    exports.unstable_wrap = unstable_wrap;
    exports.unstable_subscribe = unstable_subscribe;
    exports.unstable_unsubscribe = unstable_unsubscribe;
  })();
}

/***/ }),

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/** @license React v0.13.6
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


if (true) {
  (function () {
    'use strict';

    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    var enableSchedulerDebugging = false;
    /* eslint-disable no-var */
    // TODO: Use symbols?

    var ImmediatePriority = 1;
    var UserBlockingPriority = 2;
    var NormalPriority = 3;
    var LowPriority = 4;
    var IdlePriority = 5; // Max 31 bit integer. The max integer size in V8 for 32-bit systems.
    // Math.pow(2, 30) - 1
    // 0b111111111111111111111111111111

    var maxSigned31BitInt = 1073741823; // Times out immediately

    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out

    var USER_BLOCKING_PRIORITY = 250;
    var NORMAL_PRIORITY_TIMEOUT = 5000;
    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out

    var IDLE_PRIORITY = maxSigned31BitInt; // Callbacks are stored as a circular, doubly linked list.

    var firstCallbackNode = null;
    var currentDidTimeout = false; // Pausing the scheduler is useful for debugging.

    var isSchedulerPaused = false;
    var currentPriorityLevel = NormalPriority;
    var currentEventStartTime = -1;
    var currentExpirationTime = -1; // This is set when a callback is being executed, to prevent re-entrancy.

    var isExecutingCallback = false;
    var isHostCallbackScheduled = false;
    var hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';

    function ensureHostCallbackIsScheduled() {
      if (isExecutingCallback) {
        // Don't schedule work yet; wait until the next time we yield.
        return;
      } // Schedule the host callback using the earliest expiration in the list.


      var expirationTime = firstCallbackNode.expirationTime;

      if (!isHostCallbackScheduled) {
        isHostCallbackScheduled = true;
      } else {
        // Cancel the existing host callback.
        cancelHostCallback();
      }

      requestHostCallback(flushWork, expirationTime);
    }

    function flushFirstCallback() {
      var flushedNode = firstCallbackNode; // Remove the node from the list before calling the callback. That way the
      // list is in a consistent state even if the callback throws.

      var next = firstCallbackNode.next;

      if (firstCallbackNode === next) {
        // This is the last callback in the list.
        firstCallbackNode = null;
        next = null;
      } else {
        var lastCallbackNode = firstCallbackNode.previous;
        firstCallbackNode = lastCallbackNode.next = next;
        next.previous = lastCallbackNode;
      }

      flushedNode.next = flushedNode.previous = null; // Now it's safe to call the callback.

      var callback = flushedNode.callback;
      var expirationTime = flushedNode.expirationTime;
      var priorityLevel = flushedNode.priorityLevel;
      var previousPriorityLevel = currentPriorityLevel;
      var previousExpirationTime = currentExpirationTime;
      currentPriorityLevel = priorityLevel;
      currentExpirationTime = expirationTime;
      var continuationCallback;

      try {
        continuationCallback = callback();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
        currentExpirationTime = previousExpirationTime;
      } // A callback may return a continuation. The continuation should be scheduled
      // with the same priority and expiration as the just-finished callback.


      if (typeof continuationCallback === 'function') {
        var continuationNode = {
          callback: continuationCallback,
          priorityLevel: priorityLevel,
          expirationTime: expirationTime,
          next: null,
          previous: null
        }; // Insert the new callback into the list, sorted by its expiration. This is
        // almost the same as the code in `scheduleCallback`, except the callback
        // is inserted into the list *before* callbacks of equal expiration instead
        // of after.

        if (firstCallbackNode === null) {
          // This is the first callback in the list.
          firstCallbackNode = continuationNode.next = continuationNode.previous = continuationNode;
        } else {
          var nextAfterContinuation = null;
          var node = firstCallbackNode;

          do {
            if (node.expirationTime >= expirationTime) {
              // This callback expires at or after the continuation. We will insert
              // the continuation *before* this callback.
              nextAfterContinuation = node;
              break;
            }

            node = node.next;
          } while (node !== firstCallbackNode);

          if (nextAfterContinuation === null) {
            // No equal or lower priority callback was found, which means the new
            // callback is the lowest priority callback in the list.
            nextAfterContinuation = firstCallbackNode;
          } else if (nextAfterContinuation === firstCallbackNode) {
            // The new callback is the highest priority callback in the list.
            firstCallbackNode = continuationNode;
            ensureHostCallbackIsScheduled();
          }

          var previous = nextAfterContinuation.previous;
          previous.next = nextAfterContinuation.previous = continuationNode;
          continuationNode.next = nextAfterContinuation;
          continuationNode.previous = previous;
        }
      }
    }

    function flushImmediateWork() {
      if ( // Confirm we've exited the outer most event handler
      currentEventStartTime === -1 && firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority) {
        isExecutingCallback = true;

        try {
          do {
            flushFirstCallback();
          } while ( // Keep flushing until there are no more immediate callbacks
          firstCallbackNode !== null && firstCallbackNode.priorityLevel === ImmediatePriority);
        } finally {
          isExecutingCallback = false;

          if (firstCallbackNode !== null) {
            // There's still work remaining. Request another callback.
            ensureHostCallbackIsScheduled();
          } else {
            isHostCallbackScheduled = false;
          }
        }
      }
    }

    function flushWork(didTimeout) {
      // Exit right away if we're currently paused
      if (enableSchedulerDebugging && isSchedulerPaused) {
        return;
      }

      isExecutingCallback = true;
      var previousDidTimeout = currentDidTimeout;
      currentDidTimeout = didTimeout;

      try {
        if (didTimeout) {
          // Flush all the expired callbacks without yielding.
          while (firstCallbackNode !== null && !(enableSchedulerDebugging && isSchedulerPaused)) {
            // TODO Wrap in feature flag
            // Read the current time. Flush all the callbacks that expire at or
            // earlier than that time. Then read the current time again and repeat.
            // This optimizes for as few performance.now calls as possible.
            var currentTime = exports.unstable_now();

            if (firstCallbackNode.expirationTime <= currentTime) {
              do {
                flushFirstCallback();
              } while (firstCallbackNode !== null && firstCallbackNode.expirationTime <= currentTime && !(enableSchedulerDebugging && isSchedulerPaused));

              continue;
            }

            break;
          }
        } else {
          // Keep flushing callbacks until we run out of time in the frame.
          if (firstCallbackNode !== null) {
            do {
              if (enableSchedulerDebugging && isSchedulerPaused) {
                break;
              }

              flushFirstCallback();
            } while (firstCallbackNode !== null && !shouldYieldToHost());
          }
        }
      } finally {
        isExecutingCallback = false;
        currentDidTimeout = previousDidTimeout;

        if (firstCallbackNode !== null) {
          // There's still work remaining. Request another callback.
          ensureHostCallbackIsScheduled();
        } else {
          isHostCallbackScheduled = false;
        } // Before exiting, flush all the immediate work that was scheduled.


        flushImmediateWork();
      }
    }

    function unstable_runWithPriority(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case ImmediatePriority:
        case UserBlockingPriority:
        case NormalPriority:
        case LowPriority:
        case IdlePriority:
          break;

        default:
          priorityLevel = NormalPriority;
      }

      var previousPriorityLevel = currentPriorityLevel;
      var previousEventStartTime = currentEventStartTime;
      currentPriorityLevel = priorityLevel;
      currentEventStartTime = exports.unstable_now();

      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
        currentEventStartTime = previousEventStartTime; // Before exiting, flush all the immediate work that was scheduled.

        flushImmediateWork();
      }
    }

    function unstable_next(eventHandler) {
      var priorityLevel = void 0;

      switch (currentPriorityLevel) {
        case ImmediatePriority:
        case UserBlockingPriority:
        case NormalPriority:
          // Shift down to normal priority
          priorityLevel = NormalPriority;
          break;

        default:
          // Anything lower than normal priority should remain at the current level.
          priorityLevel = currentPriorityLevel;
          break;
      }

      var previousPriorityLevel = currentPriorityLevel;
      var previousEventStartTime = currentEventStartTime;
      currentPriorityLevel = priorityLevel;
      currentEventStartTime = exports.unstable_now();

      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
        currentEventStartTime = previousEventStartTime; // Before exiting, flush all the immediate work that was scheduled.

        flushImmediateWork();
      }
    }

    function unstable_wrapCallback(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function () {
        // This is a fork of runWithPriority, inlined for performance.
        var previousPriorityLevel = currentPriorityLevel;
        var previousEventStartTime = currentEventStartTime;
        currentPriorityLevel = parentPriorityLevel;
        currentEventStartTime = exports.unstable_now();

        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
          currentEventStartTime = previousEventStartTime;
          flushImmediateWork();
        }
      };
    }

    function unstable_scheduleCallback(callback, deprecated_options) {
      var startTime = currentEventStartTime !== -1 ? currentEventStartTime : exports.unstable_now();
      var expirationTime;

      if (typeof deprecated_options === 'object' && deprecated_options !== null && typeof deprecated_options.timeout === 'number') {
        // FIXME: Remove this branch once we lift expiration times out of React.
        expirationTime = startTime + deprecated_options.timeout;
      } else {
        switch (currentPriorityLevel) {
          case ImmediatePriority:
            expirationTime = startTime + IMMEDIATE_PRIORITY_TIMEOUT;
            break;

          case UserBlockingPriority:
            expirationTime = startTime + USER_BLOCKING_PRIORITY;
            break;

          case IdlePriority:
            expirationTime = startTime + IDLE_PRIORITY;
            break;

          case LowPriority:
            expirationTime = startTime + LOW_PRIORITY_TIMEOUT;
            break;

          case NormalPriority:
          default:
            expirationTime = startTime + NORMAL_PRIORITY_TIMEOUT;
        }
      }

      var newNode = {
        callback: callback,
        priorityLevel: currentPriorityLevel,
        expirationTime: expirationTime,
        next: null,
        previous: null
      }; // Insert the new callback into the list, ordered first by expiration, then
      // by insertion. So the new callback is inserted any other callback with
      // equal expiration.

      if (firstCallbackNode === null) {
        // This is the first callback in the list.
        firstCallbackNode = newNode.next = newNode.previous = newNode;
        ensureHostCallbackIsScheduled();
      } else {
        var next = null;
        var node = firstCallbackNode;

        do {
          if (node.expirationTime > expirationTime) {
            // The new callback expires before this one.
            next = node;
            break;
          }

          node = node.next;
        } while (node !== firstCallbackNode);

        if (next === null) {
          // No callback with a later expiration was found, which means the new
          // callback has the latest expiration in the list.
          next = firstCallbackNode;
        } else if (next === firstCallbackNode) {
          // The new callback has the earliest expiration in the entire list.
          firstCallbackNode = newNode;
          ensureHostCallbackIsScheduled();
        }

        var previous = next.previous;
        previous.next = next.previous = newNode;
        newNode.next = next;
        newNode.previous = previous;
      }

      return newNode;
    }

    function unstable_pauseExecution() {
      isSchedulerPaused = true;
    }

    function unstable_continueExecution() {
      isSchedulerPaused = false;

      if (firstCallbackNode !== null) {
        ensureHostCallbackIsScheduled();
      }
    }

    function unstable_getFirstCallbackNode() {
      return firstCallbackNode;
    }

    function unstable_cancelCallback(callbackNode) {
      var next = callbackNode.next;

      if (next === null) {
        // Already cancelled.
        return;
      }

      if (next === callbackNode) {
        // This is the only scheduled callback. Clear the list.
        firstCallbackNode = null;
      } else {
        // Remove the callback from its position in the list.
        if (callbackNode === firstCallbackNode) {
          firstCallbackNode = next;
        }

        var previous = callbackNode.previous;
        previous.next = next;
        next.previous = previous;
      }

      callbackNode.next = callbackNode.previous = null;
    }

    function unstable_getCurrentPriorityLevel() {
      return currentPriorityLevel;
    }

    function unstable_shouldYield() {
      return !currentDidTimeout && (firstCallbackNode !== null && firstCallbackNode.expirationTime < currentExpirationTime || shouldYieldToHost());
    } // The remaining code is essentially a polyfill for requestIdleCallback. It
    // works by scheduling a requestAnimationFrame, storing the time for the start
    // of the frame, then scheduling a postMessage which gets scheduled after paint.
    // Within the postMessage handler do as much work as possible until time + frame
    // rate. By separating the idle call into a separate event tick we ensure that
    // layout, paint and other browser work is counted against the available time.
    // The frame rate is dynamically adjusted.
    // We capture a local reference to any global, in case it gets polyfilled after
    // this module is initially evaluated. We want to be using a
    // consistent implementation.


    var localDate = Date; // This initialization code may run even on server environments if a component
    // just imports ReactDOM (e.g. for findDOMNode). Some environments might not
    // have setTimeout or clearTimeout. However, we always expect them to be defined
    // on the client. https://github.com/facebook/react/pull/13088

    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;
    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined; // We don't expect either of these to necessarily be defined, but we will error
    // later if they are missing on the client.

    var localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;
    var localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined; // requestAnimationFrame does not run when the tab is in the background. If
    // we're backgrounded we prefer for that work to happen so that the page
    // continues to load in the background. So we also schedule a 'setTimeout' as
    // a fallback.
    // TODO: Need a better heuristic for backgrounded work.

    var ANIMATION_FRAME_TIMEOUT = 100;
    var rAFID;
    var rAFTimeoutID;

    var requestAnimationFrameWithTimeout = function (callback) {
      // schedule rAF and also a setTimeout
      rAFID = localRequestAnimationFrame(function (timestamp) {
        // cancel the setTimeout
        localClearTimeout(rAFTimeoutID);
        callback(timestamp);
      });
      rAFTimeoutID = localSetTimeout(function () {
        // cancel the requestAnimationFrame
        localCancelAnimationFrame(rAFID);
        callback(exports.unstable_now());
      }, ANIMATION_FRAME_TIMEOUT);
    };

    if (hasNativePerformanceNow) {
      var Performance = performance;

      exports.unstable_now = function () {
        return Performance.now();
      };
    } else {
      exports.unstable_now = function () {
        return localDate.now();
      };
    }

    var requestHostCallback;
    var cancelHostCallback;
    var shouldYieldToHost;
    var globalValue = null;

    if (typeof window !== 'undefined') {
      globalValue = window;
    } else if (typeof global !== 'undefined') {
      globalValue = global;
    }

    if (globalValue && globalValue._schedMock) {
      // Dynamic injection, only for testing purposes.
      var globalImpl = globalValue._schedMock;
      requestHostCallback = globalImpl[0];
      cancelHostCallback = globalImpl[1];
      shouldYieldToHost = globalImpl[2];
      exports.unstable_now = globalImpl[3];
    } else if ( // If Scheduler runs in a non-DOM environment, it falls back to a naive
    // implementation using setTimeout.
    typeof window === 'undefined' || // Check if MessageChannel is supported, too.
    typeof MessageChannel !== 'function') {
      // If this accidentally gets imported in a non-browser environment, e.g. JavaScriptCore,
      // fallback to a naive implementation.
      var _callback = null;

      var _flushCallback = function (didTimeout) {
        if (_callback !== null) {
          try {
            _callback(didTimeout);
          } finally {
            _callback = null;
          }
        }
      };

      requestHostCallback = function (cb, ms) {
        if (_callback !== null) {
          // Protect against re-entrancy.
          setTimeout(requestHostCallback, 0, cb);
        } else {
          _callback = cb;
          setTimeout(_flushCallback, 0, false);
        }
      };

      cancelHostCallback = function () {
        _callback = null;
      };

      shouldYieldToHost = function () {
        return false;
      };
    } else {
      if (typeof console !== 'undefined') {
        // TODO: Remove fb.me link
        if (typeof localRequestAnimationFrame !== 'function') {
          console.error("This browser doesn't support requestAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
        }

        if (typeof localCancelAnimationFrame !== 'function') {
          console.error("This browser doesn't support cancelAnimationFrame. " + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');
        }
      }

      var scheduledHostCallback = null;
      var isMessageEventScheduled = false;
      var timeoutTime = -1;
      var isAnimationFrameScheduled = false;
      var isFlushingHostCallback = false;
      var frameDeadline = 0; // We start out assuming that we run at 30fps but then the heuristic tracking
      // will adjust this value to a faster fps if we get more frequent animation
      // frames.

      var previousFrameTime = 33;
      var activeFrameTime = 33;

      shouldYieldToHost = function () {
        return frameDeadline <= exports.unstable_now();
      }; // We use the postMessage trick to defer idle work until after the repaint.


      var channel = new MessageChannel();
      var port = channel.port2;

      channel.port1.onmessage = function (event) {
        isMessageEventScheduled = false;
        var prevScheduledCallback = scheduledHostCallback;
        var prevTimeoutTime = timeoutTime;
        scheduledHostCallback = null;
        timeoutTime = -1;
        var currentTime = exports.unstable_now();
        var didTimeout = false;

        if (frameDeadline - currentTime <= 0) {
          // There's no time left in this idle period. Check if the callback has
          // a timeout and whether it's been exceeded.
          if (prevTimeoutTime !== -1 && prevTimeoutTime <= currentTime) {
            // Exceeded the timeout. Invoke the callback even though there's no
            // time left.
            didTimeout = true;
          } else {
            // No timeout.
            if (!isAnimationFrameScheduled) {
              // Schedule another animation callback so we retry later.
              isAnimationFrameScheduled = true;
              requestAnimationFrameWithTimeout(animationTick);
            } // Exit without invoking the callback.


            scheduledHostCallback = prevScheduledCallback;
            timeoutTime = prevTimeoutTime;
            return;
          }
        }

        if (prevScheduledCallback !== null) {
          isFlushingHostCallback = true;

          try {
            prevScheduledCallback(didTimeout);
          } finally {
            isFlushingHostCallback = false;
          }
        }
      };

      var animationTick = function (rafTime) {
        if (scheduledHostCallback !== null) {
          // Eagerly schedule the next animation callback at the beginning of the
          // frame. If the scheduler queue is not empty at the end of the frame, it
          // will continue flushing inside that callback. If the queue *is* empty,
          // then it will exit immediately. Posting the callback at the start of the
          // frame ensures it's fired within the earliest possible frame. If we
          // waited until the end of the frame to post the callback, we risk the
          // browser skipping a frame and not firing the callback until the frame
          // after that.
          requestAnimationFrameWithTimeout(animationTick);
        } else {
          // No pending work. Exit.
          isAnimationFrameScheduled = false;
          return;
        }

        var nextFrameTime = rafTime - frameDeadline + activeFrameTime;

        if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {
          if (nextFrameTime < 8) {
            // Defensive coding. We don't support higher frame rates than 120hz.
            // If the calculated frame time gets lower than 8, it is probably a bug.
            nextFrameTime = 8;
          } // If one frame goes long, then the next one can be short to catch up.
          // If two frames are short in a row, then that's an indication that we
          // actually have a higher frame rate than what we're currently optimizing.
          // We adjust our heuristic dynamically accordingly. For example, if we're
          // running on 120hz display or 90hz VR display.
          // Take the max of the two in case one of them was an anomaly due to
          // missed frame deadlines.


          activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;
        } else {
          previousFrameTime = nextFrameTime;
        }

        frameDeadline = rafTime + activeFrameTime;

        if (!isMessageEventScheduled) {
          isMessageEventScheduled = true;
          port.postMessage(undefined);
        }
      };

      requestHostCallback = function (callback, absoluteTimeout) {
        scheduledHostCallback = callback;
        timeoutTime = absoluteTimeout;

        if (isFlushingHostCallback || absoluteTimeout < 0) {
          // Don't wait for the next frame. Continue working ASAP, in a new event.
          port.postMessage(undefined);
        } else if (!isAnimationFrameScheduled) {
          // If rAF didn't already schedule one, we need to schedule a frame.
          // TODO: If this rAF doesn't materialize because the browser throttles, we
          // might want to still have setTimeout trigger rIC as a backup to ensure
          // that we keep performing work.
          isAnimationFrameScheduled = true;
          requestAnimationFrameWithTimeout(animationTick);
        }
      };

      cancelHostCallback = function () {
        scheduledHostCallback = null;
        isMessageEventScheduled = false;
        timeoutTime = -1;
      };
    }

    exports.unstable_ImmediatePriority = ImmediatePriority;
    exports.unstable_UserBlockingPriority = UserBlockingPriority;
    exports.unstable_NormalPriority = NormalPriority;
    exports.unstable_IdlePriority = IdlePriority;
    exports.unstable_LowPriority = LowPriority;
    exports.unstable_runWithPriority = unstable_runWithPriority;
    exports.unstable_next = unstable_next;
    exports.unstable_scheduleCallback = unstable_scheduleCallback;
    exports.unstable_cancelCallback = unstable_cancelCallback;
    exports.unstable_wrapCallback = unstable_wrapCallback;
    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
    exports.unstable_shouldYield = unstable_shouldYield;
    exports.unstable_continueExecution = unstable_continueExecution;
    exports.unstable_pauseExecution = unstable_pauseExecution;
    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
  })();
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ "./node_modules/scheduler/cjs/scheduler.development.js");
}

/***/ }),

/***/ "./node_modules/scheduler/tracing.js":
/*!*******************************************!*\
  !*** ./node_modules/scheduler/tracing.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/scheduler-tracing.development.js */ "./node_modules/scheduler/cjs/scheduler-tracing.development.js");
}

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target, parent) {
  if (parent){
    return parent.querySelector(target);
  }
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target, parent) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target, parent);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertAt.before, target);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	if(options.attrs.nonce === undefined) {
		var nonce = getNonce();
		if (nonce) {
			options.attrs.nonce = nonce;
		}
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function getNonce() {
	if (false) {}

	return __webpack_require__.nc;
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = typeof options.transform === 'function'
		 ? options.transform(obj.css) 
		 : options.transform.default(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */
module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  } // blank or null?


  if (!css || typeof css !== "string") {
    return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/"); // convert each url(...)

  /*
  This regular expression is just a way to recursively match brackets within
  a string.
  	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
     (  = Start a capturing group
       (?:  = Start a non-capturing group
           [^)(]  = Match anything that isn't a parentheses
           |  = OR
           \(  = Match a start parentheses
               (?:  = Start another non-capturing groups
                   [^)(]+  = Match anything that isn't a parentheses
                   |  = OR
                   \(  = Match a start parentheses
                       [^)(]*  = Match anything that isn't a parentheses
                   \)  = Match a end parentheses
               )  = End Group
               *\) = Match anything and then a close parens
           )  = Close non-capturing group
           *  = Match anything
        )  = Close capturing group
   \)  = Match a close parens
  	 /gi  = Get all matches, not the first.  Be case insensitive.
   */

  var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
    // strip quotes (if they exist)
    var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
      return $1;
    }).replace(/^'(.*)'$/, function (o, $1) {
      return $1;
    }); // already a full url? no change

    if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
      return fullMatch;
    } // convert the url to a full url


    var newUrl;

    if (unquotedOrigUrl.indexOf("//") === 0) {
      //TODO: should we add protocol?
      newUrl = unquotedOrigUrl;
    } else if (unquotedOrigUrl.indexOf("/") === 0) {
      // path should be relative to the base url
      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
    } else {
      // path should be relative to current directory
      newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
    } // send back the fixed url(...)


    return "url(" + JSON.stringify(newUrl) + ")";
  }); // send back the fixed css

  return fixedCss;
};

/***/ }),

/***/ "./node_modules/uc.micro/categories/Cc/regex.js":
/*!******************************************************!*\
  !*** ./node_modules/uc.micro/categories/Cc/regex.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = /[\0-\x1F\x7F-\x9F]/;

/***/ }),

/***/ "./node_modules/uc.micro/categories/Cf/regex.js":
/*!******************************************************!*\
  !*** ./node_modules/uc.micro/categories/Cf/regex.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

/***/ }),

/***/ "./node_modules/uc.micro/categories/P/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uc.micro/categories/P/regex.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

/***/ }),

/***/ "./node_modules/uc.micro/categories/Z/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uc.micro/categories/Z/regex.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

/***/ }),

/***/ "./node_modules/uc.micro/index.js":
/*!****************************************!*\
  !*** ./node_modules/uc.micro/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.Any = __webpack_require__(/*! ./properties/Any/regex */ "./node_modules/uc.micro/properties/Any/regex.js");
exports.Cc = __webpack_require__(/*! ./categories/Cc/regex */ "./node_modules/uc.micro/categories/Cc/regex.js");
exports.Cf = __webpack_require__(/*! ./categories/Cf/regex */ "./node_modules/uc.micro/categories/Cf/regex.js");
exports.P = __webpack_require__(/*! ./categories/P/regex */ "./node_modules/uc.micro/categories/P/regex.js");
exports.Z = __webpack_require__(/*! ./categories/Z/regex */ "./node_modules/uc.micro/categories/Z/regex.js");

/***/ }),

/***/ "./node_modules/uc.micro/properties/Any/regex.js":
/*!*******************************************************!*\
  !*** ./node_modules/uc.micro/properties/Any/regex.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function () {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function () {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "./src/components/DropList/index.jsx":
/*!*******************************************!*\
  !*** ./src/components/DropList/index.jsx ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.less */ "./src/components/DropList/index.less");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_index_less__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// DropList



var DropList =
/*#__PURE__*/
function (_React$Component) {
  _inherits(DropList, _React$Component);

  function DropList(props) {
    var _this;

    _classCallCheck(this, DropList);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DropList).call(this, props));
    _this.handleClose = _this._handleClose.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(DropList, [{
    key: "_handleClose",
    value: function _handleClose(e) {
      e.stopPropagation();
      var onClose = this.props.onClose;
      typeof onClose === 'function' && onClose();
    }
  }, {
    key: "render",
    value: function render() {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "drop-wrap ".concat(this.props.show ? 'show' : 'hidden'),
        onClick: this.handleClose
      }, typeof this.props.render === 'function' && this.props.render());
    }
  }]);

  return DropList;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

/* harmony default export */ __webpack_exports__["default"] = (DropList);

/***/ }),

/***/ "./src/components/DropList/index.less":
/*!********************************************!*\
  !*** ./src/components/DropList/index.less ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/DropList/index.less");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(true) {
	module.hot.accept(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/DropList/index.less", function() {
		var newContent = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/DropList/index.less");

		if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/components/HeaderList/index.jsx":
/*!*********************************************!*\
  !*** ./src/components/HeaderList/index.jsx ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.less */ "./src/components/HeaderList/index.less");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_index_less__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// HeaderList



var HeaderList =
/*#__PURE__*/
function (_React$Component) {
  _inherits(HeaderList, _React$Component);

  function HeaderList() {
    _classCallCheck(this, HeaderList);

    return _possibleConstructorReturn(this, _getPrototypeOf(HeaderList).apply(this, arguments));
  }

  _createClass(HeaderList, [{
    key: "handleHeader",
    value: function handleHeader(header) {
      var onSelectHeader = this.props.onSelectHeader;
      typeof onSelectHeader === 'function' && onSelectHeader(header);
    }
  }, {
    key: "render",
    value: function render() {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", {
        className: "header-list"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", {
        className: "list-item"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h1", {
        onClick: this.handleHeader.bind(this, 'h1')
      }, "H1")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", {
        className: "list-item"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h2", {
        onClick: this.handleHeader.bind(this, 'h2')
      }, "H2")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", {
        className: "list-item"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h3", {
        onClick: this.handleHeader.bind(this, 'h3')
      }, "H3")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", {
        className: "list-item"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h4", {
        onClick: this.handleHeader.bind(this, 'h4')
      }, "H4")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", {
        className: "list-item"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h5", {
        onClick: this.handleHeader.bind(this, 'h5')
      }, "H5")), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", {
        className: "list-item"
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h6", {
        onClick: this.handleHeader.bind(this, 'h6')
      }, "H6")));
    }
  }]);

  return HeaderList;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

/* harmony default export */ __webpack_exports__["default"] = (HeaderList);

/***/ }),

/***/ "./src/components/HeaderList/index.less":
/*!**********************************************!*\
  !*** ./src/components/HeaderList/index.less ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/HeaderList/index.less");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(true) {
	module.hot.accept(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/HeaderList/index.less", function() {
		var newContent = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/HeaderList/index.less");

		if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/components/Icon/font.less":
/*!***************************************!*\
  !*** ./src/components/Icon/font.less ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./font.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/Icon/font.less");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(true) {
	module.hot.accept(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./font.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/Icon/font.less", function() {
		var newContent = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./font.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/Icon/font.less");

		if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/components/Icon/fonts/icomoon.woff?cbt6hv":
/*!*******************************************************!*\
  !*** ./src/components/Icon/fonts/icomoon.woff?cbt6hv ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "1799bf3c596d1acf6a69f6a5b63697ec.woff";

/***/ }),

/***/ "./src/components/Icon/index.jsx":
/*!***************************************!*\
  !*** ./src/components/Icon/index.jsx ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _font_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./font.less */ "./src/components/Icon/font.less");
/* harmony import */ var _font_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_font_less__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// Icon



var Icon =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Icon, _React$Component);

  function Icon() {
    _classCallCheck(this, Icon);

    return _possibleConstructorReturn(this, _getPrototypeOf(Icon).apply(this, arguments));
  }

  _createClass(Icon, [{
    key: "render",
    value: function render() {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        className: this.props.type
      });
    }
  }]);

  return Icon;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

/* harmony default export */ __webpack_exports__["default"] = (Icon);

/***/ }),

/***/ "./src/components/InputFile/index.jsx":
/*!********************************************!*\
  !*** ./src/components/InputFile/index.jsx ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.less */ "./src/components/InputFile/index.less");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_index_less__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// TableList



var InputFile =
/*#__PURE__*/
function (_React$Component) {
  _inherits(InputFile, _React$Component);

  function InputFile(props) {
    _classCallCheck(this, InputFile);

    return _possibleConstructorReturn(this, _getPrototypeOf(InputFile).call(this, props));
  }

  _createClass(InputFile, [{
    key: "click",
    value: function click() {
      var _this = this;

      if (this.locked) {
        return;
      }

      this.locked = true;
      this.input.value = '';
      this.input.click();
      this.timerId && clearTimeout(this.timerId);
      this.timerId = setTimeout(function () {
        _this.locked = false;
      }, 200);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.timerId && clearTimeout(this.timerId);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", {
        type: "file",
        ref: function ref(el) {
          _this2.input = el;
        },
        style: {
          position: 'absolute',
          zIndex: -1,
          left: 0,
          top: 0,
          width: 0,
          height: 0,
          opacity: 0
        },
        onChange: this.props.onChange
      });
    }
  }]);

  return InputFile;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

/* harmony default export */ __webpack_exports__["default"] = (InputFile);

/***/ }),

/***/ "./src/components/InputFile/index.less":
/*!*********************************************!*\
  !*** ./src/components/InputFile/index.less ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/InputFile/index.less");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(true) {
	module.hot.accept(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/InputFile/index.less", function() {
		var newContent = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/InputFile/index.less");

		if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/components/NavigationBar/index.jsx":
/*!************************************************!*\
  !*** ./src/components/NavigationBar/index.jsx ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// navigationBar


var NavigationBar =
/*#__PURE__*/
function (_React$Component) {
  _inherits(NavigationBar, _React$Component);

  function NavigationBar(props) {
    _classCallCheck(this, NavigationBar);

    return _possibleConstructorReturn(this, _getPrototypeOf(NavigationBar).call(this, props));
  }

  _createClass(NavigationBar, [{
    key: "render",
    value: function render() {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: 'rc-md-navigation'
      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "navigation-nav left"
      }, this.props.left), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "navigation-nav middle"
      }, this.props.middle), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "navigation-nav right"
      }, this.props.right));
    }
  }]);

  return NavigationBar;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

/* harmony default export */ __webpack_exports__["default"] = (NavigationBar);

/***/ }),

/***/ "./src/components/TableList/index.jsx":
/*!********************************************!*\
  !*** ./src/components/TableList/index.jsx ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.less */ "./src/components/TableList/index.less");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_index_less__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// TableList



var TableList =
/*#__PURE__*/
function (_React$Component) {
  _inherits(TableList, _React$Component);

  function TableList(props) {
    var _this;

    _classCallCheck(this, TableList);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TableList).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "config", {
      padding: 3,
      width: 20,
      height: 20
    });

    var _props$maxRow = props.maxRow,
        maxRow = _props$maxRow === void 0 ? 5 : _props$maxRow,
        _props$maxCol = props.maxCol,
        maxCol = _props$maxCol === void 0 ? 6 : _props$maxCol;
    _this.state = {
      maxRow: maxRow,
      maxCol: maxCol,
      list: _this.formatTableModel(maxRow, maxCol)
    };
    return _this;
  }

  _createClass(TableList, [{
    key: "formatTableModel",
    value: function formatTableModel() {
      var maxRow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var maxCol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var result = new Array(maxRow).fill();
      return result.map(function (v) {
        return new Array(maxCol).fill(0);
      });
    }
  }, {
    key: "calcWrapStyle",
    value: function calcWrapStyle() {
      var _this$state = this.state,
          maxRow = _this$state.maxRow,
          maxCol = _this$state.maxCol;
      var _this$config = this.config,
          width = _this$config.width,
          height = _this$config.height,
          padding = _this$config.padding;
      var wrapWidth = (width + padding) * maxCol - padding;
      var wrapHeight = (height + padding) * maxRow - padding;
      return {
        width: "".concat(wrapWidth, "px"),
        height: "".concat(wrapHeight, "px")
      };
    }
  }, {
    key: "calcItemStyle",
    value: function calcItemStyle() {
      var row = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var col = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var _this$config2 = this.config,
          width = _this$config2.width,
          height = _this$config2.height,
          padding = _this$config2.padding;
      var top = (height + padding) * row;
      var left = (width + padding) * col;
      return {
        top: "".concat(top, "px"),
        left: "".concat(left, "px")
      };
    }
  }, {
    key: "handleHover",
    value: function handleHover(i, j) {
      var list = this.state.list;
      var newList = list.map(function (v, row) {
        return v.map(function (item, col) {
          if (row <= i && col <= j) {
            item = 1;
          } else {
            item = 0;
          }

          return item;
        });
      });
      this.setState({
        list: newList
      });
    }
  }, {
    key: "handleSetTable",
    value: function handleSetTable(i, j) {
      var onSetTable = this.props.onSetTable;
      typeof onSetTable === 'function' && onSetTable({
        row: i,
        col: j
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var list = this.state.list;
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("ul", {
        className: "table-list wrap",
        style: this.calcWrapStyle()
      }, list.map(function (row, i) {
        return row.map(function (col, j) {
          return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("li", {
            className: "list-item ".concat(col === 1 ? 'active' : ''),
            key: "".concat(i, "-").concat(j),
            style: _this2.calcItemStyle(i, j),
            onMouseOver: _this2.handleHover.bind(_this2, i, j),
            onClick: _this2.handleSetTable.bind(_this2, i, j)
          });
        });
      }));
    }
  }]);

  return TableList;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

/* harmony default export */ __webpack_exports__["default"] = (TableList);

/***/ }),

/***/ "./src/components/TableList/index.less":
/*!*********************************************!*\
  !*** ./src/components/TableList/index.less ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/TableList/index.less");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(true) {
	module.hot.accept(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/TableList/index.less", function() {
		var newContent = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/TableList/index.less");

		if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/components/ToolBar/index.jsx":
/*!******************************************!*\
  !*** ./src/components/ToolBar/index.jsx ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.less */ "./src/components/ToolBar/index.less");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_index_less__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }




var ToolBar =
/*#__PURE__*/
function (_React$Component) {
  _inherits(ToolBar, _React$Component);

  function ToolBar() {
    _classCallCheck(this, ToolBar);

    return _possibleConstructorReturn(this, _getPrototypeOf(ToolBar).apply(this, arguments));
  }

  _createClass(ToolBar, [{
    key: "render",
    value: function render() {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "tool-bar",
        style: this.props.style
      }, this.props.children);
    }
  }]);

  return ToolBar;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

/* harmony default export */ __webpack_exports__["default"] = (ToolBar);

/***/ }),

/***/ "./src/components/ToolBar/index.less":
/*!*******************************************!*\
  !*** ./src/components/ToolBar/index.less ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/ToolBar/index.less");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(true) {
	module.hot.accept(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/ToolBar/index.less", function() {
		var newContent = __webpack_require__(/*! !../../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../../node_modules/postcss-loader/lib!../../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/components/ToolBar/index.less");

		if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * config
 */
var config = {
  theme: 'default',
  view: {
    menu: true,
    md: true,
    html: true
  },
  logger: {
    interval: 3000
  },
  synchScroll: true,
  imageUrl: '',
  linkUrl: '',
  table: {
    maxRow: 4,
    maxCol: 6
  }
};
/* harmony default export */ __webpack_exports__["default"] = (config);

/***/ }),

/***/ "./src/editor/index.jsx":
/*!******************************!*\
  !*** ./src/editor/index.jsx ***!
  \******************************/
/*! exports provided: HtmlRender, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HtmlRender", function() { return HtmlRender; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_tool__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/tool */ "./src/utils/tool.js");
/* harmony import */ var _utils_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/logger */ "./src/utils/logger.js");
/* harmony import */ var _utils_decorate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/decorate */ "./src/utils/decorate.js");
/* harmony import */ var _components_NavigationBar__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../components/NavigationBar */ "./src/components/NavigationBar/index.jsx");
/* harmony import */ var _components_DropList__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../components/DropList */ "./src/components/DropList/index.jsx");
/* harmony import */ var _components_HeaderList__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../components/HeaderList */ "./src/components/HeaderList/index.jsx");
/* harmony import */ var _components_TableList__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../components/TableList */ "./src/components/TableList/index.jsx");
/* harmony import */ var _components_InputFile__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../components/InputFile */ "./src/components/InputFile/index.jsx");
/* harmony import */ var _components_Icon__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../components/Icon */ "./src/components/Icon/index.jsx");
/* harmony import */ var _components_ToolBar__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../components/ToolBar */ "./src/components/ToolBar/index.jsx");
/* harmony import */ var _config_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../config.js */ "./src/config.js");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./index.less */ "./src/editor/index.less");
/* harmony import */ var _index_less__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_index_less__WEBPACK_IMPORTED_MODULE_13__);
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

// markdown editor 














var HtmlRender =
/*#__PURE__*/
function (_React$Component) {
  _inherits(HtmlRender, _React$Component);

  function HtmlRender() {
    _classCallCheck(this, HtmlRender);

    return _possibleConstructorReturn(this, _getPrototypeOf(HtmlRender).apply(this, arguments));
  }

  _createClass(HtmlRender, [{
    key: "render",
    value: function render() {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        dangerouslySetInnerHTML: {
          __html: this.props.html
        },
        className: 'custom-html-style'
      });
    }
  }]);

  return HtmlRender;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

var HtmlCode =
/*#__PURE__*/
function (_React$Component2) {
  _inherits(HtmlCode, _React$Component2);

  function HtmlCode() {
    _classCallCheck(this, HtmlCode);

    return _possibleConstructorReturn(this, _getPrototypeOf(HtmlCode).apply(this, arguments));
  }

  _createClass(HtmlCode, [{
    key: "render",
    value: function render() {
      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("textarea", {
        className: "html-code",
        value: this.props.html,
        onChange: function onChange() {}
      });
    }
  }]);

  return HtmlCode;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

var MdEditor =
/*#__PURE__*/
function (_React$Component3) {
  _inherits(MdEditor, _React$Component3);

  // 即将滚动的元素 md html
  function MdEditor(props) {
    var _this;

    _classCallCheck(this, MdEditor);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MdEditor).call(this, props));

    _defineProperty(_assertThisInitialized(_this), "config", {});

    _defineProperty(_assertThisInitialized(_this), "logger", {});

    _defineProperty(_assertThisInitialized(_this), "loggerTimerId", null);

    _defineProperty(_assertThisInitialized(_this), "mdjs", null);

    _defineProperty(_assertThisInitialized(_this), "nodeMdText", null);

    _defineProperty(_assertThisInitialized(_this), "nodeMdPreview", null);

    _defineProperty(_assertThisInitialized(_this), "nodeMdPreviewWraper", null);

    _defineProperty(_assertThisInitialized(_this), "inputFile", null);

    _defineProperty(_assertThisInitialized(_this), "scale", 0);

    _defineProperty(_assertThisInitialized(_this), "willScrollEle", '');

    _defineProperty(_assertThisInitialized(_this), "hasContentChanged", true);

    _defineProperty(_assertThisInitialized(_this), "initialSelection", {
      isSelected: false,
      start: 0,
      end: 0,
      text: ''
    });

    _defineProperty(_assertThisInitialized(_this), "selection", _objectSpread({}, _this.initialSelection));

    _this.config = _this.initConfig();
    _this.state = {
      text: (_this.formatString(_this.props.value) || '').replace(/↵/g, '\n'),
      html: '',
      view: _this.config.view,
      htmlType: 'render',
      // 'render' 'source'
      dropButton: {
        header: false,
        table: false
      },
      fullScreen: false,
      table: _this.config.table
    };
    _this.handleChange = _this._handleChange.bind(_assertThisInitialized(_this));
    _this.handleInputSelect = _this._handleInputSelect.bind(_assertThisInitialized(_this));
    _this.handleImageUpload = _this._handleImageUpload.bind(_assertThisInitialized(_this));
    _this.handleEmpty = _this._handleEmpty.bind(_assertThisInitialized(_this));
    _this.handleUndo = _this._handleUndo.bind(_assertThisInitialized(_this));
    _this.handleRedo = _this._handleRedo.bind(_assertThisInitialized(_this));
    _this.handleToggleFullScreen = _this._handleToggleFullScreen.bind(_assertThisInitialized(_this));
    _this.handleToggleMenu = _this._handleToggleMenu.bind(_assertThisInitialized(_this));
    _this.handleToggleView = _this._handleToggleView.bind(_assertThisInitialized(_this));
    _this.handleMdPreview = _this._handleMdPreview.bind(_assertThisInitialized(_this));
    _this.handleHtmlPreview = _this._handleHtmlPreview.bind(_assertThisInitialized(_this));
    _this.handleToggleHtmlType = _this._handleToggleHtmlType.bind(_assertThisInitialized(_this));
    _this.handleonKeyDown = _this._handleonKeyDown.bind(_assertThisInitialized(_this));
    _this.handleInputScroll = _utils_tool__WEBPACK_IMPORTED_MODULE_2__["throttle"](function (e) {
      var synchScroll = _this.config.synchScroll;

      if (!synchScroll) {
        return;
      }

      e.persist();

      if (_this.willScrollEle === 'md') {
        _this.hasContentChanged && _this._setScrollValue();
        _this.nodeMdPreviewWraper.scrollTop = _this.nodeMdText.scrollTop / _this.scale;
      }
    }, 1000 / 60);
    _this.handlePreviewScroll = _utils_tool__WEBPACK_IMPORTED_MODULE_2__["throttle"](function (e) {
      var synchScroll = _this.config.synchScroll;

      if (!synchScroll) {
        return;
      }

      e.persist();

      if (_this.willScrollEle === 'html') {
        _this.hasContentChanged && _this._setScrollValue();
        _this.nodeMdText.scrollTop = _this.nodeMdPreviewWraper.scrollTop * _this.scale;
      }
    }, 1000 / 60);
    return _this;
  }

  _createClass(MdEditor, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      this.renderHTML(this.props.value || "").then(function (html) {
        _this2.setState({
          html: html
        });
      });
      this.initLogger();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this3 = this;

      if (nextProps.value === this.props.value) {
        // console.log('value not change')
        return;
      }

      var value = nextProps.value;
      value = this.formatString(value);
      value = value && value.replace(/↵/g, '\n');
      this.renderHTML(value).then(function (html) {
        _this3.setState({
          text: value,
          html: html
        });
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.endLogger();
    }
  }, {
    key: "formatString",
    value: function formatString(value) {
      if (typeof this.props.value !== 'string') {
        console && console.error && console.error('The type of "value" must be String!');
        return new String(value).toString();
      }

      return value;
    }
  }, {
    key: "initConfig",
    value: function initConfig() {
      return _objectSpread({}, _config_js__WEBPACK_IMPORTED_MODULE_12__["default"], this.props.config);
    }
  }, {
    key: "initLogger",
    value: function initLogger() {
      this.logger = new _utils_logger__WEBPACK_IMPORTED_MODULE_3__["default"]();
      this.startLogger();
      this.logger.pushRecord(this.state.text);
    }
  }, {
    key: "startLogger",
    value: function startLogger() {
      var _this4 = this;

      if (!this.loggerTimerId) {
        this.loggerTimerId = setInterval(function () {
          var text = _this4.state.text;

          if (_this4.logger.getLastRecord() !== text) {
            _this4.logger.pushRecord(text);
          }
        }, this.config.logger.interval);
      } // 清空redo历史


      this.logger.cleanRedoList();
    }
  }, {
    key: "endLogger",
    value: function endLogger() {
      if (this.loggerTimerId) {
        clearInterval(this.loggerTimerId);
        this.loggerTimerId = null;
      }
    }
  }, {
    key: "handleGetLogger",
    value: function handleGetLogger() {
      console.log('handleGetLogger', this.logger);
    }
  }, {
    key: "_handleUndo",
    value: function _handleUndo() {
      var _this5 = this;

      this.logger.undo(function (last) {
        _this5.endLogger();

        _this5._setMdText(last);
      });
    }
  }, {
    key: "_handleRedo",
    value: function _handleRedo() {
      var _this6 = this;

      this.logger.redo(function (last) {
        _this6._setMdText(last);
      });
    }
  }, {
    key: "handleDecorate",
    value: function handleDecorate(type) {
      var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var clearList = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'bold', 'italic', 'underline', 'strikethrough', 'unorder', 'order', 'quote', 'hr', 'inlinecode', 'code', 'table', 'image', 'link'];

      if (clearList.indexOf(type) > -1) {
        if (!this.selection.isSelected) {
          return;
        }

        var content = this._getDecoratedText(type, option);

        this._setMdText(content);

        this._clearSelection();
      } else {
        var _content = this._getDecoratedText(type, option);

        this._setMdText(_content);
      }
    }
  }, {
    key: "_getDecoratedText",
    value: function _getDecoratedText(type, option) {
      var _this$state$text = this.state.text,
          text = _this$state$text === void 0 ? '' : _this$state$text;
      var selection = this.selection;
      var beforeContent = text.slice(0, selection.start);
      var afterContent = text.slice(selection.end, text.length);
      var decorate = new _utils_decorate__WEBPACK_IMPORTED_MODULE_4__["default"](selection.text);
      var decoratedText = '';

      if (type === 'image') {
        decoratedText = decorate.getDecoratedText(type, {
          imageUrl: option.imageUrl || this.config.imageUrl
        });
      } else if (type === 'link') {
        decoratedText = decorate.getDecoratedText(type, {
          linkUrl: this.config.linkUrl
        });
      } else {
        decoratedText = decorate.getDecoratedText(type, option);
      }

      var result = beforeContent + "".concat(decoratedText) + afterContent;
      return result;
    }
  }, {
    key: "renderHTML",
    value: function renderHTML(markdownText) {
      var res = this.props.renderHTML(markdownText);

      if (typeof res === "string") {
        return Promise.resolve(res);
      } else {
        return res;
      }
    }
  }, {
    key: "_handleToggleFullScreen",
    value: function _handleToggleFullScreen() {
      this.setState({
        fullScreen: !this.state.fullScreen
      });
    }
  }, {
    key: "changeView",
    value: function changeView(to) {
      var view = Object.assign({}, this.state.view, to);
      this.setState({
        view: view
      });
    }
  }, {
    key: "_handleToggleMenu",
    value: function _handleToggleMenu() {
      this.changeView({
        'menu': !this.state.view.menu
      });
    }
  }, {
    key: "_handleToggleView",
    value: function _handleToggleView(type) {
      if (type === 'md') {
        this.changeView({
          'md': false,
          'html': true
        });
      } else {
        this.changeView({
          'md': true,
          'html': false
        });
      }
    }
  }, {
    key: "_handleMdPreview",
    value: function _handleMdPreview() {
      this.changeView({
        'html': !this.state.view.html
      });
    }
  }, {
    key: "_handleHtmlPreview",
    value: function _handleHtmlPreview() {
      this.changeView({
        'md': !this.state.view.md
      });
    }
  }, {
    key: "_handleToggleHtmlType",
    value: function _handleToggleHtmlType() {
      var htmlType = this.state.htmlType;

      if (htmlType === 'render') {
        htmlType = 'source';
      } else if (htmlType === 'source') {
        htmlType = 'render';
      }

      this.setState({
        htmlType: htmlType
      });
    }
  }, {
    key: "_handleEmpty",
    value: function _handleEmpty() {
      if (window.confirm) {
        var result = window.confirm('Are you sure to empty markdown ?');

        if (result) {
          this.setState({
            text: '',
            html: ''
          });
        }
      }
    }
  }, {
    key: "_handleImageUpload",
    value: function _handleImageUpload() {
      var onImageUpload = this.props.onImageUpload;

      if (typeof onImageUpload === 'function') {
        this.inputFile && this.inputFile.click();
      } else {
        this.handleDecorate('image');
      }
    }
  }, {
    key: "onImageChanged",
    value: function onImageChanged(file) {
      var _this7 = this;

      var onImageUpload = this.props.onImageUpload;
      onImageUpload(file, function (imageUrl) {
        _this7.handleDecorate('image', {
          imageUrl: imageUrl
        });
      });
    }
  }, {
    key: "_handleChange",
    value: function _handleChange(e) {
      this.startLogger();
      var value = e.target.value;

      if (!this.hasContentChanged) {
        this.hasContentChanged = true;
      }

      this._setMdText(value);
    }
  }, {
    key: "_handleInputSelect",
    value: function _handleInputSelect(e) {
      e.persist();
      this.selection = Object.assign({}, this.selection, {
        isSelected: true
      }, this._getSelectionInfo(e));
    }
  }, {
    key: "handleScrollEle",
    value: function handleScrollEle(node) {
      this.willScrollEle = node;
    }
  }, {
    key: "_setScrollValue",
    value: function _setScrollValue() {
      // 设置值，方便 scrollBy 操作
      var nodeMdText = this.nodeMdText,
          nodeMdPreview = this.nodeMdPreview,
          nodeMdPreviewWraper = this.nodeMdPreviewWraper;
      this.scale = (nodeMdText.scrollHeight - nodeMdText.offsetHeight) / (nodeMdPreview.offsetHeight - nodeMdPreviewWraper.offsetHeight);
      this.hasContentChanged = false;
    }
  }, {
    key: "_clearSelection",
    value: function _clearSelection() {
      this.selection = Object.assign({}, this.initialSelection);
    }
  }, {
    key: "_getSelectionInfo",
    value: function _getSelectionInfo(e) {
      var source = e.srcElement || e.target;
      var start = source.selectionStart;
      var end = source.selectionEnd;
      var text = (source.value || '').slice(start, end);
      var selection = {
        start: start,
        end: end,
        text: text
      };
      return selection;
    }
  }, {
    key: "_setMdText",
    value: function _setMdText() {
      var _this8 = this;

      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var text = value.replace(/↵/g, '\n');
      this.setState({
        text: value
      });
      this.renderHTML(text).then(function (html) {
        _this8.setState({
          html: html
        });

        _this8.onEmit({
          text: text,
          html: html
        });
      });
    }
  }, {
    key: "_isKeyMatch",
    value: function _isKeyMatch(event, key, keyCode) {
      var withCtrl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      if (event.ctrlKey !== withCtrl) {
        return false;
      }

      if (event.key) {
        return event.key === key;
      } else {
        return event.keyCode === keyCode;
      }
    }
  }, {
    key: "_handleonKeyDown",
    value: function _handleonKeyDown(e) {
      if (this._isKeyMatch(e, 'z', 90, true)) {
        this._handleUndo();

        e.preventDefault();
      }

      if (this._isKeyMatch(e, 'y', 89, true)) {
        this._handleRedo();

        e.preventDefault();
      }
    }
  }, {
    key: "onEmit",
    value: function onEmit(output) {
      var onChange = this.props.onChange;
      onChange && onChange(output);
    }
  }, {
    key: "getMdValue",
    value: function getMdValue() {
      return this.state.text;
    }
  }, {
    key: "getHtmlValue",
    value: function getHtmlValue() {
      return this.state.html;
    }
  }, {
    key: "showDropList",
    value: function showDropList() {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'header';
      var flag = arguments.length > 1 ? arguments[1] : undefined;
      var dropButton = this.state.dropButton;
      this.setState({
        dropButton: _objectSpread({}, dropButton, _defineProperty({}, type, flag))
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this9 = this;

      var _this$state = this.state,
          view = _this$state.view,
          dropButton = _this$state.dropButton,
          fullScreen = _this$state.fullScreen,
          table = _this$state.table;

      var renderNavigation = function renderNavigation() {
        return view.menu && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_NavigationBar__WEBPACK_IMPORTED_MODULE_5__["default"], {
          left: react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
            className: "button-wrap"
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "header",
            onMouseEnter: function onMouseEnter() {
              return _this9.showDropList('header', true);
            },
            onMouseLeave: function onMouseLeave() {
              return _this9.showDropList('header', false);
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-header"
          }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_DropList__WEBPACK_IMPORTED_MODULE_6__["default"], {
            show: dropButton.header,
            onClose: function onClose() {
              _this9.showDropList('header', false);
            },
            render: function render() {
              return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_HeaderList__WEBPACK_IMPORTED_MODULE_7__["default"], {
                onSelectHeader: function onSelectHeader(header) {
                  _this9.handleDecorate(header);
                }
              });
            }
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "bold",
            onClick: function onClick() {
              return _this9.handleDecorate('bold');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-bold"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "italic",
            onClick: function onClick() {
              return _this9.handleDecorate('italic');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-italic"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "italic",
            onClick: function onClick() {
              return _this9.handleDecorate('underline');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-underline"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "strikethrough",
            onClick: function onClick() {
              return _this9.handleDecorate('strikethrough');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-strikethrough"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "unorder",
            onClick: function onClick() {
              return _this9.handleDecorate('unorder');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-list-ul"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "order",
            onClick: function onClick() {
              return _this9.handleDecorate('order');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-list-ol"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "quote",
            onClick: function onClick() {
              return _this9.handleDecorate('quote');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-quote-left"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "hr",
            onClick: function onClick() {
              return _this9.handleDecorate('hr');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-window-minimize"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "inline code",
            onClick: function onClick() {
              return _this9.handleDecorate('inlinecode');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-embed"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "code",
            onClick: function onClick() {
              return _this9.handleDecorate('code');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-embed2"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "table",
            onMouseEnter: function onMouseEnter() {
              return _this9.showDropList('table', true);
            },
            onMouseLeave: function onMouseLeave() {
              return _this9.showDropList('table', false);
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-table"
          }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_DropList__WEBPACK_IMPORTED_MODULE_6__["default"], {
            show: dropButton.table,
            onClose: function onClose() {
              _this9.showDropList('table', false);
            },
            render: function render() {
              return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_TableList__WEBPACK_IMPORTED_MODULE_8__["default"], {
                maxRow: table.maxRow,
                maxCol: table.maxCol,
                onSetTable: function onSetTable(option) {
                  _this9.handleDecorate('table', option);
                }
              });
            }
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "image",
            onClick: _this9.handleImageUpload,
            style: {
              position: 'relative'
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-photo"
          }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_InputFile__WEBPACK_IMPORTED_MODULE_9__["default"], {
            ref: function ref(input) {
              _this9.inputFile = input;
            },
            onChange: function onChange(e) {
              e.persist();
              var file = e.target.files[0];

              _this9.onImageChanged(file);
            }
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "link",
            onClick: function onClick() {
              return _this9.handleDecorate('link');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-link"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "empty",
            onClick: _this9.handleEmpty
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-trash"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "undo",
            onClick: _this9.handleUndo
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-reply"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "redo",
            onClick: _this9.handleRedo
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-share"
          }))),
          right: react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
            className: "button-wrap"
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "full screen",
            onClick: _this9.handleToggleFullScreen
          }, fullScreen ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-shrink"
          }) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-enlarge"
          })))
        });
      };

      var renderContent = function renderContent() {
        var _this9$state = _this9.state,
            html = _this9$state.html,
            text = _this9$state.text,
            view = _this9$state.view,
            htmlType = _this9$state.htmlType;
        var res = [];

        if (view.md) {
          res.push(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("section", {
            className: 'sec-md',
            key: "md"
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_ToolBar__WEBPACK_IMPORTED_MODULE_11__["default"], null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: view.menu ? 'hidden menu' : 'show menu',
            onClick: _this9.handleToggleMenu
          }, view.menu ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-chevron-up"
          }) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-chevron-down"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: view.html ? 'preview' : 'column',
            onClick: _this9.handleMdPreview
          }, view.html ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-desktop"
          }) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-columns"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: 'toggle',
            onClick: function onClick() {
              return _this9.handleToggleView('md');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-refresh"
          }))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("textarea", {
            id: "textarea",
            ref: function ref(node) {
              return _this9.nodeMdText = node;
            },
            value: text,
            className: 'input',
            wrap: "hard",
            onChange: _this9.handleChange,
            onSelect: _this9.handleInputSelect,
            onScroll: _this9.handleInputScroll,
            onMouseOver: function onMouseOver() {
              return _this9.handleScrollEle('md');
            }
          })));
        }

        if (view.html) {
          res.push(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("section", {
            className: 'sec-html',
            key: "html"
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_ToolBar__WEBPACK_IMPORTED_MODULE_11__["default"], {
            style: {
              right: '20px'
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: view.menu ? 'hidden menu' : 'show menu',
            onClick: _this9.handleToggleMenu
          }, view.menu ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-chevron-up"
          }) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-chevron-down"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: view.md ? 'preview' : 'column',
            onClick: _this9.handleHtmlPreview
          }, view.md ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-desktop"
          }) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-columns"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: 'toggle',
            onClick: function onClick() {
              return _this9.handleToggleView('html');
            }
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-refresh"
          })), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
            className: "button",
            title: "HTML code",
            onClick: _this9.handleToggleHtmlType
          }, htmlType === 'render' ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-code"
          }) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_components_Icon__WEBPACK_IMPORTED_MODULE_10__["default"], {
            type: "icon-eye"
          }))), htmlType === 'render' ? react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
            className: "html-wrap",
            ref: function ref(node) {
              return _this9.nodeMdPreviewWraper = node;
            },
            onMouseOver: function onMouseOver() {
              return _this9.handleScrollEle('html');
            },
            onScroll: _this9.handlePreviewScroll
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(HtmlRender, {
            html: html,
            ref: function ref(node) {
              return _this9.nodeMdPreview = react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.findDOMNode(node);
            }
          })) : react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
            className: 'html-code-wrap',
            ref: function ref(node) {
              return _this9.nodeMdPreviewWraper = react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.findDOMNode(node);
            },
            onScroll: _this9.handlePreviewScroll
          }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(HtmlCode, {
            html: html,
            ref: function ref(node) {
              return _this9.nodeMdPreview = react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.findDOMNode(node);
            }
          }))));
        }

        return res;
      };

      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "rc-md-editor ".concat(fullScreen ? 'full' : ''),
        style: this.props.style,
        onKeyDown: this.handleonKeyDown
      }, renderNavigation(), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "editor-container"
      }, renderContent()));
    }
  }]);

  return MdEditor;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

MdEditor.HtmlRender = HtmlRender;
/* harmony default export */ __webpack_exports__["default"] = (MdEditor);

/***/ }),

/***/ "./src/editor/index.less":
/*!*******************************!*\
  !*** ./src/editor/index.less ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../node_modules/postcss-loader/lib!../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/editor/index.less");

if(typeof content === 'string') content = [[module.i, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! ../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(true) {
	module.hot.accept(/*! !../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../node_modules/postcss-loader/lib!../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/editor/index.less", function() {
		var newContent = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js??ref--6-1!../../node_modules/postcss-loader/lib!../../node_modules/less-loader/dist/cjs.js!./index.less */ "./node_modules/css-loader/dist/cjs.js?!./node_modules/postcss-loader/lib/index.js!./node_modules/less-loader/dist/cjs.js!./src/editor/index.less");

		if(typeof newContent === 'string') newContent = [[module.i, newContent, '']];

		var locals = (function(a, b) {
			var key, idx = 0;

			for(key in a) {
				if(!b || a[key] !== b[key]) return false;
				idx++;
			}

			for(key in b) idx--;

			return idx === 0;
		}(content.locals, newContent.locals));

		if(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');

		update(newContent);
	});

	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./editor */ "./src/editor/index.jsx");

/* harmony default export */ __webpack_exports__["default"] = (_editor__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./src/utils/decorate.js":
/*!*******************************!*\
  !*** ./src/utils/decorate.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// deal with selection text
var Decorate =
/*#__PURE__*/
function () {
  function Decorate(target) {
    _classCallCheck(this, Decorate);

    _defineProperty(this, "name", 'selection decoration');

    _defineProperty(this, "target", '');

    _defineProperty(this, "type", '');

    _defineProperty(this, "option", {});

    _defineProperty(this, "result", '');

    this.target = target;
  }

  _createClass(Decorate, [{
    key: "getDecoratedText",
    value: function getDecoratedText(type) {
      var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.type = type;
      this.option = option;
      return this.result = this.calcDecorateText(this.type, option);
    }
  }, {
    key: "calcDecorateText",
    value: function calcDecorateText(type) {
      var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      switch (type) {
        case 'h1':
          return "\n# ".concat(this.target, " \n");

        case 'h2':
          return "\n## ".concat(this.target, " \n");

        case 'h3':
          return "\n### ".concat(this.target, " \n");

        case 'h4':
          return "\n#### ".concat(this.target, " \n");

        case 'h5':
          return "\n##### ".concat(this.target, " \n");

        case 'h6':
          return "\n###### ".concat(this.target, " \n");

        case 'bold':
          return "**".concat(this.target, "**");

        case 'italic':
          return "*".concat(this.target, "*");

        case 'underline':
          return "++".concat(this.target, "++");

        case 'strikethrough':
          return "~~".concat(this.target, "~~");

        case 'unorder':
          return "\n- ".concat(this.target, "\n");

        case 'order':
          return "\n1. ".concat(this.target, "\n");

        case 'quote':
          return "\n> ".concat(this.target, "\n");

        case 'hr':
          return "\n---\n";

        case 'inlinecode':
          return "`".concat(this.target, "`");

        case 'code':
          return "\n```\n".concat(this.target, "\n```\n");

        case 'table':
          // return `\n| ${this.target} |  |\n| -- | -- |\n|  |  |\n`
          return this.formatTableText(this.target, option);

        case 'image':
          return "![".concat(this.target, "](").concat(option.imageUrl || '', ")");

        case 'link':
          return "[".concat(this.target, "](").concat(option.linkUrl || '', ")");

        default:
          return "".concat(this.target);
      }
    }
  }, {
    key: "formatTableText",
    value: function formatTableText(target, option) {
      var _option$row = option.row,
          row = _option$row === void 0 ? 2 : _option$row,
          _option$col = option.col,
          col = _option$col === void 0 ? 2 : _option$col;
      var rowHeader = ['|'];
      var rowData = ['|'];
      var rowDivision = ['|'];
      var colStr = '';
      var result = '';

      for (var i = 0; i <= col; i++) {
        rowHeader.push(' Head |');
        rowDivision.push(' --- |');
        rowData.push(' Data |');
      }

      for (var j = 0; j <= row; j++) {
        colStr = colStr + '\n' + rowData.join('');
      }

      result = '\n' + rowHeader.join('') + '\n' + rowDivision.join('') + colStr + '\n';
      return result;
    }
  }]);

  return Decorate;
}();

/* harmony default export */ __webpack_exports__["default"] = (Decorate);

/***/ }),

/***/ "./src/utils/logger.js":
/*!*****************************!*\
  !*** ./src/utils/logger.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * logger: undo redo
 */
var Logger =
/*#__PURE__*/
function () {
  function Logger() {
    _classCallCheck(this, Logger);

    _defineProperty(this, "name", 'logger');

    _defineProperty(this, "record", []);

    _defineProperty(this, "recycle", []);
  }

  _createClass(Logger, [{
    key: "pushRecord",
    value: function pushRecord(val) {
      return this.record.push(val);
    }
  }, {
    key: "getRecord",
    value: function getRecord() {
      return this.record;
    }
  }, {
    key: "getLastRecord",
    value: function getLastRecord() {
      var length = this.record.length;
      return this.record[length - 1];
    }
  }, {
    key: "undo",
    value: function undo(cb) {
      var lastRecord = this.record.pop();
      this.recycle.push(lastRecord);
      typeof cb === 'function' && cb(this.getLastRecord());
    }
  }, {
    key: "redo",
    value: function redo(cb) {
      if (this.recycle.length > 0) {
        var history = this.recycle.pop();
        this.record.push(history);
        typeof cb === 'function' && cb(this.getLastRecord());
      }
    }
  }, {
    key: "cleanRedoList",
    value: function cleanRedoList(cb) {
      this.recycle = [];
      typeof cb === 'function' && cb();
    }
  }]);

  return Logger;
}();

/* harmony default export */ __webpack_exports__["default"] = (Logger);

/***/ }),

/***/ "./src/utils/tool.js":
/*!***************************!*\
  !*** ./src/utils/tool.js ***!
  \***************************/
/*! exports provided: deepClone, isEmpty, isRepeat, throttle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepClone", function() { return deepClone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEmpty", function() { return isEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isRepeat", function() { return isRepeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return throttle; });
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function deepClone(obj) {
  if (!obj || _typeof(obj) !== 'object') {
    return obj;
  }

  var objArray = Array.isArray(obj) ? [] : {};

  if (obj && _typeof(obj) === 'object') {
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        // 如果obj的属性是对象，递归操作
        if (obj[key] && _typeof(obj[key]) === 'object') {
          objArray[key] = deepClone(obj[key]);
        } else {
          objArray[key] = obj[key];
        }
      }
    }
  }

  return objArray;
}
function isEmpty(obj) {
  // 判断字符是否为空的方法
  if (typeof obj === 'undefined' || obj === null || obj === '') {
    return true;
  }

  return false;
}
function isRepeat(arr) {
  var hash = {};

  for (var i in arr) {
    if (hash[arr[i]]) {
      return true;
    }

    hash[arr[i]] = true;
  }

  return false;
}
function throttle(func, deltaX) {
  var lastCalledAt = new Date().getTime();
  return function () {
    if (new Date().getTime() - lastCalledAt >= deltaX) {
      func.apply(this, arguments);
      lastCalledAt = new Date().getTime();
    }
  };
}

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vZXhhbXBsZS9jb250ZW50LmpzIiwid2VicGFjazovLy8uL2V4YW1wbGUvaW5kZXguanN4Iiwid2VicGFjazovLy8uL2V4YW1wbGUvaW5kZXgubGVzcz9jOWM2Iiwid2VicGFjazovLy8uL2V4YW1wbGUvaW5kZXgubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ecm9wTGlzdC9pbmRleC5sZXNzIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0hlYWRlckxpc3QvaW5kZXgubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9JY29uL2ZvbnQubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9JbnB1dEZpbGUvaW5kZXgubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9UYWJsZUxpc3QvaW5kZXgubGVzcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ub29sQmFyL2luZGV4Lmxlc3MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VkaXRvci9pbmRleC5sZXNzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3VybC1lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpbmtpZnktaXQvbGliL3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9lbnRpdGllcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX2Jsb2Nrcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2NvbW1vbi9odG1sX3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvY29tbW9uL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvaGVscGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19kZXN0aW5hdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua19sYWJlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2hlbHBlcnMvcGFyc2VfbGlua190aXRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2Jsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcGFyc2VyX2NvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9wYXJzZXJfaW5saW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9jb21tb25tYXJrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy9kZWZhdWx0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcHJlc2V0cy96ZXJvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2Jsb2NrL2Jsb2NrcXVvdGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9jb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svZmVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9oZWFkaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svaHIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9odG1sX2Jsb2NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svbGhlYWRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay9saXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcGFyYWdyYXBoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svcmVmZXJlbmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfYmxvY2svc3RhdGVfYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19ibG9jay90YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvYmxvY2suanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL2lubGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2NvcmUvbm9ybWFsaXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19jb3JlL3NtYXJ0cXVvdGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfY29yZS9zdGF0ZV9jb3JlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2F1dG9saW5rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2JhY2t0aWNrcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9iYWxhbmNlX3BhaXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VtcGhhc2lzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL2VudGl0eS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9lc2NhcGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvbGluay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9uZXdsaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3N0YXRlX2lubGluZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3J1bGVzX2lubGluZS9zdHJpa2V0aHJvdWdoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tYXJrZG93bi1pdC9saWIvcnVsZXNfaW5saW5lL3RleHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLWl0L2xpYi9ydWxlc19pbmxpbmUvdGV4dF9jb2xsYXBzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2Rvd24taXQvbGliL3Rva2VuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZHVybC9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21kdXJsL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWR1cmwvZm9ybWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tZHVybC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWR1cmwvcGFyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci90cmFjaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL0NjL3JlZ2V4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL0NmL3JlZ2V4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91Yy5taWNyby9jYXRlZ29yaWVzL1AvcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdWMubWljcm8vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ecm9wTGlzdC9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvRHJvcExpc3QvaW5kZXgubGVzcz8wMDNhIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0hlYWRlckxpc3QvaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0hlYWRlckxpc3QvaW5kZXgubGVzcz9hYzk4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL0ljb24vZm9udC5sZXNzP2YyMWMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvSWNvbi9mb250cy9pY29tb29uLndvZmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvSWNvbi9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvSW5wdXRGaWxlL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9JbnB1dEZpbGUvaW5kZXgubGVzcz9mYmNhIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL05hdmlnYXRpb25CYXIvaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL1RhYmxlTGlzdC9pbmRleC5qc3giLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvVGFibGVMaXN0L2luZGV4Lmxlc3M/MTMwYyIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ub29sQmFyL2luZGV4LmpzeCIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9Ub29sQmFyL2luZGV4Lmxlc3M/NmQ1MCIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlnLmpzIiwid2VicGFjazovLy8uL3NyYy9lZGl0b3IvaW5kZXguanN4Iiwid2VicGFjazovLy8uL3NyYy9lZGl0b3IvaW5kZXgubGVzcz82OGFlIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvZGVjb3JhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvdXRpbHMvdG9vbC5qcyJdLCJuYW1lcyI6WyJjb250ZW50IiwibW9ja19jb250ZW50IiwiRGVtbyIsInByb3BzIiwibWRpdCIsIk1hcmtkb3duSXQiLCJodG1sIiwibGlua2lmeSIsInR5cG9ncmFwaGVyIiwidGV4dCIsImZpbGUiLCJjYWxsYmFjayIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJjb252ZXJ0QmFzZTY0VXJsVG9CbG9iIiwidXJsRGF0YSIsImFyciIsInNwbGl0IiwibWltZSIsIm1hdGNoIiwiYnN0ciIsImF0b2IiLCJuIiwibGVuZ3RoIiwidThhcnIiLCJVaW50OEFycmF5IiwiY2hhckNvZGVBdCIsIkJsb2IiLCJ0eXBlIiwiYmxvYiIsInJlc3VsdCIsInNldFRpbWVvdXQiLCJyZWFkQXNEYXRhVVJMIiwibWRFZGl0b3IiLCJhbGVydCIsImdldE1kVmFsdWUiLCJnZXRIdG1sVmFsdWUiLCJoYW5kbGVHZXRNZFZhbHVlIiwiaGFuZGxlR2V0SHRtbFZhbHVlIiwibWFyZ2luVG9wIiwibm9kZSIsImhlaWdodCIsIndpZHRoIiwicmVuZGVyIiwidmlldyIsIm1lbnUiLCJtZCIsInRhYmxlIiwibWF4Um93IiwibWF4Q29sIiwiaW1hZ2VVcmwiLCJoYW5kbGVFZGl0b3JDaGFuZ2UiLCJoYW5kbGVJbWFnZVVwbG9hZCIsIlJlYWN0IiwiQ29tcG9uZW50IiwiUmVhY3RET00iLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwibW9kdWxlIiwiZXhwb3J0cyIsInVzZVNvdXJjZU1hcCIsImxpc3QiLCJ0b1N0cmluZyIsIm1hcCIsIml0ZW0iLCJjc3NXaXRoTWFwcGluZ1RvU3RyaW5nIiwiam9pbiIsImkiLCJtb2R1bGVzIiwibWVkaWFRdWVyeSIsImFscmVhZHlJbXBvcnRlZE1vZHVsZXMiLCJpZCIsInB1c2giLCJjc3NNYXBwaW5nIiwiYnRvYSIsInNvdXJjZU1hcHBpbmciLCJ0b0NvbW1lbnQiLCJzb3VyY2VVUkxzIiwic291cmNlcyIsInNvdXJjZSIsInNvdXJjZVJvb3QiLCJjb25jYXQiLCJzb3VyY2VNYXAiLCJiYXNlNjQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkYXRhIiwiZXNjYXBlIiwidXJsIiwibmVlZFF1b3RlcyIsInRlc3QiLCJzbGljZSIsInJlcGxhY2UiLCJhc3NpZ24iLCJvYmoiLCJBcnJheSIsInByb3RvdHlwZSIsImNhbGwiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiT2JqZWN0Iiwia2V5cyIsImtleSIsIl9jbGFzcyIsImlzU3RyaW5nIiwiaXNPYmplY3QiLCJpc1JlZ0V4cCIsImlzRnVuY3Rpb24iLCJlc2NhcGVSRSIsInN0ciIsImRlZmF1bHRPcHRpb25zIiwiZnV6enlMaW5rIiwiZnV6enlFbWFpbCIsImZ1enp5SVAiLCJpc09wdGlvbnNPYmoiLCJyZWR1Y2UiLCJhY2MiLCJrIiwiaGFzT3duUHJvcGVydHkiLCJkZWZhdWx0U2NoZW1hcyIsInZhbGlkYXRlIiwicG9zIiwic2VsZiIsInRhaWwiLCJyZSIsImh0dHAiLCJSZWdFeHAiLCJzcmNfYXV0aCIsInNyY19ob3N0X3BvcnRfc3RyaWN0Iiwic3JjX3BhdGgiLCJub19odHRwIiwic3JjX2RvbWFpbiIsInNyY19kb21haW5fcm9vdCIsInNyY19wb3J0Iiwic3JjX2hvc3RfdGVybWluYXRvciIsIm1haWx0byIsInNyY19lbWFpbF9uYW1lIiwic3JjX2hvc3Rfc3RyaWN0IiwidGxkc18yY2hfc3JjX3JlIiwidGxkc19kZWZhdWx0IiwicmVzZXRTY2FuQ2FjaGUiLCJfX2luZGV4X18iLCJfX3RleHRfY2FjaGVfXyIsImNyZWF0ZVZhbGlkYXRvciIsImNyZWF0ZU5vcm1hbGl6ZXIiLCJub3JtYWxpemUiLCJjb21waWxlIiwicmVxdWlyZSIsIl9fb3B0c19fIiwidGxkcyIsIl9fdGxkc19fIiwib25Db21waWxlIiwiX190bGRzX3JlcGxhY2VkX18iLCJzcmNfeG4iLCJzcmNfdGxkcyIsInVudHBsIiwidHBsIiwiZW1haWxfZnV6enkiLCJ0cGxfZW1haWxfZnV6enkiLCJsaW5rX2Z1enp5IiwidHBsX2xpbmtfZnV6enkiLCJsaW5rX25vX2lwX2Z1enp5IiwidHBsX2xpbmtfbm9faXBfZnV6enkiLCJob3N0X2Z1enp5X3Rlc3QiLCJ0cGxfaG9zdF9mdXp6eV90ZXN0IiwiYWxpYXNlcyIsIl9fY29tcGlsZWRfXyIsInNjaGVtYUVycm9yIiwibmFtZSIsInZhbCIsIkVycm9yIiwiX19zY2hlbWFzX18iLCJjb21waWxlZCIsImxpbmsiLCJhbGlhcyIsInNsaXN0IiwiZmlsdGVyIiwic2NoZW1hX3Rlc3QiLCJzcmNfWlBDYyIsInNjaGVtYV9zZWFyY2giLCJwcmV0ZXN0IiwiTWF0Y2giLCJzaGlmdCIsInN0YXJ0IiwiZW5kIiwiX19sYXN0X2luZGV4X18iLCJzY2hlbWEiLCJfX3NjaGVtYV9fIiwidG9Mb3dlckNhc2UiLCJpbmRleCIsImxhc3RJbmRleCIsInJhdyIsImNyZWF0ZU1hdGNoIiwiTGlua2lmeUl0Iiwic2NoZW1hcyIsIm9wdGlvbnMiLCJhZGQiLCJkZWZpbml0aW9uIiwic2V0IiwibSIsIm1sIiwibWUiLCJsZW4iLCJuZXh0IiwidGxkX3BvcyIsImF0X3BvcyIsImV4ZWMiLCJ0ZXN0U2NoZW1hQXQiLCJzZWFyY2giLCJpbmRleE9mIiwia2VlcE9sZCIsImlzQXJyYXkiLCJzb3J0IiwiZWwiLCJpZHgiLCJyZXZlcnNlIiwib3B0cyIsInNyY19BbnkiLCJzcmNfQ2MiLCJzcmNfWiIsInNyY19QIiwic3JjX1pDYyIsInRleHRfc2VwYXJhdG9ycyIsInNyY19wc2V1ZG9fbGV0dGVyIiwic3JjX2lwNCIsInNyY19ob3N0IiwidHBsX2hvc3RfZnV6enkiLCJ0cGxfaG9zdF9ub19pcF9mdXp6eSIsInRwbF9ob3N0X2Z1enp5X3N0cmljdCIsInRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0IiwidHBsX2hvc3RfcG9ydF9ub19pcF9mdXp6eV9zdHJpY3QiLCJhdHRyX25hbWUiLCJ1bnF1b3RlZCIsInNpbmdsZV9xdW90ZWQiLCJkb3VibGVfcXVvdGVkIiwiYXR0cl92YWx1ZSIsImF0dHJpYnV0ZSIsIm9wZW5fdGFnIiwiY2xvc2VfdGFnIiwiY29tbWVudCIsInByb2Nlc3NpbmciLCJkZWNsYXJhdGlvbiIsImNkYXRhIiwiSFRNTF9UQUdfUkUiLCJIVE1MX09QRU5fQ0xPU0VfVEFHX1JFIiwiX2hhc093blByb3BlcnR5IiwiaGFzIiwib2JqZWN0IiwiVHlwZUVycm9yIiwiYXJyYXlSZXBsYWNlQXQiLCJzcmMiLCJuZXdFbGVtZW50cyIsImlzVmFsaWRFbnRpdHlDb2RlIiwiYyIsImZyb21Db2RlUG9pbnQiLCJzdXJyb2dhdGUxIiwic3Vycm9nYXRlMiIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIlVORVNDQVBFX01EX1JFIiwiRU5USVRZX1JFIiwiVU5FU0NBUEVfQUxMX1JFIiwiRElHSVRBTF9FTlRJVFlfVEVTVF9SRSIsImVudGl0aWVzIiwicmVwbGFjZUVudGl0eVBhdHRlcm4iLCJjb2RlIiwicGFyc2VJbnQiLCJ1bmVzY2FwZU1kIiwidW5lc2NhcGVBbGwiLCJlc2NhcGVkIiwiZW50aXR5IiwiSFRNTF9FU0NBUEVfVEVTVF9SRSIsIkhUTUxfRVNDQVBFX1JFUExBQ0VfUkUiLCJIVE1MX1JFUExBQ0VNRU5UUyIsInJlcGxhY2VVbnNhZmVDaGFyIiwiY2giLCJlc2NhcGVIdG1sIiwiUkVHRVhQX0VTQ0FQRV9SRSIsImlzU3BhY2UiLCJpc1doaXRlU3BhY2UiLCJVTklDT0RFX1BVTkNUX1JFIiwiaXNQdW5jdENoYXIiLCJpc01kQXNjaWlQdW5jdCIsIm5vcm1hbGl6ZVJlZmVyZW5jZSIsInRyaW0iLCJ0b1VwcGVyQ2FzZSIsImxpYiIsIm1kdXJsIiwidWNtaWNybyIsInBhcnNlTGlua0xhYmVsIiwicGFyc2VMaW5rRGVzdGluYXRpb24iLCJwYXJzZUxpbmtUaXRsZSIsIm1heCIsImxldmVsIiwibGluZXMiLCJvayIsInN0YXRlIiwiZGlzYWJsZU5lc3RlZCIsImZvdW5kIiwibWFya2VyIiwicHJldlBvcyIsImxhYmVsRW5kIiwicG9zTWF4Iiwib2xkUG9zIiwiaW5saW5lIiwic2tpcFRva2VuIiwidXRpbHMiLCJoZWxwZXJzIiwiUmVuZGVyZXIiLCJQYXJzZXJDb3JlIiwiUGFyc2VyQmxvY2siLCJQYXJzZXJJbmxpbmUiLCJwdW55Y29kZSIsImNvbmZpZyIsInplcm8iLCJjb21tb25tYXJrIiwiQkFEX1BST1RPX1JFIiwiR09PRF9EQVRBX1JFIiwidmFsaWRhdGVMaW5rIiwiUkVDT0RFX0hPU1ROQU1FX0ZPUiIsIm5vcm1hbGl6ZUxpbmsiLCJwYXJzZWQiLCJwYXJzZSIsImhvc3RuYW1lIiwicHJvdG9jb2wiLCJ0b0FTQ0lJIiwiZXIiLCJlbmNvZGUiLCJmb3JtYXQiLCJub3JtYWxpemVMaW5rVGV4dCIsInRvVW5pY29kZSIsImRlY29kZSIsInByZXNldE5hbWUiLCJibG9jayIsImNvcmUiLCJyZW5kZXJlciIsImNvbmZpZ3VyZSIsInByZXNldHMiLCJjb21wb25lbnRzIiwicnVsZXMiLCJydWxlciIsImVuYWJsZU9ubHkiLCJydWxlczIiLCJydWxlcjIiLCJlbmFibGUiLCJpZ25vcmVJbnZhbGlkIiwiY2hhaW4iLCJtaXNzZWQiLCJkaXNhYmxlIiwidXNlIiwicGx1Z2luIiwiYXJncyIsImFwcGx5IiwiZW52IiwiU3RhdGUiLCJwcm9jZXNzIiwidG9rZW5zIiwicGFyc2VJbmxpbmUiLCJpbmxpbmVNb2RlIiwicmVuZGVySW5saW5lIiwiUnVsZXIiLCJfcnVsZXMiLCJhbHQiLCJ0b2tlbml6ZSIsInN0YXJ0TGluZSIsImVuZExpbmUiLCJnZXRSdWxlcyIsImxpbmUiLCJoYXNFbXB0eUxpbmVzIiwibWF4TmVzdGluZyIsInNraXBFbXB0eUxpbmVzIiwic0NvdW50IiwiYmxrSW5kZW50IiwidGlnaHQiLCJpc0VtcHR5Iiwib3V0VG9rZW5zIiwibGluZU1heCIsIkNvcmUiLCJsIiwiX3J1bGVzMiIsInBvc3RQcm9jZXNzIiwiY2FjaGUiLCJwZW5kaW5nIiwicHVzaFBlbmRpbmciLCJ4aHRtbE91dCIsImJyZWFrcyIsImxhbmdQcmVmaXgiLCJxdW90ZXMiLCJoaWdobGlnaHQiLCJkZWZhdWx0X3J1bGVzIiwiY29kZV9pbmxpbmUiLCJzbGYiLCJ0b2tlbiIsInJlbmRlckF0dHJzIiwiY29kZV9ibG9jayIsImZlbmNlIiwiaW5mbyIsImxhbmdOYW1lIiwiaGlnaGxpZ2h0ZWQiLCJ0bXBBdHRycyIsInRtcFRva2VuIiwiYXR0ckluZGV4IiwiYXR0cnMiLCJpbWFnZSIsInJlbmRlcklubGluZUFzVGV4dCIsImNoaWxkcmVuIiwicmVuZGVyVG9rZW4iLCJoYXJkYnJlYWsiLCJzb2Z0YnJlYWsiLCJodG1sX2Jsb2NrIiwiaHRtbF9pbmxpbmUiLCJuZXh0VG9rZW4iLCJuZWVkTGYiLCJoaWRkZW4iLCJuZXN0aW5nIiwidGFnIiwiX19ydWxlc19fIiwiX19jYWNoZV9fIiwiX19maW5kX18iLCJfX2NvbXBpbGVfXyIsImNoYWlucyIsInJ1bGUiLCJlbmFibGVkIiwiYWx0TmFtZSIsImZuIiwiYXQiLCJvcHQiLCJiZWZvcmUiLCJiZWZvcmVOYW1lIiwicnVsZU5hbWUiLCJzcGxpY2UiLCJhZnRlciIsImFmdGVyTmFtZSIsImNoYWluTmFtZSIsImJsb2NrcXVvdGUiLCJzaWxlbnQiLCJhZGp1c3RUYWIiLCJpbml0aWFsIiwibGFzdExpbmVFbXB0eSIsIm5leHRMaW5lIiwib2Zmc2V0Iiwib2xkQk1hcmtzIiwib2xkQlNDb3VudCIsIm9sZEluZGVudCIsIm9sZFBhcmVudFR5cGUiLCJvbGRTQ291bnQiLCJvbGRUU2hpZnQiLCJzcGFjZUFmdGVyTWFya2VyIiwidGVybWluYXRlIiwidGVybWluYXRvclJ1bGVzIiwid2FzT3V0ZGVudGVkIiwib2xkTGluZU1heCIsImJNYXJrcyIsInRTaGlmdCIsImVNYXJrcyIsImJzQ291bnQiLCJwYXJlbnRUeXBlIiwibWFya3VwIiwibGFzdCIsImdldExpbmVzIiwicGFyYW1zIiwibWVtIiwiaGF2ZUVuZE1hcmtlciIsInNraXBDaGFycyIsInNraXBTcGFjZXMiLCJoZWFkaW5nIiwidG1wIiwic2tpcFNwYWNlc0JhY2siLCJza2lwQ2hhcnNCYWNrIiwiaHIiLCJjbnQiLCJibG9ja19uYW1lcyIsIkhUTUxfU0VRVUVOQ0VTIiwibGluZVRleHQiLCJsaGVhZGluZyIsInNraXBCdWxsZXRMaXN0TWFya2VyIiwic2tpcE9yZGVyZWRMaXN0TWFya2VyIiwibWFya1RpZ2h0UGFyYWdyYXBocyIsImNvbnRlbnRTdGFydCIsImluZGVudCIsImluZGVudEFmdGVyTWFya2VyIiwiaXNPcmRlcmVkIiwiaXRlbUxpbmVzIiwibGlzdExpbmVzIiwibGlzdFRva0lkeCIsIm1hcmtlckNoYXJDb2RlIiwibWFya2VyVmFsdWUiLCJvbGRMSW5kZW50Iiwib2xkVGlnaHQiLCJwb3NBZnRlck1hcmtlciIsInByZXZFbXB0eUVuZCIsImlzVGVybWluYXRpbmdQYXJhZ3JhcGgiLCJOdW1iZXIiLCJzdWJzdHIiLCJNYXRoIiwibWluIiwicGFyYWdyYXBoIiwicmVmZXJlbmNlIiwiX2VuZExpbmUiLCJkZXN0RW5kUG9zIiwiZGVzdEVuZExpbmVObyIsImhyZWYiLCJsYWJlbCIsInJlcyIsInRpdGxlIiwicmVmZXJlbmNlcyIsIlRva2VuIiwiU3RhdGVCbG9jayIsInMiLCJpbmRlbnRfZm91bmQiLCJkZEluZGVudCIsImZyb20iLCJiZWdpbiIsImtlZXBMYXN0TEYiLCJsaW5lSW5kZW50IiwiZmlyc3QiLCJxdWV1ZSIsImxpbmVTdGFydCIsImdldExpbmUiLCJlc2NhcGVkU3BsaXQiLCJlc2NhcGVzIiwibGFzdFBvcyIsImJhY2tUaWNrZWQiLCJsYXN0QmFja1RpY2siLCJzdWJzdHJpbmciLCJjb2x1bW5zIiwiY29sdW1uQ291bnQiLCJhbGlnbnMiLCJ0IiwidGFibGVMaW5lcyIsInRib2R5TGluZXMiLCJ0b2siLCJpc0xpbmtPcGVuIiwiaXNMaW5rQ2xvc2UiLCJqIiwiY3VycmVudFRva2VuIiwibm9kZXMiLCJsbiIsImh0bWxMaW5rTGV2ZWwiLCJmdWxsVXJsIiwidXJsVGV4dCIsImJsb2NrVG9rZW5zIiwibGlua3MiLCJORVdMSU5FU19SRSIsIk5VTExfUkUiLCJSQVJFX1JFIiwiU0NPUEVEX0FCQlJfVEVTVF9SRSIsIlNDT1BFRF9BQkJSX1JFIiwiU0NPUEVEX0FCQlIiLCJyIiwicCIsInRtIiwicmVwbGFjZUZuIiwicmVwbGFjZV9zY29wZWQiLCJpbmxpbmVUb2tlbnMiLCJpbnNpZGVfYXV0b2xpbmsiLCJyZXBsYWNlX3JhcmUiLCJibGtJZHgiLCJRVU9URV9URVNUX1JFIiwiUVVPVEVfUkUiLCJBUE9TVFJPUEhFIiwicmVwbGFjZUF0IiwicHJvY2Vzc19pbmxpbmVzIiwidGhpc0xldmVsIiwibGFzdENoYXIiLCJuZXh0Q2hhciIsImlzTGFzdFB1bmN0Q2hhciIsImlzTmV4dFB1bmN0Q2hhciIsImlzTGFzdFdoaXRlU3BhY2UiLCJpc05leHRXaGl0ZVNwYWNlIiwiY2FuT3BlbiIsImNhbkNsb3NlIiwiaXNTaW5nbGUiLCJzdGFjayIsIm9wZW5RdW90ZSIsImNsb3NlUXVvdGUiLCJPVVRFUiIsInNpbmdsZSIsInNtYXJ0cXVvdGVzIiwiU3RhdGVDb3JlIiwiRU1BSUxfUkUiLCJBVVRPTElOS19SRSIsImF1dG9saW5rIiwibGlua01hdGNoIiwiZW1haWxNYXRjaCIsImJhY2t0aWNrIiwibWF0Y2hTdGFydCIsIm1hdGNoRW5kIiwibGlua19wYWlycyIsImxhc3REZWxpbSIsImN1cnJEZWxpbSIsImRlbGltaXRlcnMiLCJjbG9zZSIsImp1bXAiLCJvcGVuIiwib2RkX21hdGNoIiwiZW1waGFzaXMiLCJzY2FubmVkIiwic2NhbkRlbGltcyIsImNhbl9vcGVuIiwiY2FuX2Nsb3NlIiwic3RhcnREZWxpbSIsImVuZERlbGltIiwiaXNTdHJvbmciLCJESUdJVEFMX1JFIiwiTkFNRURfUkUiLCJFU0NBUEVEIiwiaXNMZXR0ZXIiLCJsYyIsImxhYmVsU3RhcnQiLCJyZWYiLCJwYXJzZVJlZmVyZW5jZSIsIm5ld2xpbmUiLCJwbWF4IiwiU3RhdGVJbmxpbmUiLCJwZW5kaW5nTGV2ZWwiLCJjYW5TcGxpdFdvcmQiLCJjb3VudCIsImxlZnRfZmxhbmtpbmciLCJyaWdodF9mbGFua2luZyIsInN0cmlrZXRocm91Z2giLCJsb25lTWFya2VycyIsInBvcCIsImlzVGVybWluYXRvckNoYXIiLCJ0ZXh0X2NvbGxhcHNlIiwiY3VyciIsIm1ldGEiLCJhdHRyUHVzaCIsImF0dHJEYXRhIiwiYXR0clNldCIsInZhbHVlIiwiYXR0ckdldCIsImF0dHJKb2luIiwiZGVjb2RlQ2FjaGUiLCJnZXREZWNvZGVDYWNoZSIsImV4Y2x1ZGUiLCJzdHJpbmciLCJkZWZhdWx0Q2hhcnMiLCJzZXEiLCJiMSIsImIyIiwiYjMiLCJiNCIsImNociIsImNvbXBvbmVudENoYXJzIiwiZW5jb2RlQ2FjaGUiLCJnZXRFbmNvZGVDYWNoZSIsImtlZXBFc2NhcGVkIiwibmV4dENvZGUiLCJzbGFzaGVzIiwiYXV0aCIsInBvcnQiLCJwYXRobmFtZSIsImhhc2giLCJVcmwiLCJwcm90b2NvbFBhdHRlcm4iLCJwb3J0UGF0dGVybiIsInNpbXBsZVBhdGhQYXR0ZXJuIiwiZGVsaW1zIiwidW53aXNlIiwiYXV0b0VzY2FwZSIsIm5vbkhvc3RDaGFycyIsImhvc3RFbmRpbmdDaGFycyIsImhvc3RuYW1lTWF4TGVuIiwiaG9zdG5hbWVQYXJ0UGF0dGVybiIsImhvc3RuYW1lUGFydFN0YXJ0IiwiaG9zdGxlc3NQcm90b2NvbCIsInNsYXNoZWRQcm90b2NvbCIsInVybFBhcnNlIiwic2xhc2hlc0Rlbm90ZUhvc3QiLCJ1IiwibG93ZXJQcm90byIsImhlYyIsInJlc3QiLCJzaW1wbGVQYXRoIiwicHJvdG8iLCJob3N0RW5kIiwiYXRTaWduIiwibGFzdEluZGV4T2YiLCJob3N0IiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwicGFydCIsIm5ld3BhcnQiLCJ2YWxpZFBhcnRzIiwibm90SG9zdCIsImJpdCIsInVuc2hpZnQiLCJxbSIsInJvb3QiLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImZyZWVHbG9iYWwiLCJnbG9iYWwiLCJ3aW5kb3ciLCJtYXhJbnQiLCJiYXNlIiwidE1pbiIsInRNYXgiLCJza2V3IiwiZGFtcCIsImluaXRpYWxCaWFzIiwiaW5pdGlhbE4iLCJkZWxpbWl0ZXIiLCJyZWdleFB1bnljb2RlIiwicmVnZXhOb25BU0NJSSIsInJlZ2V4U2VwYXJhdG9ycyIsImVycm9ycyIsImJhc2VNaW51c1RNaW4iLCJmbG9vciIsInN0cmluZ0Zyb21DaGFyQ29kZSIsImVycm9yIiwiUmFuZ2VFcnJvciIsImFycmF5IiwibWFwRG9tYWluIiwicGFydHMiLCJsYWJlbHMiLCJlbmNvZGVkIiwidWNzMmRlY29kZSIsIm91dHB1dCIsImNvdW50ZXIiLCJleHRyYSIsInVjczJlbmNvZGUiLCJiYXNpY1RvRGlnaXQiLCJjb2RlUG9pbnQiLCJkaWdpdFRvQmFzaWMiLCJkaWdpdCIsImZsYWciLCJhZGFwdCIsImRlbHRhIiwibnVtUG9pbnRzIiwiZmlyc3RUaW1lIiwiaW5wdXQiLCJpbnB1dExlbmd0aCIsIm91dCIsImJpYXMiLCJiYXNpYyIsIm9sZGkiLCJ3IiwiYmFzZU1pbnVzVCIsImhhbmRsZWRDUENvdW50IiwiYmFzaWNMZW5ndGgiLCJxIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsImRlZmluZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwidW5kZWZpbmVkIiwic2hvdWxkVXNlTmF0aXZlIiwidGVzdDEiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJvcmRlcjIiLCJ0ZXN0MyIsImxldHRlciIsImVyciIsInRhcmdldCIsInRvIiwic3ltYm9scyIsInByaW50V2FybmluZyIsIlJlYWN0UHJvcFR5cGVzU2VjcmV0IiwibG9nZ2VkVHlwZUZhaWx1cmVzIiwiRnVuY3Rpb24iLCJiaW5kIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ4IiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImNvbXBvbmVudE5hbWUiLCJnZXRTdGFjayIsInR5cGVTcGVjTmFtZSIsImV4IiwicmVzZXRXYXJuaW5nQ2FjaGUiLCJfYXNzaWduIiwic2NoZWR1bGVyIiwidHJhY2luZyIsInZhbGlkYXRlRm9ybWF0IiwiaW52YXJpYW50IiwiY29uZGl0aW9uIiwiYSIsImIiLCJkIiwiZSIsImYiLCJhcmdJbmRleCIsImZyYW1lc1RvUG9wIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCIsImZ1bmMiLCJjb250ZXh0IiwiZnVuY0FyZ3MiLCJvbkVycm9yIiwiZGlzcGF0Y2hFdmVudCIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJjcmVhdGVFbGVtZW50IiwiaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2IiwiZXZ0IiwiZGlkRXJyb3IiLCJ3aW5kb3dFdmVudCIsImV2ZW50Iiwid2luZG93RXZlbnREZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiY2FsbENhbGxiYWNrIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2dFR5cGUiLCJkaWRTZXRFcnJvciIsImlzQ3Jvc3NPcmlnaW5FcnJvciIsImhhbmRsZVdpbmRvd0Vycm9yIiwiY29sbm8iLCJsaW5lbm8iLCJkZWZhdWx0UHJldmVudGVkIiwiX3N1cHByZXNzTG9nZ2luZyIsImlubmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImluaXRFdmVudCIsImRlZmluZVByb3BlcnR5IiwiaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCQxIiwiaGFzRXJyb3IiLCJjYXVnaHRFcnJvciIsImhhc1JldGhyb3dFcnJvciIsInJldGhyb3dFcnJvciIsInJlcG9ydGVyIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yIiwiY2xlYXJDYXVnaHRFcnJvciIsInJldGhyb3dDYXVnaHRFcnJvciIsImhhc0NhdWdodEVycm9yIiwiZXZlbnRQbHVnaW5PcmRlciIsIm5hbWVzVG9QbHVnaW5zIiwicmVjb21wdXRlUGx1Z2luT3JkZXJpbmciLCJwbHVnaW5OYW1lIiwicGx1Z2luTW9kdWxlIiwicGx1Z2luSW5kZXgiLCJwbHVnaW5zIiwiZXh0cmFjdEV2ZW50cyIsInB1Ymxpc2hlZEV2ZW50cyIsImV2ZW50VHlwZXMiLCJldmVudE5hbWUiLCJwdWJsaXNoRXZlbnRGb3JQbHVnaW4iLCJkaXNwYXRjaENvbmZpZyIsImV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzIiwicGhhc2VOYW1lIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZSIsInB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lIiwicmVnaXN0cmF0aW9uTmFtZSIsInJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzIiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsImRlcGVuZGVuY2llcyIsImxvd2VyQ2FzZWROYW1lIiwicG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyIsIm9uZGJsY2xpY2siLCJpbmplY3RFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lIiwiaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyIsImlzT3JkZXJpbmdEaXJ0eSIsIndhcm5pbmdXaXRob3V0U3RhY2siLCJfbGVuIiwiX2tleSIsImFyZ3NXaXRoRm9ybWF0Iiwid2FybmluZ1dpdGhvdXRTdGFjayQxIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJnZXROb2RlRnJvbUluc3RhbmNlIiwic2V0Q29tcG9uZW50VHJlZSIsImdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGVJbXBsIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZUltcGwiLCJnZXROb2RlRnJvbUluc3RhbmNlSW1wbCIsInZhbGlkYXRlRXZlbnREaXNwYXRjaGVzIiwiZGlzcGF0Y2hMaXN0ZW5lcnMiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMiLCJkaXNwYXRjaEluc3RhbmNlcyIsIl9kaXNwYXRjaEluc3RhbmNlcyIsImxpc3RlbmVyc0lzQXJyIiwibGlzdGVuZXJzTGVuIiwiaW5zdGFuY2VzSXNBcnIiLCJpbnN0YW5jZXNMZW4iLCJleGVjdXRlRGlzcGF0Y2giLCJsaXN0ZW5lciIsImluc3QiLCJjdXJyZW50VGFyZ2V0IiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJhY2N1bXVsYXRlSW50byIsImN1cnJlbnQiLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJjYiIsInNjb3BlIiwiZXZlbnRRdWV1ZSIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSIsImlzUGVyc2lzdGVudCIsImNvbnN0cnVjdG9yIiwicmVsZWFzZSIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsIiwiaXNJbnRlcmFjdGl2ZSIsInNob3VsZFByZXZlbnRNb3VzZUV2ZW50IiwiZGlzYWJsZWQiLCJpbmplY3Rpb24iLCJnZXRMaXN0ZW5lciIsInN0YXRlTm9kZSIsInRvcExldmVsVHlwZSIsInRhcmdldEluc3QiLCJuYXRpdmVFdmVudCIsIm5hdGl2ZUV2ZW50VGFyZ2V0IiwiZXZlbnRzIiwicG9zc2libGVQbHVnaW4iLCJleHRyYWN0ZWRFdmVudHMiLCJydW5FdmVudHNJbkJhdGNoIiwicHJvY2Vzc2luZ0V2ZW50UXVldWUiLCJydW5FeHRyYWN0ZWRFdmVudHNJbkJhdGNoIiwiRnVuY3Rpb25Db21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJIb3N0Um9vdCIsIkhvc3RQb3J0YWwiLCJIb3N0Q29tcG9uZW50IiwiSG9zdFRleHQiLCJGcmFnbWVudCIsIk1vZGUiLCJDb250ZXh0Q29uc3VtZXIiLCJDb250ZXh0UHJvdmlkZXIiLCJGb3J3YXJkUmVmIiwiUHJvZmlsZXIiLCJTdXNwZW5zZUNvbXBvbmVudCIsIk1lbW9Db21wb25lbnQiLCJTaW1wbGVNZW1vQ29tcG9uZW50IiwiTGF6eUNvbXBvbmVudCIsIkluY29tcGxldGVDbGFzc0NvbXBvbmVudCIsIkRlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCIsInJhbmRvbUtleSIsInJhbmRvbSIsImludGVybmFsSW5zdGFuY2VLZXkiLCJpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkiLCJwcmVjYWNoZUZpYmVyTm9kZSIsImhvc3RJbnN0IiwiZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUiLCJwYXJlbnROb2RlIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSQxIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSQxIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxIiwidXBkYXRlRmliZXJQcm9wcyIsImdldFBhcmVudCIsInJldHVybiIsImdldExvd2VzdENvbW1vbkFuY2VzdG9yIiwiaW5zdEEiLCJpbnN0QiIsImRlcHRoQSIsInRlbXBBIiwiZGVwdGhCIiwidGVtcEIiLCJkZXB0aCIsImFsdGVybmF0ZSIsInRyYXZlcnNlVHdvUGhhc2UiLCJhcmciLCJwYXRoIiwidHJhdmVyc2VFbnRlckxlYXZlIiwiYXJnRnJvbSIsImFyZ1RvIiwiY29tbW9uIiwicGF0aEZyb20iLCJwYXRoVG8iLCJfYWx0ZXJuYXRlIiwiX2kiLCJsaXN0ZW5lckF0UGhhc2UiLCJwcm9wYWdhdGlvblBoYXNlIiwiYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyIsInBoYXNlIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSIsIl90YXJnZXRJbnN0IiwiYWNjdW11bGF0ZURpc3BhdGNoZXMiLCJpZ25vcmVkRGlyZWN0aW9uIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzIiwiYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzIiwibGVhdmUiLCJlbnRlciIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzIiwiY2FuVXNlRE9NIiwidW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlIiwidW5zYWZlQ2FzdERPTVRvcExldmVsVHlwZVRvU3RyaW5nIiwibWFrZVByZWZpeE1hcCIsInN0eWxlUHJvcCIsInByZWZpeGVzIiwidmVuZG9yUHJlZml4ZXMiLCJhbmltYXRpb25lbmQiLCJhbmltYXRpb25pdGVyYXRpb24iLCJhbmltYXRpb25zdGFydCIsInRyYW5zaXRpb25lbmQiLCJwcmVmaXhlZEV2ZW50TmFtZXMiLCJzdHlsZSIsImFuaW1hdGlvbiIsInRyYW5zaXRpb24iLCJnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSIsInByZWZpeE1hcCIsIlRPUF9BQk9SVCIsIlRPUF9BTklNQVRJT05fRU5EIiwiVE9QX0FOSU1BVElPTl9JVEVSQVRJT04iLCJUT1BfQU5JTUFUSU9OX1NUQVJUIiwiVE9QX0JMVVIiLCJUT1BfQ0FOX1BMQVkiLCJUT1BfQ0FOX1BMQVlfVEhST1VHSCIsIlRPUF9DQU5DRUwiLCJUT1BfQ0hBTkdFIiwiVE9QX0NMSUNLIiwiVE9QX0NMT1NFIiwiVE9QX0NPTVBPU0lUSU9OX0VORCIsIlRPUF9DT01QT1NJVElPTl9TVEFSVCIsIlRPUF9DT01QT1NJVElPTl9VUERBVEUiLCJUT1BfQ09OVEVYVF9NRU5VIiwiVE9QX0NPUFkiLCJUT1BfQ1VUIiwiVE9QX0RPVUJMRV9DTElDSyIsIlRPUF9BVVhfQ0xJQ0siLCJUT1BfRFJBRyIsIlRPUF9EUkFHX0VORCIsIlRPUF9EUkFHX0VOVEVSIiwiVE9QX0RSQUdfRVhJVCIsIlRPUF9EUkFHX0xFQVZFIiwiVE9QX0RSQUdfT1ZFUiIsIlRPUF9EUkFHX1NUQVJUIiwiVE9QX0RST1AiLCJUT1BfRFVSQVRJT05fQ0hBTkdFIiwiVE9QX0VNUFRJRUQiLCJUT1BfRU5DUllQVEVEIiwiVE9QX0VOREVEIiwiVE9QX0VSUk9SIiwiVE9QX0ZPQ1VTIiwiVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkUiLCJUT1BfSU5QVVQiLCJUT1BfSU5WQUxJRCIsIlRPUF9LRVlfRE9XTiIsIlRPUF9LRVlfUFJFU1MiLCJUT1BfS0VZX1VQIiwiVE9QX0xPQUQiLCJUT1BfTE9BRF9TVEFSVCIsIlRPUF9MT0FERURfREFUQSIsIlRPUF9MT0FERURfTUVUQURBVEEiLCJUT1BfTE9TVF9QT0lOVEVSX0NBUFRVUkUiLCJUT1BfTU9VU0VfRE9XTiIsIlRPUF9NT1VTRV9NT1ZFIiwiVE9QX01PVVNFX09VVCIsIlRPUF9NT1VTRV9PVkVSIiwiVE9QX01PVVNFX1VQIiwiVE9QX1BBU1RFIiwiVE9QX1BBVVNFIiwiVE9QX1BMQVkiLCJUT1BfUExBWUlORyIsIlRPUF9QT0lOVEVSX0NBTkNFTCIsIlRPUF9QT0lOVEVSX0RPV04iLCJUT1BfUE9JTlRFUl9NT1ZFIiwiVE9QX1BPSU5URVJfT1VUIiwiVE9QX1BPSU5URVJfT1ZFUiIsIlRPUF9QT0lOVEVSX1VQIiwiVE9QX1BST0dSRVNTIiwiVE9QX1JBVEVfQ0hBTkdFIiwiVE9QX1JFU0VUIiwiVE9QX1NDUk9MTCIsIlRPUF9TRUVLRUQiLCJUT1BfU0VFS0lORyIsIlRPUF9TRUxFQ1RJT05fQ0hBTkdFIiwiVE9QX1NUQUxMRUQiLCJUT1BfU1VCTUlUIiwiVE9QX1NVU1BFTkQiLCJUT1BfVEVYVF9JTlBVVCIsIlRPUF9USU1FX1VQREFURSIsIlRPUF9UT0dHTEUiLCJUT1BfVE9VQ0hfQ0FOQ0VMIiwiVE9QX1RPVUNIX0VORCIsIlRPUF9UT1VDSF9NT1ZFIiwiVE9QX1RPVUNIX1NUQVJUIiwiVE9QX1RSQU5TSVRJT05fRU5EIiwiVE9QX1ZPTFVNRV9DSEFOR0UiLCJUT1BfV0FJVElORyIsIlRPUF9XSEVFTCIsIm1lZGlhRXZlbnRUeXBlcyIsImdldFJhd0V2ZW50TmFtZSIsInN0YXJ0VGV4dCIsImZhbGxiYWNrVGV4dCIsImluaXRpYWxpemUiLCJnZXRUZXh0IiwicmVzZXQiLCJnZXREYXRhIiwic3RhcnRWYWx1ZSIsInN0YXJ0TGVuZ3RoIiwiZW5kVmFsdWUiLCJlbmRMZW5ndGgiLCJtaW5FbmQiLCJzbGljZVRhaWwiLCJ0ZXh0Q29udGVudCIsIkVWRU5UX1BPT0xfU0laRSIsIkV2ZW50SW50ZXJmYWNlIiwiZXZlbnRQaGFzZSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidGltZVN0YW1wIiwiRGF0ZSIsIm5vdyIsImlzVHJ1c3RlZCIsImZ1bmN0aW9uVGhhdFJldHVybnNUcnVlIiwiZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlIiwiU3ludGhldGljRXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImlzRGVmYXVsdFByZXZlbnRlZCIsIkludGVyZmFjZSIsInByb3BOYW1lIiwicmV0dXJuVmFsdWUiLCJjYW5jZWxCdWJibGUiLCJwZXJzaXN0IiwiZGVzdHJ1Y3RvciIsImdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24iLCJleHRlbmQiLCJTdXBlciIsIkUiLCJDbGFzcyIsImFkZEV2ZW50UG9vbGluZ1RvIiwiZ2V0VmFsIiwiY29uZmlndXJhYmxlIiwiZ2V0IiwiYWN0aW9uIiwid2FybiIsIndhcm5pbmdDb25kaXRpb24iLCJnZXRQb29sZWRFdmVudCIsIm5hdGl2ZUluc3QiLCJFdmVudENvbnN0cnVjdG9yIiwiZXZlbnRQb29sIiwiaW5zdGFuY2UiLCJyZWxlYXNlUG9vbGVkRXZlbnQiLCJnZXRQb29sZWQiLCJTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50IiwiU3ludGhldGljSW5wdXRFdmVudCIsIkVORF9LRVlDT0RFUyIsIlNUQVJUX0tFWUNPREUiLCJjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IiwiZG9jdW1lbnRNb2RlIiwiY2FuVXNlVGV4dElucHV0RXZlbnQiLCJ1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSIsIlNQQUNFQkFSX0NPREUiLCJTUEFDRUJBUl9DSEFSIiwiYmVmb3JlSW5wdXQiLCJidWJibGVkIiwiY2FwdHVyZWQiLCJjb21wb3NpdGlvbkVuZCIsImNvbXBvc2l0aW9uU3RhcnQiLCJjb21wb3NpdGlvblVwZGF0ZSIsImhhc1NwYWNlS2V5cHJlc3MiLCJpc0tleXByZXNzQ29tbWFuZCIsImN0cmxLZXkiLCJhbHRLZXkiLCJtZXRhS2V5IiwiZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCIsImtleUNvZGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQiLCJnZXREYXRhRnJvbUN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiaXNVc2luZ0tvcmVhbklNRSIsImxvY2FsZSIsImlzQ29tcG9zaW5nIiwiZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQiLCJldmVudFR5cGUiLCJmYWxsYmFja0RhdGEiLCJjdXN0b21EYXRhIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsIndoaWNoIiwiY2hhcnMiLCJnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnMiLCJjaGFyIiwiZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQiLCJCZWZvcmVJbnB1dEV2ZW50UGx1Z2luIiwiY29tcG9zaXRpb24iLCJyZXN0b3JlSW1wbCIsInJlc3RvcmVUYXJnZXQiLCJyZXN0b3JlUXVldWUiLCJyZXN0b3JlU3RhdGVPZlRhcmdldCIsImludGVybmFsSW5zdGFuY2UiLCJzZXRSZXN0b3JlSW1wbGVtZW50YXRpb24iLCJpbXBsIiwiZW5xdWV1ZVN0YXRlUmVzdG9yZSIsIm5lZWRzU3RhdGVSZXN0b3JlIiwicmVzdG9yZVN0YXRlSWZOZWVkZWQiLCJxdWV1ZWRUYXJnZXRzIiwiX2JhdGNoZWRVcGRhdGVzSW1wbCIsImJvb2trZWVwaW5nIiwiX2ludGVyYWN0aXZlVXBkYXRlc0ltcGwiLCJfZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXNJbXBsIiwiaXNCYXRjaGluZyIsImJhdGNoZWRVcGRhdGVzIiwiY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMiLCJpbnRlcmFjdGl2ZVVwZGF0ZXMiLCJzZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uIiwiYmF0Y2hlZFVwZGF0ZXNJbXBsIiwiaW50ZXJhY3RpdmVVcGRhdGVzSW1wbCIsImZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbCIsInN1cHBvcnRlZElucHV0VHlwZXMiLCJjb2xvciIsImRhdGUiLCJkYXRldGltZSIsImVtYWlsIiwibW9udGgiLCJudW1iZXIiLCJwYXNzd29yZCIsInJhbmdlIiwidGVsIiwidGltZSIsIndlZWsiLCJpc1RleHRJbnB1dEVsZW1lbnQiLCJlbGVtIiwibm9kZU5hbWUiLCJFTEVNRU5UX05PREUiLCJURVhUX05PREUiLCJDT01NRU5UX05PREUiLCJET0NVTUVOVF9OT0RFIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImdldEV2ZW50VGFyZ2V0Iiwic3JjRWxlbWVudCIsImNvcnJlc3BvbmRpbmdVc2VFbGVtZW50IiwiaXNFdmVudFN1cHBvcnRlZCIsImV2ZW50TmFtZVN1ZmZpeCIsImlzU3VwcG9ydGVkIiwiZWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImlzQ2hlY2thYmxlIiwiZ2V0VHJhY2tlciIsIl92YWx1ZVRyYWNrZXIiLCJkZXRhY2hUcmFja2VyIiwiZ2V0VmFsdWVGcm9tTm9kZSIsImNoZWNrZWQiLCJ0cmFja1ZhbHVlT25Ob2RlIiwidmFsdWVGaWVsZCIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwidHJhY2tlciIsImdldFZhbHVlIiwic2V0VmFsdWUiLCJzdG9wVHJhY2tpbmciLCJ0cmFjayIsInVwZGF0ZVZhbHVlSWZDaGFuZ2VkIiwibGFzdFZhbHVlIiwibmV4dFZhbHVlIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJCRUZPUkVfU0xBU0hfUkUiLCJkZXNjcmliZUNvbXBvbmVudEZyYW1lIiwib3duZXJOYW1lIiwic291cmNlSW5mbyIsImZpbGVOYW1lIiwicGF0aEJlZm9yZVNsYXNoIiwiZm9sZGVyTmFtZSIsImxpbmVOdW1iZXIiLCJoYXNTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSIsIlJFQUNUX0ZPUldBUkRfUkVGX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9UWVBFIiwiUkVBQ1RfTUVNT19UWVBFIiwiUkVBQ1RfTEFaWV9UWVBFIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsIlBlbmRpbmciLCJSZXNvbHZlZCIsIlJlamVjdGVkIiwicmVmaW5lUmVzb2x2ZWRMYXp5Q29tcG9uZW50IiwibGF6eUNvbXBvbmVudCIsIl9zdGF0dXMiLCJfcmVzdWx0IiwiZ2V0V3JhcHBlZE5hbWUiLCJvdXRlclR5cGUiLCJpbm5lclR5cGUiLCJ3cmFwcGVyTmFtZSIsImZ1bmN0aW9uTmFtZSIsImRpc3BsYXlOYW1lIiwiZ2V0Q29tcG9uZW50TmFtZSIsIiQkdHlwZW9mIiwidGhlbmFibGUiLCJyZXNvbHZlZFRoZW5hYmxlIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsImRlc2NyaWJlRmliZXIiLCJmaWJlciIsIm93bmVyIiwiX2RlYnVnT3duZXIiLCJfZGVidWdTb3VyY2UiLCJnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QiLCJ3b3JrSW5Qcm9ncmVzcyIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldiIsInJlc2V0Q3VycmVudEZpYmVyIiwiZ2V0Q3VycmVudFN0YWNrIiwic2V0Q3VycmVudEZpYmVyIiwic2V0Q3VycmVudFBoYXNlIiwibGlmZUN5Y2xlUGhhc2UiLCJ3YXJuaW5nIiwiZ2V0U3RhY2tBZGRlbmR1bSIsIndhcm5pbmckMSIsIlJFU0VSVkVEIiwiU1RSSU5HIiwiQk9PTEVBTklTSF9TVFJJTkciLCJCT09MRUFOIiwiT1ZFUkxPQURFRF9CT09MRUFOIiwiTlVNRVJJQyIsIlBPU0lUSVZFX05VTUVSSUMiLCJBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSIiwiQVRUUklCVVRFX05BTUVfQ0hBUiIsIlJPT1RfQVRUUklCVVRFX05BTUUiLCJWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCIsImlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJ2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUiLCJpc0F0dHJpYnV0ZU5hbWVTYWZlIiwiYXR0cmlidXRlTmFtZSIsInNob3VsZElnbm9yZUF0dHJpYnV0ZSIsInByb3BlcnR5SW5mbyIsImlzQ3VzdG9tQ29tcG9uZW50VGFnIiwic2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmciLCJhY2NlcHRzQm9vbGVhbnMiLCJwcmVmaXgiLCJzaG91bGRSZW1vdmVBdHRyaWJ1dGUiLCJpc05hTiIsImdldFByb3BlcnR5SW5mbyIsInByb3BlcnRpZXMiLCJQcm9wZXJ0eUluZm9SZWNvcmQiLCJtdXN0VXNlUHJvcGVydHkiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJwcm9wZXJ0eU5hbWUiLCJfcmVmIiwiQ0FNRUxJWkUiLCJjYXBpdGFsaXplIiwiZ2V0VmFsdWVGb3JQcm9wZXJ0eSIsImV4cGVjdGVkIiwic3RyaW5nVmFsdWUiLCJoYXNBdHRyaWJ1dGUiLCJnZXRBdHRyaWJ1dGUiLCJnZXRWYWx1ZUZvckF0dHJpYnV0ZSIsInNldFZhbHVlRm9yUHJvcGVydHkiLCJfYXR0cmlidXRlTmFtZSIsInJlbW92ZUF0dHJpYnV0ZSIsIl90eXBlIiwiYXR0cmlidXRlVmFsdWUiLCJzZXRBdHRyaWJ1dGVOUyIsImdldFRvU3RyaW5nVmFsdWUiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyIsImhhc1JlYWRPbmx5VmFsdWUiLCJidXR0b24iLCJjaGVja2JveCIsInJhZGlvIiwic3VibWl0IiwicHJvcFR5cGVzIiwib25DaGFuZ2UiLCJyZWFkT25seSIsInRhZ05hbWUiLCJlbmFibGVVc2VyVGltaW5nQVBJIiwiZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIiwiZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSIsInJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrIiwid2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMiLCJlbmFibGVQcm9maWxlclRpbWVyIiwiZW5hYmxlU2NoZWR1bGVyVHJhY2luZyIsImVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIiLCJkaXNhYmxlSW5wdXRBdHRyaWJ1dGVTeW5jaW5nIiwiZW5hYmxlU3RhYmxlQ29uY3VycmVudE1vZGVBUElzIiwid2FybkFib3V0U2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb24iLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUiLCJkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkIiwiZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCIsImRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQiLCJpc0NvbnRyb2xsZWQiLCJ1c2VzQ2hlY2tlZCIsImdldEhvc3RQcm9wcyIsImhvc3RQcm9wcyIsImRlZmF1bHRDaGVja2VkIiwiZGVmYXVsdFZhbHVlIiwiX3dyYXBwZXJTdGF0ZSIsImluaXRpYWxDaGVja2VkIiwiaW5pdFdyYXBwZXJTdGF0ZSIsImluaXRpYWxWYWx1ZSIsImNvbnRyb2xsZWQiLCJ1cGRhdGVDaGVja2VkIiwidXBkYXRlV3JhcHBlciIsIl9jb250cm9sbGVkIiwic2V0RGVmYXVsdFZhbHVlIiwicG9zdE1vdW50V3JhcHBlciIsImlzSHlkcmF0aW5nIiwiaXNCdXR0b24iLCJfaW5pdGlhbFZhbHVlIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSIsInVwZGF0ZU5hbWVkQ291c2lucyIsInJvb3ROb2RlIiwicXVlcnlSb290IiwiZ3JvdXAiLCJxdWVyeVNlbGVjdG9yQWxsIiwib3RoZXJOb2RlIiwiZm9ybSIsIm90aGVyUHJvcHMiLCJvd25lckRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImV2ZW50VHlwZXMkMSIsImNoYW5nZSIsImNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudCIsImFjdGl2ZUVsZW1lbnRJbnN0Iiwic2hvdWxkVXNlQ2hhbmdlRXZlbnQiLCJtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50IiwicnVuRXZlbnRJbkJhdGNoIiwiZ2V0SW5zdElmVmFsdWVDaGFuZ2VkIiwidGFyZ2V0Tm9kZSIsImdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCIsImlzSW5wdXRFdmVudFN1cHBvcnRlZCIsInN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsImF0dGFjaEV2ZW50IiwiaGFuZGxlUHJvcGVydHlDaGFuZ2UiLCJzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsImRldGFjaEV2ZW50IiwiaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsIiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCIsInNob3VsZFVzZUNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQiLCJoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyIiwiQ2hhbmdlRXZlbnRQbHVnaW4iLCJfaXNJbnB1dEV2ZW50U3VwcG9ydGVkIiwiZ2V0VGFyZ2V0SW5zdEZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJET01FdmVudFBsdWdpbk9yZGVyIiwiU3ludGhldGljVUlFdmVudCIsIm1vZGlmaWVyS2V5VG9Qcm9wIiwiQWx0IiwiQ29udHJvbCIsIk1ldGEiLCJTaGlmdCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImdldE1vZGlmaWVyU3RhdGUiLCJrZXlQcm9wIiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwicHJldmlvdXNTY3JlZW5YIiwicHJldmlvdXNTY3JlZW5ZIiwiaXNNb3ZlbWVudFhTZXQiLCJpc01vdmVtZW50WVNldCIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwicGFnZVgiLCJwYWdlWSIsInNoaWZ0S2V5IiwiYnV0dG9ucyIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsIm1vdmVtZW50WCIsIm1vdmVtZW50WSIsIlN5bnRoZXRpY1BvaW50ZXJFdmVudCIsInBvaW50ZXJJZCIsInByZXNzdXJlIiwidGFuZ2VudGlhbFByZXNzdXJlIiwidGlsdFgiLCJ0aWx0WSIsInR3aXN0IiwicG9pbnRlclR5cGUiLCJpc1ByaW1hcnkiLCJldmVudFR5cGVzJDIiLCJtb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsInBvaW50ZXJFbnRlciIsInBvaW50ZXJMZWF2ZSIsIkVudGVyTGVhdmVFdmVudFBsdWdpbiIsImlzT3ZlckV2ZW50IiwiaXNPdXRFdmVudCIsIndpbiIsImRvYyIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwicmVsYXRlZCIsImV2ZW50SW50ZXJmYWNlIiwibGVhdmVFdmVudFR5cGUiLCJlbnRlckV2ZW50VHlwZSIsImV2ZW50VHlwZVByZWZpeCIsImZyb21Ob2RlIiwidG9Ob2RlIiwiaXMiLCJ5IiwiaGFzT3duUHJvcGVydHkkMSIsInNoYWxsb3dFcXVhbCIsIm9iakEiLCJvYmpCIiwia2V5c0EiLCJrZXlzQiIsIl9yZWFjdEludGVybmFsRmliZXIiLCJOb0VmZmVjdCIsIlBlcmZvcm1lZFdvcmsiLCJQbGFjZW1lbnQiLCJVcGRhdGUiLCJQbGFjZW1lbnRBbmRVcGRhdGUiLCJEZWxldGlvbiIsIkNvbnRlbnRSZXNldCIsIkNhbGxiYWNrIiwiRGlkQ2FwdHVyZSIsIlJlZiIsIlNuYXBzaG90IiwiUGFzc2l2ZSIsIkxpZmVjeWNsZUVmZmVjdE1hc2siLCJIb3N0RWZmZWN0TWFzayIsIkluY29tcGxldGUiLCJTaG91bGRDYXB0dXJlIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiTU9VTlRJTkciLCJNT1VOVEVEIiwiVU5NT1VOVEVEIiwiaXNGaWJlck1vdW50ZWRJbXBsIiwiZWZmZWN0VGFnIiwiaXNGaWJlck1vdW50ZWQiLCJpc01vdW50ZWQiLCJjb21wb25lbnQiLCJvd25lckZpYmVyIiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiYXNzZXJ0SXNNb3VudGVkIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJwYXJlbnRBIiwicGFyZW50QiIsImNoaWxkIiwic2libGluZyIsImRpZEZpbmRDaGlsZCIsIl9jaGlsZCIsImZpbmRDdXJyZW50SG9zdEZpYmVyIiwicGFyZW50IiwiY3VycmVudFBhcmVudCIsImZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyIsImFkZEV2ZW50QnViYmxlTGlzdGVuZXIiLCJhZGRFdmVudENhcHR1cmVMaXN0ZW5lciIsIlN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50IiwiYW5pbWF0aW9uTmFtZSIsImVsYXBzZWRUaW1lIiwicHNldWRvRWxlbWVudCIsIlN5bnRoZXRpY0NsaXBib2FyZEV2ZW50IiwiY2xpcGJvYXJkRGF0YSIsIlN5bnRoZXRpY0ZvY3VzRXZlbnQiLCJnZXRFdmVudENoYXJDb2RlIiwiY2hhckNvZGUiLCJub3JtYWxpemVLZXkiLCJFc2MiLCJTcGFjZWJhciIsIkxlZnQiLCJVcCIsIlJpZ2h0IiwiRG93biIsIkRlbCIsIldpbiIsIk1lbnUiLCJBcHBzIiwiU2Nyb2xsIiwiTW96UHJpbnRhYmxlS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJnZXRFdmVudEtleSIsIlN5bnRoZXRpY0tleWJvYXJkRXZlbnQiLCJyZXBlYXQiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJkYXRhVHJhbnNmZXIiLCJTeW50aGV0aWNUb3VjaEV2ZW50IiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIlN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCIsIlN5bnRoZXRpY1doZWVsRXZlbnQiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsImludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMiLCJub25JbnRlcmFjdGl2ZUV2ZW50VHlwZU5hbWVzIiwiZXZlbnRUeXBlcyQ0IiwidG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnIiwiYWRkRXZlbnRUeXBlTmFtZVRvQ29uZmlnIiwidG9wRXZlbnQiLCJjYXBpdGFsaXplZEV2ZW50Iiwib25FdmVudCIsImV2ZW50VHVwbGUiLCJrbm93bkhUTUxUb3BMZXZlbFR5cGVzIiwiU2ltcGxlRXZlbnRQbHVnaW4iLCJpc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGUiLCJDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUiLCJjYWxsYmFja0Jvb2trZWVwaW5nUG9vbCIsImZpbmRSb290Q29udGFpbmVyTm9kZSIsImNvbnRhaW5lckluZm8iLCJnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmciLCJhbmNlc3RvcnMiLCJyZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwiaGFuZGxlVG9wTGV2ZWwiLCJib29rS2VlcGluZyIsImFuY2VzdG9yIiwiX2VuYWJsZWQiLCJzZXRFbmFibGVkIiwiaXNFbmFibGVkIiwidHJhcEJ1YmJsZWRFdmVudCIsImRpc3BhdGNoIiwiZGlzcGF0Y2hJbnRlcmFjdGl2ZUV2ZW50IiwidHJhcENhcHR1cmVkRXZlbnQiLCJhbHJlYWR5TGlzdGVuaW5nVG8iLCJyZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIiLCJ0b3BMaXN0ZW5lcnNJREtleSIsImdldExpc3RlbmluZ0ZvckRvY3VtZW50IiwibW91bnRBdCIsImxpc3RlblRvIiwiaXNMaXN0ZW5pbmciLCJkZXBlbmRlbmN5IiwiaXNNZWRpYUV2ZW50IiwiaXNMaXN0ZW5pbmdUb0FsbERlcGVuZGVuY2llcyIsImdldEFjdGl2ZUVsZW1lbnQiLCJib2R5IiwiZ2V0TGVhZk5vZGUiLCJmaXJzdENoaWxkIiwiZ2V0U2libGluZ05vZGUiLCJuZXh0U2libGluZyIsImdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQiLCJub2RlU3RhcnQiLCJub2RlRW5kIiwiZ2V0T2Zmc2V0cyIsIm91dGVyTm9kZSIsInNlbGVjdGlvbiIsImdldFNlbGVjdGlvbiIsInJhbmdlQ291bnQiLCJhbmNob3JOb2RlIiwiYW5jaG9yT2Zmc2V0IiwiZm9jdXNOb2RlIiwiZm9jdXNPZmZzZXQiLCJnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyIsImluZGV4V2l0aGluQW5jaG9yIiwiaW5kZXhXaXRoaW5Gb2N1cyIsIm91dGVyIiwibm9kZVZhbHVlIiwic2V0T2Zmc2V0cyIsIm9mZnNldHMiLCJ0ZW1wIiwic3RhcnRNYXJrZXIiLCJlbmRNYXJrZXIiLCJjcmVhdGVSYW5nZSIsInNldFN0YXJ0IiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJzZXRFbmQiLCJpc1RleHROb2RlIiwiY29udGFpbnNOb2RlIiwiaW5uZXJOb2RlIiwiY29udGFpbnMiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImlzSW5Eb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImlzU2FtZU9yaWdpbkZyYW1lIiwiaWZyYW1lIiwiY29udGVudFdpbmRvdyIsImdldEFjdGl2ZUVsZW1lbnREZWVwIiwiSFRNTElGcmFtZUVsZW1lbnQiLCJoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMiLCJjb250ZW50RWRpdGFibGUiLCJnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbiIsImZvY3VzZWRFbGVtIiwic2VsZWN0aW9uUmFuZ2UiLCJnZXRTZWxlY3Rpb24kMSIsInJlc3RvcmVTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsImxlZnQiLCJzY3JvbGxMZWZ0IiwidG9wIiwic2Nyb2xsVG9wIiwiZm9jdXMiLCJzZWxlY3Rpb25TdGFydCIsInNlbGVjdGlvbkVuZCIsInNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCIsImV2ZW50VHlwZXMkMyIsInNlbGVjdCIsImFjdGl2ZUVsZW1lbnQkMSIsImFjdGl2ZUVsZW1lbnRJbnN0JDEiLCJsYXN0U2VsZWN0aW9uIiwibW91c2VEb3duIiwiZ2V0RXZlbnRUYXJnZXREb2N1bWVudCIsImV2ZW50VGFyZ2V0IiwiY29uc3RydWN0U2VsZWN0RXZlbnQiLCJjdXJyZW50U2VsZWN0aW9uIiwiU2VsZWN0RXZlbnRQbHVnaW4iLCJkaWRXYXJuU2VsZWN0ZWRTZXRPbk9wdGlvbiIsImRpZFdhcm5JbnZhbGlkQ2hpbGQiLCJmbGF0dGVuQ2hpbGRyZW4iLCJDaGlsZHJlbiIsInZhbGlkYXRlUHJvcHMiLCJzZWxlY3RlZCIsInBvc3RNb3VudFdyYXBwZXIkMSIsImdldEhvc3RQcm9wcyQxIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEiLCJnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0iLCJ2YWx1ZVByb3BOYW1lcyIsImNoZWNrU2VsZWN0UHJvcFR5cGVzIiwibXVsdGlwbGUiLCJ1cGRhdGVPcHRpb25zIiwicHJvcFZhbHVlIiwic2V0RGVmYXVsdFNlbGVjdGVkIiwic2VsZWN0ZWRWYWx1ZXMiLCJzZWxlY3RlZFZhbHVlIiwiZGVmYXVsdFNlbGVjdGVkIiwiX3NlbGVjdGVkVmFsdWUiLCJfaTIiLCJnZXRIb3N0UHJvcHMkMiIsImluaXRXcmFwcGVyU3RhdGUkMSIsIndhc011bHRpcGxlIiwicG9zdE1vdW50V3JhcHBlciQyIiwicG9zdFVwZGF0ZVdyYXBwZXIiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIiLCJkaWRXYXJuVmFsRGVmYXVsdFZhbCIsImdldEhvc3RQcm9wcyQzIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJpbml0V3JhcHBlclN0YXRlJDIiLCJ1cGRhdGVXcmFwcGVyJDEiLCJuZXdWYWx1ZSIsInBvc3RNb3VudFdyYXBwZXIkMyIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyIsIkhUTUxfTkFNRVNQQUNFJDEiLCJNQVRIX05BTUVTUEFDRSIsIlNWR19OQU1FU1BBQ0UiLCJOYW1lc3BhY2VzIiwibWF0aG1sIiwic3ZnIiwiZ2V0SW50cmluc2ljTmFtZXNwYWNlIiwiZ2V0Q2hpbGROYW1lc3BhY2UiLCJwYXJlbnROYW1lc3BhY2UiLCJjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uIiwiTVNBcHAiLCJleGVjVW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJyZXVzYWJsZVNWR0NvbnRhaW5lciIsInNldElubmVySFRNTCIsIm5hbWVzcGFjZVVSSSIsImlubmVySFRNTCIsInN2Z05vZGUiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwic2V0VGV4dENvbnRlbnQiLCJsYXN0Q2hpbGQiLCJzaG9ydGhhbmRUb0xvbmdoYW5kIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRQb3NpdGlvbiIsImJvcmRlciIsImJvcmRlckJsb2NrRW5kIiwiYm9yZGVyQmxvY2tTdGFydCIsImJvcmRlckJvdHRvbSIsImJvcmRlckNvbG9yIiwiYm9yZGVySW1hZ2UiLCJib3JkZXJJbmxpbmVFbmQiLCJib3JkZXJJbmxpbmVTdGFydCIsImJvcmRlckxlZnQiLCJib3JkZXJSYWRpdXMiLCJib3JkZXJSaWdodCIsImJvcmRlclN0eWxlIiwiYm9yZGVyVG9wIiwiYm9yZGVyV2lkdGgiLCJjb2x1bW5SdWxlIiwiZmxleCIsImZsZXhGbG93IiwiZm9udCIsImZvbnRWYXJpYW50IiwiZ2FwIiwiZ3JpZCIsImdyaWRBcmVhIiwiZ3JpZENvbHVtbiIsImdyaWRDb2x1bW5HYXAiLCJncmlkR2FwIiwiZ3JpZFJvdyIsImdyaWRSb3dHYXAiLCJncmlkVGVtcGxhdGUiLCJsaXN0U3R5bGUiLCJtYXJnaW4iLCJtYXNrIiwibWFza1Bvc2l0aW9uIiwib3V0bGluZSIsIm92ZXJmbG93IiwicGFkZGluZyIsInBsYWNlQ29udGVudCIsInBsYWNlSXRlbXMiLCJwbGFjZVNlbGYiLCJ0ZXh0RGVjb3JhdGlvbiIsInRleHRFbXBoYXNpcyIsIndvcmRXcmFwIiwiaXNVbml0bGVzc051bWJlciIsImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IiwiYm9yZGVySW1hZ2VPdXRzZXQiLCJib3JkZXJJbWFnZVNsaWNlIiwiYm9yZGVySW1hZ2VXaWR0aCIsImJveEZsZXgiLCJib3hGbGV4R3JvdXAiLCJib3hPcmRpbmFsR3JvdXAiLCJmbGV4R3JvdyIsImZsZXhQb3NpdGl2ZSIsImZsZXhTaHJpbmsiLCJmbGV4TmVnYXRpdmUiLCJmbGV4T3JkZXIiLCJncmlkUm93RW5kIiwiZ3JpZFJvd1NwYW4iLCJncmlkUm93U3RhcnQiLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInByZWZpeEtleSIsImNoYXJBdCIsInByb3AiLCJkYW5nZXJvdXNTdHlsZVZhbHVlIiwiaXNDdXN0b21Qcm9wZXJ0eSIsInVwcGVyY2FzZVBhdHRlcm4iLCJtc1BhdHRlcm4iLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJ3YXJuVmFsaWRTdHlsZSIsImJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiIsIm1zUGF0dGVybiQxIiwiaHlwaGVuUGF0dGVybiIsImJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiIsIndhcm5lZFN0eWxlTmFtZXMiLCJ3YXJuZWRTdHlsZVZhbHVlcyIsIndhcm5lZEZvck5hTlZhbHVlIiwid2FybmVkRm9ySW5maW5pdHlWYWx1ZSIsImNhbWVsaXplIiwiXyIsImNoYXJhY3RlciIsIndhcm5IeXBoZW5hdGVkU3R5bGVOYW1lIiwid2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lIiwid2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uIiwid2FyblN0eWxlVmFsdWVJc05hTiIsIndhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSIsImlzRmluaXRlIiwid2FyblZhbGlkU3R5bGUkMSIsImNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyIsInN0eWxlcyIsInNlcmlhbGl6ZWQiLCJzdHlsZU5hbWUiLCJzdHlsZVZhbHVlIiwic2V0VmFsdWVGb3JTdHlsZXMiLCJzZXRQcm9wZXJ0eSIsImlzVmFsdWVFbXB0eSIsImV4cGFuZFNob3J0aGFuZE1hcCIsImV4cGFuZGVkIiwibG9uZ2hhbmRzIiwidmFsaWRhdGVTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbkluRGV2Iiwic3R5bGVVcGRhdGVzIiwibmV4dFN0eWxlcyIsImV4cGFuZGVkVXBkYXRlcyIsImV4cGFuZGVkU3R5bGVzIiwid2FybmVkQWJvdXQiLCJvcmlnaW5hbEtleSIsImNvcnJlY3RPcmlnaW5hbEtleSIsIndhcm5pbmdLZXkiLCJvbWl0dGVkQ2xvc2VUYWdzIiwiYXJlYSIsImJyIiwiY29sIiwiZW1iZWQiLCJpbWciLCJrZXlnZW4iLCJwYXJhbSIsIndiciIsInZvaWRFbGVtZW50VGFncyIsIm1lbnVpdGVtIiwiSFRNTCQxIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQyIiwiYXNzZXJ0VmFsaWRQcm9wcyIsInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyIsImlzQ3VzdG9tQ29tcG9uZW50IiwicG9zc2libGVTdGFuZGFyZE5hbWVzIiwiYWNjZXB0IiwiYWNjZXB0Y2hhcnNldCIsImFjY2Vzc2tleSIsImFsbG93ZnVsbHNjcmVlbiIsImFzIiwiYXN5bmMiLCJhdXRvY2FwaXRhbGl6ZSIsImF1dG9jb21wbGV0ZSIsImF1dG9jb3JyZWN0IiwiYXV0b2ZvY3VzIiwiYXV0b3BsYXkiLCJhdXRvc2F2ZSIsImNhcHR1cmUiLCJjZWxscGFkZGluZyIsImNlbGxzcGFjaW5nIiwiY2hhbGxlbmdlIiwiY2hhcnNldCIsImNpdGUiLCJjbGFzcyIsImNsYXNzaWQiLCJjbGFzc25hbWUiLCJjb2xzIiwiY29sc3BhbiIsImNvbnRlbnRlZGl0YWJsZSIsImNvbnRleHRtZW51IiwiY29udHJvbHMiLCJjb250cm9sc2xpc3QiLCJjb29yZHMiLCJjcm9zc29yaWdpbiIsImRhbmdlcm91c2x5c2V0aW5uZXJodG1sIiwiZGVmYXVsdCIsImRlZmF1bHRjaGVja2VkIiwiZGVmYXVsdHZhbHVlIiwiZGVmZXIiLCJkaXIiLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY3R5cGUiLCJmb3JtbWV0aG9kIiwiZm9ybWFjdGlvbiIsImZvcm1lbmN0eXBlIiwiZm9ybW5vdmFsaWRhdGUiLCJmb3JtdGFyZ2V0IiwiZnJhbWVib3JkZXIiLCJoZWFkZXJzIiwiaGlnaCIsImhyZWZsYW5nIiwiaHRtbGZvciIsImh0dHBlcXVpdiIsImljb24iLCJpbm5lcmh0bWwiLCJpbnB1dG1vZGUiLCJpbnRlZ3JpdHkiLCJpdGVtaWQiLCJpdGVtcHJvcCIsIml0ZW1yZWYiLCJpdGVtc2NvcGUiLCJpdGVtdHlwZSIsImtleXBhcmFtcyIsImtleXR5cGUiLCJraW5kIiwibGFuZyIsImxvb3AiLCJsb3ciLCJtYW5pZmVzdCIsIm1hcmdpbndpZHRoIiwibWFyZ2luaGVpZ2h0IiwibWF4bGVuZ3RoIiwibWVkaWEiLCJtZWRpYWdyb3VwIiwibWV0aG9kIiwibWlubGVuZ3RoIiwibXV0ZWQiLCJub21vZHVsZSIsIm5vbmNlIiwibm92YWxpZGF0ZSIsIm9wdGltdW0iLCJwYXR0ZXJuIiwicGxhY2Vob2xkZXIiLCJwbGF5c2lubGluZSIsInBvc3RlciIsInByZWxvYWQiLCJwcm9maWxlIiwicmFkaW9ncm91cCIsInJlYWRvbmx5IiwicmVmZXJyZXJwb2xpY3kiLCJyZWwiLCJyZXF1aXJlZCIsInJldmVyc2VkIiwicm9sZSIsInJvd3MiLCJyb3dzcGFuIiwic2FuZGJveCIsInNjb3BlZCIsInNjcm9sbGluZyIsInNlYW1sZXNzIiwic2hhcGUiLCJzaXplIiwic2l6ZXMiLCJzcGFuIiwic3BlbGxjaGVjayIsInNyY2RvYyIsInNyY2xhbmciLCJzcmNzZXQiLCJzdGVwIiwic3VtbWFyeSIsInRhYmluZGV4IiwidXNlbWFwIiwid21vZGUiLCJ3cmFwIiwiYWJvdXQiLCJhY2NlbnRoZWlnaHQiLCJhY2N1bXVsYXRlIiwiYWRkaXRpdmUiLCJhbGlnbm1lbnRiYXNlbGluZSIsImFsbG93cmVvcmRlciIsImFscGhhYmV0aWMiLCJhbXBsaXR1ZGUiLCJhcmFiaWNmb3JtIiwiYXNjZW50IiwiYXR0cmlidXRlbmFtZSIsImF0dHJpYnV0ZXR5cGUiLCJhdXRvcmV2ZXJzZSIsImF6aW11dGgiLCJiYXNlZnJlcXVlbmN5IiwiYmFzZWxpbmVzaGlmdCIsImJhc2Vwcm9maWxlIiwiYmJveCIsImJ5IiwiY2FsY21vZGUiLCJjYXBoZWlnaHQiLCJjbGlwIiwiY2xpcHBhdGgiLCJjbGlwcGF0aHVuaXRzIiwiY2xpcHJ1bGUiLCJjb2xvcmludGVycG9sYXRpb24iLCJjb2xvcmludGVycG9sYXRpb25maWx0ZXJzIiwiY29sb3Jwcm9maWxlIiwiY29sb3JyZW5kZXJpbmciLCJjb250ZW50c2NyaXB0dHlwZSIsImNvbnRlbnRzdHlsZXR5cGUiLCJjdXJzb3IiLCJjeCIsImN5IiwiZGF0YXR5cGUiLCJkZWNlbGVyYXRlIiwiZGVzY2VudCIsImRpZmZ1c2Vjb25zdGFudCIsImRpcmVjdGlvbiIsImRpc3BsYXkiLCJkaXZpc29yIiwiZG9taW5hbnRiYXNlbGluZSIsImR1ciIsImR4IiwiZHkiLCJlZGdlbW9kZSIsImVsZXZhdGlvbiIsImVuYWJsZWJhY2tncm91bmQiLCJleHBvbmVudCIsImV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQiLCJmaWxsIiwiZmlsbG9wYWNpdHkiLCJmaWxscnVsZSIsImZpbHRlcnJlcyIsImZpbHRlcnVuaXRzIiwiZmxvb2RvcGFjaXR5IiwiZmxvb2Rjb2xvciIsImZvY3VzYWJsZSIsImZvbnRmYW1pbHkiLCJmb250c2l6ZSIsImZvbnRzaXplYWRqdXN0IiwiZm9udHN0cmV0Y2giLCJmb250c3R5bGUiLCJmb250dmFyaWFudCIsImZvbnR3ZWlnaHQiLCJmeCIsImZ5IiwiZzEiLCJnMiIsImdseXBobmFtZSIsImdseXBob3JpZW50YXRpb25ob3Jpem9udGFsIiwiZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsIiwiZ2x5cGhyZWYiLCJncmFkaWVudHRyYW5zZm9ybSIsImdyYWRpZW50dW5pdHMiLCJoYW5naW5nIiwiaG9yaXphZHZ4IiwiaG9yaXpvcmlnaW54IiwiaWRlb2dyYXBoaWMiLCJpbWFnZXJlbmRlcmluZyIsImluMiIsImluIiwiaW5saXN0IiwiaW50ZXJjZXB0IiwiazEiLCJrMiIsImszIiwiazQiLCJrZXJuZWxtYXRyaXgiLCJrZXJuZWx1bml0bGVuZ3RoIiwia2VybmluZyIsImtleXBvaW50cyIsImtleXNwbGluZXMiLCJrZXl0aW1lcyIsImxlbmd0aGFkanVzdCIsImxldHRlcnNwYWNpbmciLCJsaWdodGluZ2NvbG9yIiwibGltaXRpbmdjb25lYW5nbGUiLCJsb2NhbCIsIm1hcmtlcmVuZCIsIm1hcmtlcmhlaWdodCIsIm1hcmtlcm1pZCIsIm1hcmtlcnN0YXJ0IiwibWFya2VydW5pdHMiLCJtYXJrZXJ3aWR0aCIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXRoZW1hdGljYWwiLCJtb2RlIiwibnVtb2N0YXZlcyIsIm9wZXJhdG9yIiwib3JpZW50Iiwib3JpZW50YXRpb24iLCJvcmlnaW4iLCJvdmVybGluZXBvc2l0aW9uIiwib3ZlcmxpbmV0aGlja25lc3MiLCJwYWludG9yZGVyIiwicGFub3NlMSIsInBhdGhsZW5ndGgiLCJwYXR0ZXJuY29udGVudHVuaXRzIiwicGF0dGVybnRyYW5zZm9ybSIsInBhdHRlcm51bml0cyIsInBvaW50ZXJldmVudHMiLCJwb2ludHMiLCJwb2ludHNhdHgiLCJwb2ludHNhdHkiLCJwb2ludHNhdHoiLCJwcmVzZXJ2ZWFscGhhIiwicHJlc2VydmVhc3BlY3RyYXRpbyIsInByaW1pdGl2ZXVuaXRzIiwicHJvcGVydHkiLCJyYWRpdXMiLCJyZWZ4IiwicmVmeSIsInJlbmRlcmluZ2ludGVudCIsInJlcGVhdGNvdW50IiwicmVwZWF0ZHVyIiwicmVxdWlyZWRleHRlbnNpb25zIiwicmVxdWlyZWRmZWF0dXJlcyIsInJlc291cmNlIiwicmVzdGFydCIsInJlc3VsdHMiLCJyb3RhdGUiLCJyeCIsInJ5Iiwic2NhbGUiLCJzZWN1cml0eSIsInNlZWQiLCJzaGFwZXJlbmRlcmluZyIsInNsb3BlIiwic3BhY2luZyIsInNwZWN1bGFyY29uc3RhbnQiLCJzcGVjdWxhcmV4cG9uZW50Iiwic3BlZWQiLCJzcHJlYWRtZXRob2QiLCJzdGFydG9mZnNldCIsInN0ZGRldmlhdGlvbiIsInN0ZW1oIiwic3RlbXYiLCJzdGl0Y2h0aWxlcyIsInN0b3Bjb2xvciIsInN0b3BvcGFjaXR5Iiwic3RyaWtldGhyb3VnaHBvc2l0aW9uIiwic3RyaWtldGhyb3VnaHRoaWNrbmVzcyIsInN0cm9rZSIsInN0cm9rZWRhc2hhcnJheSIsInN0cm9rZWRhc2hvZmZzZXQiLCJzdHJva2VsaW5lY2FwIiwic3Ryb2tlbGluZWpvaW4iLCJzdHJva2VtaXRlcmxpbWl0Iiwic3Ryb2tld2lkdGgiLCJzdHJva2VvcGFjaXR5Iiwic3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nIiwic3VwcHJlc3NoeWRyYXRpb253YXJuaW5nIiwic3VyZmFjZXNjYWxlIiwic3lzdGVtbGFuZ3VhZ2UiLCJ0YWJsZXZhbHVlcyIsInRhcmdldHgiLCJ0YXJnZXR5IiwidGV4dGFuY2hvciIsInRleHRkZWNvcmF0aW9uIiwidGV4dGxlbmd0aCIsInRleHRyZW5kZXJpbmciLCJ0cmFuc2Zvcm0iLCJ0eXBlb2YiLCJ1MSIsInUyIiwidW5kZXJsaW5lcG9zaXRpb24iLCJ1bmRlcmxpbmV0aGlja25lc3MiLCJ1bmljb2RlIiwidW5pY29kZWJpZGkiLCJ1bmljb2RlcmFuZ2UiLCJ1bml0c3BlcmVtIiwidW5zZWxlY3RhYmxlIiwidmFscGhhYmV0aWMiLCJ2ZWN0b3JlZmZlY3QiLCJ2ZXJzaW9uIiwidmVydGFkdnkiLCJ2ZXJ0b3JpZ2lueCIsInZlcnRvcmlnaW55IiwidmhhbmdpbmciLCJ2aWRlb2dyYXBoaWMiLCJ2aWV3Ym94Iiwidmlld3RhcmdldCIsInZpc2liaWxpdHkiLCJ2bWF0aGVtYXRpY2FsIiwidm9jYWIiLCJ3aWR0aHMiLCJ3b3Jkc3BhY2luZyIsIndyaXRpbmdtb2RlIiwieDEiLCJ4MiIsInhjaGFubmVsc2VsZWN0b3IiLCJ4aGVpZ2h0IiwieGxpbmthY3R1YXRlIiwieGxpbmthcmNyb2xlIiwieGxpbmtocmVmIiwieGxpbmtyb2xlIiwieGxpbmtzaG93IiwieGxpbmt0aXRsZSIsInhsaW5rdHlwZSIsInhtbGJhc2UiLCJ4bWxsYW5nIiwieG1sbnMiLCJ4bWxuc3hsaW5rIiwieG1sc3BhY2UiLCJ5MSIsInkyIiwieWNoYW5uZWxzZWxlY3RvciIsInoiLCJ6b29tYW5kcGFuIiwiYXJpYVByb3BlcnRpZXMiLCJ3YXJuZWRQcm9wZXJ0aWVzIiwickFSSUEiLCJyQVJJQUNhbWVsIiwiaGFzT3duUHJvcGVydHkkMiIsInZhbGlkYXRlUHJvcGVydHkiLCJhcmlhTmFtZSIsImNvcnJlY3ROYW1lIiwic3RhbmRhcmROYW1lIiwid2FybkludmFsaWRBUklBUHJvcHMiLCJpbnZhbGlkUHJvcHMiLCJpc1ZhbGlkIiwidW5rbm93blByb3BTdHJpbmciLCJ2YWxpZGF0ZVByb3BlcnRpZXMiLCJkaWRXYXJuVmFsdWVOdWxsIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDEiLCJ2YWxpZGF0ZVByb3BlcnR5JDEiLCJ3YXJuZWRQcm9wZXJ0aWVzJDEiLCJFVkVOVF9OQU1FX1JFR0VYIiwiSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYIiwickFSSUEkMSIsInJBUklBQ2FtZWwkMSIsImNhblVzZUV2ZW50U3lzdGVtIiwiaXNSZXNlcnZlZCIsIndhcm5Vbmtub3duUHJvcGVydGllcyIsInVua25vd25Qcm9wcyIsInZhbGlkYXRlUHJvcGVydGllcyQyIiwiZGlkV2FybkludmFsaWRIeWRyYXRpb24iLCJkaWRXYXJuU2hhZHlET00iLCJEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCIsIlNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEiLCJBVVRPRk9DVVMiLCJDSElMRFJFTiIsIlNUWUxFJDEiLCJIVE1MIiwiSFRNTF9OQU1FU1BBQ0UiLCJ3YXJuZWRVbmtub3duVGFncyIsInN1cHByZXNzSHlkcmF0aW9uV2FybmluZyIsInZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQiLCJ3YXJuRm9yVGV4dERpZmZlcmVuY2UiLCJ3YXJuRm9yUHJvcERpZmZlcmVuY2UiLCJ3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzIiwid2FybkZvckludmFsaWRFdmVudExpc3RlbmVyIiwiY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZyIsIm5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSIsIm5vcm1hbGl6ZUhUTUwiLCJkaWFsb2ciLCJ3ZWJ2aWV3IiwiTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYIiwiTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYIiwibWFya3VwU3RyaW5nIiwic2VydmVyVGV4dCIsImNsaWVudFRleHQiLCJub3JtYWxpemVkQ2xpZW50VGV4dCIsIm5vcm1hbGl6ZWRTZXJ2ZXJUZXh0Iiwic2VydmVyVmFsdWUiLCJjbGllbnRWYWx1ZSIsIm5vcm1hbGl6ZWRDbGllbnRWYWx1ZSIsIm5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSIsImF0dHJpYnV0ZU5hbWVzIiwibmFtZXMiLCJ0ZXN0RWxlbWVudCIsImNyZWF0ZUVsZW1lbnROUyIsImVuc3VyZUxpc3RlbmluZ1RvIiwicm9vdENvbnRhaW5lckVsZW1lbnQiLCJpc0RvY3VtZW50T3JGcmFnbWVudCIsImdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lciIsIm5vb3AiLCJ0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudCIsIm9uY2xpY2siLCJzZXRJbml0aWFsRE9NUHJvcGVydGllcyIsImRvbUVsZW1lbnQiLCJuZXh0UHJvcHMiLCJwcm9wS2V5IiwibmV4dFByb3AiLCJmcmVlemUiLCJuZXh0SHRtbCIsImNhblNldFRleHRDb250ZW50IiwidXBkYXRlRE9NUHJvcGVydGllcyIsInVwZGF0ZVBheWxvYWQiLCJ3YXNDdXN0b21Db21wb25lbnRUYWciLCJkaXYiLCJjcmVhdGVUZXh0Tm9kZSIsInNldEluaXRpYWxQcm9wZXJ0aWVzIiwicmF3UHJvcHMiLCJzaGFkeVJvb3QiLCJvbkNsaWNrIiwiZGlmZlByb3BlcnRpZXMiLCJsYXN0UmF3UHJvcHMiLCJuZXh0UmF3UHJvcHMiLCJsYXN0UHJvcHMiLCJsYXN0U3R5bGUiLCJsYXN0UHJvcCIsImxhc3RIdG1sIiwidXBkYXRlUHJvcGVydGllcyIsImdldFBvc3NpYmxlU3RhbmRhcmROYW1lIiwiZGlmZkh5ZHJhdGVkUHJvcGVydGllcyIsImV4dHJhQXR0cmlidXRlTmFtZXMiLCJTZXQiLCJhdHRyaWJ1dGVzIiwic2VydmVySFRNTCIsImV4cGVjdGVkSFRNTCIsImRlbGV0ZSIsImV4cGVjdGVkU3R5bGUiLCJpc01pc21hdGNoRHVlVG9CYWRDYXNpbmciLCJvd25OYW1lc3BhY2UiLCJkaWZmSHlkcmF0ZWRUZXh0IiwidGV4dE5vZGUiLCJpc0RpZmZlcmVudCIsIndhcm5Gb3JVbm1hdGNoZWRUZXh0Iiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCIsIndhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEiLCJ2YWxpZGF0ZURPTU5lc3RpbmciLCJ1cGRhdGVkQW5jZXN0b3JJbmZvIiwic3BlY2lhbFRhZ3MiLCJpblNjb3BlVGFncyIsImJ1dHRvblNjb3BlVGFncyIsImltcGxpZWRFbmRUYWdzIiwiZW1wdHlBbmNlc3RvckluZm8iLCJmb3JtVGFnIiwiYVRhZ0luU2NvcGUiLCJidXR0b25UYWdJblNjb3BlIiwibm9iclRhZ0luU2NvcGUiLCJwVGFnSW5CdXR0b25TY29wZSIsImxpc3RJdGVtVGFnQXV0b2Nsb3NpbmciLCJkbEl0ZW1UYWdBdXRvY2xvc2luZyIsIm9sZEluZm8iLCJhbmNlc3RvckluZm8iLCJpc1RhZ1ZhbGlkV2l0aFBhcmVudCIsInBhcmVudFRhZyIsImZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWciLCJkaWRXYXJuIiwiY2hpbGRUYWciLCJjaGlsZFRleHQiLCJwYXJlbnRJbmZvIiwiaW52YWxpZFBhcmVudCIsImludmFsaWRBbmNlc3RvciIsImludmFsaWRQYXJlbnRPckFuY2VzdG9yIiwiYW5jZXN0b3JUYWciLCJhZGRlbmR1bSIsIndhcm5LZXkiLCJ0YWdEaXNwbGF5TmFtZSIsIndoaXRlc3BhY2VJbmZvIiwic2hpbSIsInN1cHBvcnRzUGVyc2lzdGVuY2UiLCJjbG9uZUluc3RhbmNlIiwiY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQiLCJmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuIiwicmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuIiwiY2xvbmVIaWRkZW5JbnN0YW5jZSIsImNsb25lVW5oaWRkZW5JbnN0YW5jZSIsImNyZWF0ZUhpZGRlblRleHRJbnN0YW5jZSIsIlNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HIiwiU1VTUEVOU0VfU1RBUlRfREFUQSIsIlNVU1BFTlNFX0VORF9EQVRBIiwiU1RZTEUiLCJldmVudHNFbmFibGVkIiwic2VsZWN0aW9uSW5mb3JtYXRpb24iLCJzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50IiwiYXV0b0ZvY3VzIiwiZ2V0Um9vdEhvc3RDb250ZXh0Iiwicm9vdENvbnRhaW5lckluc3RhbmNlIiwibmFtZXNwYWNlIiwiY29udGFpbmVyIiwidmFsaWRhdGVkVGFnIiwiX2FuY2VzdG9ySW5mbyIsImdldENoaWxkSG9zdENvbnRleHQiLCJwYXJlbnRIb3N0Q29udGV4dCIsInBhcmVudEhvc3RDb250ZXh0RGV2IiwiX25hbWVzcGFjZSIsIl9hbmNlc3RvckluZm8yIiwiZ2V0UHVibGljSW5zdGFuY2UiLCJwcmVwYXJlRm9yQ29tbWl0IiwicmVzZXRBZnRlckNvbW1pdCIsImNyZWF0ZUluc3RhbmNlIiwiaG9zdENvbnRleHQiLCJpbnRlcm5hbEluc3RhbmNlSGFuZGxlIiwiaG9zdENvbnRleHREZXYiLCJvd25BbmNlc3RvckluZm8iLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJwYXJlbnRJbnN0YW5jZSIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwicHJlcGFyZVVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJzaG91bGRTZXRUZXh0Q29udGVudCIsIl9faHRtbCIsInNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUiLCJjcmVhdGVUZXh0SW5zdGFuY2UiLCJpc1ByaW1hcnlSZW5kZXJlciIsInNjaGVkdWxlVGltZW91dCIsImNhbmNlbFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJub1RpbWVvdXQiLCJzY2hlZHVsZVBhc3NpdmVFZmZlY3RzIiwidW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayIsImNhbmNlbFBhc3NpdmVFZmZlY3RzIiwidW5zdGFibGVfY2FuY2VsQ2FsbGJhY2siLCJzdXBwb3J0c011dGF0aW9uIiwiY29tbWl0TW91bnQiLCJjb21taXRVcGRhdGUiLCJyZXNldFRleHRDb250ZW50IiwiY29tbWl0VGV4dFVwZGF0ZSIsInRleHRJbnN0YW5jZSIsIm9sZFRleHQiLCJuZXdUZXh0IiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImluc2VydEJlZm9yZSIsInJlYWN0Um9vdENvbnRhaW5lciIsIl9yZWFjdFJvb3RDb250YWluZXIiLCJiZWZvcmVDaGlsZCIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwicmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyIiwiY2xlYXJTdXNwZW5zZUJvdW5kYXJ5Iiwic3VzcGVuc2VJbnN0YW5jZSIsIm5leHROb2RlIiwiY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lciIsImhpZGVJbnN0YW5jZSIsImhpZGVUZXh0SW5zdGFuY2UiLCJ1bmhpZGVJbnN0YW5jZSIsInVuaGlkZVRleHRJbnN0YW5jZSIsInN1cHBvcnRzSHlkcmF0aW9uIiwiY2FuSHlkcmF0ZUluc3RhbmNlIiwiY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSIsImNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlIiwiZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQiLCJoeWRyYXRlSW5zdGFuY2UiLCJoeWRyYXRlVGV4dEluc3RhbmNlIiwiZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSIsImRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UiLCJwYXJlbnRDb250YWluZXIiLCJkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlIiwicGFyZW50UHJvcHMiLCJkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UiLCJkaWROb3RIeWRyYXRlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlIiwiZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2UiLCJyZWFjdEVtb2ppIiwid2FybmluZ0Vtb2ppIiwic3VwcG9ydHNVc2VyVGltaW5nIiwicGVyZm9ybWFuY2UiLCJtYXJrIiwiY2xlYXJNYXJrcyIsIm1lYXN1cmUiLCJjbGVhck1lYXN1cmVzIiwiY3VycmVudEZpYmVyIiwiY3VycmVudFBoYXNlIiwiY3VycmVudFBoYXNlRmliZXIiLCJpc0NvbW1pdHRpbmciLCJoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQiLCJoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSIsImNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AiLCJlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCIsImlzV2FpdGluZ0ZvckNhbGxiYWNrIiwibGFiZWxzSW5DdXJyZW50Q29tbWl0IiwiZm9ybWF0TWFya05hbWUiLCJtYXJrTmFtZSIsImZvcm1hdExhYmVsIiwic3VmZml4IiwiYmVnaW5NYXJrIiwiY2xlYXJNYXJrIiwiZW5kTWFyayIsImZvcm1hdHRlZE1hcmtOYW1lIiwiZm9ybWF0dGVkTGFiZWwiLCJnZXRGaWJlck1hcmtOYW1lIiwiZGVidWdJRCIsImdldEZpYmVyTGFiZWwiLCJiZWdpbkZpYmVyTWFyayIsIl9kZWJ1Z0lEIiwiY2xlYXJGaWJlck1hcmsiLCJlbmRGaWJlck1hcmsiLCJzaG91bGRJZ25vcmVGaWJlciIsImNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQiLCJwYXVzZVRpbWVycyIsIl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nIiwicmVzdW1lVGltZXJzUmVjdXJzaXZlbHkiLCJyZXN1bWVUaW1lcnMiLCJyZWNvcmRFZmZlY3QiLCJyZWNvcmRTY2hlZHVsZVVwZGF0ZSIsInN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIiLCJzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIiLCJkaWRFeHBpcmUiLCJleHBpcmF0aW9uVGltZSIsInN0YXJ0V29ya1RpbWVyIiwiY2FuY2VsV29ya1RpbWVyIiwic3RvcFdvcmtUaW1lciIsInN0b3BGYWlsZWRXb3JrVGltZXIiLCJzdGFydFBoYXNlVGltZXIiLCJzdG9wUGhhc2VUaW1lciIsInN0YXJ0V29ya0xvb3BUaW1lciIsIm5leHRVbml0T2ZXb3JrIiwic3RvcFdvcmtMb29wVGltZXIiLCJpbnRlcnJ1cHRlZEJ5IiwiZGlkQ29tcGxldGVSb290Iiwic3RhcnRDb21taXRUaW1lciIsImNsZWFyIiwic3RvcENvbW1pdFRpbWVyIiwic3RhcnRDb21taXRTbmFwc2hvdEVmZmVjdHNUaW1lciIsInN0b3BDb21taXRTbmFwc2hvdEVmZmVjdHNUaW1lciIsInN0YXJ0Q29tbWl0SG9zdEVmZmVjdHNUaW1lciIsInN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyIiwic3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIiLCJzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyIiwidmFsdWVTdGFjayIsImZpYmVyU3RhY2siLCJjcmVhdGVDdXJzb3IiLCJjaGVja1RoYXRTdGFja0lzRW1wdHkiLCJyZXNldFN0YWNrQWZ0ZXJGYXRhbEVycm9ySW5EZXYiLCJ3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQiLCJlbXB0eUNvbnRleHRPYmplY3QiLCJjb250ZXh0U3RhY2tDdXJzb3IiLCJkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yIiwicHJldmlvdXNDb250ZXh0IiwiZ2V0VW5tYXNrZWRDb250ZXh0IiwiZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyIiwiaXNDb250ZXh0UHJvdmlkZXIiLCJjYWNoZUNvbnRleHQiLCJ1bm1hc2tlZENvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0IiwiZ2V0TWFza2VkQ29udGV4dCIsImNvbnRleHRUeXBlcyIsImhhc0NvbnRleHRDaGFuZ2VkIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJwb3BDb250ZXh0IiwicG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwicHVzaFRvcExldmVsQ29udGV4dE9iamVjdCIsImRpZENoYW5nZSIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiZ2V0Q2hpbGRDb250ZXh0IiwiY2hpbGRDb250ZXh0IiwiY29udGV4dEtleSIsInB1c2hDb250ZXh0UHJvdmlkZXIiLCJtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwiaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlciIsIm1lcmdlZENvbnRleHQiLCJmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCIsIm9uQ29tbWl0RmliZXJSb290Iiwib25Db21taXRGaWJlclVubW91bnQiLCJoYXNMb2dnZWRFcnJvciIsImNhdGNoRXJyb3JzIiwiaXNEZXZUb29sc1ByZXNlbnQiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpbmplY3RJbnRlcm5hbHMiLCJpbnRlcm5hbHMiLCJob29rIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJyZW5kZXJlcklEIiwiaW5qZWN0Iiwib25Db21taXRSb290Iiwib25Db21taXRVbm1vdW50IiwibWF4U2lnbmVkMzFCaXRJbnQiLCJOb1dvcmsiLCJOZXZlciIsIlN5bmMiLCJVTklUX1NJWkUiLCJNQUdJQ19OVU1CRVJfT0ZGU0VUIiwibXNUb0V4cGlyYXRpb25UaW1lIiwibXMiLCJleHBpcmF0aW9uVGltZVRvTXMiLCJjZWlsaW5nIiwibnVtIiwicHJlY2lzaW9uIiwiY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQiLCJjdXJyZW50VGltZSIsImV4cGlyYXRpb25Jbk1zIiwiYnVja2V0U2l6ZU1zIiwiTE9XX1BSSU9SSVRZX0VYUElSQVRJT04iLCJMT1dfUFJJT1JJVFlfQkFUQ0hfU0laRSIsImNvbXB1dGVBc3luY0V4cGlyYXRpb24iLCJISUdIX1BSSU9SSVRZX0VYUElSQVRJT04iLCJISUdIX1BSSU9SSVRZX0JBVENIX1NJWkUiLCJjb21wdXRlSW50ZXJhY3RpdmVFeHBpcmF0aW9uIiwiTm9Db250ZXh0IiwiQ29uY3VycmVudE1vZGUiLCJTdHJpY3RNb2RlIiwiUHJvZmlsZU1vZGUiLCJoYXNCYWRNYXBQb2x5ZmlsbCIsIm5vbkV4dGVuc2libGVPYmplY3QiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInRlc3RNYXAiLCJNYXAiLCJ0ZXN0U2V0IiwiZGVidWdDb3VudGVyIiwiRmliZXJOb2RlIiwicGVuZGluZ1Byb3BzIiwiZWxlbWVudFR5cGUiLCJtZW1vaXplZFByb3BzIiwidXBkYXRlUXVldWUiLCJtZW1vaXplZFN0YXRlIiwiY29udGV4dERlcGVuZGVuY2llcyIsIm5leHRFZmZlY3QiLCJmaXJzdEVmZmVjdCIsImxhc3RFZmZlY3QiLCJjaGlsZEV4cGlyYXRpb25UaW1lIiwiYWN0dWFsRHVyYXRpb24iLCJOYU4iLCJhY3R1YWxTdGFydFRpbWUiLCJzZWxmQmFzZUR1cmF0aW9uIiwidHJlZUJhc2VEdXJhdGlvbiIsIl9kZWJ1Z0hvb2tUeXBlcyIsImNyZWF0ZUZpYmVyIiwic2hvdWxkQ29uc3RydWN0IiwiaXNSZWFjdENvbXBvbmVudCIsImlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQiLCJkZWZhdWx0UHJvcHMiLCJyZXNvbHZlTGF6eUNvbXBvbmVudFRhZyIsImNyZWF0ZVdvcmtJblByb2dyZXNzIiwiY3JlYXRlSG9zdFJvb3RGaWJlciIsImlzQ29uY3VycmVudCIsImNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyIsImZpYmVyVGFnIiwicmVzb2x2ZWRUeXBlIiwiZ2V0VGFnIiwiY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQiLCJjcmVhdGVGaWJlckZyb21Nb2RlIiwiY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIiLCJjcmVhdGVGaWJlckZyb21TdXNwZW5zZSIsImNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQiLCJfb3duZXIiLCJfc291cmNlIiwiZWxlbWVudHMiLCJvblJlbmRlciIsImNyZWF0ZUZpYmVyRnJvbVRleHQiLCJjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbiIsImNyZWF0ZUZpYmVyRnJvbVBvcnRhbCIsInBvcnRhbCIsInBlbmRpbmdDaGlsZHJlbiIsImltcGxlbWVudGF0aW9uIiwiYXNzaWduRmliZXJQcm9wZXJ0aWVzSW5ERVYiLCJjcmVhdGVGaWJlclJvb3QiLCJoeWRyYXRlIiwidW5pbml0aWFsaXplZEZpYmVyIiwiZWFybGllc3RQZW5kaW5nVGltZSIsImxhdGVzdFBlbmRpbmdUaW1lIiwiZWFybGllc3RTdXNwZW5kZWRUaW1lIiwibGF0ZXN0U3VzcGVuZGVkVGltZSIsImxhdGVzdFBpbmdlZFRpbWUiLCJwaW5nQ2FjaGUiLCJwZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUiLCJmaW5pc2hlZFdvcmsiLCJ0aW1lb3V0SGFuZGxlIiwicGVuZGluZ0NvbnRleHQiLCJuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiIsImZpcnN0QmF0Y2giLCJuZXh0U2NoZWR1bGVkUm9vdCIsImludGVyYWN0aW9uVGhyZWFkSUQiLCJ1bnN0YWJsZV9nZXRUaHJlYWRJRCIsIm1lbW9pemVkSW50ZXJhY3Rpb25zIiwicGVuZGluZ0ludGVyYWN0aW9uTWFwIiwibG93UHJpb3JpdHlXYXJuaW5nIiwiX2xlbjIiLCJfa2V5MiIsImxvd1ByaW9yaXR5V2FybmluZyQxIiwiUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MiLCJkaXNjYXJkUGVuZGluZ1dhcm5pbmdzIiwiZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5ncyIsImZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwicmVjb3JkRGVwcmVjYXRpb25XYXJuaW5ncyIsInJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwicmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmciLCJmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiTElGRUNZQ0xFX1NVR0dFU1RJT05TIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUiLCJwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsInBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsInBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyIsImRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzIiwiZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyIsImRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQiLCJzZXRUb1NvcnRlZFN0cmluZyIsImxpZmVjeWNsZVdhcm5pbmdzTWFwIiwic3RyaWN0Um9vdCIsImxpZmVjeWNsZXNXYXJuaW5nTWVzc2FnZXMiLCJsaWZlY3ljbGUiLCJsaWZlY3ljbGVXYXJuaW5ncyIsImNvbXBvbmVudE5hbWVzIiwiZm9ybWF0dGVkIiwic3VnZ2VzdGlvbiIsInNvcnRlZENvbXBvbmVudE5hbWVzIiwic3RyaWN0Um9vdENvbXBvbmVudFN0YWNrIiwiZmluZFN0cmljdFJvb3QiLCJtYXliZVN0cmljdFJvb3QiLCJ1bmlxdWVOYW1lcyIsInNvcnRlZE5hbWVzIiwiX3VuaXF1ZU5hbWVzIiwiX3NvcnRlZE5hbWVzIiwiX3VuaXF1ZU5hbWVzMiIsIl9zb3J0ZWROYW1lczIiLCJjb21wb25lbnRXaWxsTW91bnQiLCJfX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJ3YXJuaW5nc0ZvclJvb3QiLCJ1bnNhZmVMaWZlY3ljbGVzIiwiZmliZXJBcnJheSIsIlJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24iLCJkZWJ1Z1Rvb2wiLCJSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEiLCJtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwiLCJmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24iLCJtYXJrQ29tbWl0dGVkUHJpb3JpdHlMZXZlbHMiLCJlYXJsaWVzdFJlbWFpbmluZ1RpbWUiLCJoYXNMb3dlclByaW9yaXR5V29yayIsImVycm9yZWRFeHBpcmF0aW9uVGltZSIsImlzUHJpb3JpdHlMZXZlbFN1c3BlbmRlZCIsIm1hcmtTdXNwZW5kZWRQcmlvcml0eUxldmVsIiwic3VzcGVuZGVkVGltZSIsImNsZWFyUGluZyIsIm1hcmtQaW5nZWRQcmlvcml0eUxldmVsIiwicGluZ2VkVGltZSIsImNvbXBsZXRlZFRpbWUiLCJmaW5kRWFybGllc3RPdXRzdGFuZGluZ1ByaW9yaXR5TGV2ZWwiLCJyZW5kZXJFeHBpcmF0aW9uVGltZSIsImVhcmxpZXN0RXhwaXJhdGlvblRpbWUiLCJkaWRFeHBpcmVBdEV4cGlyYXRpb25UaW1lIiwiY29tcGxldGVkRXhwaXJhdGlvblRpbWUiLCJyZXNvbHZlRGVmYXVsdFByb3BzIiwiYmFzZVByb3BzIiwicmVhZExhenlDb21wb25lbnRUeXBlIiwic3RhdHVzIiwiY3RvciIsIl9jdG9yIiwiX3RoZW5hYmxlIiwidGhlbiIsIm1vZHVsZU9iamVjdCIsImRlZmF1bHRFeHBvcnQiLCJmYWtlSW50ZXJuYWxJbnN0YW5jZSIsImlzQXJyYXkkMSIsImVtcHR5UmVmc09iamVjdCIsInJlZnMiLCJkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUiLCJkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUiLCJkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlIiwiZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwid2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwid2Fybk9uSW52YWxpZENhbGxiYWNrJDEiLCJkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZSIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzIiwiZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlIiwiZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrIiwiY2FsbGVyTmFtZSIsInBhcnRpYWxTdGF0ZSIsImFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwicHJldlN0YXRlIiwiYmFzZVN0YXRlIiwiY2xhc3NDb21wb25lbnRVcGRhdGVyIiwiZW5xdWV1ZVNldFN0YXRlIiwicGF5bG9hZCIsInJlcXVlc3RDdXJyZW50VGltZSIsImNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIiLCJ1cGRhdGUiLCJjcmVhdGVVcGRhdGUiLCJmbHVzaFBhc3NpdmVFZmZlY3RzIiwiZW5xdWV1ZVVwZGF0ZSIsInNjaGVkdWxlV29yayIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJGb3JjZVVwZGF0ZSIsImNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlIiwib2xkU3RhdGUiLCJuZXdTdGF0ZSIsIm5leHRDb250ZXh0Iiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwic2hvdWxkVXBkYXRlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJyZW5kZXJQcmVzZW50Iiwibm9HZXRJbml0aWFsU3RhdGVPbkVTNiIsImdldEluaXRpYWxTdGF0ZSIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwibm9HZXREZWZhdWx0UHJvcHNPbkVTNiIsImdldERlZmF1bHRQcm9wcyIsIm5vSW5zdGFuY2VQcm9wVHlwZXMiLCJub0luc3RhbmNlQ29udGV4dFR5cGUiLCJjb250ZXh0VHlwZSIsIm5vSW5zdGFuY2VDb250ZXh0VHlwZXMiLCJub0NvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsIm5vQ29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFVubW91bnQiLCJub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsIm5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJub1Vuc2FmZUNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsIm5vSW5zdGFuY2VEZWZhdWx0UHJvcHMiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsIm5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJub0luc3RhbmNlR2V0RGVyaXZlZFN0YXRlRnJvbUNhdGNoIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwibm9TdGF0aWNHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsIl9zdGF0ZSIsImFkb3B0Q2xhc3NJbnN0YW5jZSIsInVwZGF0ZXIiLCJfcmVhY3RJbnRlcm5hbEluc3RhbmNlIiwiY29uc3RydWN0Q2xhc3NJbnN0YW5jZSIsImlzTGVnYWN5Q29udGV4dENvbnN1bWVyIiwiX2NvbnRleHQiLCJyZWFkQ29udGV4dCIsImZvdW5kV2lsbE1vdW50TmFtZSIsImZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiX2NvbXBvbmVudE5hbWUiLCJuZXdBcGlOYW1lIiwiY2FsbENvbXBvbmVudFdpbGxNb3VudCIsImNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwibW91bnRDbGFzc0luc3RhbmNlIiwicHJvY2Vzc1VwZGF0ZVF1ZXVlIiwiY29tcG9uZW50RGlkTW91bnQiLCJyZXN1bWVNb3VudENsYXNzSW5zdGFuY2UiLCJvbGRDb250ZXh0IiwibmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCIsImhhc05ld0xpZmVjeWNsZXMiLCJyZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZyIsImNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmciLCJ1cGRhdGVDbGFzc0luc3RhbmNlIiwibmV4dFVubWFza2VkQ29udGV4dCIsImRpZFdhcm5BYm91dE1hcHMiLCJkaWRXYXJuQWJvdXRHZW5lcmF0b3JzIiwiZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlIiwib3duZXJIYXNLZXlVc2VXYXJuaW5nIiwib3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nIiwid2FybkZvck1pc3NpbmdLZXkiLCJfc3RvcmUiLCJ2YWxpZGF0ZWQiLCJjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwiY29lcmNlUmVmIiwicmV0dXJuRmliZXIiLCJjdXJyZW50JCQxIiwibWl4ZWRSZWYiLCJzdHJpbmdSZWYiLCJfc3RyaW5nUmVmIiwidGhyb3dPbkludmFsaWRPYmplY3RUeXBlIiwibmV3Q2hpbGQiLCJ3YXJuT25GdW5jdGlvblR5cGUiLCJDaGlsZFJlY29uY2lsZXIiLCJzaG91bGRUcmFja1NpZGVFZmZlY3RzIiwiZGVsZXRlQ2hpbGQiLCJjaGlsZFRvRGVsZXRlIiwiZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4iLCJjdXJyZW50Rmlyc3RDaGlsZCIsIm1hcFJlbWFpbmluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGQiLCJ1c2VGaWJlciIsImNsb25lIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJvbGRJbmRleCIsInBsYWNlU2luZ2xlQ2hpbGQiLCJ1cGRhdGVUZXh0Tm9kZSIsImNyZWF0ZWQiLCJleGlzdGluZyIsInVwZGF0ZUVsZW1lbnQiLCJ1cGRhdGVQb3J0YWwiLCJ1cGRhdGVGcmFnbWVudCIsImZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfY3JlYXRlZCIsIl9jcmVhdGVkMiIsIl9jcmVhdGVkMyIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIndhcm5PbkludmFsaWRLZXkiLCJrbm93bktleXMiLCJyZWNvbmNpbGVDaGlsZHJlbkFycmF5IiwibmV3Q2hpbGRyZW4iLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsIl9uZXdGaWJlciIsIl9uZXdGaWJlcjIiLCJyZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yIiwibmV3Q2hpbGRyZW5JdGVyYWJsZSIsIml0ZXJhdG9yRm4iLCJ0b1N0cmluZ1RhZyIsImVudHJpZXMiLCJfbmV3Q2hpbGRyZW4iLCJfc3RlcCIsImRvbmUiLCJfbmV3RmliZXIzIiwiX25ld0ZpYmVyNCIsInJlY29uY2lsZVNpbmdsZVRleHROb2RlIiwicmVjb25jaWxlU2luZ2xlRWxlbWVudCIsIl9jcmVhdGVkNCIsInJlY29uY2lsZVNpbmdsZVBvcnRhbCIsInJlY29uY2lsZUNoaWxkRmliZXJzIiwiaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCIsIl9pc01vY2tGdW5jdGlvbiIsIm1vdW50Q2hpbGRGaWJlcnMiLCJjbG9uZUNoaWxkRmliZXJzIiwiY3VycmVudENoaWxkIiwiTk9fQ09OVEVYVCIsImNvbnRleHRTdGFja0N1cnNvciQxIiwiY29udGV4dEZpYmVyU3RhY2tDdXJzb3IiLCJyb290SW5zdGFuY2VTdGFja0N1cnNvciIsInJlcXVpcmVkQ29udGV4dCIsImdldFJvb3RIb3N0Q29udGFpbmVyIiwicm9vdEluc3RhbmNlIiwicHVzaEhvc3RDb250YWluZXIiLCJuZXh0Um9vdEluc3RhbmNlIiwibmV4dFJvb3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsImdldEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRleHQiLCJOb0VmZmVjdCQxIiwiVW5tb3VudFNuYXBzaG90IiwiVW5tb3VudE11dGF0aW9uIiwiTW91bnRNdXRhdGlvbiIsIlVubW91bnRMYXlvdXQiLCJNb3VudExheW91dCIsIk1vdW50UGFzc2l2ZSIsIlVubW91bnRQYXNzaXZlIiwiUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxIiwiZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50IiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSIsImN1cnJlbnRIb29rIiwibmV4dEN1cnJlbnRIb29rIiwiZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2siLCJ3b3JrSW5Qcm9ncmVzc0hvb2siLCJuZXh0V29ya0luUHJvZ3Jlc3NIb29rIiwicmVtYWluaW5nRXhwaXJhdGlvblRpbWUiLCJjb21wb25lbnRVcGRhdGVRdWV1ZSIsInNpZGVFZmZlY3RUYWciLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlIiwicmVuZGVyUGhhc2VVcGRhdGVzIiwibnVtYmVyT2ZSZVJlbmRlcnMiLCJSRV9SRU5ERVJfTElNSVQiLCJjdXJyZW50SG9va05hbWVJbkRldiIsImhvb2tUeXBlc0RldiIsImhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2IiwibW91bnRIb29rVHlwZXNEZXYiLCJob29rTmFtZSIsInVwZGF0ZUhvb2tUeXBlc0RldiIsIndhcm5Pbkhvb2tNaXNtYXRjaEluRGV2IiwiY3VycmVudEhvb2tOYW1lIiwic2Vjb25kQ29sdW1uU3RhcnQiLCJvbGRIb29rTmFtZSIsIm5ld0hvb2tOYW1lIiwicm93IiwidGhyb3dJbnZhbGlkSG9va0Vycm9yIiwiYXJlSG9va0lucHV0c0VxdWFsIiwibmV4dERlcHMiLCJwcmV2RGVwcyIsInJlbmRlcldpdGhIb29rcyIsInJlZk9yQ29udGV4dCIsIm5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSIsIkhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWIiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWIiwiQ29udGV4dE9ubHlEaXNwYXRjaGVyIiwicmVuZGVyZWRXb3JrIiwiZGlkUmVuZGVyVG9vRmV3SG9va3MiLCJiYWlsb3V0SG9va3MiLCJyZXNldEhvb2tzIiwibW91bnRXb3JrSW5Qcm9ncmVzc0hvb2siLCJiYXNlVXBkYXRlIiwidXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rIiwibmV3SG9vayIsImNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUiLCJiYXNpY1N0YXRlUmVkdWNlciIsIm1vdW50UmVkdWNlciIsInJlZHVjZXIiLCJpbml0aWFsQXJnIiwiaW5pdCIsImluaXRpYWxTdGF0ZSIsImxhc3RSZW5kZXJlZFJlZHVjZXIiLCJsYXN0UmVuZGVyZWRTdGF0ZSIsImRpc3BhdGNoQWN0aW9uIiwidXBkYXRlUmVkdWNlciIsIl9kaXNwYXRjaCIsImZpcnN0UmVuZGVyUGhhc2VVcGRhdGUiLCJfYWN0aW9uIiwibWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUiLCJfbmV3U3RhdGUiLCJuZXdCYXNlU3RhdGUiLCJuZXdCYXNlVXBkYXRlIiwicHJldlVwZGF0ZSIsIl91cGRhdGUiLCJkaWRTa2lwIiwidXBkYXRlRXhwaXJhdGlvblRpbWUiLCJlYWdlclJlZHVjZXIiLCJlYWdlclN0YXRlIiwiX2FjdGlvbjIiLCJtb3VudFN0YXRlIiwidXBkYXRlU3RhdGUiLCJwdXNoRWZmZWN0IiwiY3JlYXRlIiwiZGVzdHJveSIsImRlcHMiLCJlZmZlY3QiLCJfbGFzdEVmZmVjdCIsIm1vdW50UmVmIiwic2VhbCIsInVwZGF0ZVJlZiIsIm1vdW50RWZmZWN0SW1wbCIsImZpYmVyRWZmZWN0VGFnIiwiaG9va0VmZmVjdFRhZyIsInVwZGF0ZUVmZmVjdEltcGwiLCJwcmV2RWZmZWN0IiwibW91bnRFZmZlY3QiLCJ1cGRhdGVFZmZlY3QiLCJtb3VudExheW91dEVmZmVjdCIsInVwZGF0ZUxheW91dEVmZmVjdCIsImltcGVyYXRpdmVIYW5kbGVFZmZlY3QiLCJyZWZDYWxsYmFjayIsIl9pbnN0IiwicmVmT2JqZWN0IiwiX2luc3QyIiwibW91bnRJbXBlcmF0aXZlSGFuZGxlIiwiZWZmZWN0RGVwcyIsInVwZGF0ZUltcGVyYXRpdmVIYW5kbGUiLCJtb3VudERlYnVnVmFsdWUiLCJmb3JtYXR0ZXJGbiIsInVwZGF0ZURlYnVnVmFsdWUiLCJtb3VudENhbGxiYWNrIiwidXBkYXRlQ2FsbGJhY2siLCJtb3VudE1lbW8iLCJuZXh0Q3JlYXRlIiwidXBkYXRlTWVtbyIsInNob3VsZFdhcm5Gb3JVbmJhdGNoZWRTZXRTdGF0ZSIsImplc3QiLCJsYXN0UmVuZGVyUGhhc2VVcGRhdGUiLCJfZXhwaXJhdGlvblRpbWUiLCJfdXBkYXRlMiIsIl9sYXN0IiwiX2xhc3RSZW5kZXJlZFJlZHVjZXIiLCJwcmV2RGlzcGF0Y2hlciIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWIiwiY3VycmVudFN0YXRlIiwiX2VhZ2VyU3RhdGUiLCJ3YXJuSWZOb3RDdXJyZW50bHlCYXRjaGluZ0luRGV2IiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUxheW91dEVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWR1Y2VyIiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VEZWJ1Z1ZhbHVlIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsIndhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyIsIndhcm5JbnZhbGlkSG9va0FjY2VzcyIsIm9ic2VydmVkQml0cyIsImNvbW1pdFRpbWUiLCJwcm9maWxlclN0YXJ0VGltZSIsImdldENvbW1pdFRpbWUiLCJyZWNvcmRDb21taXRUaW1lIiwidW5zdGFibGVfbm93Iiwic3RhcnRQcm9maWxlclRpbWVyIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmciLCJzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhIiwib3ZlcnJpZGVCYXNlVGltZSIsImh5ZHJhdGlvblBhcmVudEZpYmVyIiwibmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsImVudGVySHlkcmF0aW9uU3RhdGUiLCJyZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwiZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlIiwiaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZSIsIl9wcm9wcyIsIl90ZXh0IiwidHJ5SHlkcmF0ZSIsIm5leHRJbnN0YW5jZSIsInRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSIsInNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJwb3BIeWRyYXRpb25TdGF0ZSIsInJlc2V0SHlkcmF0aW9uU3RhdGUiLCJSZWFjdEN1cnJlbnRPd25lciQzIiwiZGlkUmVjZWl2ZVVwZGF0ZSIsImRpZFdhcm5BYm91dEJhZENsYXNzIiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmcyIsImRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMiLCJyZWNvbmNpbGVDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsImZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUiLCJ1cGRhdGVGb3J3YXJkUmVmIiwiaW5uZXJQcm9wVHlwZXMiLCJwcmVwYXJlVG9SZWFkQ29udGV4dCIsImJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsiLCJ1cGRhdGVNZW1vQ29tcG9uZW50IiwiY29tcGFyZSIsInZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldiIsInVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQiLCJfaW5uZXJQcm9wVHlwZXMiLCJwcmV2UHJvcHMiLCJvdXRlck1lbW9UeXBlIiwib3V0ZXJQcm9wVHlwZXMiLCJ1cGRhdGVGdW5jdGlvbkNvbXBvbmVudCIsInVwZGF0ZU1vZGUiLCJ1cGRhdGVQcm9maWxlciIsIm1hcmtSZWYiLCJ1cGRhdGVDbGFzc0NvbXBvbmVudCIsImhhc0NvbnRleHQiLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsImRpZENhcHR1cmVFcnJvciIsInB1c2hIb3N0Um9vdENvbnRleHQiLCJ1cGRhdGVIb3N0Um9vdCIsInByZXZDaGlsZHJlbiIsIm5leHRTdGF0ZSIsInVwZGF0ZUhvc3RDb21wb25lbnQiLCJpc0RpcmVjdFRleHRDaGlsZCIsInVwZGF0ZUhvc3RUZXh0IiwibW91bnRMYXp5Q29tcG9uZW50IiwiX2N1cnJlbnQiLCJyZXNvbHZlZFRhZyIsInJlc29sdmVkUHJvcHMiLCJoaW50IiwibW91bnRJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQiLCJtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQiLCJkZWJ1Z1NvdXJjZSIsInVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50IiwibmV4dERpZFRpbWVvdXQiLCJ0aW1lZE91dEF0IiwiZmFsbGJhY2siLCJ1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQiLCJuZXh0RmFsbGJhY2tDaGlsZHJlbiIsInByaW1hcnlDaGlsZEZyYWdtZW50IiwicHJvZ3Jlc3NlZFN0YXRlIiwicHJvZ3Jlc3NlZFByaW1hcnlDaGlsZCIsImZhbGxiYWNrQ2hpbGRGcmFnbWVudCIsIm5leHRQcmltYXJ5Q2hpbGRyZW4iLCJwcmV2RGlkVGltZW91dCIsImN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCIsImN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQiLCJfbmV4dEZhbGxiYWNrQ2hpbGRyZW4iLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJfcHJvZ3Jlc3NlZFN0YXRlIiwiX3Byb2dyZXNzZWRQcmltYXJ5Q2hpbGQiLCJoaWRkZW5DaGlsZCIsIl9mYWxsYmFja0NoaWxkRnJhZ21lbnQiLCJfbmV4dFByaW1hcnlDaGlsZHJlbiIsImN1cnJlbnRQcmltYXJ5Q2hpbGQiLCJwcmltYXJ5Q2hpbGQiLCJfY3VycmVudFByaW1hcnlDaGlsZCIsIl9uZXh0RmFsbGJhY2tDaGlsZHJlbjIiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQyIiwiX3Byb2dyZXNzZWRTdGF0ZTIiLCJfcHJvZ3Jlc3NlZFByaW1hcnlDaGlsZDIiLCJfdHJlZUJhc2VEdXJhdGlvbiIsIl9oaWRkZW5DaGlsZCIsIl9mYWxsYmFja0NoaWxkRnJhZ21lbnQyIiwiX25leHRQcmltYXJ5Q2hpbGRyZW4yIiwiaGFzQ29udGV4dENoYW5nZWQkJDEiLCJ1cGRhdGVQb3J0YWxDb21wb25lbnQiLCJ1cGRhdGVDb250ZXh0UHJvdmlkZXIiLCJwcm92aWRlclR5cGUiLCJwcm92aWRlclByb3BUeXBlcyIsInB1c2hQcm92aWRlciIsIm9sZFZhbHVlIiwiY2hhbmdlZEJpdHMiLCJjYWxjdWxhdGVDaGFuZ2VkQml0cyIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2UiLCJoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIiLCJ1cGRhdGVDb250ZXh0Q29uc3VtZXIiLCJDb25zdW1lciIsInVuc3RhYmxlX29ic2VydmVkQml0cyIsImJlZ2luV29yayIsImRpZFRpbWVvdXQiLCJwcmltYXJ5Q2hpbGRFeHBpcmF0aW9uVGltZSIsIl9lbGVtZW50VHlwZSIsIl9Db21wb25lbnQiLCJ1bnJlc29sdmVkUHJvcHMiLCJfQ29tcG9uZW50MiIsIl91bnJlc29sdmVkUHJvcHMiLCJfcmVzb2x2ZWRQcm9wcyIsIl91bnJlc29sdmVkUHJvcHMyIiwiX3Jlc29sdmVkUHJvcHMyIiwiX3R5cGUyIiwiX3VucmVzb2x2ZWRQcm9wczMiLCJfcmVzb2x2ZWRQcm9wczMiLCJfQ29tcG9uZW50MyIsIl91bnJlc29sdmVkUHJvcHM0IiwiX3Jlc29sdmVkUHJvcHM0IiwidmFsdWVDdXJzb3IiLCJyZW5kZXJlclNpZ2lsIiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIiLCJsYXN0Q29udGV4dERlcGVuZGVuY3kiLCJsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQiLCJpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwicmVzZXRDb250ZXh0RGVwZW5kZW5jZXMiLCJlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwiZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwicHJvdmlkZXJGaWJlciIsIl9jdXJyZW50VmFsdWUiLCJfY3VycmVudFJlbmRlcmVyIiwiX2N1cnJlbnRWYWx1ZTIiLCJfY3VycmVudFJlbmRlcmVyMiIsInBvcFByb3ZpZGVyIiwiX2NhbGN1bGF0ZUNoYW5nZWRCaXRzIiwic2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoIiwibmV4dEZpYmVyIiwiY3VycmVudERlcGVuZGVuY2llcyIsInJlc29sdmVkT2JzZXJ2ZWRCaXRzIiwiY29udGV4dEl0ZW0iLCJVcGRhdGVTdGF0ZSIsIkNhcHR1cmVVcGRhdGUiLCJoYXNGb3JjZVVwZGF0ZSIsImRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUiLCJjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUiLCJyZXNldEN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSIsImNyZWF0ZVVwZGF0ZVF1ZXVlIiwiZmlyc3RVcGRhdGUiLCJsYXN0VXBkYXRlIiwiZmlyc3RDYXB0dXJlZFVwZGF0ZSIsImxhc3RDYXB0dXJlZFVwZGF0ZSIsImZpcnN0Q2FwdHVyZWRFZmZlY3QiLCJsYXN0Q2FwdHVyZWRFZmZlY3QiLCJjbG9uZVVwZGF0ZVF1ZXVlIiwiY3VycmVudFF1ZXVlIiwiYXBwZW5kVXBkYXRlVG9RdWV1ZSIsInF1ZXVlMSIsInF1ZXVlMiIsImVucXVldWVDYXB0dXJlZFVwZGF0ZSIsIndvcmtJblByb2dyZXNzUXVldWUiLCJlbnN1cmVXb3JrSW5Qcm9ncmVzc1F1ZXVlSXNBQ2xvbmUiLCJnZXRTdGF0ZUZyb21VcGRhdGUiLCJfcGF5bG9hZCIsIl9wYXlsb2FkMiIsIm5ld0ZpcnN0VXBkYXRlIiwibmV3RXhwaXJhdGlvblRpbWUiLCJyZXN1bHRTdGF0ZSIsIl9jYWxsYmFjayIsIm5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUiLCJfdXBkYXRlRXhwaXJhdGlvblRpbWUiLCJfY2FsbGJhY2syIiwiY29tbWl0VXBkYXRlUXVldWUiLCJmaW5pc2hlZFF1ZXVlIiwiY29tbWl0VXBkYXRlRWZmZWN0cyIsIl9jYWxsYmFjazMiLCJjcmVhdGVDYXB0dXJlZFZhbHVlIiwibWFya1VwZGF0ZSIsIm1hcmtSZWYkMSIsImFwcGVuZEFsbENoaWxkcmVuIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInVwZGF0ZUhvc3RDb21wb25lbnQkMSIsInVwZGF0ZUhvc3RUZXh0JDEiLCJuZWVkc1Zpc2liaWxpdHlUb2dnbGUiLCJpc0hpZGRlbiIsImN1cnJlbnRIb3N0Q29udGV4dCIsImJyYW5jaGVzIiwiX2luc3RhbmNlIiwib2xkSXNIaWRkZW4iLCJuZXdJc0hpZGRlbiIsInByaW1hcnlDaGlsZFBhcmVudCIsImFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIiLCJjb250YWluZXJDaGlsZFNldCIsIl9pbnN0YW5jZTIiLCJwb3J0YWxPclJvb3QiLCJjaGlsZHJlblVuY2hhbmdlZCIsIm5ld0NoaWxkU2V0IiwiY3VycmVudEluc3RhbmNlIiwicmVjeWNsYWJsZUluc3RhbmNlIiwibmV3SW5zdGFuY2UiLCJjb21wbGV0ZVdvcmsiLCJmaWJlclJvb3QiLCJ3YXNIeWRyYXRlZCIsIl9yb290Q29udGFpbmVySW5zdGFuY2UiLCJfY3VycmVudEhvc3RDb250ZXh0IiwiX3dhc0h5ZHJhdGVkIiwiY3VycmVudEZhbGxiYWNrQ2hpbGQiLCJfd2FzSHlkcmF0ZWQyIiwic2hvdWxkQ2FwdHVyZVN1c3BlbnNlIiwic2hvd0Vycm9yRGlhbG9nIiwiY2FwdHVyZWRFcnJvciIsImxvZ0NhcHR1cmVkRXJyb3IiLCJsb2dFcnJvciIsImNvbXBvbmVudFN0YWNrIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJlcnJvckJvdW5kYXJ5Rm91bmQiLCJ3aWxsUmV0cnkiLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tYmluZWRNZXNzYWdlIiwiZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUiLCJQb3NzaWJseVdlYWtTZXQkMSIsIldlYWtTZXQiLCJib3VuZGFyeSIsImVycm9ySW5mbyIsImVycm9yQm91bmRhcnkiLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsInVubW91bnRFcnJvciIsImNhcHR1cmVDb21taXRQaGFzZUVycm9yIiwic2FmZWx5RGV0YWNoUmVmIiwicmVmRXJyb3IiLCJzYWZlbHlDYWxsRGVzdHJveSIsImNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZUN5Y2xlcyIsImNvbW1pdEhvb2tFZmZlY3RMaXN0Iiwic25hcHNob3QiLCJkaWRXYXJuU2V0IiwiX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUiLCJ1bm1vdW50VGFnIiwibW91bnRUYWciLCJfZGVzdHJveSIsImNvbW1pdFBhc3NpdmVIb29rRWZmZWN0cyIsImNvbW1pdExpZmVDeWNsZXMiLCJmaW5pc2hlZFJvb3QiLCJjb21taXR0ZWRFeHBpcmF0aW9uVGltZSIsIl91cGRhdGVRdWV1ZSIsImhpZGVPclVuaGlkZUFsbENoaWxkcmVuIiwiX2luc3RhbmNlMyIsImNvbW1pdEF0dGFjaFJlZiIsImluc3RhbmNlVG9Vc2UiLCJjb21taXREZXRhY2hSZWYiLCJjdXJyZW50UmVmIiwiY29tbWl0VW5tb3VudCIsInVubW91bnRIb3N0Q29tcG9uZW50cyIsImVtcHR5UG9ydGFsQ29udGFpbmVyIiwiY29tbWl0TmVzdGVkVW5tb3VudHMiLCJkZXRhY2hGaWJlciIsImVtcHR5Q2hpbGRTZXQiLCJjb21taXRDb250YWluZXIiLCJfcGVuZGluZ0NoaWxkcmVuIiwiZ2V0SG9zdFBhcmVudEZpYmVyIiwiaXNIb3N0UGFyZW50IiwiZ2V0SG9zdFNpYmxpbmciLCJzaWJsaW5ncyIsImNvbW1pdFBsYWNlbWVudCIsInBhcmVudEZpYmVyIiwiaXNDb250YWluZXIiLCJjdXJyZW50UGFyZW50SXNWYWxpZCIsImN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciIsImZpbmRQYXJlbnQiLCJjb21taXREZWxldGlvbiIsImNvbW1pdFdvcmsiLCJuZXdEaWRUaW1lb3V0IiwidGhlbmFibGVzIiwicmV0cnlDYWNoZSIsInJldHJ5IiwicmV0cnlUaW1lZE91dEJvdW5kYXJ5IiwidW5zdGFibGVfd3JhcCIsImNvbW1pdFJlc2V0VGV4dENvbnRlbnQiLCJQb3NzaWJseVdlYWtTZXQiLCJQb3NzaWJseVdlYWtNYXAiLCJXZWFrTWFwIiwiY3JlYXRlUm9vdEVycm9yVXBkYXRlIiwib25VbmNhdWdodEVycm9yIiwiY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSIsImNvbXBvbmVudERpZENhdGNoIiwibWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCIsImF0dGFjaFBpbmdMaXN0ZW5lciIsInRocmVhZElEcyIsInBpbmciLCJwaW5nU3VzcGVuZGVkUm9vdCIsInRocm93RXhjZXB0aW9uIiwic291cmNlRmliZXIiLCJfd29ya0luUHJvZ3Jlc3MiLCJlYXJsaWVzdFRpbWVvdXRNcyIsInN0YXJ0VGltZU1zIiwidGltZW91dFByb3BNcyIsIm1heER1cmF0aW9uIiwiY3VycmVudFNvdXJjZUZpYmVyIiwiYWJzb2x1dGVUaW1lb3V0TXMiLCJlYXJsaWVzdEV4cGlyYXRpb25UaW1lTXMiLCJyZW5kZXJEaWRTdXNwZW5kIiwicmVuZGVyRGlkRXJyb3IiLCJfZXJyb3JJbmZvIiwiaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeSIsInVud2luZFdvcmsiLCJfZWZmZWN0VGFnIiwiX2VmZmVjdFRhZzIiLCJfZWZmZWN0VGFnMyIsInVud2luZEludGVycnVwdGVkV29yayIsImludGVycnVwdGVkV29yayIsIlJlYWN0Q3VycmVudE93bmVyJDIiLCJkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24iLCJkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQiLCJ3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCIsIndhcm5BYm91dEludmFsaWRVcGRhdGVzIiwiX19pbnRlcmFjdGlvbnNSZWYiLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQiLCJpc0NsYXNzIiwibGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiIsImlzV29ya2luZyIsIm5leHRSb290IiwibmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zIiwibmV4dFJlbmRlckRpZEVycm9yIiwiaXNDb21taXR0aW5nJDEiLCJyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyIsInBhc3NpdmVFZmZlY3RDYWxsYmFja0hhbmRsZSIsInBhc3NpdmVFZmZlY3RDYWxsYmFjayIsImxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkIiwic3Rhc2hlZFdvcmtJblByb2dyZXNzUHJvcGVydGllcyIsInJlcGxheVVuaXRPZldvcmsiLCJtYXlSZXBsYXlGYWlsZWRVbml0T2ZXb3JrIiwiaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrIiwib3JpZ2luYWxSZXBsYXlFcnJvciIsInJldGhyb3dPcmlnaW5hbEVycm9yIiwiZmFpbGVkVW5pdE9mV29yayIsInRocm93blZhbHVlIiwiaXNZaWVsZHkiLCJ3b3JrTG9vcCIsInJlcGxheUVycm9yIiwicmVzZXRTdGFjayIsImNvbW1pdEFsbEhvc3RFZmZlY3RzIiwicHJpbWFyeUVmZmVjdFRhZyIsIl9jdXJyZW50MiIsImNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcyIsImNvbW1pdEFsbExpZmVDeWNsZXMiLCJjb21taXRQYXNzaXZlRWZmZWN0cyIsInByZXZpb3VzSXNSZW5kZXJpbmciLCJpc1JlbmRlcmluZyIsInJvb3RFeHBpcmF0aW9uVGltZSIsInJlcXVlc3RXb3JrIiwiaXNCYXRjaGluZ1VwZGF0ZXMiLCJwZXJmb3JtU3luY1dvcmsiLCJjb21taXRSb290IiwidXBkYXRlRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQiLCJjaGlsZEV4cGlyYXRpb25UaW1lQmVmb3JlQ29tbWl0IiwiZWFybGllc3RSZW1haW5pbmdUaW1lQmVmb3JlQ29tbWl0IiwicHJldkludGVyYWN0aW9ucyIsIl9kaWRFcnJvciIsIl9lcnJvciIsIl9kaWRFcnJvcjIiLCJfZXJyb3IyIiwidW5zdGFibGVfcnVuV2l0aFByaW9yaXR5IiwidW5zdGFibGVfTm9ybWFsUHJpb3JpdHkiLCJvbkNvbW1pdFdvcmsiLCJ1cGRhdGVFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0IiwiY2hpbGRFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0IiwiZWFybGllc3RSZW1haW5pbmdUaW1lQWZ0ZXJDb21taXQiLCJvbkNvbW1pdCIsInN1YnNjcmliZXIiLCJfX3N1YnNjcmliZXJSZWYiLCJ0aHJlYWRJRCIsImNvbXB1dGVUaHJlYWRJRCIsIm9uV29ya1N0b3BwZWQiLCJoYXNVbmhhbmRsZWRFcnJvciIsInVuaGFuZGxlZEVycm9yIiwic2NoZWR1bGVkSW50ZXJhY3Rpb25zIiwic2NoZWR1bGVkRXhwaXJhdGlvblRpbWUiLCJpbnRlcmFjdGlvbiIsIl9fY291bnQiLCJvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZCIsInJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSIsInJlbmRlclRpbWUiLCJuZXdDaGlsZEV4cGlyYXRpb25UaW1lIiwic2hvdWxkQnViYmxlQWN0dWFsRHVyYXRpb25zIiwiY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZSIsImNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSIsIl9jaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiX2NoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSIsImNvbXBsZXRlVW5pdE9mV29yayIsInNpYmxpbmdGaWJlciIsIm9uQ29tcGxldGVXb3JrIiwicGVyZm9ybVVuaXRPZldvcmsiLCJvbkJlZ2luV29yayIsInNob3VsZFlpZWxkVG9SZW5kZXJlciIsInJlbmRlclJvb3QiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJpbnRlcmFjdGlvbnMiLCJvbldvcmtTdGFydGVkIiwiZGlkRmF0YWwiLCJtYXlSZXBsYXkiLCJfZGlkQ29tcGxldGVSb290Iiwib25GYXRhbCIsIl9kaWRDb21wbGV0ZVJvb3QyIiwib25ZaWVsZCIsInJvb3RXb3JrSW5Qcm9ncmVzcyIsInN1c3BlbmRlZEV4cGlyYXRpb25UaW1lIiwib25TdXNwZW5kIiwiX3N1c3BlbmRlZEV4cGlyYXRpb25UaW1lIiwiX3Jvb3RFeHBpcmF0aW9uVGltZSIsIl9zdXNwZW5kZWRFeHBpcmF0aW9uVGltZTIiLCJjdXJyZW50VGltZU1zIiwibXNVbnRpbFRpbWVvdXQiLCJfcm9vdEV4cGlyYXRpb25UaW1lMiIsIm9uQ29tcGxldGUiLCJyb290RmliZXIiLCJfZXJyb3JJbmZvMiIsImNvbXB1dGVVbmlxdWVBc3luY0V4cGlyYXRpb24iLCJwcmlvcml0eUxldmVsIiwidW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwiLCJ1bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSIsInVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5IiwidW5zdGFibGVfTG93UHJpb3JpdHkiLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lIiwicGluZ1RpbWUiLCJib3VuZGFyeUZpYmVyIiwicmV0cnlUaW1lIiwic2NoZWR1bGVXb3JrVG9Sb290IiwicGVuZGluZ0ludGVyYWN0aW9ucyIsIm9uV29ya1NjaGVkdWxlZCIsIm5lc3RlZFVwZGF0ZUNvdW50IiwiTkVTVEVEX1VQREFURV9MSU1JVCIsInN5bmNVcGRhdGVzIiwiZmlyc3RTY2hlZHVsZWRSb290IiwibGFzdFNjaGVkdWxlZFJvb3QiLCJjYWxsYmFja0V4cGlyYXRpb25UaW1lIiwiY2FsbGJhY2tJRCIsIm5leHRGbHVzaGVkUm9vdCIsIm5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUiLCJpc1VuYmF0Y2hpbmdVcGRhdGVzIiwiY29tcGxldGVkQmF0Y2hlcyIsIm9yaWdpbmFsU3RhcnRUaW1lTXMiLCJjdXJyZW50UmVuZGVyZXJUaW1lIiwiY3VycmVudFNjaGVkdWxlclRpbWUiLCJsYXN0Q29tbWl0dGVkUm9vdER1cmluZ1RoaXNCYXRjaCIsInJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUiLCJzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb25UaW1lIiwiY3VycmVudE1zIiwiZXhwaXJhdGlvblRpbWVNcyIsInRpbWVvdXQiLCJwZXJmb3JtQXN5bmNXb3JrIiwib25UaW1lb3V0IiwiZmx1c2hSb290IiwiZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QiLCJhZGRSb290VG9TY2hlZHVsZSIsInBlcmZvcm1Xb3JrT25Sb290IiwiaGlnaGVzdFByaW9yaXR5V29yayIsImhpZ2hlc3RQcmlvcml0eVJvb3QiLCJwcmV2aW91c1NjaGVkdWxlZFJvb3QiLCJkaWRZaWVsZCIsInVuc3RhYmxlX3Nob3VsZFlpZWxkIiwicGVyZm9ybVdvcmsiLCJtaW5FeHBpcmF0aW9uVGltZSIsImZpbmlzaFJlbmRlcmluZyIsImJhdGNoZXMiLCJiYXRjaCIsIl9vbkNvbXBsZXRlIiwiY29tcGxldGVSb290IiwiX2ZpbmlzaGVkV29yayIsIl90aW1lb3V0SGFuZGxlIiwiX2RlZmVyIiwiYmF0Y2hlZFVwZGF0ZXMkMSIsInByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMiLCJ1bmJhdGNoZWRVcGRhdGVzIiwiZmx1c2hTeW5jIiwiaW50ZXJhY3RpdmVVcGRhdGVzJDEiLCJmbHVzaEludGVyYWN0aXZlVXBkYXRlcyQxIiwiZmx1c2hDb250cm9sbGVkIiwiZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyIsImRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlIiwiZ2V0Q29udGV4dEZvclN1YnRyZWUiLCJwYXJlbnRDb21wb25lbnQiLCJzY2hlZHVsZVJvb3RVcGRhdGUiLCJ1cGRhdGVDb250YWluZXJBdEV4cGlyYXRpb25UaW1lIiwib25Nb3VudENvbnRhaW5lciIsIm9uVW5tb3VudENvbnRhaW5lciIsIm9uVXBkYXRlQ29udGFpbmVyIiwiZmluZEhvc3RJbnN0YW5jZSIsImhvc3RGaWJlciIsImZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyIsIm1ldGhvZE5hbWUiLCJjcmVhdGVDb250YWluZXIiLCJ1cGRhdGVDb250YWluZXIiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJjb250YWluZXJGaWJlciIsImZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzIiwib3ZlcnJpZGVQcm9wcyIsImNvcHlXaXRoU2V0SW1wbCIsInVwZGF0ZWQiLCJjb3B5V2l0aFNldCIsImluamVjdEludG9EZXZUb29scyIsImRldlRvb2xzQ29uZmlnIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJjdXJyZW50RGlzcGF0Y2hlclJlZiIsImZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyIiwiY3JlYXRlUG9ydGFsJDEiLCJSZWFjdFZlcnNpb24iLCJ0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzIiwid2Fybk9uSW52YWxpZENhbGxiYWNrIiwiZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwiLCJob3N0SW5zdGFuY2UiLCJfaW50ZXJuYWxSb290IiwiaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCIsInJvb3RFbCIsImdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciIsImhhc05vblJvb3RSZWFjdENoaWxkIiwiUmVhY3RCYXRjaCIsIl9yb290IiwiX25leHQiLCJfY2FsbGJhY2tzIiwiX2RpZENvbXBsZXRlIiwiX2hhc0NoaWxkcmVuIiwiX2NoaWxkcmVuIiwiaW50ZXJuYWxSb290Iiwid29yayIsIlJlYWN0V29yayIsIl9vbkNvbW1pdCIsImNhbGxiYWNrcyIsImNvbW1pdCIsInByZXZpb3VzIiwiX2RpZENvbW1pdCIsIlJlYWN0Um9vdCIsInVubW91bnQiLCJsZWdhY3lfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJjcmVhdGVCYXRjaCIsImluc2VydEFmdGVyIiwiaXNWYWxpZENvbnRhaW5lciIsInNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyIsInJvb3RFbGVtZW50Iiwid2FybmVkQWJvdXRIeWRyYXRlQVBJIiwibGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIiLCJmb3JjZUh5ZHJhdGUiLCJzaG91bGRIeWRyYXRlIiwid2FybmVkIiwicm9vdFNpYmxpbmciLCJsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsIm9yaWdpbmFsQ2FsbGJhY2siLCJfb3JpZ2luYWxDYWxsYmFjayIsImNyZWF0ZVBvcnRhbCQkMSIsImNyZWF0ZVBvcnRhbCIsImZpbmRET01Ob2RlIiwiY29tcG9uZW50T3JFbGVtZW50Iiwid2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJfcmVhY3RIYXNCZWVuUGFzc2VkVG9DcmVhdGVSb290REVWIiwidW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJjb250YWluZXJOb2RlIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCIsIl9yb290RWwiLCJpc0NvbnRhaW5lclJlYWN0Um9vdCIsInVuc3RhYmxlX2NyZWF0ZVBvcnRhbCIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfaW50ZXJhY3RpdmVVcGRhdGVzIiwidW5zdGFibGVfY3JlYXRlUm9vdCIsImNyZWF0ZVJvb3QiLCJ1bnN0YWJsZV9mbHVzaENvbnRyb2xsZWQiLCJFdmVudHMiLCJmb3VuZERldlRvb2xzIiwiYnVuZGxlVHlwZSIsInJlbmRlcmVyUGFja2FnZU5hbWUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJSZWFjdERPTSQyIiwiUmVhY3RET00kMyIsInJlYWN0RG9tIiwiY2hlY2tEQ0UiLCJ3YXJuTm9vcCIsInB1YmxpY0luc3RhbmNlIiwiX2NvbnN0cnVjdG9yIiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJjb21wbGV0ZVN0YXRlIiwiZW1wdHlPYmplY3QiLCJzZXRTdGF0ZSIsImZvcmNlVXBkYXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJmbk5hbWUiLCJDb21wb25lbnREdW1teSIsIlB1cmVDb21wb25lbnQiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwiY3JlYXRlUmVmIiwiY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCIsIlJlYWN0Q29tcG9uZW50VHJlZUhvb2siLCJSRVNFUlZFRF9QUk9QUyIsIl9fc2VsZiIsIl9fc291cmNlIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImhhc1ZhbGlkUmVmIiwiZ2V0dGVyIiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJ3cml0YWJsZSIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImNsb25lQW5kUmVwbGFjZUtleSIsIm9sZEVsZW1lbnQiLCJuZXdLZXkiLCJuZXdFbGVtZW50IiwiX3NlbGYiLCJjbG9uZUVsZW1lbnQiLCJpc1ZhbGlkRWxlbWVudCIsIlNFUEFSQVRPUiIsIlNVQlNFUEFSQVRPUiIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJ1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCIsImVzY2FwZVVzZXJQcm92aWRlZEtleSIsIlBPT0xfU0laRSIsInRyYXZlcnNlQ29udGV4dFBvb2wiLCJnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQiLCJtYXBSZXN1bHQiLCJrZXlQcmVmaXgiLCJtYXBGdW5jdGlvbiIsIm1hcENvbnRleHQiLCJ0cmF2ZXJzZUNvbnRleHQiLCJyZWxlYXNlVHJhdmVyc2VDb250ZXh0IiwidHJhdmVyc2VBbGxDaGlsZHJlbkltcGwiLCJuYW1lU29GYXIiLCJpbnZva2VDYWxsYmFjayIsImdldENvbXBvbmVudEtleSIsIm5leHROYW1lIiwic3VidHJlZUNvdW50IiwibmV4dE5hbWVQcmVmaXgiLCJpaSIsImNoaWxkcmVuU3RyaW5nIiwidHJhdmVyc2VBbGxDaGlsZHJlbiIsImZvckVhY2hTaW5nbGVDaGlsZCIsImZvckVhY2hDaGlsZHJlbiIsImZvckVhY2hGdW5jIiwiZm9yRWFjaENvbnRleHQiLCJtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0IiwiY2hpbGRLZXkiLCJtYXBwZWRDaGlsZCIsIm1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwiLCJlc2NhcGVkUHJlZml4IiwibWFwQ2hpbGRyZW4iLCJjb3VudENoaWxkcmVuIiwidG9BcnJheSIsIm9ubHlDaGlsZCIsImNyZWF0ZUNvbnRleHQiLCJfdGhyZWFkQ291bnQiLCJQcm92aWRlciIsImhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzIiwiaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX1Byb3ZpZGVyIiwibGF6eSIsImxhenlUeXBlIiwibmV3RGVmYXVsdFByb3BzIiwibmV3UHJvcFR5cGVzIiwiZm9yd2FyZFJlZiIsImlzVmFsaWRFbGVtZW50VHlwZSIsIm1lbW8iLCJyZXNvbHZlRGlzcGF0Y2hlciIsImRpc3BhdGNoZXIiLCJDb250ZXh0IiwicmVhbENvbnRleHQiLCJpbnB1dHMiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtIiwiZWxlbWVudFByb3BzIiwiZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwiY2hpbGRPd25lciIsInZhbGlkYXRlQ2hpbGRLZXlzIiwidmFsaWRhdGVQcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24iLCJ2YWxpZFR5cGUiLCJ0eXBlU3RyaW5nIiwiY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uIiwidmFsaWRhdGVkRmFjdG9yeSIsImNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uIiwib25seSIsIlN1c3BlbnNlIiwiY3JlYXRlRmFjdG9yeSIsInVuc3RhYmxlX0NvbmN1cnJlbnRNb2RlIiwidW5zdGFibGVfUHJvZmlsZXIiLCJSZWFjdCQyIiwiUmVhY3QkMyIsInJlYWN0IiwiREVGQVVMVF9USFJFQURfSUQiLCJpbnRlcmFjdGlvbklEQ291bnRlciIsInRocmVhZElEQ291bnRlciIsInVuc3RhYmxlX2NsZWFyIiwidW5zdGFibGVfZ2V0Q3VycmVudCIsInVuc3RhYmxlX3RyYWNlIiwidGltZXN0YW1wIiwib25JbnRlcmFjdGlvblRyYWNlZCIsIndyYXBwZWRJbnRlcmFjdGlvbnMiLCJoYXNSdW4iLCJ3cmFwcGVkIiwiY2FuY2VsIiwib25Xb3JrQ2FuY2VsZWQiLCJzdWJzY3JpYmVycyIsInVuc3RhYmxlX3N1YnNjcmliZSIsInVuc3RhYmxlX3Vuc3Vic2NyaWJlIiwiZGlkQ2F0Y2hFcnJvciIsImVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyIsIkltbWVkaWF0ZVByaW9yaXR5IiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJOb3JtYWxQcmlvcml0eSIsIkxvd1ByaW9yaXR5IiwiSWRsZVByaW9yaXR5IiwiSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQiLCJVU0VSX0JMT0NLSU5HX1BSSU9SSVRZIiwiTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQiLCJMT1dfUFJJT1JJVFlfVElNRU9VVCIsIklETEVfUFJJT1JJVFkiLCJmaXJzdENhbGxiYWNrTm9kZSIsImN1cnJlbnREaWRUaW1lb3V0IiwiaXNTY2hlZHVsZXJQYXVzZWQiLCJjdXJyZW50UHJpb3JpdHlMZXZlbCIsImN1cnJlbnRFdmVudFN0YXJ0VGltZSIsImN1cnJlbnRFeHBpcmF0aW9uVGltZSIsImlzRXhlY3V0aW5nQ2FsbGJhY2siLCJpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCIsImhhc05hdGl2ZVBlcmZvcm1hbmNlTm93IiwiZW5zdXJlSG9zdENhbGxiYWNrSXNTY2hlZHVsZWQiLCJjYW5jZWxIb3N0Q2FsbGJhY2siLCJyZXF1ZXN0SG9zdENhbGxiYWNrIiwiZmx1c2hXb3JrIiwiZmx1c2hGaXJzdENhbGxiYWNrIiwiZmx1c2hlZE5vZGUiLCJsYXN0Q2FsbGJhY2tOb2RlIiwicHJldmlvdXNQcmlvcml0eUxldmVsIiwicHJldmlvdXNFeHBpcmF0aW9uVGltZSIsImNvbnRpbnVhdGlvbkNhbGxiYWNrIiwiY29udGludWF0aW9uTm9kZSIsIm5leHRBZnRlckNvbnRpbnVhdGlvbiIsImZsdXNoSW1tZWRpYXRlV29yayIsInByZXZpb3VzRGlkVGltZW91dCIsInNob3VsZFlpZWxkVG9Ib3N0IiwiZXZlbnRIYW5kbGVyIiwicHJldmlvdXNFdmVudFN0YXJ0VGltZSIsInVuc3RhYmxlX25leHQiLCJ1bnN0YWJsZV93cmFwQ2FsbGJhY2siLCJwYXJlbnRQcmlvcml0eUxldmVsIiwiZGVwcmVjYXRlZF9vcHRpb25zIiwic3RhcnRUaW1lIiwibmV3Tm9kZSIsInVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uIiwidW5zdGFibGVfY29udGludWVFeGVjdXRpb24iLCJ1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSIsImNhbGxiYWNrTm9kZSIsImxvY2FsRGF0ZSIsImxvY2FsU2V0VGltZW91dCIsImxvY2FsQ2xlYXJUaW1lb3V0IiwibG9jYWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJsb2NhbENhbmNlbEFuaW1hdGlvbkZyYW1lIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJBTklNQVRJT05fRlJBTUVfVElNRU9VVCIsInJBRklEIiwickFGVGltZW91dElEIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lV2l0aFRpbWVvdXQiLCJQZXJmb3JtYW5jZSIsImdsb2JhbFZhbHVlIiwiX3NjaGVkTW9jayIsImdsb2JhbEltcGwiLCJNZXNzYWdlQ2hhbm5lbCIsIl9mbHVzaENhbGxiYWNrIiwic2NoZWR1bGVkSG9zdENhbGxiYWNrIiwiaXNNZXNzYWdlRXZlbnRTY2hlZHVsZWQiLCJ0aW1lb3V0VGltZSIsImlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQiLCJpc0ZsdXNoaW5nSG9zdENhbGxiYWNrIiwiZnJhbWVEZWFkbGluZSIsInByZXZpb3VzRnJhbWVUaW1lIiwiYWN0aXZlRnJhbWVUaW1lIiwiY2hhbm5lbCIsInBvcnQyIiwicG9ydDEiLCJvbm1lc3NhZ2UiLCJwcmV2U2NoZWR1bGVkQ2FsbGJhY2siLCJwcmV2VGltZW91dFRpbWUiLCJhbmltYXRpb25UaWNrIiwicmFmVGltZSIsIm5leHRGcmFtZVRpbWUiLCJwb3N0TWVzc2FnZSIsImFic29sdXRlVGltZW91dCIsImNzcyIsImJhc2VVcmwiLCJjdXJyZW50RGlyIiwiZml4ZWRDc3MiLCJmdWxsTWF0Y2giLCJvcmlnVXJsIiwidW5xdW90ZWRPcmlnVXJsIiwibyIsIiQxIiwibmV3VXJsIiwiQW55IiwiQ2MiLCJDZiIsIlAiLCJaIiwiZyIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiRHJvcExpc3QiLCJoYW5kbGVDbG9zZSIsIl9oYW5kbGVDbG9zZSIsIm9uQ2xvc2UiLCJzaG93IiwiSGVhZGVyTGlzdCIsImhlYWRlciIsIm9uU2VsZWN0SGVhZGVyIiwiaGFuZGxlSGVhZGVyIiwiSWNvbiIsIklucHV0RmlsZSIsImxvY2tlZCIsImNsaWNrIiwidGltZXJJZCIsInBvc2l0aW9uIiwiTmF2aWdhdGlvbkJhciIsIm1pZGRsZSIsInJpZ2h0IiwiVGFibGVMaXN0IiwiZm9ybWF0VGFibGVNb2RlbCIsInYiLCJ3cmFwV2lkdGgiLCJ3cmFwSGVpZ2h0IiwibmV3TGlzdCIsIm9uU2V0VGFibGUiLCJjYWxjV3JhcFN0eWxlIiwiY2FsY0l0ZW1TdHlsZSIsImhhbmRsZUhvdmVyIiwiaGFuZGxlU2V0VGFibGUiLCJUb29sQmFyIiwidGhlbWUiLCJsb2dnZXIiLCJpbnRlcnZhbCIsInN5bmNoU2Nyb2xsIiwibGlua1VybCIsIkh0bWxSZW5kZXIiLCJIdG1sQ29kZSIsIk1kRWRpdG9yIiwiaXNTZWxlY3RlZCIsImluaXRpYWxTZWxlY3Rpb24iLCJpbml0Q29uZmlnIiwiZm9ybWF0U3RyaW5nIiwiaHRtbFR5cGUiLCJkcm9wQnV0dG9uIiwiZnVsbFNjcmVlbiIsImhhbmRsZUNoYW5nZSIsIl9oYW5kbGVDaGFuZ2UiLCJoYW5kbGVJbnB1dFNlbGVjdCIsIl9oYW5kbGVJbnB1dFNlbGVjdCIsIl9oYW5kbGVJbWFnZVVwbG9hZCIsImhhbmRsZUVtcHR5IiwiX2hhbmRsZUVtcHR5IiwiaGFuZGxlVW5kbyIsIl9oYW5kbGVVbmRvIiwiaGFuZGxlUmVkbyIsIl9oYW5kbGVSZWRvIiwiaGFuZGxlVG9nZ2xlRnVsbFNjcmVlbiIsIl9oYW5kbGVUb2dnbGVGdWxsU2NyZWVuIiwiaGFuZGxlVG9nZ2xlTWVudSIsIl9oYW5kbGVUb2dnbGVNZW51IiwiaGFuZGxlVG9nZ2xlVmlldyIsIl9oYW5kbGVUb2dnbGVWaWV3IiwiaGFuZGxlTWRQcmV2aWV3IiwiX2hhbmRsZU1kUHJldmlldyIsImhhbmRsZUh0bWxQcmV2aWV3IiwiX2hhbmRsZUh0bWxQcmV2aWV3IiwiaGFuZGxlVG9nZ2xlSHRtbFR5cGUiLCJfaGFuZGxlVG9nZ2xlSHRtbFR5cGUiLCJoYW5kbGVvbktleURvd24iLCJfaGFuZGxlb25LZXlEb3duIiwiaGFuZGxlSW5wdXRTY3JvbGwiLCJ0b29sIiwid2lsbFNjcm9sbEVsZSIsImhhc0NvbnRlbnRDaGFuZ2VkIiwiX3NldFNjcm9sbFZhbHVlIiwibm9kZU1kUHJldmlld1dyYXBlciIsIm5vZGVNZFRleHQiLCJoYW5kbGVQcmV2aWV3U2Nyb2xsIiwicmVuZGVySFRNTCIsImluaXRMb2dnZXIiLCJlbmRMb2dnZXIiLCJfY29uZmlnIiwiTG9nZ2VyIiwic3RhcnRMb2dnZXIiLCJwdXNoUmVjb3JkIiwibG9nZ2VyVGltZXJJZCIsInNldEludGVydmFsIiwiZ2V0TGFzdFJlY29yZCIsImNsZWFuUmVkb0xpc3QiLCJjbGVhckludGVydmFsIiwibG9nIiwidW5kbyIsIl9zZXRNZFRleHQiLCJyZWRvIiwib3B0aW9uIiwiY2xlYXJMaXN0IiwiX2dldERlY29yYXRlZFRleHQiLCJfY2xlYXJTZWxlY3Rpb24iLCJiZWZvcmVDb250ZW50IiwiYWZ0ZXJDb250ZW50IiwiZGVjb3JhdGUiLCJEZWNvcmF0ZSIsImRlY29yYXRlZFRleHQiLCJnZXREZWNvcmF0ZWRUZXh0IiwibWFya2Rvd25UZXh0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJjaGFuZ2VWaWV3IiwiY29uZmlybSIsIm9uSW1hZ2VVcGxvYWQiLCJpbnB1dEZpbGUiLCJoYW5kbGVEZWNvcmF0ZSIsIl9nZXRTZWxlY3Rpb25JbmZvIiwibm9kZU1kUHJldmlldyIsInNjcm9sbEhlaWdodCIsIm9mZnNldEhlaWdodCIsIm9uRW1pdCIsIndpdGhDdHJsIiwiX2lzS2V5TWF0Y2giLCJyZW5kZXJOYXZpZ2F0aW9uIiwic2hvd0Ryb3BMaXN0IiwiZmlsZXMiLCJvbkltYWdlQ2hhbmdlZCIsInJlbmRlckNvbnRlbnQiLCJoYW5kbGVTY3JvbGxFbGUiLCJjYWxjRGVjb3JhdGVUZXh0IiwiZm9ybWF0VGFibGVUZXh0Iiwicm93SGVhZGVyIiwicm93RGF0YSIsInJvd0RpdmlzaW9uIiwiY29sU3RyIiwicmVjb3JkIiwibGFzdFJlY29yZCIsInJlY3ljbGUiLCJoaXN0b3J5IiwiZGVlcENsb25lIiwib2JqQXJyYXkiLCJpc1JlcGVhdCIsInRocm90dGxlIiwibGFzdENhbGxlZEF0IiwiZ2V0VGltZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxlQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBNkI7QUFDN0IscUNBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw2QkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQWtCLDhCQUE4QjtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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LEVBQWlCOVAsU0FBakI7QUFDQTg2SCxrQkFBWSxHQUFHLElBQUkvN0YsSUFBSixHQUFXZzhGLE9BQVgsRUFBZjtBQUNEO0FBQ0YsR0FMRDtBQU1ELEMiLCJmaWxlIjoiYXBwLmJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdGZ1bmN0aW9uIGhvdERpc3Bvc2VDaHVuayhjaHVua0lkKSB7XG4gXHRcdGRlbGV0ZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHR9XG4gXHR2YXIgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2sgPSB3aW5kb3dbXCJ3ZWJwYWNrSG90VXBkYXRlXCJdO1xuIFx0d2luZG93W1wid2VicGFja0hvdFVwZGF0ZVwiXSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0ZnVuY3Rpb24gd2VicGFja0hvdFVwZGF0ZUNhbGxiYWNrKGNodW5rSWQsIG1vcmVNb2R1bGVzKSB7XG4gXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcbiBcdFx0aWYgKHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrKSBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcyk7XG4gXHR9IDtcblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpIHtcbiBcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gXHRcdHNjcmlwdC5jaGFyc2V0ID0gXCJ1dGYtOFwiO1xuIFx0XHRzY3JpcHQuc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGNodW5rSWQgKyBcIi5cIiArIGhvdEN1cnJlbnRIYXNoICsgXCIuaG90LXVwZGF0ZS5qc1wiO1xuIFx0XHRpZiAobnVsbCkgc2NyaXB0LmNyb3NzT3JpZ2luID0gbnVsbDtcbiBcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuIFx0fVxuXG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIGhvdERvd25sb2FkTWFuaWZlc3QocmVxdWVzdFRpbWVvdXQpIHtcbiBcdFx0cmVxdWVzdFRpbWVvdXQgPSByZXF1ZXN0VGltZW91dCB8fCAxMDAwMDtcbiBcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuIFx0XHRcdGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiBcdFx0XHRcdHJldHVybiByZWplY3QobmV3IEVycm9yKFwiTm8gYnJvd3NlciBzdXBwb3J0XCIpKTtcbiBcdFx0XHR9XG4gXHRcdFx0dHJ5IHtcbiBcdFx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gXHRcdFx0XHR2YXIgcmVxdWVzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgaG90Q3VycmVudEhhc2ggKyBcIi5ob3QtdXBkYXRlLmpzb25cIjtcbiBcdFx0XHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCByZXF1ZXN0UGF0aCwgdHJ1ZSk7XG4gXHRcdFx0XHRyZXF1ZXN0LnRpbWVvdXQgPSByZXF1ZXN0VGltZW91dDtcbiBcdFx0XHRcdHJlcXVlc3Quc2VuZChudWxsKTtcbiBcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiBcdFx0XHRcdHJldHVybiByZWplY3QoZXJyKTtcbiBcdFx0XHR9XG4gXHRcdFx0cmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiBcdFx0XHRcdGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcbiBcdFx0XHRcdGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCkge1xuIFx0XHRcdFx0XHQvLyB0aW1lb3V0XG4gXHRcdFx0XHRcdHJlamVjdChcbiBcdFx0XHRcdFx0XHRuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiB0aW1lZCBvdXQuXCIpXG4gXHRcdFx0XHRcdCk7XG4gXHRcdFx0XHR9IGVsc2UgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDQpIHtcbiBcdFx0XHRcdFx0Ly8gbm8gdXBkYXRlIGF2YWlsYWJsZVxuIFx0XHRcdFx0XHRyZXNvbHZlKCk7XG4gXHRcdFx0XHR9IGVsc2UgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDAgJiYgcmVxdWVzdC5zdGF0dXMgIT09IDMwNCkge1xuIFx0XHRcdFx0XHQvLyBvdGhlciBmYWlsdXJlXG4gXHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiBmYWlsZWQuXCIpKTtcbiBcdFx0XHRcdH0gZWxzZSB7XG4gXHRcdFx0XHRcdC8vIHN1Y2Nlc3NcbiBcdFx0XHRcdFx0dHJ5IHtcbiBcdFx0XHRcdFx0XHR2YXIgdXBkYXRlID0gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcbiBcdFx0XHRcdFx0XHRyZWplY3QoZSk7XG4gXHRcdFx0XHRcdFx0cmV0dXJuO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdHJlc29sdmUodXBkYXRlKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9O1xuIFx0XHR9KTtcbiBcdH1cblxuIFx0dmFyIGhvdEFwcGx5T25VcGRhdGUgPSB0cnVlO1xuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHR2YXIgaG90Q3VycmVudEhhc2ggPSBcIjYxMWQ0NjhiNTkxNDMxOTQyMmVjXCI7XG4gXHR2YXIgaG90UmVxdWVzdFRpbWVvdXQgPSAxMDAwMDtcbiBcdHZhciBob3RDdXJyZW50TW9kdWxlRGF0YSA9IHt9O1xuIFx0dmFyIGhvdEN1cnJlbnRDaGlsZE1vZHVsZTtcbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzID0gW107XG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdHZhciBob3RDdXJyZW50UGFyZW50c1RlbXAgPSBbXTtcblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVSZXF1aXJlKG1vZHVsZUlkKSB7XG4gXHRcdHZhciBtZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRpZiAoIW1lKSByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXztcbiBcdFx0dmFyIGZuID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuIFx0XHRcdGlmIChtZS5ob3QuYWN0aXZlKSB7XG4gXHRcdFx0XHRpZiAoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xuIFx0XHRcdFx0XHRpZiAoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpID09PSAtMSkge1xuIFx0XHRcdFx0XHRcdGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuIFx0XHRcdFx0XHRob3RDdXJyZW50Q2hpbGRNb2R1bGUgPSByZXF1ZXN0O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYgKG1lLmNoaWxkcmVuLmluZGV4T2YocmVxdWVzdCkgPT09IC0xKSB7XG4gXHRcdFx0XHRcdG1lLmNoaWxkcmVuLnB1c2gocmVxdWVzdCk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdGNvbnNvbGUud2FybihcbiBcdFx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgK1xuIFx0XHRcdFx0XHRcdHJlcXVlc3QgK1xuIFx0XHRcdFx0XHRcdFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWRcbiBcdFx0XHRcdCk7XG4gXHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFtdO1xuIFx0XHRcdH1cbiBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhyZXF1ZXN0KTtcbiBcdFx0fTtcbiBcdFx0dmFyIE9iamVjdEZhY3RvcnkgPSBmdW5jdGlvbiBPYmplY3RGYWN0b3J5KG5hbWUpIHtcbiBcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG4gXHRcdFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdO1xuIFx0XHRcdFx0fSxcbiBcdFx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiBcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXSA9IHZhbHVlO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH07XG4gXHRcdH07XG4gXHRcdGZvciAodmFyIG5hbWUgaW4gX193ZWJwYWNrX3JlcXVpcmVfXykge1xuIFx0XHRcdGlmIChcbiBcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfX3dlYnBhY2tfcmVxdWlyZV9fLCBuYW1lKSAmJlxuIFx0XHRcdFx0bmFtZSAhPT0gXCJlXCIgJiZcbiBcdFx0XHRcdG5hbWUgIT09IFwidFwiXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIG5hbWUsIE9iamVjdEZhY3RvcnkobmFtZSkpO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRmbi5lID0gZnVuY3Rpb24oY2h1bmtJZCkge1xuIFx0XHRcdGlmIChob3RTdGF0dXMgPT09IFwicmVhZHlcIikgaG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcbiBcdFx0XHRob3RDaHVua3NMb2FkaW5nKys7XG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZShjaHVua0lkKS50aGVuKGZpbmlzaENodW5rTG9hZGluZywgZnVuY3Rpb24oZXJyKSB7XG4gXHRcdFx0XHRmaW5pc2hDaHVua0xvYWRpbmcoKTtcbiBcdFx0XHRcdHRocm93IGVycjtcbiBcdFx0XHR9KTtcblxuIFx0XHRcdGZ1bmN0aW9uIGZpbmlzaENodW5rTG9hZGluZygpIHtcbiBcdFx0XHRcdGhvdENodW5rc0xvYWRpbmctLTtcbiBcdFx0XHRcdGlmIChob3RTdGF0dXMgPT09IFwicHJlcGFyZVwiKSB7XG4gXHRcdFx0XHRcdGlmICghaG90V2FpdGluZ0ZpbGVzTWFwW2NodW5rSWRdKSB7XG4gXHRcdFx0XHRcdFx0aG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0aWYgKGhvdENodW5rc0xvYWRpbmcgPT09IDAgJiYgaG90V2FpdGluZ0ZpbGVzID09PSAwKSB7XG4gXHRcdFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9O1xuIFx0XHRmbi50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0XHRpZiAobW9kZSAmIDEpIHZhbHVlID0gZm4odmFsdWUpO1xuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLnQodmFsdWUsIG1vZGUgJiB+MSk7XG4gXHRcdH07XG4gXHRcdHJldHVybiBmbjtcbiBcdH1cblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpIHtcbiBcdFx0dmFyIGhvdCA9IHtcbiBcdFx0XHQvLyBwcml2YXRlIHN0dWZmXG4gXHRcdFx0X2FjY2VwdGVkRGVwZW5kZW5jaWVzOiB7fSxcbiBcdFx0XHRfZGVjbGluZWREZXBlbmRlbmNpZXM6IHt9LFxuIFx0XHRcdF9zZWxmQWNjZXB0ZWQ6IGZhbHNlLFxuIFx0XHRcdF9zZWxmRGVjbGluZWQ6IGZhbHNlLFxuIFx0XHRcdF9kaXNwb3NlSGFuZGxlcnM6IFtdLFxuIFx0XHRcdF9tYWluOiBob3RDdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkLFxuXG4gXHRcdFx0Ly8gTW9kdWxlIEFQSVxuIFx0XHRcdGFjdGl2ZTogdHJ1ZSxcbiBcdFx0XHRhY2NlcHQ6IGZ1bmN0aW9uKGRlcCwgY2FsbGJhY2spIHtcbiBcdFx0XHRcdGlmIChkZXAgPT09IHVuZGVmaW5lZCkgaG90Ll9zZWxmQWNjZXB0ZWQgPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJmdW5jdGlvblwiKSBob3QuX3NlbGZBY2NlcHRlZCA9IGRlcDtcbiBcdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXG4gXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxuIFx0XHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG4gXHRcdFx0XHRlbHNlIGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG4gXHRcdFx0fSxcbiBcdFx0XHRkZWNsaW5lOiBmdW5jdGlvbihkZXApIHtcbiBcdFx0XHRcdGlmIChkZXAgPT09IHVuZGVmaW5lZCkgaG90Ll9zZWxmRGVjbGluZWQgPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIilcbiBcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXG4gXHRcdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBbaV1dID0gdHJ1ZTtcbiBcdFx0XHRcdGVsc2UgaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBdID0gdHJ1ZTtcbiBcdFx0XHR9LFxuIFx0XHRcdGRpc3Bvc2U6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcbiBcdFx0XHR9LFxuIFx0XHRcdGFkZERpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuIFx0XHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG4gXHRcdFx0fSxcbiBcdFx0XHRyZW1vdmVEaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiBcdFx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiBcdFx0XHRcdGlmIChpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0fSxcblxuIFx0XHRcdC8vIE1hbmFnZW1lbnQgQVBJXG4gXHRcdFx0Y2hlY2s6IGhvdENoZWNrLFxuIFx0XHRcdGFwcGx5OiBob3RBcHBseSxcbiBcdFx0XHRzdGF0dXM6IGZ1bmN0aW9uKGwpIHtcbiBcdFx0XHRcdGlmICghbCkgcmV0dXJuIGhvdFN0YXR1cztcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG4gXHRcdFx0fSxcbiBcdFx0XHRhZGRTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xuIFx0XHRcdH0sXG4gXHRcdFx0cmVtb3ZlU3RhdHVzSGFuZGxlcjogZnVuY3Rpb24obCkge1xuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdFN0YXR1c0hhbmRsZXJzLmluZGV4T2YobCk7XG4gXHRcdFx0XHRpZiAoaWR4ID49IDApIGhvdFN0YXR1c0hhbmRsZXJzLnNwbGljZShpZHgsIDEpO1xuIFx0XHRcdH0sXG5cbiBcdFx0XHQvL2luaGVyaXQgZnJvbSBwcmV2aW91cyBkaXNwb3NlIGNhbGxcbiBcdFx0XHRkYXRhOiBob3RDdXJyZW50TW9kdWxlRGF0YVttb2R1bGVJZF1cbiBcdFx0fTtcbiBcdFx0aG90Q3VycmVudENoaWxkTW9kdWxlID0gdW5kZWZpbmVkO1xuIFx0XHRyZXR1cm4gaG90O1xuIFx0fVxuXG4gXHR2YXIgaG90U3RhdHVzSGFuZGxlcnMgPSBbXTtcbiBcdHZhciBob3RTdGF0dXMgPSBcImlkbGVcIjtcblxuIFx0ZnVuY3Rpb24gaG90U2V0U3RhdHVzKG5ld1N0YXR1cykge1xuIFx0XHRob3RTdGF0dXMgPSBuZXdTdGF0dXM7XG4gXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaG90U3RhdHVzSGFuZGxlcnMubGVuZ3RoOyBpKyspXG4gXHRcdFx0aG90U3RhdHVzSGFuZGxlcnNbaV0uY2FsbChudWxsLCBuZXdTdGF0dXMpO1xuIFx0fVxuXG4gXHQvLyB3aGlsZSBkb3dubG9hZGluZ1xuIFx0dmFyIGhvdFdhaXRpbmdGaWxlcyA9IDA7XG4gXHR2YXIgaG90Q2h1bmtzTG9hZGluZyA9IDA7XG4gXHR2YXIgaG90V2FpdGluZ0ZpbGVzTWFwID0ge307XG4gXHR2YXIgaG90UmVxdWVzdGVkRmlsZXNNYXAgPSB7fTtcbiBcdHZhciBob3RBdmFpbGFibGVGaWxlc01hcCA9IHt9O1xuIFx0dmFyIGhvdERlZmVycmVkO1xuXG4gXHQvLyBUaGUgdXBkYXRlIGluZm9cbiBcdHZhciBob3RVcGRhdGUsIGhvdFVwZGF0ZU5ld0hhc2g7XG5cbiBcdGZ1bmN0aW9uIHRvTW9kdWxlSWQoaWQpIHtcbiBcdFx0dmFyIGlzTnVtYmVyID0gK2lkICsgXCJcIiA9PT0gaWQ7XG4gXHRcdHJldHVybiBpc051bWJlciA/ICtpZCA6IGlkO1xuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RDaGVjayhhcHBseSkge1xuIFx0XHRpZiAoaG90U3RhdHVzICE9PSBcImlkbGVcIikge1xuIFx0XHRcdHRocm93IG5ldyBFcnJvcihcImNoZWNrKCkgaXMgb25seSBhbGxvd2VkIGluIGlkbGUgc3RhdHVzXCIpO1xuIFx0XHR9XG4gXHRcdGhvdEFwcGx5T25VcGRhdGUgPSBhcHBseTtcbiBcdFx0aG90U2V0U3RhdHVzKFwiY2hlY2tcIik7XG4gXHRcdHJldHVybiBob3REb3dubG9hZE1hbmlmZXN0KGhvdFJlcXVlc3RUaW1lb3V0KS50aGVuKGZ1bmN0aW9uKHVwZGF0ZSkge1xuIFx0XHRcdGlmICghdXBkYXRlKSB7XG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoXCJpZGxlXCIpO1xuIFx0XHRcdFx0cmV0dXJuIG51bGw7XG4gXHRcdFx0fVxuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwID0ge307XG4gXHRcdFx0aG90QXZhaWxhYmxlRmlsZXNNYXAgPSB1cGRhdGUuYztcbiBcdFx0XHRob3RVcGRhdGVOZXdIYXNoID0gdXBkYXRlLmg7XG5cbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xuIFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gXHRcdFx0XHRob3REZWZlcnJlZCA9IHtcbiBcdFx0XHRcdFx0cmVzb2x2ZTogcmVzb2x2ZSxcbiBcdFx0XHRcdFx0cmVqZWN0OiByZWplY3RcbiBcdFx0XHRcdH07XG4gXHRcdFx0fSk7XG4gXHRcdFx0aG90VXBkYXRlID0ge307XG4gXHRcdFx0dmFyIGNodW5rSWQgPSBcImFwcFwiO1xuIFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xuIFx0XHRcdHtcbiBcdFx0XHRcdC8qZ2xvYmFscyBjaHVua0lkICovXG4gXHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcbiBcdFx0XHR9XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0aG90U3RhdHVzID09PSBcInByZXBhcmVcIiAmJlxuIFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJlxuIFx0XHRcdFx0aG90V2FpdGluZ0ZpbGVzID09PSAwXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XG4gXHRcdFx0fVxuIFx0XHRcdHJldHVybiBwcm9taXNlO1xuIFx0XHR9KTtcbiBcdH1cblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3RBZGRVcGRhdGVDaHVuayhjaHVua0lkLCBtb3JlTW9kdWxlcykge1xuIFx0XHRpZiAoIWhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdIHx8ICFob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSlcbiBcdFx0XHRyZXR1cm47XG4gXHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gZmFsc2U7XG4gXHRcdGZvciAodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4gXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHRob3RVcGRhdGVbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRpZiAoLS1ob3RXYWl0aW5nRmlsZXMgPT09IDAgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCkge1xuIFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKSB7XG4gXHRcdGlmICghaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0pIHtcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xuIFx0XHR9IGVsc2Uge1xuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gdHJ1ZTtcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXMrKztcbiBcdFx0XHRob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpO1xuIFx0XHR9XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdFVwZGF0ZURvd25sb2FkZWQoKSB7XG4gXHRcdGhvdFNldFN0YXR1cyhcInJlYWR5XCIpO1xuIFx0XHR2YXIgZGVmZXJyZWQgPSBob3REZWZlcnJlZDtcbiBcdFx0aG90RGVmZXJyZWQgPSBudWxsO1xuIFx0XHRpZiAoIWRlZmVycmVkKSByZXR1cm47XG4gXHRcdGlmIChob3RBcHBseU9uVXBkYXRlKSB7XG4gXHRcdFx0Ly8gV3JhcCBkZWZlcnJlZCBvYmplY3QgaW4gUHJvbWlzZSB0byBtYXJrIGl0IGFzIGEgd2VsbC1oYW5kbGVkIFByb21pc2UgdG9cbiBcdFx0XHQvLyBhdm9pZCB0cmlnZ2VyaW5nIHVuY2F1Z2h0IGV4Y2VwdGlvbiB3YXJuaW5nIGluIENocm9tZS5cbiBcdFx0XHQvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDY1NjY2XG4gXHRcdFx0UHJvbWlzZS5yZXNvbHZlKClcbiBcdFx0XHRcdC50aGVuKGZ1bmN0aW9uKCkge1xuIFx0XHRcdFx0XHRyZXR1cm4gaG90QXBwbHkoaG90QXBwbHlPblVwZGF0ZSk7XG4gXHRcdFx0XHR9KVxuIFx0XHRcdFx0LnRoZW4oXG4gXHRcdFx0XHRcdGZ1bmN0aW9uKHJlc3VsdCkge1xuIFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiBcdFx0XHRcdFx0fSxcbiBcdFx0XHRcdFx0ZnVuY3Rpb24oZXJyKSB7XG4gXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KGVycik7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdCk7XG4gXHRcdH0gZWxzZSB7XG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuIFx0XHRcdGZvciAodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xuIFx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaCh0b01vZHVsZUlkKGlkKSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHRcdGRlZmVycmVkLnJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RBcHBseShvcHRpb25zKSB7XG4gXHRcdGlmIChob3RTdGF0dXMgIT09IFwicmVhZHlcIilcbiBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJhcHBseSgpIGlzIG9ubHkgYWxsb3dlZCBpbiByZWFkeSBzdGF0dXNcIik7XG4gXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gXHRcdHZhciBjYjtcbiBcdFx0dmFyIGk7XG4gXHRcdHZhciBqO1xuIFx0XHR2YXIgbW9kdWxlO1xuIFx0XHR2YXIgbW9kdWxlSWQ7XG5cbiBcdFx0ZnVuY3Rpb24gZ2V0QWZmZWN0ZWRTdHVmZih1cGRhdGVNb2R1bGVJZCkge1xuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbdXBkYXRlTW9kdWxlSWRdO1xuIFx0XHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xuXG4gXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLm1hcChmdW5jdGlvbihpZCkge1xuIFx0XHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdFx0Y2hhaW46IFtpZF0sXG4gXHRcdFx0XHRcdGlkOiBpZFxuIFx0XHRcdFx0fTtcbiBcdFx0XHR9KTtcbiBcdFx0XHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuIFx0XHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xuIFx0XHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWVJdGVtLmlkO1xuIFx0XHRcdFx0dmFyIGNoYWluID0gcXVldWVJdGVtLmNoYWluO1xuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0XHRpZiAoIW1vZHVsZSB8fCBtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWQpIGNvbnRpbnVlO1xuIFx0XHRcdFx0aWYgKG1vZHVsZS5ob3QuX3NlbGZEZWNsaW5lZCkge1xuIFx0XHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1kZWNsaW5lZFwiLFxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbixcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcbiBcdFx0XHRcdFx0fTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGlmIChtb2R1bGUuaG90Ll9tYWluKSB7XG4gXHRcdFx0XHRcdHJldHVybiB7XG4gXHRcdFx0XHRcdFx0dHlwZTogXCJ1bmFjY2VwdGVkXCIsXG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxuIFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuIFx0XHRcdFx0XHR9O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0XHR2YXIgcGFyZW50SWQgPSBtb2R1bGUucGFyZW50c1tpXTtcbiBcdFx0XHRcdFx0dmFyIHBhcmVudCA9IGluc3RhbGxlZE1vZHVsZXNbcGFyZW50SWRdO1xuIFx0XHRcdFx0XHRpZiAoIXBhcmVudCkgY29udGludWU7XG4gXHRcdFx0XHRcdGlmIChwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRcdFx0dHlwZTogXCJkZWNsaW5lZFwiLFxuIFx0XHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcbiBcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0XHRcdHBhcmVudElkOiBwYXJlbnRJZFxuIFx0XHRcdFx0XHRcdH07XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0aWYgKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSAhPT0gLTEpIGNvbnRpbnVlO1xuIFx0XHRcdFx0XHRpZiAocGFyZW50LmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXG4gXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0gPSBbXTtcbiBcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0sIFttb2R1bGVJZF0pO1xuIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF07XG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcbiBcdFx0XHRcdFx0cXVldWUucHVzaCh7XG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcbiBcdFx0XHRcdFx0XHRpZDogcGFyZW50SWRcbiBcdFx0XHRcdFx0fSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuXG4gXHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcbiBcdFx0XHRcdG1vZHVsZUlkOiB1cGRhdGVNb2R1bGVJZCxcbiBcdFx0XHRcdG91dGRhdGVkTW9kdWxlczogb3V0ZGF0ZWRNb2R1bGVzLFxuIFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXG4gXHRcdFx0fTtcbiBcdFx0fVxuXG4gXHRcdGZ1bmN0aW9uIGFkZEFsbFRvU2V0KGEsIGIpIHtcbiBcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdHZhciBpdGVtID0gYltpXTtcbiBcdFx0XHRcdGlmIChhLmluZGV4T2YoaXRlbSkgPT09IC0xKSBhLnB1c2goaXRlbSk7XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gYXQgYmVnaW4gYWxsIHVwZGF0ZXMgbW9kdWxlcyBhcmUgb3V0ZGF0ZWRcbiBcdFx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxuIFx0XHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcbiBcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuIFx0XHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xuXG4gXHRcdHZhciB3YXJuVW5leHBlY3RlZFJlcXVpcmUgPSBmdW5jdGlvbiB3YXJuVW5leHBlY3RlZFJlcXVpcmUoKSB7XG4gXHRcdFx0Y29uc29sZS53YXJuKFxuIFx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgKyByZXN1bHQubW9kdWxlSWQgKyBcIikgdG8gZGlzcG9zZWQgbW9kdWxlXCJcbiBcdFx0XHQpO1xuIFx0XHR9O1xuXG4gXHRcdGZvciAodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xuIFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaG90VXBkYXRlLCBpZCkpIHtcbiBcdFx0XHRcdG1vZHVsZUlkID0gdG9Nb2R1bGVJZChpZCk7XG4gXHRcdFx0XHQvKiogQHR5cGUge1RPRE99ICovXG4gXHRcdFx0XHR2YXIgcmVzdWx0O1xuIFx0XHRcdFx0aWYgKGhvdFVwZGF0ZVtpZF0pIHtcbiBcdFx0XHRcdFx0cmVzdWx0ID0gZ2V0QWZmZWN0ZWRTdHVmZihtb2R1bGVJZCk7XG4gXHRcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0XHRyZXN1bHQgPSB7XG4gXHRcdFx0XHRcdFx0dHlwZTogXCJkaXNwb3NlZFwiLFxuIFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBpZFxuIFx0XHRcdFx0XHR9O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0LyoqIEB0eXBlIHtFcnJvcnxmYWxzZX0gKi9cbiBcdFx0XHRcdHZhciBhYm9ydEVycm9yID0gZmFsc2U7XG4gXHRcdFx0XHR2YXIgZG9BcHBseSA9IGZhbHNlO1xuIFx0XHRcdFx0dmFyIGRvRGlzcG9zZSA9IGZhbHNlO1xuIFx0XHRcdFx0dmFyIGNoYWluSW5mbyA9IFwiXCI7XG4gXHRcdFx0XHRpZiAocmVzdWx0LmNoYWluKSB7XG4gXHRcdFx0XHRcdGNoYWluSW5mbyA9IFwiXFxuVXBkYXRlIHByb3BhZ2F0aW9uOiBcIiArIHJlc3VsdC5jaGFpbi5qb2luKFwiIC0+IFwiKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdHN3aXRjaCAocmVzdWx0LnR5cGUpIHtcbiBcdFx0XHRcdFx0Y2FzZSBcInNlbGYtZGVjbGluZWRcIjpcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRlY2xpbmVkKSBvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcbiBcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuIFx0XHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBvZiBzZWxmIGRlY2xpbmU6IFwiICtcbiBcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQubW9kdWxlSWQgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdGNoYWluSW5mb1xuIFx0XHRcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcImRlY2xpbmVkXCI6XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EZWNsaW5lZCkgb3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcbiBcdFx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2Ugb2YgZGVjbGluZWQgZGVwZW5kZW5jeTogXCIgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5tb2R1bGVJZCArXG4gXHRcdFx0XHRcdFx0XHRcdFx0XCIgaW4gXCIgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5wYXJlbnRJZCArXG4gXHRcdFx0XHRcdFx0XHRcdFx0Y2hhaW5JbmZvXG4gXHRcdFx0XHRcdFx0XHQpO1xuIFx0XHRcdFx0XHRcdGJyZWFrO1xuIFx0XHRcdFx0XHRjYXNlIFwidW5hY2NlcHRlZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uVW5hY2NlcHRlZCkgb3B0aW9ucy5vblVuYWNjZXB0ZWQocmVzdWx0KTtcbiBcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlVW5hY2NlcHRlZClcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG4gXHRcdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIiArIGNoYWluSW5mb1xuIFx0XHRcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcImFjY2VwdGVkXCI6XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25BY2NlcHRlZCkgb3B0aW9ucy5vbkFjY2VwdGVkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0ZG9BcHBseSA9IHRydWU7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGNhc2UgXCJkaXNwb3NlZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGlzcG9zZWQpIG9wdGlvbnMub25EaXNwb3NlZChyZXN1bHQpO1xuIFx0XHRcdFx0XHRcdGRvRGlzcG9zZSA9IHRydWU7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGRlZmF1bHQ6XG4gXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leGNlcHRpb24gdHlwZSBcIiArIHJlc3VsdC50eXBlKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGlmIChhYm9ydEVycm9yKSB7XG4gXHRcdFx0XHRcdGhvdFNldFN0YXR1cyhcImFib3J0XCIpO1xuIFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoYWJvcnRFcnJvcik7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpZiAoZG9BcHBseSkge1xuIFx0XHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IGhvdFVwZGF0ZVttb2R1bGVJZF07XG4gXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgcmVzdWx0Lm91dGRhdGVkTW9kdWxlcyk7XG4gXHRcdFx0XHRcdGZvciAobW9kdWxlSWQgaW4gcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG4gXHRcdFx0XHRcdFx0aWYgKFxuIFx0XHRcdFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuIFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMsXG4gXHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkXG4gXHRcdFx0XHRcdFx0XHQpXG4gXHRcdFx0XHRcdFx0KSB7XG4gXHRcdFx0XHRcdFx0XHRpZiAoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcbiBcdFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XG4gXHRcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChcbiBcdFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdLFxuIFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdXG4gXHRcdFx0XHRcdFx0XHQpO1xuIFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYgKGRvRGlzcG9zZSkge1xuIFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIFtyZXN1bHQubW9kdWxlSWRdKTtcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSB3YXJuVW5leHBlY3RlZFJlcXVpcmU7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gU3RvcmUgc2VsZiBhY2NlcHRlZCBvdXRkYXRlZCBtb2R1bGVzIHRvIHJlcXVpcmUgdGhlbSBsYXRlciBieSB0aGUgbW9kdWxlIHN5c3RlbVxuIFx0XHR2YXIgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzID0gW107XG4gXHRcdGZvciAoaSA9IDA7IGkgPCBvdXRkYXRlZE1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRtb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tpXTtcbiBcdFx0XHRpZiAoXG4gXHRcdFx0XHRpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSAmJlxuIFx0XHRcdFx0aW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uaG90Ll9zZWxmQWNjZXB0ZWQgJiZcbiBcdFx0XHRcdC8vIHJlbW92ZWQgc2VsZi1hY2NlcHRlZCBtb2R1bGVzIHNob3VsZCBub3QgYmUgcmVxdWlyZWRcbiBcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdICE9PSB3YXJuVW5leHBlY3RlZFJlcXVpcmVcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5wdXNoKHtcbiBcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZFxuIFx0XHRcdFx0fSk7XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXG4gXHRcdGhvdFNldFN0YXR1cyhcImRpc3Bvc2VcIik7XG4gXHRcdE9iamVjdC5rZXlzKGhvdEF2YWlsYWJsZUZpbGVzTWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rSWQpIHtcbiBcdFx0XHRpZiAoaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0gPT09IGZhbHNlKSB7XG4gXHRcdFx0XHRob3REaXNwb3NlQ2h1bmsoY2h1bmtJZCk7XG4gXHRcdFx0fVxuIFx0XHR9KTtcblxuIFx0XHR2YXIgaWR4O1xuIFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKTtcbiBcdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiBcdFx0XHRtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xuIFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdGlmICghbW9kdWxlKSBjb250aW51ZTtcblxuIFx0XHRcdHZhciBkYXRhID0ge307XG5cbiBcdFx0XHQvLyBDYWxsIGRpc3Bvc2UgaGFuZGxlcnNcbiBcdFx0XHR2YXIgZGlzcG9zZUhhbmRsZXJzID0gbW9kdWxlLmhvdC5fZGlzcG9zZUhhbmRsZXJzO1xuIFx0XHRcdGZvciAoaiA9IDA7IGogPCBkaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiBcdFx0XHRcdGNiID0gZGlzcG9zZUhhbmRsZXJzW2pdO1xuIFx0XHRcdFx0Y2IoZGF0YSk7XG4gXHRcdFx0fVxuIFx0XHRcdGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXSA9IGRhdGE7XG5cbiBcdFx0XHQvLyBkaXNhYmxlIG1vZHVsZSAodGhpcyBkaXNhYmxlcyByZXF1aXJlcyBmcm9tIHRoaXMgbW9kdWxlKVxuIFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XG5cbiBcdFx0XHQvLyByZW1vdmUgbW9kdWxlIGZyb20gY2FjaGVcbiBcdFx0XHRkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG5cbiBcdFx0XHQvLyB3aGVuIGRpc3Bvc2luZyB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgZGlzcG9zZSBoYW5kbGVyXG4gXHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcblxuIFx0XHRcdC8vIHJlbW92ZSBcInBhcmVudHNcIiByZWZlcmVuY2VzIGZyb20gYWxsIGNoaWxkcmVuXG4gXHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0dmFyIGNoaWxkID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGUuY2hpbGRyZW5bal1dO1xuIFx0XHRcdFx0aWYgKCFjaGlsZCkgY29udGludWU7XG4gXHRcdFx0XHRpZHggPSBjaGlsZC5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpO1xuIFx0XHRcdFx0aWYgKGlkeCA+PSAwKSB7XG4gXHRcdFx0XHRcdGNoaWxkLnBhcmVudHMuc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gcmVtb3ZlIG91dGRhdGVkIGRlcGVuZGVuY3kgZnJvbSBtb2R1bGUgY2hpbGRyZW5cbiBcdFx0dmFyIGRlcGVuZGVuY3k7XG4gXHRcdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcbiBcdFx0Zm9yIChtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xuIFx0XHRcdGlmIChcbiBcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdGlmIChtb2R1bGUpIHtcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XG4gXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0XHRcdGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcbiBcdFx0XHRcdFx0XHRpZHggPSBtb2R1bGUuY2hpbGRyZW4uaW5kZXhPZihkZXBlbmRlbmN5KTtcbiBcdFx0XHRcdFx0XHRpZiAoaWR4ID49IDApIG1vZHVsZS5jaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fVxuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIE5vdyBpbiBcImFwcGx5XCIgcGhhc2VcbiBcdFx0aG90U2V0U3RhdHVzKFwiYXBwbHlcIik7XG5cbiBcdFx0aG90Q3VycmVudEhhc2ggPSBob3RVcGRhdGVOZXdIYXNoO1xuXG4gXHRcdC8vIGluc2VydCBuZXcgY29kZVxuIFx0XHRmb3IgKG1vZHVsZUlkIGluIGFwcGxpZWRVcGRhdGUpIHtcbiBcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcGxpZWRVcGRhdGUsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBhcHBsaWVkVXBkYXRlW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xuIFx0XHR2YXIgZXJyb3IgPSBudWxsO1xuIFx0XHRmb3IgKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZClcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdFx0aWYgKG1vZHVsZSkge1xuIFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xuIFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV07XG4gXHRcdFx0XHRcdFx0Y2IgPSBtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcbiBcdFx0XHRcdFx0XHRpZiAoY2IpIHtcbiBcdFx0XHRcdFx0XHRcdGlmIChjYWxsYmFja3MuaW5kZXhPZihjYikgIT09IC0xKSBjb250aW51ZTtcbiBcdFx0XHRcdFx0XHRcdGNhbGxiYWNrcy5wdXNoKGNiKTtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0XHRcdGNiID0gY2FsbGJhY2tzW2ldO1xuIFx0XHRcdFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRcdFx0XHRjYihtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyk7XG4gXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG4gXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuIFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yZWRcIixcbiBcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG4gXHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tpXSxcbiBcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXG4gXHRcdFx0XHRcdFx0XHRcdH0pO1xuIFx0XHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gXHRcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gTG9hZCBzZWxmIGFjY2VwdGVkIG1vZHVsZXNcbiBcdFx0Zm9yIChpID0gMDsgaSA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdHZhciBpdGVtID0gb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzW2ldO1xuIFx0XHRcdG1vZHVsZUlkID0gaXRlbS5tb2R1bGU7XG4gXHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuIFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKTtcbiBcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiBcdFx0XHRcdGlmICh0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuIFx0XHRcdFx0XHR0cnkge1xuIFx0XHRcdFx0XHRcdGl0ZW0uZXJyb3JIYW5kbGVyKGVycik7XG4gXHRcdFx0XHRcdH0gY2F0Y2ggKGVycjIpIHtcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcbiBcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvci1oYW5kbGVyLWVycm9yZWRcIixcbiBcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuIFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyMixcbiBcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXG4gXHRcdFx0XHRcdFx0XHR9KTtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZXJyMjtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH0gZWxzZSB7XG4gXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuIFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcbiBcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3JlZFwiLFxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuIFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxuIFx0XHRcdFx0XHRcdH0pO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG4gXHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBoYW5kbGUgZXJyb3JzIGluIGFjY2VwdCBoYW5kbGVycyBhbmQgc2VsZiBhY2NlcHRlZCBtb2R1bGUgbG9hZFxuIFx0XHRpZiAoZXJyb3IpIHtcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJmYWlsXCIpO1xuIFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gXHRcdH1cblxuIFx0XHRob3RTZXRTdGF0dXMoXCJpZGxlXCIpO1xuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuIFx0XHRcdHJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcbiBcdFx0fSk7XG4gXHR9XG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGhvdDogaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSxcbiBcdFx0XHRwYXJlbnRzOiAoaG90Q3VycmVudFBhcmVudHNUZW1wID0gaG90Q3VycmVudFBhcmVudHMsIGhvdEN1cnJlbnRQYXJlbnRzID0gW10sIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCksXG4gXHRcdFx0Y2hpbGRyZW46IFtdXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBfX3dlYnBhY2tfaGFzaF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdEN1cnJlbnRIYXNoOyB9O1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIGhvdENyZWF0ZVJlcXVpcmUoXCIuL2V4YW1wbGUvaW5kZXguanN4XCIpKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9leGFtcGxlL2luZGV4LmpzeFwiKTtcbiIsImNvbnN0IGNvbnRlbnQgPSBgIyBoMSBIZWFkaW5nIDgtKVxuIyMgaDIgSGVhZGluZ1xuIyMjIGgzIEhlYWRpbmdcbiMjIyMgaDQgSGVhZGluZ1xuIyMjIyMgaDUgSGVhZGluZ1xuIyMjIyMjIGg2IEhlYWRpbmdcblxuXG4jIyBIb3Jpem9udGFsIFJ1bGVzXG5cbl9fX1xuXG4tLS1cblxuKioqXG5cblxuIyMgVHlwb2dyYXBoaWMgcmVwbGFjZW1lbnRzXG5cbkVuYWJsZSB0eXBvZ3JhcGhlciBvcHRpb24gdG8gc2VlIHJlc3VsdC5cblxuKGMpIChDKSAocikgKFIpICh0bSkgKFRNKSAocCkgKFApICstXG5cbnRlc3QuLiB0ZXN0Li4uIHRlc3QuLi4uLiB0ZXN0Py4uLi4uIHRlc3QhLi4uLlxuXG4hISEhISEgPz8/PyAsLCAgLS0gLS0tXG5cblwiU21hcnR5cGFudHMsIGRvdWJsZSBxdW90ZXNcIiBhbmQgJ3NpbmdsZSBxdW90ZXMnXG5cblxuIyMgRW1waGFzaXNcblxuKipUaGlzIGlzIGJvbGQgdGV4dCoqXG5cbl9fVGhpcyBpcyBib2xkIHRleHRfX1xuXG4qVGhpcyBpcyBpdGFsaWMgdGV4dCpcblxuX1RoaXMgaXMgaXRhbGljIHRleHRfXG5cbn5+U3RyaWtldGhyb3VnaH5+XG5cblxuIyMgQmxvY2txdW90ZXNcblxuPiBCbG9ja3F1b3RlcyB0ZXN0XG4gLSBuZXN0XG4+IEJsb2NrcXVvdGVzIGNhbiBhbHNvIGJlIG5lc3RlZC4uLlxuPj4gLi4uYnkgdXNpbmcgYWRkaXRpb25hbCBncmVhdGVyLXRoYW4gc2lnbnMgcmlnaHQgbmV4dCB0byBlYWNoIG90aGVyLi4uXG4+ID4gPiAuLi5vciB3aXRoIHNwYWNlcyBiZXR3ZWVuIGFycm93cy5cblxuXG4jIyBMaXN0c1xuXG5Vbm9yZGVyZWRcblxuKyBDcmVhdGUgYSBsaXN0IGJ5IHN0YXJ0aW5nIGEgbGluZSB3aXRoIFxcYCtcXGAsIFxcYC1cXGAsIG9yIFxcYCpcXGBcbisgU3ViLWxpc3RzIGFyZSBtYWRlIGJ5IGluZGVudGluZyAyIHNwYWNlczpcbiAgLSBNYXJrZXIgY2hhcmFjdGVyIGNoYW5nZSBmb3JjZXMgbmV3IGxpc3Qgc3RhcnQ6XG4gICAgKiBBYyB0cmlzdGlxdWUgbGliZXJvIHZvbHV0cGF0IGF0XG4gICAgKyBGYWNpbGlzaXMgaW4gcHJldGl1bSBuaXNsIGFsaXF1ZXRcbiAgICAtIE51bGxhIHZvbHV0cGF0IGFsaXF1YW0gdmVsaXRcbisgVmVyeSBlYXN5IVxuXG5PcmRlcmVkXG5cbjEuIExvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0XG4yLiBDb25zZWN0ZXR1ciBhZGlwaXNjaW5nIGVsaXRcbjMuIEludGVnZXIgbW9sZXN0aWUgbG9yZW0gYXQgbWFzc2FcblxuXG4xLiBZb3UgY2FuIHVzZSBzZXF1ZW50aWFsIG51bWJlcnMuLi5cbjEuIC4uLm9yIGtlZXAgYWxsIHRoZSBudW1iZXJzIGFzIFxcYDEuXFxgXG5cblN0YXJ0IG51bWJlcmluZyB3aXRoIG9mZnNldDpcblxuNTcuIGZvb1xuMS4gYmFyXG5cblxuIyMgQ29kZVxuXG5JbmxpbmUgXFxgY29kZVxcYFxuXG5JbmRlbnRlZCBjb2RlXG5cbiAgICAvLyBTb21lIGNvbW1lbnRzXG4gICAgbGluZSAxIG9mIGNvZGVcbiAgICBsaW5lIDIgb2YgY29kZVxuICAgIGxpbmUgMyBvZiBjb2RlXG5cblxuQmxvY2sgY29kZSBcImZlbmNlc1wiXG5cblxcYFxcYFxcYFxuU2FtcGxlIHRleHQgaGVyZS4uLlxuXFxgXFxgXFxgXG5cblN5bnRheCBoaWdobGlnaHRpbmdcblxuXFxgXFxgXFxgIGpzXG52YXIgZm9vID0gZnVuY3Rpb24gKGJhcikge1xuICByZXR1cm4gYmFyKys7XG59O1xuXG5jb25zb2xlLmxvZyhmb28oNSkpO1xuXFxgXFxgXFxgXG5cbiMjIFRhYmxlc1xuXG58IE9wdGlvbiB8IERlc2NyaXB0aW9uIHxcbnwgLS0tLS0tIHwgLS0tLS0tLS0tLS0gfFxufCBkYXRhICAgfCBwYXRoIHRvIGRhdGEgZmlsZXMgdG8gc3VwcGx5IHRoZSBkYXRhIHRoYXQgd2lsbCBiZSBwYXNzZWQgaW50byB0ZW1wbGF0ZXMuIHxcbnwgZW5naW5lIHwgZW5naW5lIHRvIGJlIHVzZWQgZm9yIHByb2Nlc3NpbmcgdGVtcGxhdGVzLiBIYW5kbGViYXJzIGlzIHRoZSBkZWZhdWx0LiB8XG58IGV4dCAgICB8IGV4dGVuc2lvbiB0byBiZSB1c2VkIGZvciBkZXN0IGZpbGVzLiB8XG5cblJpZ2h0IGFsaWduZWQgY29sdW1uc1xuXG58IE9wdGlvbiB8IERlc2NyaXB0aW9uIHxcbnwgLS0tLS0tOnwgLS0tLS0tLS0tLS06fFxufCBkYXRhICAgfCBwYXRoIHRvIGRhdGEgZmlsZXMgdG8gc3VwcGx5IHRoZSBkYXRhIHRoYXQgd2lsbCBiZSBwYXNzZWQgaW50byB0ZW1wbGF0ZXMuIHxcbnwgZW5naW5lIHwgZW5naW5lIHRvIGJlIHVzZWQgZm9yIHByb2Nlc3NpbmcgdGVtcGxhdGVzLiBIYW5kbGViYXJzIGlzIHRoZSBkZWZhdWx0LiB8XG58IGV4dCAgICB8IGV4dGVuc2lvbiB0byBiZSB1c2VkIGZvciBkZXN0IGZpbGVzLiB8XG5cblxuIyMgTGlua3NcblxuW2xpbmsgdGV4dF0oaHR0cDovL2Rldi5ub2RlY2EuY29tKVxuXG5bbGluayB3aXRoIHRpdGxlXShodHRwOi8vbm9kZWNhLmdpdGh1Yi5pby9waWNhL2RlbW8vIFwidGl0bGUgdGV4dCFcIilcblxuQXV0b2NvbnZlcnRlZCBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGljYSAoZW5hYmxlIGxpbmtpZnkgdG8gc2VlKVxuXG5cbiMjIEltYWdlc1xuXG4hW01pbmlvbl0oaHR0cHM6Ly9vY3RvZGV4LmdpdGh1Yi5jb20vaW1hZ2VzL21pbmlvbi5wbmcpXG4hW1N0b3JtdHJvb3BvY2F0XShodHRwczovL29jdG9kZXguZ2l0aHViLmNvbS9pbWFnZXMvc3Rvcm10cm9vcG9jYXQuanBnIFwiVGhlIFN0b3JtdHJvb3BvY2F0XCIpXG5cbkxpa2UgbGlua3MsIEltYWdlcyBhbHNvIGhhdmUgYSBmb290bm90ZSBzdHlsZSBzeW50YXhcblxuIVtBbHQgdGV4dF1baWRdXG5cbldpdGggYSByZWZlcmVuY2UgbGF0ZXIgaW4gdGhlIGRvY3VtZW50IGRlZmluaW5nIHRoZSBVUkwgbG9jYXRpb246XG5cbltpZF06IGh0dHBzOi8vb2N0b2RleC5naXRodWIuY29tL2ltYWdlcy9kb2pvY2F0LmpwZyAgXCJUaGUgRG9qb2NhdFwiXG5cblxuIyMgUGx1Z2luc1xuXG5UaGUga2lsbGVyIGZlYXR1cmUgb2YgXFxgbWFya2Rvd24taXRcXGAgaXMgdmVyeSBlZmZlY3RpdmUgc3VwcG9ydCBvZlxuW3N5bnRheCBwbHVnaW5zXShodHRwczovL3d3dy5ucG1qcy5vcmcvYnJvd3NlL2tleXdvcmQvbWFya2Rvd24taXQtcGx1Z2luKS5cblxuXG4jIyMgW0Vtb2ppZXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC1lbW9qaSlcblxuPiBDbGFzc2ljIG1hcmt1cDogOndpbms6IDpjcnVzaDogOmNyeTogOnRlYXI6IDpsYXVnaGluZzogOnl1bTpcbj5cbj4gU2hvcnRjdXRzIChlbW90aWNvbnMpOiA6LSkgOi0oIDgtKSA7KVxuXG5zZWUgW2hvdyB0byBjaGFuZ2Ugb3V0cHV0XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQtZW1vamkjY2hhbmdlLW91dHB1dCkgd2l0aCB0d2Vtb2ppLlxuXG5cbiMjIyBbU3Vic2NyaXB0XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQtc3ViKSAvIFtTdXBlcnNjcmlwdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0LXN1cClcblxuLSAxOV50aF5cbi0gSH4yfk9cblxuXG4jIyMgW1xcPGlucz5dKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC1pbnMpXG5cbisrSW5zZXJ0ZWQgdGV4dCsrXG5cblxuIyMjIFtcXDxtYXJrPl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0LW1hcmspXG5cbj09TWFya2VkIHRleHQ9PVxuXG5cbiMjIyBbRm9vdG5vdGVzXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQtZm9vdG5vdGUpXG5cbkZvb3Rub3RlIDEgbGlua1teZmlyc3RdLlxuXG5Gb290bm90ZSAyIGxpbmtbXnNlY29uZF0uXG5cbklubGluZSBmb290bm90ZV5bVGV4dCBvZiBpbmxpbmUgZm9vdG5vdGVdIGRlZmluaXRpb24uXG5cbkR1cGxpY2F0ZWQgZm9vdG5vdGUgcmVmZXJlbmNlW15zZWNvbmRdLlxuXG5bXmZpcnN0XTogRm9vdG5vdGUgKipjYW4gaGF2ZSBtYXJrdXAqKlxuXG4gICAgYW5kIG11bHRpcGxlIHBhcmFncmFwaHMuXG5cbltec2Vjb25kXTogRm9vdG5vdGUgdGV4dC5cblxuXG4jIyMgW0RlZmluaXRpb24gbGlzdHNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC1kZWZsaXN0KVxuXG5UZXJtIDFcblxuOiAgIERlZmluaXRpb24gMVxud2l0aCBsYXp5IGNvbnRpbnVhdGlvbi5cblxuVGVybSAyIHdpdGggKmlubGluZSBtYXJrdXAqXG5cbjogICBEZWZpbml0aW9uIDJcblxuICAgICAgICB7IHNvbWUgY29kZSwgcGFydCBvZiBEZWZpbml0aW9uIDIgfVxuXG4gICAgVGhpcmQgcGFyYWdyYXBoIG9mIGRlZmluaXRpb24gMi5cblxuX0NvbXBhY3Qgc3R5bGU6X1xuXG5UZXJtIDFcbiAgfiBEZWZpbml0aW9uIDFcblxuVGVybSAyXG4gIH4gRGVmaW5pdGlvbiAyYVxuICB+IERlZmluaXRpb24gMmJcblxuXG4jIyMgW0FiYnJldmlhdGlvbnNdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC1hYmJyKVxuXG5UaGlzIGlzIEhUTUwgYWJicmV2aWF0aW9uIGV4YW1wbGUuXG5cbkl0IGNvbnZlcnRzIFwiSFRNTFwiLCBidXQga2VlcCBpbnRhY3QgcGFydGlhbCBlbnRyaWVzIGxpa2UgXCJ4eHhIVE1MeXl5XCIgYW5kIHNvIG9uLlxuXG4qW0hUTUxdOiBIeXBlciBUZXh0IE1hcmt1cCBMYW5ndWFnZVxuXG4jIyMgW0N1c3RvbSBjb250YWluZXJzXShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQtY29udGFpbmVyKVxuXG46Ojogd2FybmluZ1xuKmhlcmUgYmUgZHJhZ29ucypcbjo6OlxuYFxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50IiwiaW1wb3J0IE1hcmtkb3duSXQgZnJvbSAnbWFya2Rvd24taXQnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IE1kRWRpdG9yIGZyb20gJy4uL3NyYy9pbmRleC5qcyc7XG4vLyBpbXBvcnQgTWRFZGl0b3IgZnJvbSAnLi4vbGliL3JlYWN0LW1hcmtkb3duLWVkaXRvci1saXRlLm1pbi5qcydcbmltcG9ydCBjb250ZW50IGZyb20gJy4vY29udGVudC5qcyc7XG5pbXBvcnQgJy4vaW5kZXgubGVzcyc7XG5jb25zdCBtb2NrX2NvbnRlbnQgPSBjb250ZW50XG5cblxuY2xhc3MgRGVtbyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cbiAgbWRFZGl0b3IgPSBudWxsXG5cbiAgbWRpdCA9IG51bGxcblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuXG4gICAgdGhpcy5tZGl0ID0gbmV3IE1hcmtkb3duSXQoe1xuICAgICAgaHRtbDogdHJ1ZSxcbiAgICAgIGxpbmtpZnk6IHRydWUsXG4gICAgICB0eXBvZ3JhcGhlcjogdHJ1ZVxuICAgIH0pXG4gIH1cblxuICBoYW5kbGVFZGl0b3JDaGFuZ2UoeyBodG1sLCB0ZXh0IH0pIHtcbiAgICAvLyBjb25zb2xlLmxvZygnaGFuZGxlRWRpdG9yQ2hhbmdlJywgdGV4dClcbiAgfVxuXG4gIGhhbmRsZUltYWdlVXBsb2FkKGZpbGUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjb252ZXJ0QmFzZTY0VXJsVG9CbG9iID0gKHVybERhdGEpID0+IHtcbiAgICAgICAgbGV0IGFyciA9IHVybERhdGEuc3BsaXQoJywnKSwgbWltZSA9IGFyclswXS5tYXRjaCgvOiguKj8pOy8pWzFdXG4gICAgICAgIGxldCBic3RyID0gYXRvYihhcnJbMV0pXG4gICAgICAgIGxldCBuID0gYnN0ci5sZW5ndGhcbiAgICAgICAgbGV0IHU4YXJyID0gbmV3IFVpbnQ4QXJyYXkobilcbiAgICAgICAgd2hpbGUgKG4tLSkge1xuICAgICAgICAgIHU4YXJyW25dID0gYnN0ci5jaGFyQ29kZUF0KG4pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFt1OGFycl0sIHsgdHlwZTogbWltZSB9KVxuICAgICAgfVxuICAgICAgY29uc3QgYmxvYiA9IGNvbnZlcnRCYXNlNjRVcmxUb0Jsb2IocmVhZGVyLnJlc3VsdClcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyBzZXRUaW1lb3V0IOaooeaLn29zc+W8guatpeS4iuS8oOWbvueJh1xuICAgICAgICAvLyDlvZNvc3PlvILmraXkuIrkvKDojrflj5blm77niYflnLDlnYDlkI7vvIzmiafooYxjYWxiYWNr5Zue6LCD77yI5Y+C5pWw5Li6aW1hZ2VVcmzlrZfnrKbkuLLvvInvvIzljbPlj6/lsIblm77niYflnLDlnYDlhpnlhaVtYXJrZG93blxuICAgICAgICBjYWxsYmFjaygnaHR0cHM6Ly9hdmF0YXJzMC5naXRodWJ1c2VyY29udGVudC5jb20vdS8yMTI2MzgwNT9zPTQwJnY9NCcpXG4gICAgICB9LCAxMDAwKVxuICAgIH1cbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKVxuICB9XG5cbiAgaGFuZGxlR2V0TWRWYWx1ZSgpIHtcbiAgICBpZiAodGhpcy5tZEVkaXRvcikge1xuICAgICAgYWxlcnQodGhpcy5tZEVkaXRvci5nZXRNZFZhbHVlKCkpXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlR2V0SHRtbFZhbHVlKCkge1xuICAgIGlmICh0aGlzLm1kRWRpdG9yKSB7XG4gICAgICBhbGVydCh0aGlzLm1kRWRpdG9yLmdldEh0bWxWYWx1ZSgpKVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZW1vLXdyYXBcIj5cbiAgICAgICAgPGgzPnJlYWN0LW1hcmtkb3duLWVkaXRvci1saXRlIGRlbW88L2gzPlxuICAgICAgICA8bmF2IGNsYXNzTmFtZT1cIm5hdlwiPlxuICAgICAgICAgIDxidXR0b24gb25DbGljaz17dGhpcy5oYW5kbGVHZXRNZFZhbHVlfSA+Z2V0TWRWYWx1ZTwvYnV0dG9uPlxuICAgICAgICAgIDxidXR0b24gb25DbGljaz17dGhpcy5oYW5kbGVHZXRIdG1sVmFsdWV9ID5nZXRIdG1sVmFsdWU8L2J1dHRvbj5cbiAgICAgICAgPC9uYXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZWRpdG9yLXdyYXBcIiBzdHlsZT17eyBtYXJnaW5Ub3A6ICczMHB4JyB9fT5cbiAgICAgICAgICA8TWRFZGl0b3JcbiAgICAgICAgICAgIHJlZj17bm9kZSA9PiB0aGlzLm1kRWRpdG9yID0gbm9kZX1cbiAgICAgICAgICAgIHZhbHVlPXttb2NrX2NvbnRlbnR9XG4gICAgICAgICAgICBzdHlsZT17eyBoZWlnaHQ6ICc1MDBweCcsIHdpZHRoOiAnMTAwJScgfX1cbiAgICAgICAgICAgIHJlbmRlckhUTUw9eyh0ZXh0KSA9PiB0aGlzLm1kaXQucmVuZGVyKHRleHQpfVxuICAgICAgICAgICAgY29uZmlnPXt7XG4gICAgICAgICAgICAgIHZpZXc6IHtcbiAgICAgICAgICAgICAgICBtZW51OiB0cnVlLFxuICAgICAgICAgICAgICAgIG1kOiB0cnVlLFxuICAgICAgICAgICAgICAgIGh0bWw6IHRydWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdGFibGU6IHtcbiAgICAgICAgICAgICAgICBtYXhSb3c6IDUsXG4gICAgICAgICAgICAgICAgbWF4Q29sOiA2XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGltYWdlVXJsOiAnaHR0cHM6Ly9vY3RvZGV4LmdpdGh1Yi5jb20vaW1hZ2VzL21pbmlvbi5wbmcnLFxuICAgICAgICAgICAgfX1cbiAgICAgICAgICAgIG9uQ2hhbmdlPXt0aGlzLmhhbmRsZUVkaXRvckNoYW5nZX1cbiAgICAgICAgICAgIG9uSW1hZ2VVcGxvYWQ9e3RoaXMuaGFuZGxlSW1hZ2VVcGxvYWR9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIHsvKiA8ZGl2IHN0eWxlPXt7bWFyZ2luVG9wOiAnMzBweCd9fT5cbiAgICAgICAgICA8TWRFZGl0b3JcbiAgICAgICAgICAgIHZhbHVlPXttb2NrX2NvbnRlbnRfMX1cbiAgICAgICAgICAgIHN0eWxlPXt7aGVpZ2h0OiAnMjAwcHgnLCB3aWR0aDogJzEwMCUnfX1cbiAgICAgICAgICAgIGNvbmZpZz17e1xuICAgICAgICAgICAgICB2aWV3OiB7XG4gICAgICAgICAgICAgICAgbWVudTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBodG1sOiB0cnVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGltYWdlVXJsOiAnaHR0cHM6Ly9vY3RvZGV4LmdpdGh1Yi5jb20vaW1hZ2VzL21pbmlvbi5wbmcnXG4gICAgICAgICAgICB9fVxuICAgICAgICAgICAgb25DaGFuZ2U9e3RoaXMuaGFuZGxlRWRpdG9yQ2hhbmdlfSBcbiAgICAgICAgICAvPiAgXG4gICAgICAgIDwvZGl2PiAgKi99XG5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuXG5SZWFjdERPTS5yZW5kZXIoXG4gIDxEZW1vIC8+LFxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpXG4pIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LTEhLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5sZXNzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIuZGVtby13cmFwIHtcXG4gIHBhZGRpbmc6IDIwcHg7XFxufVxcbi5kZW1vLXdyYXAgLm5hdiB7XFxuICBtYXJnaW46IDEwcHggMCAgMTBweCAwO1xcbn1cXG4uZGVtby13cmFwIC5uYXYgYnV0dG9uIHtcXG4gIG1hcmdpbi1yaWdodDogMTBweDtcXG59XFxuLmRlbW8td3JhcCAuZWRpdG9yLXdyYXAge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDUwMHB4O1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKShmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5kcm9wLXdyYXAge1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICBsZWZ0OiAwO1xcbiAgdG9wOiAyOHB4O1xcbiAgei1pbmRleDogMjtcXG4gIG1pbi13aWR0aDogMjBweDtcXG4gIHBhZGRpbmc6IDEwcHggMDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZmY7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZjFmMWYxO1xcbiAgYm9yZGVyLXJpZ2h0LWNvbG9yOiAjZGRkO1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogI2RkZDtcXG59XFxuLmRyb3Atd3JhcC5oaWRkZW4ge1xcbiAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKShmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5oZWFkZXItbGlzdCAubGlzdC1pdGVtIHtcXG4gIHdpZHRoOiAxMDBweDtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIHBhZGRpbmc6IDVweCAwO1xcbn1cXG4uaGVhZGVyLWxpc3QgLmxpc3QtaXRlbTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiAjZjFmMWYxO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKShmYWxzZSk7XG4vLyBJbXBvcnRzXG52YXIgdXJsRXNjYXBlID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS91cmwtZXNjYXBlLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfVVJMX19fMF9fXyA9IHVybEVzY2FwZShyZXF1aXJlKFwiLi9mb250cy9pY29tb29uLndvZmY/Y2J0Nmh2XCIpKTtcblxuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJAZm9udC1mYWNlIHtcXG4gIGZvbnQtZmFtaWx5OiAnaWNvbW9vbic7XFxuICBzcmM6IHVybChcIiArIF9fX0NTU19MT0FERVJfVVJMX19fMF9fXyArIFwiKSBmb3JtYXQoJ3dvZmYnKTtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBmb250LXN0eWxlOiBub3JtYWw7XFxufVxcbltjbGFzc149XFxcImljb24tXFxcIl0sXFxuW2NsYXNzKj1cXFwiIGljb24tXFxcIl0ge1xcbiAgLyogdXNlICFpbXBvcnRhbnQgdG8gcHJldmVudCBpc3N1ZXMgd2l0aCBicm93c2VyIGV4dGVuc2lvbnMgdGhhdCBjaGFuZ2UgZm9udHMgKi9cXG4gIGZvbnQtZmFtaWx5OiAnaWNvbW9vbicgIWltcG9ydGFudDtcXG4gIHNwZWFrOiBub25lO1xcbiAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcXG4gIGZvbnQtdmFyaWFudDogbm9ybWFsO1xcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxuICBsaW5lLWhlaWdodDogMTtcXG4gIC8qIEJldHRlciBGb250IFJlbmRlcmluZyA9PT09PT09PT09PSAqL1xcbiAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxuICAtbW96LW9zeC1mb250LXNtb290aGluZzogZ3JheXNjYWxlO1xcbn1cXG4uaWNvbi1hc3RlcmlzazpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxmMDY5XFxcIjtcXG59XFxuLmljb24tcG93ZXItb2ZmOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYwMTFcXFwiO1xcbn1cXG4uaWNvbi1jb2c6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjAxM1xcXCI7XFxufVxcbi5pY29uLWdlYXI6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjAxM1xcXCI7XFxufVxcbi5pY29uLXJlZnJlc2g6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjAyMVxcXCI7XFxufVxcbi5pY29uLWJvbGQ6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjAzMlxcXCI7XFxufVxcbi5pY29uLWl0YWxpYzpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxmMDMzXFxcIjtcXG59XFxuLmljb24taW1hZ2U6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjAzZVxcXCI7XFxufVxcbi5pY29uLXBob3RvOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYwM2VcXFwiO1xcbn1cXG4uaWNvbi1waWN0dXJlLW86YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjAzZVxcXCI7XFxufVxcbi5pY29uLXBlbmNpbDpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxmMDQwXFxcIjtcXG59XFxuLmljb24tYWRqdXN0OmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYwNDJcXFwiO1xcbn1cXG4uaWNvbi1zaGFyZS1zcXVhcmUtbzpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxmMDQ1XFxcIjtcXG59XFxuLmljb24tY2hldnJvbi1sZWZ0OmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYwNTNcXFwiO1xcbn1cXG4uaWNvbi1jaGV2cm9uLXJpZ2h0OmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYwNTRcXFwiO1xcbn1cXG4uaWNvbi1tYWlsLWZvcndhcmQ6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjA2NFxcXCI7XFxufVxcbi5pY29uLXNoYXJlOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYwNjRcXFwiO1xcbn1cXG4uaWNvbi1leHBhbmQ6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjA2NVxcXCI7XFxufVxcbi5pY29uLWNvbXByZXNzOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYwNjZcXFwiO1xcbn1cXG4uaWNvbi1leWU6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjA2ZVxcXCI7XFxufVxcbi5pY29uLWNoZXZyb24tdXA6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjA3N1xcXCI7XFxufVxcbi5pY29uLWNoZXZyb24tZG93bjpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxmMDc4XFxcIjtcXG59XFxuLmljb24tY2hhaW46YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjBjMVxcXCI7XFxufVxcbi5pY29uLWxpbms6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjBjMVxcXCI7XFxufVxcbi5pY29uLWN1dDpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxmMGM0XFxcIjtcXG59XFxuLmljb24tc2Npc3NvcnM6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjBjNFxcXCI7XFxufVxcbi5pY29uLWNvcHk6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjBjNVxcXCI7XFxufVxcbi5pY29uLWZpbGVzLW86YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjBjNVxcXCI7XFxufVxcbi5pY29uLWxpc3QtdWw6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjBjYVxcXCI7XFxufVxcbi5pY29uLWxpc3Qtb2w6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjBjYlxcXCI7XFxufVxcbi5pY29uLXN0cmlrZXRocm91Z2g6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjBjY1xcXCI7XFxufVxcbi5pY29uLXVuZGVybGluZTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxmMGNkXFxcIjtcXG59XFxuLmljb24tdGFibGU6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjBjZVxcXCI7XFxufVxcbi5pY29uLWNvbHVtbnM6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjBkYlxcXCI7XFxufVxcbi5pY29uLWV4Y2hhbmdlOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYwZWNcXFwiO1xcbn1cXG4uaWNvbi1kZXNrdG9wOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYxMDhcXFwiO1xcbn1cXG4uaWNvbi1xdW90ZS1sZWZ0OmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYxMGRcXFwiO1xcbn1cXG4uaWNvbi1zcGlubmVyOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYxMTBcXFwiO1xcbn1cXG4uaWNvbi1tYWlsLXJlcGx5OmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYxMTJcXFwiO1xcbn1cXG4uaWNvbi1yZXBseTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxmMTEyXFxcIjtcXG59XFxuLmljb24tdGVybWluYWw6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjEyMFxcXCI7XFxufVxcbi5pY29uLXN1cGVyc2NyaXB0OmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGYxMmJcXFwiO1xcbn1cXG4uaWNvbi1zdWJzY3JpcHQ6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjEyY1xcXCI7XFxufVxcbi5pY29uLWVyYXNlcjpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxmMTJkXFxcIjtcXG59XFxuLmljb24tZmlsZS1jb2RlLW86YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjFjOVxcXCI7XFxufVxcbi5pY29uLWhlYWRlcjpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxmMWRjXFxcIjtcXG59XFxuLmljb24tdHJhc2g6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFxcZjFmOFxcXCI7XFxufVxcbi5pY29uLXdpbmRvdy1taW5pbWl6ZTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxmMmQxXFxcIjtcXG59XFxuLmljb24tZW5sYXJnZTpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxlOTg5XFxcIjtcXG59XFxuLmljb24tc2hyaW5rOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGU5OGFcXFwiO1xcbn1cXG4uaWNvbi1lbWJlZDpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXFxlYTdmXFxcIjtcXG59XFxuLmljb24tZW1iZWQyOmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwiXFxcXGVhODBcXFwiO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKShmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlwiLCBcIlwiXSk7XG5cbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCIpKGZhbHNlKTtcbi8vIE1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLnRhYmxlLWxpc3Qud3JhcCB7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBtYXJnaW46IDAgMTBweDtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG59XFxuLnRhYmxlLWxpc3Qud3JhcCAubGlzdC1pdGVtIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICB3aWR0aDogMjBweDtcXG4gIGhlaWdodDogMjBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlMGUwZTA7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxufVxcbi50YWJsZS1saXN0LndyYXAgLmxpc3QtaXRlbS5hY3RpdmUge1xcbiAgYmFja2dyb3VuZDogI2I0YjRiNDtcXG59XFxuXCIsIFwiXCJdKTtcblxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIikoZmFsc2UpO1xuLy8gTW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIudG9vbC1iYXIge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgei1pbmRleDogMTtcXG4gIHJpZ2h0OiAzMHB4O1xcbiAgdG9wOiAxMHB4O1xcbn1cXG4udG9vbC1iYXIgLmJ1dHRvbiB7XFxuICBtaW4td2lkdGg6IDI0cHg7XFxuICBoZWlnaHQ6IDI4cHg7XFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGxpbmUtaGVpZ2h0OiAyOHB4O1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgY29sb3I6ICM5OTk7XFxufVxcbi50b29sLWJhciAuYnV0dG9uOmhvdmVyIHtcXG4gIGNvbG9yOiAjMzMzO1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiKShmYWxzZSk7XG4vLyBNb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi5yYy1tZC1lZGl0b3Ige1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgbWluLWhlaWdodDogMDtcXG4gIHBhZGRpbmctYm90dG9tOiAxcHg7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIC13ZWJraXQtYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gICAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcXG4gIC13ZWJraXQtYm94LWRpcmVjdGlvbjogbm9ybWFsO1xcbiAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG4ucmMtbWQtZWRpdG9yLmZ1bGwge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCUgIWltcG9ydGFudDtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGxlZnQ6IDBweDtcXG4gIHRvcDogMHB4O1xcbiAgei1pbmRleDogMTAwMDtcXG59XFxuLnJjLW1kLWVkaXRvciAuY3RybC13cmFwIHtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogMDtcXG4gIHJpZ2h0OiAwO1xcbn1cXG4ucmMtbWQtZWRpdG9yIC5jdHJsLXdyYXAgYnV0dG9uIHtcXG4gIGxpbmUtaGVpZ2h0OiAyNHB4O1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNkOWQ5ZDk7XFxufVxcbi5yYy1tZC1lZGl0b3IgLmN0cmwtd3JhcCBidXR0b24uY2hlY2tlZCB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjMTg5MEZGO1xcbiAgY29sb3I6ICMxODkwRkY7XFxufVxcbi5yYy1tZC1lZGl0b3IgLmVkaXRvci1jb250YWluZXIge1xcbiAgLXdlYmtpdC1ib3gtZmxleDogMTtcXG4gIC13ZWJraXQtZmxleDogMTtcXG4gICAgICAtbXMtZmxleDogMTtcXG4gICAgICAgICAgZmxleDogMTtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBtaW4taGVpZ2h0OiAwO1xcbn1cXG4ucmMtbWQtZWRpdG9yIC5lZGl0b3ItY29udGFpbmVyIC5zZWMtbWQge1xcbiAgLXdlYmtpdC1ib3gtZmxleDogMTtcXG4gIC13ZWJraXQtZmxleDogMTtcXG4gICAgICAtbXMtZmxleDogMTtcXG4gICAgICAgICAgZmxleDogMTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIG1pbi1oZWlnaHQ6IDA7XFxuICBtaW4td2lkdGg6IDA7XFxufVxcbi5yYy1tZC1lZGl0b3IgLmVkaXRvci1jb250YWluZXIgLnNlYy1tZCAuaW5wdXQge1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBwYWRkaW5nOiAyMHB4IDE1cHggMTVweCAxNXB4O1xcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xcbiAgYm9yZGVyOiBub25lO1xcbiAgcmVzaXplOiBub25lO1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIG1pbi1oZWlnaHQ6IDA7XFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xcbiAgY29sb3I6ICMzMzM7XFxuICBmb250LXNpemU6IDE0cHg7XFxuICBsaW5lLWhlaWdodDogMjBweDtcXG59XFxuLnJjLW1kLWVkaXRvciAuZWRpdG9yLWNvbnRhaW5lciAuc2VjLWh0bWwge1xcbiAgLXdlYmtpdC1ib3gtZmxleDogMTtcXG4gIC13ZWJraXQtZmxleDogMTtcXG4gICAgICAtbXMtZmxleDogMTtcXG4gICAgICAgICAgZmxleDogMTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIG1pbi1oZWlnaHQ6IDA7XFxuICBtaW4td2lkdGg6IDA7XFxuICBtYXJnaW4tbGVmdDogMjBweDtcXG59XFxuLnJjLW1kLWVkaXRvciAuZWRpdG9yLWNvbnRhaW5lciAuc2VjLWh0bWwgLmh0bWwtd3JhcCB7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICAtd2Via2l0LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBwYWRkaW5nLXRvcDogMjBweDtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbn1cXG4ucmMtbWQtZWRpdG9yIC5lZGl0b3ItY29udGFpbmVyIC5zZWMtaHRtbCAuaHRtbC1jb2RlLXdyYXAge1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgcGFkZGluZy10b3A6IDIwcHg7XFxufVxcbi5yYy1tZC1lZGl0b3IgLmVkaXRvci1jb250YWluZXIgLnNlYy1odG1sIC5odG1sLWNvZGUge1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBwYWRkaW5nOiAyMHB4IDE1cHggMTVweCAxNXB4O1xcbiAgYm9yZGVyOiBub25lO1xcbiAgcmVzaXplOiBub25lO1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIG1pbi1oZWlnaHQ6IDIwMHB4O1xcbiAgYmFja2dyb3VuZDogI2ZmZjtcXG4gIGNvbG9yOiAjMzMzO1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgbGluZS1oZWlnaHQ6IDIwcHg7XFxufVxcbi5yYy1tZC1uYXZpZ2F0aW9uIHtcXG4gIG1pbi1oZWlnaHQ6IDM4cHg7XFxuICBwYWRkaW5nOiAwcHggOHB4O1xcbiAgLXdlYmtpdC1ib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcbiAgYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICNkZGQ7XFxuICBmb250LXNpemU6IDE2cHg7XFxuICBiYWNrZ3JvdW5kOiAjZjFmMWYxO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIGRpc3BsYXk6IC13ZWJraXQtYm94O1xcbiAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xcbiAgZGlzcGxheTogLW1zLWZsZXhib3g7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgLXdlYmtpdC1ib3gtb3JpZW50OiBob3Jpem9udGFsO1xcbiAgLXdlYmtpdC1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XFxuICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAtd2Via2l0LWJveC1wYWNrOiBqdXN0aWZ5O1xcbiAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxuICAgICAgLW1zLWZsZXgtcGFjazoganVzdGlmeTtcXG4gICAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcbn1cXG4ucmMtbWQtbmF2aWdhdGlvbiAubmF2aWdhdGlvbi1uYXYge1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IGhvcml6b250YWw7XFxuICAtd2Via2l0LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcXG4gIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgICAtbXMtZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIC13ZWJraXQtYm94LWFsaWduOiBjZW50ZXI7XFxuICAtd2Via2l0LWFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcXG4gICAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIC13ZWJraXQtYm94LXBhY2s6IGNlbnRlcjtcXG4gIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xcbiAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGNvbG9yOiAjNjY2O1xcbn1cXG4ucmMtbWQtbmF2aWdhdGlvbiAuYnV0dG9uLXdyYXAge1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XFxuICBkaXNwbGF5OiAtbXMtZmxleGJveDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICAtd2Via2l0LWJveC1vcmllbnQ6IGhvcml6b250YWw7XFxuICAtd2Via2l0LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcXG4gIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgICAtbXMtZmxleC1kaXJlY3Rpb246IHJvdztcXG4gICAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG4gIC13ZWJraXQtZmxleC13cmFwOiB3cmFwO1xcbiAgICAgIC1tcy1mbGV4LXdyYXA6IHdyYXA7XFxuICAgICAgICAgIGZsZXgtd3JhcDogd3JhcDtcXG59XFxuLnJjLW1kLW5hdmlnYXRpb24gLmJ1dHRvbi13cmFwIC5idXR0b24ge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgbWluLXdpZHRoOiAyNHB4O1xcbiAgaGVpZ2h0OiAyOHB4O1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBsaW5lLWhlaWdodDogMjhweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGNvbG9yOiAjOTk5O1xcbn1cXG4ucmMtbWQtbmF2aWdhdGlvbiAuYnV0dG9uLXdyYXAgLmJ1dHRvbjpob3ZlciB7XFxuICBjb2xvcjogIzMzMztcXG59XFxuLnJjLW1kLW5hdmlnYXRpb24gdWwsXFxuLnJjLW1kLW5hdmlnYXRpb24gbGkge1xcbiAgbGlzdC1zdHlsZTogbm9uZTtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcbi5yYy1tZC1uYXZpZ2F0aW9uIGgxLFxcbi5yYy1tZC1uYXZpZ2F0aW9uIGgyLFxcbi5yYy1tZC1uYXZpZ2F0aW9uIGgzLFxcbi5yYy1tZC1uYXZpZ2F0aW9uIGg0LFxcbi5yYy1tZC1uYXZpZ2F0aW9uIGg1LFxcbi5yYy1tZC1uYXZpZ2F0aW9uIGg2LFxcbi5yYy1tZC1uYXZpZ2F0aW9uIC5oMSxcXG4ucmMtbWQtbmF2aWdhdGlvbiAuaDIsXFxuLnJjLW1kLW5hdmlnYXRpb24gLmgzLFxcbi5yYy1tZC1uYXZpZ2F0aW9uIC5oNCxcXG4ucmMtbWQtbmF2aWdhdGlvbiAuaDUsXFxuLnJjLW1kLW5hdmlnYXRpb24gLmg2IHtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgZm9udC13ZWlnaHQ6IDUwMDtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG4gIGxpbmUtaGVpZ2h0OiAxLjE7XFxufVxcbi5yYy1tZC1uYXZpZ2F0aW9uIGgxIHtcXG4gIGZvbnQtc2l6ZTogMzRweDtcXG59XFxuLnJjLW1kLW5hdmlnYXRpb24gaDIge1xcbiAgZm9udC1zaXplOiAzMHB4O1xcbn1cXG4ucmMtbWQtbmF2aWdhdGlvbiBoMyB7XFxuICBmb250LXNpemU6IDI0cHg7XFxufVxcbi5yYy1tZC1uYXZpZ2F0aW9uIGg0IHtcXG4gIGZvbnQtc2l6ZTogMThweDtcXG59XFxuLnJjLW1kLW5hdmlnYXRpb24gaDUge1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbn1cXG4ucmMtbWQtbmF2aWdhdGlvbiBoNiB7XFxuICBmb250LXNpemU6IDEycHg7XFxufVxcbi5jdXN0b20taHRtbC1zdHlsZSB7XFxuICBjb2xvcjogIzMzMztcXG59XFxuLmN1c3RvbS1odG1sLXN0eWxlIGgxIHtcXG4gIGZvbnQtc2l6ZTogMzJweDtcXG4gIHBhZGRpbmc6IDE2cHggMDtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICBtYXJnaW46IDA7XFxufVxcbi5jdXN0b20taHRtbC1zdHlsZSBoMiB7XFxuICBmb250LXNpemU6IDI2cHg7XFxuICBwYWRkaW5nOiAxMnB4IDA7XFxuICBib3JkZXI6IG5vbmU7XFxuICBmb250LXdlaWdodDogNzAwO1xcbiAgbWFyZ2luOiAwO1xcbn1cXG4uY3VzdG9tLWh0bWwtc3R5bGUgaDMge1xcbiAgZm9udC1zaXplOiAyMHB4O1xcbiAgbGluZS1oZWlnaHQ6IDQwcHg7XFxuICBtYXJnaW46IDA7XFxufVxcbi5jdXN0b20taHRtbC1zdHlsZSBwIHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGxpbmUtaGVpZ2h0OiAyOHB4O1xcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG59XFxuLmN1c3RvbS1odG1sLXN0eWxlIGEge1xcbiAgY29sb3I6ICMwMDUyZDk7XFxufVxcbi5jdXN0b20taHRtbC1zdHlsZSBhOmhvdmVyIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuLmN1c3RvbS1odG1sLXN0eWxlIHN0cm9uZyB7XFxuICBmb250LXdlaWdodDogNzAwO1xcbn1cXG4uY3VzdG9tLWh0bWwtc3R5bGUgb2wsXFxuLmN1c3RvbS1odG1sLXN0eWxlIHVsIHtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGxpbmUtaGVpZ2h0OiAyOHB4O1xcbiAgcGFkZGluZy1sZWZ0OiAzNnB4O1xcbn1cXG4uY3VzdG9tLWh0bWwtc3R5bGUgaHIge1xcbiAgbWFyZ2luLXRvcDogMjBweDtcXG4gIG1hcmdpbi1ib3R0b206IDIwcHg7XFxuICBib3JkZXI6IDA7XFxuICBib3JkZXItdG9wOiAxcHggc29saWQgI2VlZTtcXG59XFxuLmN1c3RvbS1odG1sLXN0eWxlIHByZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjVmNWY1O1xcbiAgcGFkZGluZzogMjBweDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGxpbmUtaGVpZ2h0OiAyOHB4O1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG59XFxuLmN1c3RvbS1odG1sLXN0eWxlIGNvZGUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcbi5jdXN0b20taHRtbC1zdHlsZSBjb2RlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmNWY1ZjU7XFxuICBib3JkZXItcmFkaXVzOiAwO1xcbiAgcGFkZGluZzogM3B4IDA7XFxuICBtYXJnaW46IDA7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcbi5jdXN0b20taHRtbC1zdHlsZSBjb2RlOmFmdGVyLFxcbi5jdXN0b20taHRtbC1zdHlsZSBjb2RlOmJlZm9yZSB7XFxuICBsZXR0ZXItc3BhY2luZzogMDtcXG59XFxuLmN1c3RvbS1odG1sLXN0eWxlIGJsb2NrcXVvdGUge1xcbiAgbWFyZ2luOiAwO1xcbiAgYmFja2dyb3VuZDogbm9uZSByZXBlYXQgc2Nyb2xsIDAgMCByZ2JhKDEwMiwgMTI4LCAxNTMsIDAuMDUpO1xcbiAgcGFkZGluZy1sZWZ0OiAzMHB4O1xcbiAgYm9yZGVyOiBub25lO1xcbiAgcGFkZGluZzogNXB4IDhweCA1cHggMzBweDtcXG4gIGNvbG9yOiAjMzMzO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYm9yZGVyLWxlZnQ6IDEwcHggc29saWQgI0Q2REJERjtcXG59XFxuLmN1c3RvbS1odG1sLXN0eWxlIGltZyB7XFxuICBtYXgtd2lkdGg6IDM1JTtcXG59XFxuLmN1c3RvbS1odG1sLXN0eWxlIHRhYmxlIHtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG4gIGxpbmUtaGVpZ2h0OiAyNHB4O1xcbiAgYm9yZGVyLXNwYWNpbmc6IDA7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG4uY3VzdG9tLWh0bWwtc3R5bGUgdGFibGUgdGQsXFxuLmN1c3RvbS1odG1sLXN0eWxlIHRhYmxlIHRoIHtcXG4gIHdvcmQtYnJlYWs6IGJyZWFrLWFsbDtcXG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcXG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxufVxcbi5jdXN0b20taHRtbC1zdHlsZSB0YWJsZSB0aCB7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBmb250LXdlaWdodDogNzAwO1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2VmZWZlZjtcXG4gIHBhZGRpbmc6IDE0cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjVmN2ZhO1xcbn1cXG4uY3VzdG9tLWh0bWwtc3R5bGUgdGFibGUgdHIge1xcbiAgYm9yZGVyOiAxcHggc29saWQgI2VmZWZlZjtcXG59XFxuLmN1c3RvbS1odG1sLXN0eWxlIHRhYmxlIHRyOm50aC1jaGlsZCgybikge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcbi5jdXN0b20taHRtbC1zdHlsZSB0YWJsZSB0ZCB7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWZlZmVmO1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIHBhZGRpbmc6IDlweCAxNXB4O1xcbn1cXG4uY3VzdG9tLWh0bWwtc3R5bGUgdGFibGUgdGQsXFxuLmN1c3RvbS1odG1sLXN0eWxlIHRhYmxlIHRoIHtcXG4gIG1pbi13aWR0aDogODBweDtcXG4gIG1heC13aWR0aDogNDMwcHg7XFxufVxcblwiLCBcIlwiXSk7XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHVzZVNvdXJjZU1hcCkge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIHJldHVybiAnQG1lZGlhICcgKyBpdGVtWzJdICsgJ3snICsgY29udGVudCArICd9JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgfVxuICAgIH0pLmpvaW4oJycpO1xuICB9OyAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXG5cbiAgbGlzdC5pID0gZnVuY3Rpb24gKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCAnJ11dO1xuICAgIH1cblxuICAgIHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpZCA9IHRoaXNbaV1bMF07XG5cbiAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBtb2R1bGVzW2ldOyAvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG4gICAgICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuICAgICAgLy8gd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuICAgICAgLy8gSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXG4gICAgICBpZiAoaXRlbVswXSA9PSBudWxsIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGlmIChtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVkaWFRdWVyeSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSAnKCcgKyBpdGVtWzJdICsgJykgYW5kICgnICsgbWVkaWFRdWVyeSArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG4gIHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblxuICBpZiAoIWNzc01hcHBpbmcpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcbiAgICB2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgcmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJztcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcblxuXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgdmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcbiAgcmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlc2NhcGUodXJsLCBuZWVkUXVvdGVzKSB7XG4gIGlmICh0eXBlb2YgdXJsICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB1cmw7XG4gIH0gLy8gSWYgdXJsIGlzIGFscmVhZHkgd3JhcHBlZCBpbiBxdW90ZXMsIHJlbW92ZSB0aGVtXG5cblxuICBpZiAoL15bJ1wiXS4qWydcIl0kLy50ZXN0KHVybCkpIHtcbiAgICB1cmwgPSB1cmwuc2xpY2UoMSwgLTEpO1xuICB9IC8vIFNob3VsZCB1cmwgYmUgd3JhcHBlZD9cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtdmFsdWVzLTMvI3VybHNcblxuXG4gIGlmICgvW1wiJygpIFxcdFxcbl0vLnRlc3QodXJsKSB8fCBuZWVkUXVvdGVzKSB7XG4gICAgcmV0dXJuICdcIicgKyB1cmwucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSArICdcIic7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTsiLCIndXNlIHN0cmljdCc7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhlbHBlcnNcblxuLy8gTWVyZ2Ugb2JqZWN0c1xuLy9cbmZ1bmN0aW9uIGFzc2lnbihvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkgeyByZXR1cm47IH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfY2xhc3Mob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKTsgfVxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikgeyByZXR1cm4gX2NsYXNzKG9iaikgPT09ICdbb2JqZWN0IE9iamVjdF0nOyB9XG5mdW5jdGlvbiBpc1JlZ0V4cChvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBSZWdFeHBdJzsgfVxuZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHsgcmV0dXJuIF9jbGFzcyhvYmopID09PSAnW29iamVjdCBGdW5jdGlvbl0nOyB9XG5cblxuZnVuY3Rpb24gZXNjYXBlUkUoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvWy4/KiteJFtcXF1cXFxcKCl7fXwtXS9nLCAnXFxcXCQmJyk7IH1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGZ1enp5TGluazogdHJ1ZSxcbiAgZnV6enlFbWFpbDogdHJ1ZSxcbiAgZnV6enlJUDogZmFsc2Vcbn07XG5cblxuZnVuY3Rpb24gaXNPcHRpb25zT2JqKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqIHx8IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgaykge1xuICAgIHJldHVybiBhY2MgfHwgZGVmYXVsdE9wdGlvbnMuaGFzT3duUHJvcGVydHkoayk7XG4gIH0sIGZhbHNlKTtcbn1cblxuXG52YXIgZGVmYXVsdFNjaGVtYXMgPSB7XG4gICdodHRwOic6IHtcbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHRleHQsIHBvcywgc2VsZikge1xuICAgICAgdmFyIHRhaWwgPSB0ZXh0LnNsaWNlKHBvcyk7XG5cbiAgICAgIGlmICghc2VsZi5yZS5odHRwKSB7XG4gICAgICAgIC8vIGNvbXBpbGUgbGF6aWx5LCBiZWNhdXNlIFwiaG9zdFwiLWNvbnRhaW5pbmcgdmFyaWFibGVzIGNhbiBjaGFuZ2Ugb24gdGxkcyB1cGRhdGUuXG4gICAgICAgIHNlbGYucmUuaHR0cCA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeXFxcXC9cXFxcLycgKyBzZWxmLnJlLnNyY19hdXRoICsgc2VsZi5yZS5zcmNfaG9zdF9wb3J0X3N0cmljdCArIHNlbGYucmUuc3JjX3BhdGgsICdpJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGYucmUuaHR0cC50ZXN0KHRhaWwpKSB7XG4gICAgICAgIHJldHVybiB0YWlsLm1hdGNoKHNlbGYucmUuaHR0cClbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LFxuICAnaHR0cHM6JzogICdodHRwOicsXG4gICdmdHA6JzogICAgJ2h0dHA6JyxcbiAgJy8vJzogICAgICB7XG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uICh0ZXh0LCBwb3MsIHNlbGYpIHtcbiAgICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgICBpZiAoIXNlbGYucmUubm9faHR0cCkge1xuICAgICAgLy8gY29tcGlsZSBsYXppbHksIGJlY2F1c2UgXCJob3N0XCItY29udGFpbmluZyB2YXJpYWJsZXMgY2FuIGNoYW5nZSBvbiB0bGRzIHVwZGF0ZS5cbiAgICAgICAgc2VsZi5yZS5ub19odHRwID0gIG5ldyBSZWdFeHAoXG4gICAgICAgICAgJ14nICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19hdXRoICtcbiAgICAgICAgICAvLyBEb24ndCBhbGxvdyBzaW5nbGUtbGV2ZWwgZG9tYWlucywgYmVjYXVzZSBvZiBmYWxzZSBwb3NpdGl2ZXMgbGlrZSAnLy90ZXN0J1xuICAgICAgICAgIC8vIHdpdGggY29kZSBjb21tZW50c1xuICAgICAgICAgICcoPzpsb2NhbGhvc3R8KD86KD86JyArIHNlbGYucmUuc3JjX2RvbWFpbiArICcpXFxcXC4pKycgKyBzZWxmLnJlLnNyY19kb21haW5fcm9vdCArICcpJyArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfcG9ydCArXG4gICAgICAgICAgc2VsZi5yZS5zcmNfaG9zdF90ZXJtaW5hdG9yICtcbiAgICAgICAgICBzZWxmLnJlLnNyY19wYXRoLFxuXG4gICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLnJlLm5vX2h0dHAudGVzdCh0YWlsKSkge1xuICAgICAgICAvLyBzaG91bGQgbm90IGJlIGA6Ly9gICYgYC8vL2AsIHRoYXQgcHJvdGVjdHMgZnJvbSBlcnJvcnMgaW4gcHJvdG9jb2wgbmFtZVxuICAgICAgICBpZiAocG9zID49IDMgJiYgdGV4dFtwb3MgLSAzXSA9PT0gJzonKSB7IHJldHVybiAwOyB9XG4gICAgICAgIGlmIChwb3MgPj0gMyAmJiB0ZXh0W3BvcyAtIDNdID09PSAnLycpIHsgcmV0dXJuIDA7IH1cbiAgICAgICAgcmV0dXJuIHRhaWwubWF0Y2goc2VsZi5yZS5ub19odHRwKVswXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG4gICdtYWlsdG86Jzoge1xuICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAodGV4dCwgcG9zLCBzZWxmKSB7XG4gICAgICB2YXIgdGFpbCA9IHRleHQuc2xpY2UocG9zKTtcblxuICAgICAgaWYgKCFzZWxmLnJlLm1haWx0bykge1xuICAgICAgICBzZWxmLnJlLm1haWx0byA9ICBuZXcgUmVnRXhwKFxuICAgICAgICAgICdeJyArIHNlbGYucmUuc3JjX2VtYWlsX25hbWUgKyAnQCcgKyBzZWxmLnJlLnNyY19ob3N0X3N0cmljdCwgJ2knXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi5yZS5tYWlsdG8udGVzdCh0YWlsKSkge1xuICAgICAgICByZXR1cm4gdGFpbC5tYXRjaChzZWxmLnJlLm1haWx0bylbMF0ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG59O1xuXG4vKmVzbGludC1kaXNhYmxlIG1heC1sZW4qL1xuXG4vLyBSRSBwYXR0ZXJuIGZvciAyLWNoYXJhY3RlciB0bGRzIChhdXRvZ2VuZXJhdGVkIGJ5IC4vc3VwcG9ydC90bGRzXzJjaGFyX2dlbi5qcylcbnZhciB0bGRzXzJjaF9zcmNfcmUgPSAnYVtjZGVmZ2lsbW5vcXJzdHV3eHpdfGJbYWJkZWZnaGlqbW5vcnN0dnd5el18Y1thY2RmZ2hpa2xtbm9ydXZ3eHl6XXxkW2Vqa21vel18ZVtjZWdyc3R1XXxmW2lqa21vcl18Z1thYmRlZmdoaWxtbnBxcnN0dXd5XXxoW2ttbnJ0dV18aVtkZWxtbm9xcnN0XXxqW2Vtb3BdfGtbZWdoaW1ucHJ3eXpdfGxbYWJjaWtyc3R1dnldfG1bYWNkZWdoa2xtbm9wcXJzdHV2d3h5el18blthY2VmZ2lsb3BydXpdfG9tfHBbYWVmZ2hrbG1ucnN0d3ldfHFhfHJbZW9zdXddfHNbYWJjZGVnaGlqa2xtbm9ydHV2eHl6XXx0W2NkZmdoamtsbW5vcnR2d3pdfHVbYWdrc3l6XXx2W2FjZWdpbnVdfHdbZnNdfHlbZXRdfHpbYW13XSc7XG5cbi8vIERPTidUIHRyeSB0byBtYWtlIFBScyB3aXRoIGNoYW5nZXMuIEV4dGVuZCBUTERzIHdpdGggTGlua2lmeUl0LnRsZHMoKSBpbnN0ZWFkXG52YXIgdGxkc19kZWZhdWx0ID0gJ2Jpenxjb218ZWR1fGdvdnxuZXR8b3JnfHByb3x3ZWJ8eHh4fGFlcm98YXNpYXxjb29wfGluZm98bXVzZXVtfG5hbWV8c2hvcHzRgNGEJy5zcGxpdCgnfCcpO1xuXG4vKmVzbGludC1lbmFibGUgbWF4LWxlbiovXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIHJlc2V0U2NhbkNhY2hlKHNlbGYpIHtcbiAgc2VsZi5fX2luZGV4X18gPSAtMTtcbiAgc2VsZi5fX3RleHRfY2FjaGVfXyAgID0gJyc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRvcihyZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRleHQsIHBvcykge1xuICAgIHZhciB0YWlsID0gdGV4dC5zbGljZShwb3MpO1xuXG4gICAgaWYgKHJlLnRlc3QodGFpbCkpIHtcbiAgICAgIHJldHVybiB0YWlsLm1hdGNoKHJlKVswXS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3JtYWxpemVyKCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG1hdGNoLCBzZWxmKSB7XG4gICAgc2VsZi5ub3JtYWxpemUobWF0Y2gpO1xuICB9O1xufVxuXG4vLyBTY2hlbWFzIGNvbXBpbGVyLiBCdWlsZCByZWdleHBzLlxuLy9cbmZ1bmN0aW9uIGNvbXBpbGUoc2VsZikge1xuXG4gIC8vIExvYWQgJiBjbG9uZSBSRSBwYXR0ZXJucy5cbiAgdmFyIHJlID0gc2VsZi5yZSA9IHJlcXVpcmUoJy4vbGliL3JlJykoc2VsZi5fX29wdHNfXyk7XG5cbiAgLy8gRGVmaW5lIGR5bmFtaWMgcGF0dGVybnNcbiAgdmFyIHRsZHMgPSBzZWxmLl9fdGxkc19fLnNsaWNlKCk7XG5cbiAgc2VsZi5vbkNvbXBpbGUoKTtcblxuICBpZiAoIXNlbGYuX190bGRzX3JlcGxhY2VkX18pIHtcbiAgICB0bGRzLnB1c2godGxkc18yY2hfc3JjX3JlKTtcbiAgfVxuICB0bGRzLnB1c2gocmUuc3JjX3huKTtcblxuICByZS5zcmNfdGxkcyA9IHRsZHMuam9pbignfCcpO1xuXG4gIGZ1bmN0aW9uIHVudHBsKHRwbCkgeyByZXR1cm4gdHBsLnJlcGxhY2UoJyVUTERTJScsIHJlLnNyY190bGRzKTsgfVxuXG4gIHJlLmVtYWlsX2Z1enp5ICAgICAgPSBSZWdFeHAodW50cGwocmUudHBsX2VtYWlsX2Z1enp5KSwgJ2knKTtcbiAgcmUubGlua19mdXp6eSAgICAgICA9IFJlZ0V4cCh1bnRwbChyZS50cGxfbGlua19mdXp6eSksICdpJyk7XG4gIHJlLmxpbmtfbm9faXBfZnV6enkgPSBSZWdFeHAodW50cGwocmUudHBsX2xpbmtfbm9faXBfZnV6enkpLCAnaScpO1xuICByZS5ob3N0X2Z1enp5X3Rlc3QgID0gUmVnRXhwKHVudHBsKHJlLnRwbF9ob3N0X2Z1enp5X3Rlc3QpLCAnaScpO1xuXG4gIC8vXG4gIC8vIENvbXBpbGUgZWFjaCBzY2hlbWFcbiAgLy9cblxuICB2YXIgYWxpYXNlcyA9IFtdO1xuXG4gIHNlbGYuX19jb21waWxlZF9fID0ge307IC8vIFJlc2V0IGNvbXBpbGVkIGRhdGFcblxuICBmdW5jdGlvbiBzY2hlbWFFcnJvcihuYW1lLCB2YWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyhMaW5raWZ5SXQpIEludmFsaWQgc2NoZW1hIFwiJyArIG5hbWUgKyAnXCI6ICcgKyB2YWwpO1xuICB9XG5cbiAgT2JqZWN0LmtleXMoc2VsZi5fX3NjaGVtYXNfXykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciB2YWwgPSBzZWxmLl9fc2NoZW1hc19fW25hbWVdO1xuXG4gICAgLy8gc2tpcCBkaXNhYmxlZCBtZXRob2RzXG4gICAgaWYgKHZhbCA9PT0gbnVsbCkgeyByZXR1cm47IH1cblxuICAgIHZhciBjb21waWxlZCA9IHsgdmFsaWRhdGU6IG51bGwsIGxpbms6IG51bGwgfTtcblxuICAgIHNlbGYuX19jb21waWxlZF9fW25hbWVdID0gY29tcGlsZWQ7XG5cbiAgICBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgaWYgKGlzUmVnRXhwKHZhbC52YWxpZGF0ZSkpIHtcbiAgICAgICAgY29tcGlsZWQudmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0b3IodmFsLnZhbGlkYXRlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbih2YWwudmFsaWRhdGUpKSB7XG4gICAgICAgIGNvbXBpbGVkLnZhbGlkYXRlID0gdmFsLnZhbGlkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsLm5vcm1hbGl6ZSkpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gdmFsLm5vcm1hbGl6ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXZhbC5ub3JtYWxpemUpIHtcbiAgICAgICAgY29tcGlsZWQubm9ybWFsaXplID0gY3JlYXRlTm9ybWFsaXplcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICBhbGlhc2VzLnB1c2gobmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2NoZW1hRXJyb3IobmFtZSwgdmFsKTtcbiAgfSk7XG5cbiAgLy9cbiAgLy8gQ29tcGlsZSBwb3N0cG9uZWQgYWxpYXNlc1xuICAvL1xuXG4gIGFsaWFzZXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXMpIHtcbiAgICBpZiAoIXNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXSkge1xuICAgICAgLy8gU2lsZW50bHkgZmFpbCBvbiBtaXNzZWQgc2NoZW1hcyB0byBhdm9pZCBlcnJvbnMgb24gZGlzYWJsZS5cbiAgICAgIC8vIHNjaGVtYUVycm9yKGFsaWFzLCBzZWxmLl9fc2NoZW1hc19fW2FsaWFzXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5fX2NvbXBpbGVkX19bYWxpYXNdLnZhbGlkYXRlID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS52YWxpZGF0ZTtcbiAgICBzZWxmLl9fY29tcGlsZWRfX1thbGlhc10ubm9ybWFsaXplID1cbiAgICAgIHNlbGYuX19jb21waWxlZF9fW3NlbGYuX19zY2hlbWFzX19bYWxpYXNdXS5ub3JtYWxpemU7XG4gIH0pO1xuXG4gIC8vXG4gIC8vIEZha2UgcmVjb3JkIGZvciBndWVzc2VkIGxpbmtzXG4gIC8vXG4gIHNlbGYuX19jb21waWxlZF9fWycnXSA9IHsgdmFsaWRhdGU6IG51bGwsIG5vcm1hbGl6ZTogY3JlYXRlTm9ybWFsaXplcigpIH07XG5cbiAgLy9cbiAgLy8gQnVpbGQgc2NoZW1hIGNvbmRpdGlvblxuICAvL1xuICB2YXIgc2xpc3QgPSBPYmplY3Qua2V5cyhzZWxmLl9fY29tcGlsZWRfXylcbiAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgZGlzYWJsZWQgJiBmYWtlIHNjaGVtYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lLmxlbmd0aCA+IDAgJiYgc2VsZi5fX2NvbXBpbGVkX19bbmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAubWFwKGVzY2FwZVJFKVxuICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCd8Jyk7XG4gIC8vICg/IV8pIGNhdXNlIDEuNXggc2xvd2Rvd25cbiAgc2VsZi5yZS5zY2hlbWFfdGVzdCAgID0gUmVnRXhwKCcoXnwoPyFfKSg/Ols+PFxcdWZmNWNdfCcgKyByZS5zcmNfWlBDYyArICcpKSgnICsgc2xpc3QgKyAnKScsICdpJyk7XG4gIHNlbGYucmUuc2NoZW1hX3NlYXJjaCA9IFJlZ0V4cCgnKF58KD8hXykoPzpbPjxcXHVmZjVjXXwnICsgcmUuc3JjX1pQQ2MgKyAnKSkoJyArIHNsaXN0ICsgJyknLCAnaWcnKTtcblxuICBzZWxmLnJlLnByZXRlc3QgPSBSZWdFeHAoXG4gICAgJygnICsgc2VsZi5yZS5zY2hlbWFfdGVzdC5zb3VyY2UgKyAnKXwoJyArIHNlbGYucmUuaG9zdF9mdXp6eV90ZXN0LnNvdXJjZSArICcpfEAnLFxuICAgICdpJ1xuICApO1xuXG4gIC8vXG4gIC8vIENsZWFudXBcbiAgLy9cblxuICByZXNldFNjYW5DYWNoZShzZWxmKTtcbn1cblxuLyoqXG4gKiBjbGFzcyBNYXRjaFxuICpcbiAqIE1hdGNoIHJlc3VsdC4gU2luZ2xlIGVsZW1lbnQgb2YgYXJyYXksIHJldHVybmVkIGJ5IFtbTGlua2lmeUl0I21hdGNoXV1cbiAqKi9cbmZ1bmN0aW9uIE1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gIHZhciBzdGFydCA9IHNlbGYuX19pbmRleF9fLFxuICAgICAgZW5kICAgPSBzZWxmLl9fbGFzdF9pbmRleF9fLFxuICAgICAgdGV4dCAgPSBzZWxmLl9fdGV4dF9jYWNoZV9fLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIC8qKlxuICAgKiBNYXRjaCNzY2hlbWEgLT4gU3RyaW5nXG4gICAqXG4gICAqIFByZWZpeCAocHJvdG9jb2wpIGZvciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnNjaGVtYSAgICA9IHNlbGYuX19zY2hlbWFfXy50b0xvd2VyQ2FzZSgpO1xuICAvKipcbiAgICogTWF0Y2gjaW5kZXggLT4gTnVtYmVyXG4gICAqXG4gICAqIEZpcnN0IHBvc2l0aW9uIG9mIG1hdGNoZWQgc3RyaW5nLlxuICAgKiovXG4gIHRoaXMuaW5kZXggICAgID0gc3RhcnQgKyBzaGlmdDtcbiAgLyoqXG4gICAqIE1hdGNoI2xhc3RJbmRleCAtPiBOdW1iZXJcbiAgICpcbiAgICogTmV4dCBwb3NpdGlvbiBhZnRlciBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLmxhc3RJbmRleCA9IGVuZCArIHNoaWZ0O1xuICAvKipcbiAgICogTWF0Y2gjcmF3IC0+IFN0cmluZ1xuICAgKlxuICAgKiBNYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnJhdyAgICAgICA9IHRleHQ7XG4gIC8qKlxuICAgKiBNYXRjaCN0ZXh0IC0+IFN0cmluZ1xuICAgKlxuICAgKiBOb3RtYWxpemVkIHRleHQgb2YgbWF0Y2hlZCBzdHJpbmcuXG4gICAqKi9cbiAgdGhpcy50ZXh0ICAgICAgPSB0ZXh0O1xuICAvKipcbiAgICogTWF0Y2gjdXJsIC0+IFN0cmluZ1xuICAgKlxuICAgKiBOb3JtYWxpemVkIHVybCBvZiBtYXRjaGVkIHN0cmluZy5cbiAgICoqL1xuICB0aGlzLnVybCAgICAgICA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hdGNoKHNlbGYsIHNoaWZ0KSB7XG4gIHZhciBtYXRjaCA9IG5ldyBNYXRjaChzZWxmLCBzaGlmdCk7XG5cbiAgc2VsZi5fX2NvbXBpbGVkX19bbWF0Y2guc2NoZW1hXS5ub3JtYWxpemUobWF0Y2gsIHNlbGYpO1xuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuXG4vKipcbiAqIGNsYXNzIExpbmtpZnlJdFxuICoqL1xuXG4vKipcbiAqIG5ldyBMaW5raWZ5SXQoc2NoZW1hcywgb3B0aW9ucylcbiAqIC0gc2NoZW1hcyAoT2JqZWN0KTogT3B0aW9uYWwuIEFkZGl0aW9uYWwgc2NoZW1hcyB0byB2YWxpZGF0ZSAocHJlZml4L3ZhbGlkYXRvcilcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogeyBmdXp6eUxpbmt8ZnV6enlFbWFpbHxmdXp6eUlQOiB0cnVlfGZhbHNlIH1cbiAqXG4gKiBDcmVhdGVzIG5ldyBsaW5raWZpZXIgaW5zdGFuY2Ugd2l0aCBvcHRpb25hbCBhZGRpdGlvbmFsIHNjaGVtYXMuXG4gKiBDYW4gYmUgY2FsbGVkIHdpdGhvdXQgYG5ld2Aga2V5d29yZCBmb3IgY29udmVuaWVuY2UuXG4gKlxuICogQnkgZGVmYXVsdCB1bmRlcnN0YW5kczpcbiAqXG4gKiAtIGBodHRwKHMpOi8vLi4uYCAsIGBmdHA6Ly8uLi5gLCBgbWFpbHRvOi4uLmAgJiBgLy8uLi5gIGxpbmtzXG4gKiAtIFwiZnV6enlcIiBsaW5rcyBhbmQgZW1haWxzIChleGFtcGxlLmNvbSwgZm9vQGJhci5jb20pLlxuICpcbiAqIGBzY2hlbWFzYCBpcyBhbiBvYmplY3QsIHdoZXJlIGVhY2gga2V5L3ZhbHVlIGRlc2NyaWJlcyBwcm90b2NvbC9ydWxlOlxuICpcbiAqIC0gX19rZXlfXyAtIGxpbmsgcHJlZml4ICh1c3VhbGx5LCBwcm90b2NvbCBuYW1lIHdpdGggYDpgIGF0IHRoZSBlbmQsIGBza3lwZTpgXG4gKiAgIGZvciBleGFtcGxlKS4gYGxpbmtpZnktaXRgIG1ha2VzIHNodXJlIHRoYXQgcHJlZml4IGlzIG5vdCBwcmVjZWVkZWQgd2l0aFxuICogICBhbHBoYW51bWVyaWMgY2hhciBhbmQgc3ltYm9scy4gT25seSB3aGl0ZXNwYWNlcyBhbmQgcHVuY3R1YXRpb24gYWxsb3dlZC5cbiAqIC0gX192YWx1ZV9fIC0gcnVsZSB0byBjaGVjayB0YWlsIGFmdGVyIGxpbmsgcHJlZml4XG4gKiAgIC0gX1N0cmluZ18gLSBqdXN0IGFsaWFzIHRvIGV4aXN0aW5nIHJ1bGVcbiAqICAgLSBfT2JqZWN0X1xuICogICAgIC0gX3ZhbGlkYXRlXyAtIHZhbGlkYXRvciBmdW5jdGlvbiAoc2hvdWxkIHJldHVybiBtYXRjaGVkIGxlbmd0aCBvbiBzdWNjZXNzKSxcbiAqICAgICAgIG9yIGBSZWdFeHBgLlxuICogICAgIC0gX25vcm1hbGl6ZV8gLSBvcHRpb25hbCBmdW5jdGlvbiB0byBub3JtYWxpemUgdGV4dCAmIHVybCBvZiBtYXRjaGVkIHJlc3VsdFxuICogICAgICAgKGZvciBleGFtcGxlLCBmb3IgQHR3aXR0ZXIgbWVudGlvbnMpLlxuICpcbiAqIGBvcHRpb25zYDpcbiAqXG4gKiAtIF9fZnV6enlMaW5rX18gLSByZWNvZ25pZ2UgVVJMLXMgd2l0aG91dCBgaHR0cChzKTpgIHByZWZpeC4gRGVmYXVsdCBgdHJ1ZWAuXG4gKiAtIF9fZnV6enlJUF9fIC0gYWxsb3cgSVBzIGluIGZ1enp5IGxpbmtzIGFib3ZlLiBDYW4gY29uZmxpY3Qgd2l0aCBzb21lIHRleHRzXG4gKiAgIGxpa2UgdmVyc2lvbiBudW1iZXJzLiBEZWZhdWx0IGBmYWxzZWAuXG4gKiAtIF9fZnV6enlFbWFpbF9fIC0gcmVjb2duaXplIGVtYWlscyB3aXRob3V0IGBtYWlsdG86YCBwcmVmaXguXG4gKlxuICoqL1xuZnVuY3Rpb24gTGlua2lmeUl0KHNjaGVtYXMsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpbmtpZnlJdCkpIHtcbiAgICByZXR1cm4gbmV3IExpbmtpZnlJdChzY2hlbWFzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIGlmIChpc09wdGlvbnNPYmooc2NoZW1hcykpIHtcbiAgICAgIG9wdGlvbnMgPSBzY2hlbWFzO1xuICAgICAgc2NoZW1hcyA9IHt9O1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX19vcHRzX18gICAgICAgICAgID0gYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgLy8gQ2FjaGUgbGFzdCB0ZXN0ZWQgcmVzdWx0LiBVc2VkIHRvIHNraXAgcmVwZWF0aW5nIHN0ZXBzIG9uIG5leHQgYG1hdGNoYCBjYWxsLlxuICB0aGlzLl9faW5kZXhfXyAgICAgICAgICA9IC0xO1xuICB0aGlzLl9fbGFzdF9pbmRleF9fICAgICA9IC0xOyAvLyBOZXh0IHNjYW4gcG9zaXRpb25cbiAgdGhpcy5fX3NjaGVtYV9fICAgICAgICAgPSAnJztcbiAgdGhpcy5fX3RleHRfY2FjaGVfXyAgICAgPSAnJztcblxuICB0aGlzLl9fc2NoZW1hc19fICAgICAgICA9IGFzc2lnbih7fSwgZGVmYXVsdFNjaGVtYXMsIHNjaGVtYXMpO1xuICB0aGlzLl9fY29tcGlsZWRfXyAgICAgICA9IHt9O1xuXG4gIHRoaXMuX190bGRzX18gICAgICAgICAgID0gdGxkc19kZWZhdWx0O1xuICB0aGlzLl9fdGxkc19yZXBsYWNlZF9fICA9IGZhbHNlO1xuXG4gIHRoaXMucmUgPSB7fTtcblxuICBjb21waWxlKHRoaXMpO1xufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIExpbmtpZnlJdCNhZGQoc2NoZW1hLCBkZWZpbml0aW9uKVxuICogLSBzY2hlbWEgKFN0cmluZyk6IHJ1bGUgbmFtZSAoZml4ZWQgcGF0dGVybiBwcmVmaXgpXG4gKiAtIGRlZmluaXRpb24gKFN0cmluZ3xSZWdFeHB8T2JqZWN0KTogc2NoZW1hIGRlZmluaXRpb25cbiAqXG4gKiBBZGQgbmV3IHJ1bGUgZGVmaW5pdGlvbi4gU2VlIGNvbnN0cnVjdG9yIGRlc2NyaXB0aW9uIGZvciBkZXRhaWxzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoc2NoZW1hLCBkZWZpbml0aW9uKSB7XG4gIHRoaXMuX19zY2hlbWFzX19bc2NoZW1hXSA9IGRlZmluaXRpb247XG4gIGNvbXBpbGUodGhpcyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlXG4gKiBMaW5raWZ5SXQjc2V0KG9wdGlvbnMpXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHsgZnV6enlMaW5rfGZ1enp5RW1haWx8ZnV6enlJUDogdHJ1ZXxmYWxzZSB9XG4gKlxuICogU2V0IHJlY29nbml0aW9uIG9wdGlvbnMgZm9yIGxpbmtzIHdpdGhvdXQgc2NoZW1hLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICB0aGlzLl9fb3B0c19fID0gYXNzaWduKHRoaXMuX19vcHRzX18sIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjdGVzdCh0ZXh0KSAtPiBCb29sZWFuXG4gKlxuICogU2VhcmNoZXMgbGlua2lmaWFibGUgcGF0dGVybiBhbmQgcmV0dXJucyBgdHJ1ZWAgb24gc3VjY2VzcyBvciBgZmFsc2VgIG9uIGZhaWwuXG4gKiovXG5MaW5raWZ5SXQucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiB0ZXN0KHRleHQpIHtcbiAgLy8gUmVzZXQgc2NhbiBjYWNoZVxuICB0aGlzLl9fdGV4dF9jYWNoZV9fID0gdGV4dDtcbiAgdGhpcy5fX2luZGV4X18gICAgICA9IC0xO1xuXG4gIGlmICghdGV4dC5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdmFyIG0sIG1sLCBtZSwgbGVuLCBzaGlmdCwgbmV4dCwgcmUsIHRsZF9wb3MsIGF0X3BvcztcblxuICAvLyB0cnkgdG8gc2NhbiBmb3IgbGluayB3aXRoIHNjaGVtYSAtIHRoYXQncyB0aGUgbW9zdCBzaW1wbGUgcnVsZVxuICBpZiAodGhpcy5yZS5zY2hlbWFfdGVzdC50ZXN0KHRleHQpKSB7XG4gICAgcmUgPSB0aGlzLnJlLnNjaGVtYV9zZWFyY2g7XG4gICAgcmUubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKG0gPSByZS5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgbGVuID0gdGhpcy50ZXN0U2NoZW1hQXQodGV4dCwgbVsyXSwgcmUubGFzdEluZGV4KTtcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgdGhpcy5fX3NjaGVtYV9fICAgICA9IG1bMl07XG4gICAgICAgIHRoaXMuX19pbmRleF9fICAgICAgPSBtLmluZGV4ICsgbVsxXS5sZW5ndGg7XG4gICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBtLmluZGV4ICsgbVswXS5sZW5ndGggKyBsZW47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9fb3B0c19fLmZ1enp5TGluayAmJiB0aGlzLl9fY29tcGlsZWRfX1snaHR0cDonXSkge1xuICAgIC8vIGd1ZXNzIHNjaGVtYWxlc3MgbGlua3NcbiAgICB0bGRfcG9zID0gdGV4dC5zZWFyY2godGhpcy5yZS5ob3N0X2Z1enp5X3Rlc3QpO1xuICAgIGlmICh0bGRfcG9zID49IDApIHtcbiAgICAgIC8vIGlmIHRsZCBpcyBsb2NhdGVkIGFmdGVyIGZvdW5kIGxpbmsgLSBubyBuZWVkIHRvIGNoZWNrIGZ1enp5IHBhdHRlcm5cbiAgICAgIGlmICh0aGlzLl9faW5kZXhfXyA8IDAgfHwgdGxkX3BvcyA8IHRoaXMuX19pbmRleF9fKSB7XG4gICAgICAgIGlmICgobWwgPSB0ZXh0Lm1hdGNoKHRoaXMuX19vcHRzX18uZnV6enlJUCA/IHRoaXMucmUubGlua19mdXp6eSA6IHRoaXMucmUubGlua19ub19pcF9mdXp6eSkpICE9PSBudWxsKSB7XG5cbiAgICAgICAgICBzaGlmdCA9IG1sLmluZGV4ICsgbWxbMV0ubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fKSB7XG4gICAgICAgICAgICB0aGlzLl9fc2NoZW1hX18gICAgID0gJyc7XG4gICAgICAgICAgICB0aGlzLl9faW5kZXhfXyAgICAgID0gc2hpZnQ7XG4gICAgICAgICAgICB0aGlzLl9fbGFzdF9pbmRleF9fID0gbWwuaW5kZXggKyBtbFswXS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuX19vcHRzX18uZnV6enlFbWFpbCAmJiB0aGlzLl9fY29tcGlsZWRfX1snbWFpbHRvOiddKSB7XG4gICAgLy8gZ3Vlc3Mgc2NoZW1hbGVzcyBlbWFpbHNcbiAgICBhdF9wb3MgPSB0ZXh0LmluZGV4T2YoJ0AnKTtcbiAgICBpZiAoYXRfcG9zID49IDApIHtcbiAgICAgIC8vIFdlIGNhbid0IHNraXAgdGhpcyBjaGVjaywgYmVjYXVzZSB0aGlzIGNhc2VzIGFyZSBwb3NzaWJsZTpcbiAgICAgIC8vIDE5Mi4xNjguMS4xQGdtYWlsLmNvbSwgbXkuaW5AZXhhbXBsZS5jb21cbiAgICAgIGlmICgobWUgPSB0ZXh0Lm1hdGNoKHRoaXMucmUuZW1haWxfZnV6enkpKSAhPT0gbnVsbCkge1xuXG4gICAgICAgIHNoaWZ0ID0gbWUuaW5kZXggKyBtZVsxXS5sZW5ndGg7XG4gICAgICAgIG5leHQgID0gbWUuaW5kZXggKyBtZVswXS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuX19pbmRleF9fIDwgMCB8fCBzaGlmdCA8IHRoaXMuX19pbmRleF9fIHx8XG4gICAgICAgICAgICAoc2hpZnQgPT09IHRoaXMuX19pbmRleF9fICYmIG5leHQgPiB0aGlzLl9fbGFzdF9pbmRleF9fKSkge1xuICAgICAgICAgIHRoaXMuX19zY2hlbWFfXyAgICAgPSAnbWFpbHRvOic7XG4gICAgICAgICAgdGhpcy5fX2luZGV4X18gICAgICA9IHNoaWZ0O1xuICAgICAgICAgIHRoaXMuX19sYXN0X2luZGV4X18gPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX19pbmRleF9fID49IDA7XG59O1xuXG5cbi8qKlxuICogTGlua2lmeUl0I3ByZXRlc3QodGV4dCkgLT4gQm9vbGVhblxuICpcbiAqIFZlcnkgcXVpY2sgY2hlY2ssIHRoYXQgY2FuIGdpdmUgZmFsc2UgcG9zaXRpdmVzLiBSZXR1cm5zIHRydWUgaWYgbGluayBNQVkgQkVcbiAqIGNhbiBleGlzdHMuIENhbiBiZSB1c2VkIGZvciBzcGVlZCBvcHRpbWl6YXRpb24sIHdoZW4geW91IG5lZWQgdG8gY2hlY2sgdGhhdFxuICogbGluayBOT1QgZXhpc3RzLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5wcmV0ZXN0ID0gZnVuY3Rpb24gcHJldGVzdCh0ZXh0KSB7XG4gIHJldHVybiB0aGlzLnJlLnByZXRlc3QudGVzdCh0ZXh0KTtcbn07XG5cblxuLyoqXG4gKiBMaW5raWZ5SXQjdGVzdFNjaGVtYUF0KHRleHQsIG5hbWUsIHBvc2l0aW9uKSAtPiBOdW1iZXJcbiAqIC0gdGV4dCAoU3RyaW5nKTogdGV4dCB0byBzY2FuXG4gKiAtIG5hbWUgKFN0cmluZyk6IHJ1bGUgKHNjaGVtYSkgbmFtZVxuICogLSBwb3NpdGlvbiAoTnVtYmVyKTogdGV4dCBvZmZzZXQgdG8gY2hlY2sgZnJvbVxuICpcbiAqIFNpbWlsYXIgdG8gW1tMaW5raWZ5SXQjdGVzdF1dIGJ1dCBjaGVja3Mgb25seSBzcGVjaWZpYyBwcm90b2NvbCB0YWlsIGV4YWN0bHlcbiAqIGF0IGdpdmVuIHBvc2l0aW9uLiBSZXR1cm5zIGxlbmd0aCBvZiBmb3VuZCBwYXR0ZXJuICgwIG9uIGZhaWwpLlxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS50ZXN0U2NoZW1hQXQgPSBmdW5jdGlvbiB0ZXN0U2NoZW1hQXQodGV4dCwgc2NoZW1hLCBwb3MpIHtcbiAgLy8gSWYgbm90IHN1cHBvcnRlZCBzY2hlbWEgY2hlY2sgcmVxdWVzdGVkIC0gdGVybWluYXRlXG4gIGlmICghdGhpcy5fX2NvbXBpbGVkX19bc2NoZW1hLnRvTG93ZXJDYXNlKCldKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX19jb21waWxlZF9fW3NjaGVtYS50b0xvd2VyQ2FzZSgpXS52YWxpZGF0ZSh0ZXh0LCBwb3MsIHRoaXMpO1xufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNtYXRjaCh0ZXh0KSAtPiBBcnJheXxudWxsXG4gKlxuICogUmV0dXJucyBhcnJheSBvZiBmb3VuZCBsaW5rIGRlc2NyaXB0aW9ucyBvciBgbnVsbGAgb24gZmFpbC4gV2Ugc3Ryb25nbHlcbiAqIHJlY29tbWVuZCB0byB1c2UgW1tMaW5raWZ5SXQjdGVzdF1dIGZpcnN0LCBmb3IgYmVzdCBzcGVlZC5cbiAqXG4gKiAjIyMjIyBSZXN1bHQgbWF0Y2ggZGVzY3JpcHRpb25cbiAqXG4gKiAtIF9fc2NoZW1hX18gLSBsaW5rIHNjaGVtYSwgY2FuIGJlIGVtcHR5IGZvciBmdXp6eSBsaW5rcywgb3IgYC8vYCBmb3JcbiAqICAgcHJvdG9jb2wtbmV1dHJhbCAgbGlua3MuXG4gKiAtIF9faW5kZXhfXyAtIG9mZnNldCBvZiBtYXRjaGVkIHRleHRcbiAqIC0gX19sYXN0SW5kZXhfXyAtIGluZGV4IG9mIG5leHQgY2hhciBhZnRlciBtYXRoY2ggZW5kXG4gKiAtIF9fcmF3X18gLSBtYXRjaGVkIHRleHRcbiAqIC0gX190ZXh0X18gLSBub3JtYWxpemVkIHRleHRcbiAqIC0gX191cmxfXyAtIGxpbmssIGdlbmVyYXRlZCBmcm9tIG1hdGNoZWQgdGV4dFxuICoqL1xuTGlua2lmeUl0LnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIG1hdGNoKHRleHQpIHtcbiAgdmFyIHNoaWZ0ID0gMCwgcmVzdWx0ID0gW107XG5cbiAgLy8gVHJ5IHRvIHRha2UgcHJldmlvdXMgZWxlbWVudCBmcm9tIGNhY2hlLCBpZiAudGVzdCgpIGNhbGxlZCBiZWZvcmVcbiAgaWYgKHRoaXMuX19pbmRleF9fID49IDAgJiYgdGhpcy5fX3RleHRfY2FjaGVfXyA9PT0gdGV4dCkge1xuICAgIHJlc3VsdC5wdXNoKGNyZWF0ZU1hdGNoKHRoaXMsIHNoaWZ0KSk7XG4gICAgc2hpZnQgPSB0aGlzLl9fbGFzdF9pbmRleF9fO1xuICB9XG5cbiAgLy8gQ3V0IGhlYWQgaWYgY2FjaGUgd2FzIHVzZWRcbiAgdmFyIHRhaWwgPSBzaGlmdCA/IHRleHQuc2xpY2Uoc2hpZnQpIDogdGV4dDtcblxuICAvLyBTY2FuIHN0cmluZyB1bnRpbCBlbmQgcmVhY2hlZFxuICB3aGlsZSAodGhpcy50ZXN0KHRhaWwpKSB7XG4gICAgcmVzdWx0LnB1c2goY3JlYXRlTWF0Y2godGhpcywgc2hpZnQpKTtcblxuICAgIHRhaWwgPSB0YWlsLnNsaWNlKHRoaXMuX19sYXN0X2luZGV4X18pO1xuICAgIHNoaWZ0ICs9IHRoaXMuX19sYXN0X2luZGV4X187XG4gIH1cblxuICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTGlua2lmeUl0I3RsZHMobGlzdCBbLCBrZWVwT2xkXSkgLT4gdGhpc1xuICogLSBsaXN0IChBcnJheSk6IGxpc3Qgb2YgdGxkc1xuICogLSBrZWVwT2xkIChCb29sZWFuKTogbWVyZ2Ugd2l0aCBjdXJyZW50IGxpc3QgaWYgYHRydWVgIChgZmFsc2VgIGJ5IGRlZmF1bHQpXG4gKlxuICogTG9hZCAob3IgbWVyZ2UpIG5ldyB0bGRzIGxpc3QuIFRob3NlIGFyZSB1c2VyIGZvciBmdXp6eSBsaW5rcyAod2l0aG91dCBwcmVmaXgpXG4gKiB0byBhdm9pZCBmYWxzZSBwb3NpdGl2ZXMuIEJ5IGRlZmF1bHQgdGhpcyBhbGdvcnl0aG0gdXNlZDpcbiAqXG4gKiAtIGhvc3RuYW1lIHdpdGggYW55IDItbGV0dGVyIHJvb3Qgem9uZXMgYXJlIG9rLlxuICogLSBiaXp8Y29tfGVkdXxnb3Z8bmV0fG9yZ3xwcm98d2VifHh4eHxhZXJvfGFzaWF8Y29vcHxpbmZvfG11c2V1bXxuYW1lfHNob3B80YDRhFxuICogICBhcmUgb2suXG4gKiAtIGVuY29kZWQgKGB4bi0tLi4uYCkgcm9vdCB6b25lcyBhcmUgb2suXG4gKlxuICogSWYgbGlzdCBpcyByZXBsYWNlZCwgdGhlbiBleGFjdCBtYXRjaCBmb3IgMi1jaGFycyByb290IHpvbmVzIHdpbGwgYmUgY2hlY2tlZC5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUudGxkcyA9IGZ1bmN0aW9uIHRsZHMobGlzdCwga2VlcE9sZCkge1xuICBsaXN0ID0gQXJyYXkuaXNBcnJheShsaXN0KSA/IGxpc3QgOiBbIGxpc3QgXTtcblxuICBpZiAoIWtlZXBPbGQpIHtcbiAgICB0aGlzLl9fdGxkc19fID0gbGlzdC5zbGljZSgpO1xuICAgIHRoaXMuX190bGRzX3JlcGxhY2VkX18gPSB0cnVlO1xuICAgIGNvbXBpbGUodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl9fdGxkc19fID0gdGhpcy5fX3RsZHNfXy5jb25jYXQobGlzdClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWwsIGlkeCwgYXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWwgIT09IGFycltpZHggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXZlcnNlKCk7XG5cbiAgY29tcGlsZSh0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIExpbmtpZnlJdCNub3JtYWxpemUobWF0Y2gpXG4gKlxuICogRGVmYXVsdCBub3JtYWxpemVyIChpZiBzY2hlbWEgZG9lcyBub3QgZGVmaW5lIGl0J3Mgb3duKS5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKG1hdGNoKSB7XG5cbiAgLy8gRG8gbWluaW1hbCBwb3NzaWJsZSBjaGFuZ2VzIGJ5IGRlZmF1bHQuIE5lZWQgdG8gY29sbGVjdCBmZWVkYmFjayBwcmlvclxuICAvLyB0byBtb3ZlIGZvcndhcmQgaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQvaXNzdWVzLzFcblxuICBpZiAoIW1hdGNoLnNjaGVtYSkgeyBtYXRjaC51cmwgPSAnaHR0cDovLycgKyBtYXRjaC51cmw7IH1cblxuICBpZiAobWF0Y2guc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QobWF0Y2gudXJsKSkge1xuICAgIG1hdGNoLnVybCA9ICdtYWlsdG86JyArIG1hdGNoLnVybDtcbiAgfVxufTtcblxuXG4vKipcbiAqIExpbmtpZnlJdCNvbkNvbXBpbGUoKVxuICpcbiAqIE92ZXJyaWRlIHRvIG1vZGlmeSBiYXNpYyBSZWdFeHAtcy5cbiAqKi9cbkxpbmtpZnlJdC5wcm90b3R5cGUub25Db21waWxlID0gZnVuY3Rpb24gb25Db21waWxlKCkge1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtpZnlJdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIHZhciByZSA9IHt9O1xuXG4gIC8vIFVzZSBkaXJlY3QgZXh0cmFjdCBpbnN0ZWFkIG9mIGByZWdlbmVyYXRlYCB0byByZWR1c2UgYnJvd3NlcmlmaWVkIHNpemVcbiAgcmUuc3JjX0FueSA9IHJlcXVpcmUoJ3VjLm1pY3JvL3Byb3BlcnRpZXMvQW55L3JlZ2V4Jykuc291cmNlO1xuICByZS5zcmNfQ2MgID0gcmVxdWlyZSgndWMubWljcm8vY2F0ZWdvcmllcy9DYy9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1ogICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvWi9yZWdleCcpLnNvdXJjZTtcbiAgcmUuc3JjX1AgICA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpLnNvdXJjZTtcblxuICAvLyBcXHB7XFxaXFxQXFxDY1xcQ0Z9ICh3aGl0ZSBzcGFjZXMgKyBjb250cm9sICsgZm9ybWF0ICsgcHVuY3R1YXRpb24pXG4gIHJlLnNyY19aUENjID0gWyByZS5zcmNfWiwgcmUuc3JjX1AsIHJlLnNyY19DYyBdLmpvaW4oJ3wnKTtcblxuICAvLyBcXHB7XFxaXFxDY30gKHdoaXRlIHNwYWNlcyArIGNvbnRyb2wpXG4gIHJlLnNyY19aQ2MgPSBbIHJlLnNyY19aLCByZS5zcmNfQ2MgXS5qb2luKCd8Jyk7XG5cbiAgLy8gRXhwZXJpbWVudGFsLiBMaXN0IG9mIGNoYXJzLCBjb21wbGV0ZWx5IHByb2hpYml0ZWQgaW4gbGlua3NcbiAgLy8gYmVjYXVzZSBjYW4gc2VwYXJhdGUgaXQgZnJvbSBvdGhlciBwYXJ0IG9mIHRleHRcbiAgdmFyIHRleHRfc2VwYXJhdG9ycyA9ICdbPjxcXHVmZjVjXSc7XG5cbiAgLy8gQWxsIHBvc3NpYmxlIHdvcmQgY2hhcmFjdGVycyAoZXZlcnl0aGluZyB3aXRob3V0IHB1bmN0dWF0aW9uLCBzcGFjZXMgJiBjb250cm9scylcbiAgLy8gRGVmaW5lZCB2aWEgcHVuY3R1YXRpb24gJiBzcGFjZXMgdG8gc2F2ZSBzcGFjZVxuICAvLyBTaG91bGQgYmUgc29tZXRoaW5nIGxpa2UgXFxwe1xcTFxcTlxcU1xcTX0gKFxcdyBidXQgd2l0aG91dCBgX2ApXG4gIHJlLnNyY19wc2V1ZG9fbGV0dGVyICAgICAgID0gJyg/Oig/IScgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfCcgKyByZS5zcmNfWlBDYyArICcpJyArIHJlLnNyY19BbnkgKyAnKSc7XG4gIC8vIFRoZSBzYW1lIGFzIGFib3RoZSBidXQgd2l0aG91dCBbMC05XVxuICAvLyB2YXIgc3JjX3BzZXVkb19sZXR0ZXJfbm9uX2QgPSAnKD86KD8hWzAtOV18JyArIHNyY19aUENjICsgJyknICsgc3JjX0FueSArICcpJztcblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHJlLnNyY19pcDQgPVxuXG4gICAgJyg/OigyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFxcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPyknO1xuXG4gIC8vIFByb2hpYml0IGFueSBvZiBcIkAvW10oKVwiIGluIHVzZXIvcGFzcyB0byBhdm9pZCB3cm9uZyBkb21haW4gZmV0Y2guXG4gIHJlLnNyY19hdXRoICAgID0gJyg/Oig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbQC9cXFxcW1xcXFxdKCldKS4pK0ApPyc7XG5cbiAgcmUuc3JjX3BvcnQgPVxuXG4gICAgJyg/OjooPzo2KD86WzAtNF1cXFxcZHszfXw1KD86WzAtNF1cXFxcZHsyfXw1KD86WzAtMl1cXFxcZHwzWzAtNV0pKSl8WzEtNV0/XFxcXGR7MSw0fSkpPyc7XG5cbiAgcmUuc3JjX2hvc3RfdGVybWluYXRvciA9XG5cbiAgICAnKD89JHwnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3wnICsgcmUuc3JjX1pQQ2MgKyAnKSg/IS18X3w6XFxcXGR8XFxcXC4tfFxcXFwuKD8hJHwnICsgcmUuc3JjX1pQQ2MgKyAnKSknO1xuXG4gIHJlLnNyY19wYXRoID1cblxuICAgICcoPzonICtcbiAgICAgICdbLz8jXScgK1xuICAgICAgICAnKD86JyArXG4gICAgICAgICAgJyg/IScgKyByZS5zcmNfWkNjICsgJ3wnICsgdGV4dF9zZXBhcmF0b3JzICsgJ3xbKClbXFxcXF17fS4sXCJcXCc/IVxcXFwtXSkufCcgK1xuICAgICAgICAgICdcXFxcWyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xcXFxcXSkuKSpcXFxcXXwnICtcbiAgICAgICAgICAnXFxcXCgoPzooPyEnICsgcmUuc3JjX1pDYyArICd8WyldKS4pKlxcXFwpfCcgK1xuICAgICAgICAgICdcXFxceyg/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbfV0pLikqXFxcXH18JyArXG4gICAgICAgICAgJ1xcXFxcIig/Oig/IScgKyByZS5zcmNfWkNjICsgJ3xbXCJdKS4pK1xcXFxcInwnICtcbiAgICAgICAgICBcIlxcXFwnKD86KD8hXCIgKyByZS5zcmNfWkNjICsgXCJ8WyddKS4pK1xcXFwnfFwiICtcbiAgICAgICAgICBcIlxcXFwnKD89XCIgKyByZS5zcmNfcHNldWRvX2xldHRlciArICd8Wy1dKS58JyArICAvLyBhbGxvdyBgSSdtX2tpbmdgIGlmIG5vIHBhaXIgZm91bmRcbiAgICAgICAgICAnXFxcXC57MiwzfVthLXpBLVowLTklL118JyArIC8vIGdpdGh1YiBoYXMgLi4uIGluIGNvbW1pdCByYW5nZSBsaW5rcy4gUmVzdHJpY3QgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIGVuZ2xpc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtIHBlcmNlbnQtZW5jb2RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gcGFydHMgb2YgZmlsZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW50aWwgbW9yZSBleGFtcGxlcyBmb3VuZC5cbiAgICAgICAgICAnXFxcXC4oPyEnICsgcmUuc3JjX1pDYyArICd8Wy5dKS58JyArXG4gICAgICAgICAgKG9wdHMgJiYgb3B0c1snLS0tJ10gP1xuICAgICAgICAgICAgJ1xcXFwtKD8hLS0oPzpbXi1dfCQpKSg/Oi0qKXwnIC8vIGAtLS1gID0+IGxvbmcgZGFzaCwgdGVybWluYXRlXG4gICAgICAgICAgICA6XG4gICAgICAgICAgICAnXFxcXC0rfCdcbiAgICAgICAgICApICtcbiAgICAgICAgICAnXFxcXCwoPyEnICsgcmUuc3JjX1pDYyArICcpLnwnICsgICAgICAvLyBhbGxvdyBgLCwsYCBpbiBwYXRoc1xuICAgICAgICAgICdcXFxcISg/IScgKyByZS5zcmNfWkNjICsgJ3xbIV0pLnwnICtcbiAgICAgICAgICAnXFxcXD8oPyEnICsgcmUuc3JjX1pDYyArICd8Wz9dKS4nICtcbiAgICAgICAgJykrJyArXG4gICAgICAnfFxcXFwvJyArXG4gICAgJyk/JztcblxuICByZS5zcmNfZW1haWxfbmFtZSA9XG5cbiAgICAnW1xcXFwtOzomPVxcXFwrXFxcXCQsXFxcXFwiXFxcXC5hLXpBLVowLTlfXSsnO1xuXG4gIHJlLnNyY194biA9XG5cbiAgICAneG4tLVthLXowLTlcXFxcLV17MSw1OX0nO1xuXG4gIC8vIE1vcmUgdG8gcmVhZCBhYm91dCBkb21haW4gbmFtZXNcbiAgLy8gaHR0cDovL3NlcnZlcmZhdWx0LmNvbS9xdWVzdGlvbnMvNjM4MjYwL1xuXG4gIHJlLnNyY19kb21haW5fcm9vdCA9XG5cbiAgICAvLyBBbGxvdyBsZXR0ZXJzICYgZGlnaXRzIChodHRwOi8vdGVzdDEpXG4gICAgJyg/OicgK1xuICAgICAgcmUuc3JjX3huICtcbiAgICAgICd8JyArXG4gICAgICByZS5zcmNfcHNldWRvX2xldHRlciArICd7MSw2M30nICtcbiAgICAnKSc7XG5cbiAgcmUuc3JjX2RvbWFpbiA9XG5cbiAgICAnKD86JyArXG4gICAgICByZS5zcmNfeG4gK1xuICAgICAgJ3wnICtcbiAgICAgICcoPzonICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKScgK1xuICAgICAgJ3wnICtcbiAgICAgICcoPzonICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKD86LXwnICsgcmUuc3JjX3BzZXVkb19sZXR0ZXIgKyAnKXswLDYxfScgKyByZS5zcmNfcHNldWRvX2xldHRlciArICcpJyArXG4gICAgJyknO1xuXG4gIHJlLnNyY19ob3N0ID1cblxuICAgICcoPzonICtcbiAgICAvLyBEb24ndCBuZWVkIElQIGNoZWNrLCBiZWNhdXNlIGRpZ2l0cyBhcmUgYWxyZWFkeSBhbGxvd2VkIGluIG5vcm1hbCBkb21haW4gbmFtZXNcbiAgICAvLyAgIHNyY19pcDQgK1xuICAgIC8vICd8JyArXG4gICAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSonICsgcmUuc3JjX2RvbWFpbi8qX3Jvb3QqLyArICcpJyArXG4gICAgJyknO1xuXG4gIHJlLnRwbF9ob3N0X2Z1enp5ID1cblxuICAgICcoPzonICtcbiAgICAgIHJlLnNyY19pcDQgK1xuICAgICd8JyArXG4gICAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKScgK1xuICAgICcpJztcblxuICByZS50cGxfaG9zdF9ub19pcF9mdXp6eSA9XG5cbiAgICAnKD86KD86KD86JyArIHJlLnNyY19kb21haW4gKyAnKVxcXFwuKSsoPzolVExEUyUpKSc7XG5cbiAgcmUuc3JjX2hvc3Rfc3RyaWN0ID1cblxuICAgIHJlLnNyY19ob3N0ICsgcmUuc3JjX2hvc3RfdGVybWluYXRvcjtcblxuICByZS50cGxfaG9zdF9mdXp6eV9zdHJpY3QgPVxuXG4gICAgcmUudHBsX2hvc3RfZnV6enkgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnNyY19ob3N0X3BvcnRfc3RyaWN0ID1cblxuICAgIHJlLnNyY19ob3N0ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X3BvcnRfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG4gIHJlLnRwbF9ob3N0X3BvcnRfbm9faXBfZnV6enlfc3RyaWN0ID1cblxuICAgIHJlLnRwbF9ob3N0X25vX2lwX2Z1enp5ICsgcmUuc3JjX3BvcnQgKyByZS5zcmNfaG9zdF90ZXJtaW5hdG9yO1xuXG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gTWFpbiBydWxlc1xuXG4gIC8vIFJ1ZGUgdGVzdCBmdXp6eSBsaW5rcyBieSBob3N0LCBmb3IgcXVpY2sgZGVueVxuICByZS50cGxfaG9zdF9mdXp6eV90ZXN0ID1cblxuICAgICdsb2NhbGhvc3R8d3d3XFxcXC58XFxcXC5cXFxcZHsxLDN9XFxcXC58KD86XFxcXC4oPzolVExEUyUpKD86JyArIHJlLnNyY19aUENjICsgJ3w+fCQpKSc7XG5cbiAgcmUudHBsX2VtYWlsX2Z1enp5ID1cblxuICAgICAgJyhefCcgKyB0ZXh0X3NlcGFyYXRvcnMgKyAnfFxcXFwofCcgKyByZS5zcmNfWkNjICsgJykoJyArIHJlLnNyY19lbWFpbF9uYW1lICsgJ0AnICsgcmUudHBsX2hvc3RfZnV6enlfc3RyaWN0ICsgJyknO1xuXG4gIHJlLnRwbF9saW5rX2Z1enp5ID1cbiAgICAgIC8vIEZ1enp5IGxpbmsgY2FuJ3QgYmUgcHJlcGVuZGVkIHdpdGggLjovXFwtIGFuZCBub24gcHVuY3R1YXRpb24uXG4gICAgICAvLyBidXQgY2FuIHN0YXJ0IHdpdGggPiAobWFya2Rvd24gYmxvY2txdW90ZSlcbiAgICAgICcoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpJyArXG4gICAgICAnKCg/IVskKzw9Pl5gfFxcdWZmNWNdKScgKyByZS50cGxfaG9zdF9wb3J0X2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgJyknO1xuXG4gIHJlLnRwbF9saW5rX25vX2lwX2Z1enp5ID1cbiAgICAgIC8vIEZ1enp5IGxpbmsgY2FuJ3QgYmUgcHJlcGVuZGVkIHdpdGggLjovXFwtIGFuZCBub24gcHVuY3R1YXRpb24uXG4gICAgICAvLyBidXQgY2FuIHN0YXJ0IHdpdGggPiAobWFya2Rvd24gYmxvY2txdW90ZSlcbiAgICAgICcoXnwoPyFbLjovXFxcXC1fQF0pKD86WyQrPD0+XmB8XFx1ZmY1Y118JyArIHJlLnNyY19aUENjICsgJykpJyArXG4gICAgICAnKCg/IVskKzw9Pl5gfFxcdWZmNWNdKScgKyByZS50cGxfaG9zdF9wb3J0X25vX2lwX2Z1enp5X3N0cmljdCArIHJlLnNyY19wYXRoICsgJyknO1xuXG4gIHJldHVybiByZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi8nKTtcbiIsIi8vIEhUTUw1IGVudGl0aWVzIG1hcDogeyBuYW1lIC0+IHV0ZjE2c3RyaW5nIH1cbi8vXG4ndXNlIHN0cmljdCc7XG5cbi8qZXNsaW50IHF1b3RlczowKi9cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZW50aXRpZXMvbWFwcy9lbnRpdGllcy5qc29uJyk7XG4iLCIvLyBMaXN0IG9mIHZhbGlkIGh0bWwgYmxvY2tzIG5hbWVzLCBhY2NvcnRpbmcgdG8gY29tbW9ubWFyayBzcGVjXG4vLyBodHRwOi8vamdtLmdpdGh1Yi5pby9Db21tb25NYXJrL3NwZWMuaHRtbCNodG1sLWJsb2Nrc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdhZGRyZXNzJyxcbiAgJ2FydGljbGUnLFxuICAnYXNpZGUnLFxuICAnYmFzZScsXG4gICdiYXNlZm9udCcsXG4gICdibG9ja3F1b3RlJyxcbiAgJ2JvZHknLFxuICAnY2FwdGlvbicsXG4gICdjZW50ZXInLFxuICAnY29sJyxcbiAgJ2NvbGdyb3VwJyxcbiAgJ2RkJyxcbiAgJ2RldGFpbHMnLFxuICAnZGlhbG9nJyxcbiAgJ2RpcicsXG4gICdkaXYnLFxuICAnZGwnLFxuICAnZHQnLFxuICAnZmllbGRzZXQnLFxuICAnZmlnY2FwdGlvbicsXG4gICdmaWd1cmUnLFxuICAnZm9vdGVyJyxcbiAgJ2Zvcm0nLFxuICAnZnJhbWUnLFxuICAnZnJhbWVzZXQnLFxuICAnaDEnLFxuICAnaDInLFxuICAnaDMnLFxuICAnaDQnLFxuICAnaDUnLFxuICAnaDYnLFxuICAnaGVhZCcsXG4gICdoZWFkZXInLFxuICAnaHInLFxuICAnaHRtbCcsXG4gICdpZnJhbWUnLFxuICAnbGVnZW5kJyxcbiAgJ2xpJyxcbiAgJ2xpbmsnLFxuICAnbWFpbicsXG4gICdtZW51JyxcbiAgJ21lbnVpdGVtJyxcbiAgJ21ldGEnLFxuICAnbmF2JyxcbiAgJ25vZnJhbWVzJyxcbiAgJ29sJyxcbiAgJ29wdGdyb3VwJyxcbiAgJ29wdGlvbicsXG4gICdwJyxcbiAgJ3BhcmFtJyxcbiAgJ3NlY3Rpb24nLFxuICAnc291cmNlJyxcbiAgJ3N1bW1hcnknLFxuICAndGFibGUnLFxuICAndGJvZHknLFxuICAndGQnLFxuICAndGZvb3QnLFxuICAndGgnLFxuICAndGhlYWQnLFxuICAndGl0bGUnLFxuICAndHInLFxuICAndHJhY2snLFxuICAndWwnXG5dO1xuIiwiLy8gUmVnZXhwcyB0byBtYXRjaCBodG1sIGVsZW1lbnRzXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGF0dHJfbmFtZSAgICAgPSAnW2EtekEtWl86XVthLXpBLVowLTk6Ll8tXSonO1xuXG52YXIgdW5xdW90ZWQgICAgICA9ICdbXlwiXFwnPTw+YFxcXFx4MDAtXFxcXHgyMF0rJztcbnZhciBzaW5nbGVfcXVvdGVkID0gXCInW14nXSonXCI7XG52YXIgZG91YmxlX3F1b3RlZCA9ICdcIlteXCJdKlwiJztcblxudmFyIGF0dHJfdmFsdWUgID0gJyg/OicgKyB1bnF1b3RlZCArICd8JyArIHNpbmdsZV9xdW90ZWQgKyAnfCcgKyBkb3VibGVfcXVvdGVkICsgJyknO1xuXG52YXIgYXR0cmlidXRlICAgPSAnKD86XFxcXHMrJyArIGF0dHJfbmFtZSArICcoPzpcXFxccyo9XFxcXHMqJyArIGF0dHJfdmFsdWUgKyAnKT8pJztcblxudmFyIG9wZW5fdGFnICAgID0gJzxbQS1aYS16XVtBLVphLXowLTlcXFxcLV0qJyArIGF0dHJpYnV0ZSArICcqXFxcXHMqXFxcXC8/Pic7XG5cbnZhciBjbG9zZV90YWcgICA9ICc8XFxcXC9bQS1aYS16XVtBLVphLXowLTlcXFxcLV0qXFxcXHMqPic7XG52YXIgY29tbWVudCAgICAgPSAnPCEtLS0tPnw8IS0tKD86LT9bXj4tXSkoPzotP1teLV0pKi0tPic7XG52YXIgcHJvY2Vzc2luZyAgPSAnPFs/XS4qP1s/XT4nO1xudmFyIGRlY2xhcmF0aW9uID0gJzwhW0EtWl0rXFxcXHMrW14+XSo+JztcbnZhciBjZGF0YSAgICAgICA9ICc8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/XFxcXF1cXFxcXT4nO1xuXG52YXIgSFRNTF9UQUdfUkUgPSBuZXcgUmVnRXhwKCdeKD86JyArIG9wZW5fdGFnICsgJ3wnICsgY2xvc2VfdGFnICsgJ3wnICsgY29tbWVudCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnfCcgKyBwcm9jZXNzaW5nICsgJ3wnICsgZGVjbGFyYXRpb24gKyAnfCcgKyBjZGF0YSArICcpJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IG5ldyBSZWdFeHAoJ14oPzonICsgb3Blbl90YWcgKyAnfCcgKyBjbG9zZV90YWcgKyAnKScpO1xuXG5tb2R1bGUuZXhwb3J0cy5IVE1MX1RBR19SRSA9IEhUTUxfVEFHX1JFO1xubW9kdWxlLmV4cG9ydHMuSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IEhUTUxfT1BFTl9DTE9TRV9UQUdfUkU7XG4iLCIvLyBVdGlsaXRpZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuZnVuY3Rpb24gX2NsYXNzKG9iaikgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7IH1cblxuZnVuY3Rpb24gaXNTdHJpbmcob2JqKSB7IHJldHVybiBfY2xhc3Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7IH1cblxudmFyIF9oYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gX2hhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG4vLyBNZXJnZSBvYmplY3RzXG4vL1xuZnVuY3Rpb24gYXNzaWduKG9iaiAvKmZyb20xLCBmcm9tMiwgZnJvbTMsIC4uLiovKSB7XG4gIHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBzb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmICghc291cmNlKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHNvdXJjZSArICdtdXN0IGJlIG9iamVjdCcpO1xuICAgIH1cblxuICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gb2JqO1xufVxuXG4vLyBSZW1vdmUgZWxlbWVudCBmcm9tIGFycmF5IGFuZCBwdXQgYW5vdGhlciBhcnJheSBhdCB0aG9zZSBwb3NpdGlvbi5cbi8vIFVzZWZ1bCBmb3Igc29tZSBvcGVyYXRpb25zIHdpdGggdG9rZW5zXG5mdW5jdGlvbiBhcnJheVJlcGxhY2VBdChzcmMsIHBvcywgbmV3RWxlbWVudHMpIHtcbiAgcmV0dXJuIFtdLmNvbmNhdChzcmMuc2xpY2UoMCwgcG9zKSwgbmV3RWxlbWVudHMsIHNyYy5zbGljZShwb3MgKyAxKSk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbnRpdHlDb2RlKGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgLy8gYnJva2VuIHNlcXVlbmNlXG4gIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REZGRikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gbmV2ZXIgdXNlZFxuICBpZiAoYyA+PSAweEZERDAgJiYgYyA8PSAweEZERUYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmICgoYyAmIDB4RkZGRikgPT09IDB4RkZGRiB8fCAoYyAmIDB4RkZGRikgPT09IDB4RkZGRSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gY29udHJvbCBjb2Rlc1xuICBpZiAoYyA+PSAweDAwICYmIGMgPD0gMHgwOCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKGMgPT09IDB4MEIpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGlmIChjID49IDB4MEUgJiYgYyA8PSAweDFGKSB7IHJldHVybiBmYWxzZTsgfVxuICBpZiAoYyA+PSAweDdGICYmIGMgPD0gMHg5RikgeyByZXR1cm4gZmFsc2U7IH1cbiAgLy8gb3V0IG9mIHJhbmdlXG4gIGlmIChjID4gMHgxMEZGRkYpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmcm9tQ29kZVBvaW50KGMpIHtcbiAgLyplc2xpbnQgbm8tYml0d2lzZTowKi9cbiAgaWYgKGMgPiAweGZmZmYpIHtcbiAgICBjIC09IDB4MTAwMDA7XG4gICAgdmFyIHN1cnJvZ2F0ZTEgPSAweGQ4MDAgKyAoYyA+PiAxMCksXG4gICAgICAgIHN1cnJvZ2F0ZTIgPSAweGRjMDAgKyAoYyAmIDB4M2ZmKTtcblxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHN1cnJvZ2F0ZTEsIHN1cnJvZ2F0ZTIpO1xuICB9XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpO1xufVxuXG5cbnZhciBVTkVTQ0FQRV9NRF9SRSAgPSAvXFxcXChbIVwiIyQlJicoKSorLFxcLS5cXC86Ozw9Pj9AW1xcXFxcXF1eX2B7fH1+XSkvZztcbnZhciBFTlRJVFlfUkUgICAgICAgPSAvJihbYS16I11bYS16MC05XXsxLDMxfSk7L2dpO1xudmFyIFVORVNDQVBFX0FMTF9SRSA9IG5ldyBSZWdFeHAoVU5FU0NBUEVfTURfUkUuc291cmNlICsgJ3wnICsgRU5USVRZX1JFLnNvdXJjZSwgJ2dpJyk7XG5cbnZhciBESUdJVEFMX0VOVElUWV9URVNUX1JFID0gL14jKCg/OnhbYS1mMC05XXsxLDh9fFswLTldezEsOH0pKS9pO1xuXG52YXIgZW50aXRpZXMgPSByZXF1aXJlKCcuL2VudGl0aWVzJyk7XG5cbmZ1bmN0aW9uIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBuYW1lKSB7XG4gIHZhciBjb2RlID0gMDtcblxuICBpZiAoaGFzKGVudGl0aWVzLCBuYW1lKSkge1xuICAgIHJldHVybiBlbnRpdGllc1tuYW1lXTtcbiAgfVxuXG4gIGlmIChuYW1lLmNoYXJDb2RlQXQoMCkgPT09IDB4MjMvKiAjICovICYmIERJR0lUQUxfRU5USVRZX1RFU1RfUkUudGVzdChuYW1lKSkge1xuICAgIGNvZGUgPSBuYW1lWzFdLnRvTG93ZXJDYXNlKCkgPT09ICd4JyA/XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDIpLCAxNilcbiAgICA6XG4gICAgICBwYXJzZUludChuYW1lLnNsaWNlKDEpLCAxMCk7XG4gICAgaWYgKGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpKSB7XG4gICAgICByZXR1cm4gZnJvbUNvZGVQb2ludChjb2RlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2g7XG59XG5cbi8qZnVuY3Rpb24gcmVwbGFjZUVudGl0aWVzKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJyYnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuXG4gIHJldHVybiBzdHIucmVwbGFjZShFTlRJVFlfUkUsIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKTtcbn0qL1xuXG5mdW5jdGlvbiB1bmVzY2FwZU1kKHN0cikge1xuICBpZiAoc3RyLmluZGV4T2YoJ1xcXFwnKSA8IDApIHsgcmV0dXJuIHN0cjsgfVxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfTURfUkUsICckMScpO1xufVxuXG5mdW5jdGlvbiB1bmVzY2FwZUFsbChzdHIpIHtcbiAgaWYgKHN0ci5pbmRleE9mKCdcXFxcJykgPCAwICYmIHN0ci5pbmRleE9mKCcmJykgPCAwKSB7IHJldHVybiBzdHI7IH1cblxuICByZXR1cm4gc3RyLnJlcGxhY2UoVU5FU0NBUEVfQUxMX1JFLCBmdW5jdGlvbiAobWF0Y2gsIGVzY2FwZWQsIGVudGl0eSkge1xuICAgIGlmIChlc2NhcGVkKSB7IHJldHVybiBlc2NhcGVkOyB9XG4gICAgcmV0dXJuIHJlcGxhY2VFbnRpdHlQYXR0ZXJuKG1hdGNoLCBlbnRpdHkpO1xuICB9KTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxudmFyIEhUTUxfRVNDQVBFX1RFU1RfUkUgPSAvWyY8PlwiXS87XG52YXIgSFRNTF9FU0NBUEVfUkVQTEFDRV9SRSA9IC9bJjw+XCJdL2c7XG52YXIgSFRNTF9SRVBMQUNFTUVOVFMgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7J1xufTtcblxuZnVuY3Rpb24gcmVwbGFjZVVuc2FmZUNoYXIoY2gpIHtcbiAgcmV0dXJuIEhUTUxfUkVQTEFDRU1FTlRTW2NoXTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHIpIHtcbiAgaWYgKEhUTUxfRVNDQVBFX1RFU1RfUkUudGVzdChzdHIpKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKEhUTUxfRVNDQVBFX1JFUExBQ0VfUkUsIHJlcGxhY2VVbnNhZmVDaGFyKTtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgUkVHRVhQX0VTQ0FQRV9SRSA9IC9bLj8qK14kW1xcXVxcXFwoKXt9fC1dL2c7XG5cbmZ1bmN0aW9uIGVzY2FwZVJFKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoUkVHRVhQX0VTQ0FQRV9SRSwgJ1xcXFwkJicpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBpc1NwYWNlKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OlxuICAgIGNhc2UgMHgyMDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gWnMgKHVuaWNvZGUgY2xhc3MpIHx8IFtcXHRcXGZcXHZcXHJcXG5dXG5mdW5jdGlvbiBpc1doaXRlU3BhY2UoY29kZSkge1xuICBpZiAoY29kZSA+PSAweDIwMDAgJiYgY29kZSA8PSAweDIwMEEpIHsgcmV0dXJuIHRydWU7IH1cbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgY2FzZSAweDA5OiAvLyBcXHRcbiAgICBjYXNlIDB4MEE6IC8vIFxcblxuICAgIGNhc2UgMHgwQjogLy8gXFx2XG4gICAgY2FzZSAweDBDOiAvLyBcXGZcbiAgICBjYXNlIDB4MEQ6IC8vIFxcclxuICAgIGNhc2UgMHgyMDpcbiAgICBjYXNlIDB4QTA6XG4gICAgY2FzZSAweDE2ODA6XG4gICAgY2FzZSAweDIwMkY6XG4gICAgY2FzZSAweDIwNUY6XG4gICAgY2FzZSAweDMwMDA6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qZXNsaW50LWRpc2FibGUgbWF4LWxlbiovXG52YXIgVU5JQ09ERV9QVU5DVF9SRSA9IHJlcXVpcmUoJ3VjLm1pY3JvL2NhdGVnb3JpZXMvUC9yZWdleCcpO1xuXG4vLyBDdXJyZW50bHkgd2l0aG91dCBhc3RyYWwgY2hhcmFjdGVycyBzdXBwb3J0LlxuZnVuY3Rpb24gaXNQdW5jdENoYXIoY2gpIHtcbiAgcmV0dXJuIFVOSUNPREVfUFVOQ1RfUkUudGVzdChjaCk7XG59XG5cblxuLy8gTWFya2Rvd24gQVNDSUkgcHVuY3R1YXRpb24gY2hhcmFjdGVycy5cbi8vXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cbi8vIGh0dHA6Ly9zcGVjLmNvbW1vbm1hcmsub3JnLzAuMTUvI2FzY2lpLXB1bmN0dWF0aW9uLWNoYXJhY3RlclxuLy9cbi8vIERvbid0IGNvbmZ1c2Ugd2l0aCB1bmljb2RlIHB1bmN0dWF0aW9uICEhISBJdCBsYWNrcyBzb21lIGNoYXJzIGluIGFzY2lpIHJhbmdlLlxuLy9cbmZ1bmN0aW9uIGlzTWRBc2NpaVB1bmN0KGNoKSB7XG4gIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMi8qIFwiICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDI3LyogJyAqLzpcbiAgICBjYXNlIDB4MjgvKiAoICovOlxuICAgIGNhc2UgMHgyOS8qICkgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyQy8qICwgKi86XG4gICAgY2FzZSAweDJELyogLSAqLzpcbiAgICBjYXNlIDB4MkUvKiAuICovOlxuICAgIGNhc2UgMHgyRi8qIC8gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0IvKiA7ICovOlxuICAgIGNhc2UgMHgzQy8qIDwgKi86XG4gICAgY2FzZSAweDNELyogPSAqLzpcbiAgICBjYXNlIDB4M0UvKiA+ICovOlxuICAgIGNhc2UgMHgzRi8qID8gKi86XG4gICAgY2FzZSAweDQwLyogQCAqLzpcbiAgICBjYXNlIDB4NUIvKiBbICovOlxuICAgIGNhc2UgMHg1Qy8qIFxcICovOlxuICAgIGNhc2UgMHg1RC8qIF0gKi86XG4gICAgY2FzZSAweDVFLyogXiAqLzpcbiAgICBjYXNlIDB4NUYvKiBfICovOlxuICAgIGNhc2UgMHg2MC8qIGAgKi86XG4gICAgY2FzZSAweDdCLyogeyAqLzpcbiAgICBjYXNlIDB4N0MvKiB8ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLy8gSGVwbGVyIHRvIHVuaWZ5IFtyZWZlcmVuY2UgbGFiZWxzXS5cbi8vXG5mdW5jdGlvbiBub3JtYWxpemVSZWZlcmVuY2Uoc3RyKSB7XG4gIC8vIHVzZSAudG9VcHBlckNhc2UoKSBpbnN0ZWFkIG9mIC50b0xvd2VyQ2FzZSgpXG4gIC8vIGhlcmUgdG8gYXZvaWQgYSBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGVcbiAgLy8gbWVtYmVycyAobW9zdCBub3RhYmx5LCBgX19wcm90b19fYClcbiAgcmV0dXJuIHN0ci50cmltKCkucmVwbGFjZSgvXFxzKy9nLCAnICcpLnRvVXBwZXJDYXNlKCk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIFJlLWV4cG9ydCBsaWJyYXJpZXMgY29tbW9ubHkgdXNlZCBpbiBib3RoIG1hcmtkb3duLWl0IGFuZCBpdHMgcGx1Z2lucyxcbi8vIHNvIHBsdWdpbnMgd29uJ3QgaGF2ZSB0byBkZXBlbmQgb24gdGhlbSBleHBsaWNpdGx5LCB3aGljaCByZWR1Y2VzIHRoZWlyXG4vLyBidW5kbGVkIHNpemUgKGUuZy4gYSBicm93c2VyIGJ1aWxkKS5cbi8vXG5leHBvcnRzLmxpYiAgICAgICAgICAgICAgICAgPSB7fTtcbmV4cG9ydHMubGliLm1kdXJsICAgICAgICAgICA9IHJlcXVpcmUoJ21kdXJsJyk7XG5leHBvcnRzLmxpYi51Y21pY3JvICAgICAgICAgPSByZXF1aXJlKCd1Yy5taWNybycpO1xuXG5leHBvcnRzLmFzc2lnbiAgICAgICAgICAgICAgPSBhc3NpZ247XG5leHBvcnRzLmlzU3RyaW5nICAgICAgICAgICAgPSBpc1N0cmluZztcbmV4cG9ydHMuaGFzICAgICAgICAgICAgICAgICA9IGhhcztcbmV4cG9ydHMudW5lc2NhcGVNZCAgICAgICAgICA9IHVuZXNjYXBlTWQ7XG5leHBvcnRzLnVuZXNjYXBlQWxsICAgICAgICAgPSB1bmVzY2FwZUFsbDtcbmV4cG9ydHMuaXNWYWxpZEVudGl0eUNvZGUgICA9IGlzVmFsaWRFbnRpdHlDb2RlO1xuZXhwb3J0cy5mcm9tQ29kZVBvaW50ICAgICAgID0gZnJvbUNvZGVQb2ludDtcbi8vIGV4cG9ydHMucmVwbGFjZUVudGl0aWVzICAgICA9IHJlcGxhY2VFbnRpdGllcztcbmV4cG9ydHMuZXNjYXBlSHRtbCAgICAgICAgICA9IGVzY2FwZUh0bWw7XG5leHBvcnRzLmFycmF5UmVwbGFjZUF0ICAgICAgPSBhcnJheVJlcGxhY2VBdDtcbmV4cG9ydHMuaXNTcGFjZSAgICAgICAgICAgICA9IGlzU3BhY2U7XG5leHBvcnRzLmlzV2hpdGVTcGFjZSAgICAgICAgPSBpc1doaXRlU3BhY2U7XG5leHBvcnRzLmlzTWRBc2NpaVB1bmN0ICAgICAgPSBpc01kQXNjaWlQdW5jdDtcbmV4cG9ydHMuaXNQdW5jdENoYXIgICAgICAgICA9IGlzUHVuY3RDaGFyO1xuZXhwb3J0cy5lc2NhcGVSRSAgICAgICAgICAgID0gZXNjYXBlUkU7XG5leHBvcnRzLm5vcm1hbGl6ZVJlZmVyZW5jZSAgPSBub3JtYWxpemVSZWZlcmVuY2U7XG4iLCIvLyBKdXN0IGEgc2hvcnRjdXQgZm9yIGJ1bGsgZXhwb3J0XG4ndXNlIHN0cmljdCc7XG5cblxuZXhwb3J0cy5wYXJzZUxpbmtMYWJlbCAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19sYWJlbCcpO1xuZXhwb3J0cy5wYXJzZUxpbmtEZXN0aW5hdGlvbiA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua19kZXN0aW5hdGlvbicpO1xuZXhwb3J0cy5wYXJzZUxpbmtUaXRsZSAgICAgICA9IHJlcXVpcmUoJy4vcGFyc2VfbGlua190aXRsZScpO1xuIiwiLy8gUGFyc2UgbGluayBkZXN0aW5hdGlvblxuLy9cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgaXNTcGFjZSAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xudmFyIHVuZXNjYXBlQWxsID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykudW5lc2NhcGVBbGw7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4KSB7XG4gIHZhciBjb2RlLCBsZXZlbCxcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHN0YXJ0ID0gcG9zLFxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgbGluZXM6IDAsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH07XG5cbiAgaWYgKHN0ci5jaGFyQ29kZUF0KHBvcykgPT09IDB4M0MgLyogPCAqLykge1xuICAgIHBvcysrO1xuICAgIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGNvZGUgPT09IDB4MEEgLyogXFxuICovIHx8IGlzU3BhY2UoY29kZSkpIHsgcmV0dXJuIHJlc3VsdDsgfVxuICAgICAgaWYgKGNvZGUgPT09IDB4M0UgLyogPiAqLykge1xuICAgICAgICByZXN1bHQucG9zID0gcG9zICsgMTtcbiAgICAgICAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCArIDEsIHBvcykpO1xuICAgICAgICByZXN1bHQub2sgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgIH1cblxuICAgIC8vIG5vIGNsb3NpbmcgJz4nXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIHRoaXMgc2hvdWxkIGJlIC4uLiB9IGVsc2UgeyAuLi4gYnJhbmNoXG5cbiAgbGV2ZWwgPSAwO1xuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyMCkgeyBicmVhazsgfVxuXG4gICAgLy8gYXNjaWkgY29udHJvbCBjaGFyYWN0ZXJzXG4gICAgaWYgKGNvZGUgPCAweDIwIHx8IGNvZGUgPT09IDB4N0YpIHsgYnJlYWs7IH1cblxuICAgIGlmIChjb2RlID09PSAweDVDIC8qIFxcICovICYmIHBvcyArIDEgPCBtYXgpIHtcbiAgICAgIHBvcyArPSAyO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGNvZGUgPT09IDB4MjggLyogKCAqLykge1xuICAgICAgbGV2ZWwrKztcbiAgICB9XG5cbiAgICBpZiAoY29kZSA9PT0gMHgyOSAvKiApICovKSB7XG4gICAgICBpZiAobGV2ZWwgPT09IDApIHsgYnJlYWs7IH1cbiAgICAgIGxldmVsLS07XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHBvcykgeyByZXR1cm4gcmVzdWx0OyB9XG4gIGlmIChsZXZlbCAhPT0gMCkgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcmVzdWx0LnN0ciA9IHVuZXNjYXBlQWxsKHN0ci5zbGljZShzdGFydCwgcG9zKSk7XG4gIHJlc3VsdC5saW5lcyA9IGxpbmVzO1xuICByZXN1bHQucG9zID0gcG9zO1xuICByZXN1bHQub2sgPSB0cnVlO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIi8vIFBhcnNlIGxpbmsgbGFiZWxcbi8vXG4vLyB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBmaXJzdCBjaGFyYWN0ZXIgKFwiW1wiKSBhbHJlYWR5IG1hdGNoZXM7XG4vLyByZXR1cm5zIHRoZSBlbmQgb2YgdGhlIGxhYmVsXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGFydCwgZGlzYWJsZU5lc3RlZCkge1xuICB2YXIgbGV2ZWwsIGZvdW5kLCBtYXJrZXIsIHByZXZQb3MsXG4gICAgICBsYWJlbEVuZCA9IC0xLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4LFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zO1xuXG4gIHN0YXRlLnBvcyA9IHN0YXJ0ICsgMTtcbiAgbGV2ZWwgPSAxO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBtYXgpIHtcbiAgICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpO1xuICAgIGlmIChtYXJrZXIgPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgbGV2ZWwtLTtcbiAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZQb3MgPSBzdGF0ZS5wb3M7XG4gICAgc3RhdGUubWQuaW5saW5lLnNraXBUb2tlbihzdGF0ZSk7XG4gICAgaWYgKG1hcmtlciA9PT0gMHg1QiAvKiBbICovKSB7XG4gICAgICBpZiAocHJldlBvcyA9PT0gc3RhdGUucG9zIC0gMSkge1xuICAgICAgICAvLyBpbmNyZWFzZSBsZXZlbCBpZiB3ZSBmaW5kIHRleHQgYFtgLCB3aGljaCBpcyBub3QgYSBwYXJ0IG9mIGFueSB0b2tlblxuICAgICAgICBsZXZlbCsrO1xuICAgICAgfSBlbHNlIGlmIChkaXNhYmxlTmVzdGVkKSB7XG4gICAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmb3VuZCkge1xuICAgIGxhYmVsRW5kID0gc3RhdGUucG9zO1xuICB9XG5cbiAgLy8gcmVzdG9yZSBvbGQgc3RhdGVcbiAgc3RhdGUucG9zID0gb2xkUG9zO1xuXG4gIHJldHVybiBsYWJlbEVuZDtcbn07XG4iLCIvLyBQYXJzZSBsaW5rIHRpdGxlXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciB1bmVzY2FwZUFsbCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VMaW5rVGl0bGUoc3RyLCBwb3MsIG1heCkge1xuICB2YXIgY29kZSxcbiAgICAgIG1hcmtlcixcbiAgICAgIGxpbmVzID0gMCxcbiAgICAgIHN0YXJ0ID0gcG9zLFxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIHBvczogMCxcbiAgICAgICAgbGluZXM6IDAsXG4gICAgICAgIHN0cjogJydcbiAgICAgIH07XG5cbiAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gIG1hcmtlciA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgaWYgKG1hcmtlciAhPT0gMHgyMiAvKiBcIiAqLyAmJiBtYXJrZXIgIT09IDB4MjcgLyogJyAqLyAmJiBtYXJrZXIgIT09IDB4MjggLyogKCAqLykgeyByZXR1cm4gcmVzdWx0OyB9XG5cbiAgcG9zKys7XG5cbiAgLy8gaWYgb3BlbmluZyBtYXJrZXIgaXMgXCIoXCIsIHN3aXRjaCBpdCB0byBjbG9zaW5nIG1hcmtlciBcIilcIlxuICBpZiAobWFya2VyID09PSAweDI4KSB7IG1hcmtlciA9IDB4Mjk7IH1cblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY29kZSA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNvZGUgPT09IG1hcmtlcikge1xuICAgICAgcmVzdWx0LnBvcyA9IHBvcyArIDE7XG4gICAgICByZXN1bHQubGluZXMgPSBsaW5lcztcbiAgICAgIHJlc3VsdC5zdHIgPSB1bmVzY2FwZUFsbChzdHIuc2xpY2Uoc3RhcnQgKyAxLCBwb3MpKTtcbiAgICAgIHJlc3VsdC5vayA9IHRydWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4NUMgLyogXFwgKi8gJiYgcG9zICsgMSA8IG1heCkge1xuICAgICAgcG9zKys7XG4gICAgICBpZiAoc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xuICAgICAgICBsaW5lcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBNYWluIHBhcnNlciBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzICAgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJyk7XG52YXIgaGVscGVycyAgICAgID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG52YXIgUmVuZGVyZXIgICAgID0gcmVxdWlyZSgnLi9yZW5kZXJlcicpO1xudmFyIFBhcnNlckNvcmUgICA9IHJlcXVpcmUoJy4vcGFyc2VyX2NvcmUnKTtcbnZhciBQYXJzZXJCbG9jayAgPSByZXF1aXJlKCcuL3BhcnNlcl9ibG9jaycpO1xudmFyIFBhcnNlcklubGluZSA9IHJlcXVpcmUoJy4vcGFyc2VyX2lubGluZScpO1xudmFyIExpbmtpZnlJdCAgICA9IHJlcXVpcmUoJ2xpbmtpZnktaXQnKTtcbnZhciBtZHVybCAgICAgICAgPSByZXF1aXJlKCdtZHVybCcpO1xudmFyIHB1bnljb2RlICAgICA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cblxudmFyIGNvbmZpZyA9IHtcbiAgJ2RlZmF1bHQnOiByZXF1aXJlKCcuL3ByZXNldHMvZGVmYXVsdCcpLFxuICB6ZXJvOiByZXF1aXJlKCcuL3ByZXNldHMvemVybycpLFxuICBjb21tb25tYXJrOiByZXF1aXJlKCcuL3ByZXNldHMvY29tbW9ubWFyaycpXG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy9cbi8vIFRoaXMgdmFsaWRhdG9yIGNhbiBwcm9oaWJpdCBtb3JlIHRoYW4gcmVhbGx5IG5lZWRlZCB0byBwcmV2ZW50IFhTUy4gSXQncyBhXG4vLyB0cmFkZW9mZiB0byBrZWVwIGNvZGUgc2ltcGxlIGFuZCB0byBiZSBzZWN1cmUgYnkgZGVmYXVsdC5cbi8vXG4vLyBJZiB5b3UgbmVlZCBkaWZmZXJlbnQgc2V0dXAgLSBvdmVycmlkZSB2YWxpZGF0b3IgbWV0aG9kIGFzIHlvdSB3aXNoLiBPclxuLy8gcmVwbGFjZSBpdCB3aXRoIGR1bW15IGZ1bmN0aW9uIGFuZCB1c2UgZXh0ZXJuYWwgc2FuaXRpemVyLlxuLy9cblxudmFyIEJBRF9QUk9UT19SRSA9IC9eKHZic2NyaXB0fGphdmFzY3JpcHR8ZmlsZXxkYXRhKTovO1xudmFyIEdPT0RfREFUQV9SRSA9IC9eZGF0YTppbWFnZVxcLyhnaWZ8cG5nfGpwZWd8d2VicCk7LztcblxuZnVuY3Rpb24gdmFsaWRhdGVMaW5rKHVybCkge1xuICAvLyB1cmwgc2hvdWxkIGJlIG5vcm1hbGl6ZWQgYXQgdGhpcyBwb2ludCwgYW5kIGV4aXN0aW5nIGVudGl0aWVzIGFyZSBkZWNvZGVkXG4gIHZhciBzdHIgPSB1cmwudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIEJBRF9QUk9UT19SRS50ZXN0KHN0cikgPyAoR09PRF9EQVRBX1JFLnRlc3Qoc3RyKSA/IHRydWUgOiBmYWxzZSkgOiB0cnVlO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbnZhciBSRUNPREVfSE9TVE5BTUVfRk9SID0gWyAnaHR0cDonLCAnaHR0cHM6JywgJ21haWx0bzonIF07XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmsodXJsKSB7XG4gIHZhciBwYXJzZWQgPSBtZHVybC5wYXJzZSh1cmwsIHRydWUpO1xuXG4gIGlmIChwYXJzZWQuaG9zdG5hbWUpIHtcbiAgICAvLyBFbmNvZGUgaG9zdG5hbWVzIGluIHVybHMgbGlrZTpcbiAgICAvLyBgaHR0cDovL2hvc3QvYCwgYGh0dHBzOi8vaG9zdC9gLCBgbWFpbHRvOnVzZXJAaG9zdGAsIGAvL2hvc3QvYFxuICAgIC8vXG4gICAgLy8gV2UgZG9uJ3QgZW5jb2RlIHVua25vd24gc2NoZW1hcywgYmVjYXVzZSBpdCdzIGxpa2VseSB0aGF0IHdlIGVuY29kZVxuICAgIC8vIHNvbWV0aGluZyB3ZSBzaG91bGRuJ3QgKGUuZy4gYHNreXBlOm5hbWVgIHRyZWF0ZWQgYXMgYHNreXBlOmhvc3RgKVxuICAgIC8vXG4gICAgaWYgKCFwYXJzZWQucHJvdG9jb2wgfHwgUkVDT0RFX0hPU1ROQU1FX0ZPUi5pbmRleE9mKHBhcnNlZC5wcm90b2NvbCkgPj0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcGFyc2VkLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmVuY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUxpbmtUZXh0KHVybCkge1xuICB2YXIgcGFyc2VkID0gbWR1cmwucGFyc2UodXJsLCB0cnVlKTtcblxuICBpZiAocGFyc2VkLmhvc3RuYW1lKSB7XG4gICAgLy8gRW5jb2RlIGhvc3RuYW1lcyBpbiB1cmxzIGxpa2U6XG4gICAgLy8gYGh0dHA6Ly9ob3N0L2AsIGBodHRwczovL2hvc3QvYCwgYG1haWx0bzp1c2VyQGhvc3RgLCBgLy9ob3N0L2BcbiAgICAvL1xuICAgIC8vIFdlIGRvbid0IGVuY29kZSB1bmtub3duIHNjaGVtYXMsIGJlY2F1c2UgaXQncyBsaWtlbHkgdGhhdCB3ZSBlbmNvZGVcbiAgICAvLyBzb21ldGhpbmcgd2Ugc2hvdWxkbid0IChlLmcuIGBza3lwZTpuYW1lYCB0cmVhdGVkIGFzIGBza3lwZTpob3N0YClcbiAgICAvL1xuICAgIGlmICghcGFyc2VkLnByb3RvY29sIHx8IFJFQ09ERV9IT1NUTkFNRV9GT1IuaW5kZXhPZihwYXJzZWQucHJvdG9jb2wpID49IDApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZC5ob3N0bmFtZSA9IHB1bnljb2RlLnRvVW5pY29kZShwYXJzZWQuaG9zdG5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXIpIHsgLyoqLyB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kdXJsLmRlY29kZShtZHVybC5mb3JtYXQocGFyc2VkKSk7XG59XG5cblxuLyoqXG4gKiBjbGFzcyBNYXJrZG93bkl0XG4gKlxuICogTWFpbiBwYXJzZXIvcmVuZGVyZXIgY2xhc3MuXG4gKlxuICogIyMjIyMgVXNhZ2VcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBub2RlLmpzLCBcImNsYXNzaWNcIiB3YXk6XG4gKiB2YXIgTWFya2Rvd25JdCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JyksXG4gKiAgICAgbWQgPSBuZXcgTWFya2Rvd25JdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gbm9kZS5qcywgdGhlIHNhbWUsIGJ1dCB3aXRoIHN1Z2FyOlxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKlxuICogLy8gYnJvd3NlciB3aXRob3V0IEFNRCwgYWRkZWQgdG8gXCJ3aW5kb3dcIiBvbiBzY3JpcHQgbG9hZFxuICogLy8gTm90ZSwgdGhlcmUgYXJlIG5vIGRhc2guXG4gKiB2YXIgbWQgPSB3aW5kb3cubWFya2Rvd25pdCgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcignIyBtYXJrZG93bi1pdCBydWxlenohJyk7XG4gKiBgYGBcbiAqXG4gKiBTaW5nbGUgbGluZSByZW5kZXJpbmcsIHdpdGhvdXQgcGFyYWdyYXBoIHdyYXA6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICogdmFyIHJlc3VsdCA9IG1kLnJlbmRlcklubGluZSgnX19tYXJrZG93bi1pdF9fIHJ1bGV6eiEnKTtcbiAqIGBgYFxuICoqL1xuXG4vKipcbiAqIG5ldyBNYXJrZG93bkl0KFtwcmVzZXROYW1lLCBvcHRpb25zXSlcbiAqIC0gcHJlc2V0TmFtZSAoU3RyaW5nKTogb3B0aW9uYWwsIGBjb21tb25tYXJrYCAvIGB6ZXJvYFxuICogLSBvcHRpb25zIChPYmplY3QpXG4gKlxuICogQ3JlYXRlcyBwYXJzZXIgaW5zdGFuc2Ugd2l0aCBnaXZlbiBjb25maWcuIENhbiBiZSBjYWxsZWQgd2l0aG91dCBgbmV3YC5cbiAqXG4gKiAjIyMjIyBwcmVzZXROYW1lXG4gKlxuICogTWFya2Rvd25JdCBwcm92aWRlcyBuYW1lZCBwcmVzZXRzIGFzIGEgY29udmVuaWVuY2UgdG8gcXVpY2tseVxuICogZW5hYmxlL2Rpc2FibGUgYWN0aXZlIHN5bnRheCBydWxlcyBhbmQgb3B0aW9ucyBmb3IgY29tbW9uIHVzZSBjYXNlcy5cbiAqXG4gKiAtIFtcImNvbW1vbm1hcmtcIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2NvbW1vbm1hcmsuanMpIC1cbiAqICAgY29uZmlndXJlcyBwYXJzZXIgdG8gc3RyaWN0IFtDb21tb25NYXJrXShodHRwOi8vY29tbW9ubWFyay5vcmcvKSBtb2RlLlxuICogLSBbZGVmYXVsdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL2RlZmF1bHQuanMpIC1cbiAqICAgc2ltaWxhciB0byBHRk0sIHVzZWQgd2hlbiBubyBwcmVzZXQgbmFtZSBnaXZlbi4gRW5hYmxlcyBhbGwgYXZhaWxhYmxlIHJ1bGVzLFxuICogICBidXQgc3RpbGwgd2l0aG91dCBodG1sLCB0eXBvZ3JhcGhlciAmIGF1dG9saW5rZXIuXG4gKiAtIFtcInplcm9cIl0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L2Jsb2IvbWFzdGVyL2xpYi9wcmVzZXRzL3plcm8uanMpIC1cbiAqICAgYWxsIHJ1bGVzIGRpc2FibGVkLiBVc2VmdWwgdG8gcXVpY2tseSBzZXR1cCB5b3VyIGNvbmZpZyB2aWEgYC5lbmFibGUoKWAuXG4gKiAgIEZvciBleGFtcGxlLCB3aGVuIHlvdSBuZWVkIG9ubHkgYGJvbGRgIGFuZCBgaXRhbGljYCBtYXJrdXAgYW5kIG5vdGhpbmcgZWxzZS5cbiAqXG4gKiAjIyMjIyBvcHRpb25zOlxuICpcbiAqIC0gX19odG1sX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlLiBCZSBjYXJlZnVsIVxuICogICBUaGF0J3Mgbm90IHNhZmUhIFlvdSBtYXkgbmVlZCBleHRlcm5hbCBzYW5pdGl6ZXIgdG8gcHJvdGVjdCBvdXRwdXQgZnJvbSBYU1MuXG4gKiAgIEl0J3MgYmV0dGVyIHRvIGV4dGVuZCBmZWF0dXJlcyB2aWEgcGx1Z2lucywgaW5zdGVhZCBvZiBlbmFibGluZyBIVE1MLlxuICogLSBfX3hodG1sT3V0X18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGFkZCAnLycgd2hlbiBjbG9zaW5nIHNpbmdsZSB0YWdzXG4gKiAgIChgPGJyIC8+YCkuIFRoaXMgaXMgbmVlZGVkIG9ubHkgZm9yIGZ1bGwgQ29tbW9uTWFyayBjb21wYXRpYmlsaXR5LiBJbiByZWFsXG4gKiAgIHdvcmxkIHlvdSB3aWxsIG5lZWQgSFRNTCBvdXRwdXQuXG4gKiAtIF9fYnJlYWtzX18gLSBgZmFsc2VgLiBTZXQgYHRydWVgIHRvIGNvbnZlcnQgYFxcbmAgaW4gcGFyYWdyYXBocyBpbnRvIGA8YnI+YC5cbiAqIC0gX19sYW5nUHJlZml4X18gLSBgbGFuZ3VhZ2UtYC4gQ1NTIGxhbmd1YWdlIGNsYXNzIHByZWZpeCBmb3IgZmVuY2VkIGJsb2Nrcy5cbiAqICAgQ2FuIGJlIHVzZWZ1bCBmb3IgZXh0ZXJuYWwgaGlnaGxpZ2h0ZXJzLlxuICogLSBfX2xpbmtpZnlfXyAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dCB0byBsaW5rcy5cbiAqIC0gX190eXBvZ3JhcGhlcl9fICAtIGBmYWxzZWAuIFNldCBgdHJ1ZWAgdG8gZW5hYmxlIFtzb21lIGxhbmd1YWdlLW5ldXRyYWxcbiAqICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcnVsZXNfY29yZS9yZXBsYWNlbWVudHMuanMpICtcbiAqICAgcXVvdGVzIGJlYXV0aWZpY2F0aW9uIChzbWFydHF1b3RlcykuXG4gKiAtIF9fcXVvdGVzX18gLSBg4oCc4oCd4oCY4oCZYCwgU3RyaW5nIG9yIEFycmF5LiBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50XG4gKiAgIHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQgYW5kIHNtYXJ0cXVvdGVzIG9uLiBGb3IgZXhhbXBsZSwgeW91IGNhblxuICogICB1c2UgYCfCq8K74oCe4oCcJ2AgZm9yIFJ1c3NpYW4sIGAn4oCe4oCc4oCa4oCYJ2AgZm9yIEdlcm1hbiwgYW5kXG4gKiAgIGBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddYCBmb3IgRnJlbmNoIChpbmNsdWRpbmcgbmJzcCkuXG4gKiAtIF9faGlnaGxpZ2h0X18gLSBgbnVsbGAuIEhpZ2hsaWdodGVyIGZ1bmN0aW9uIGZvciBmZW5jZWQgY29kZSBibG9ja3MuXG4gKiAgIEhpZ2hsaWdodGVyIGBmdW5jdGlvbiAoc3RyLCBsYW5nKWAgc2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwuIEl0IGNhbiBhbHNvXG4gKiAgIHJldHVybiBlbXB0eSBzdHJpbmcgaWYgdGhlIHNvdXJjZSB3YXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkXG4gKiAgIGV4dGVybmFseS4gSWYgcmVzdWx0IHN0YXJ0cyB3aXRoIDxwcmUuLi4gaW50ZXJuYWwgd3JhcHBlciBpcyBza2lwcGVkLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiAvLyBjb21tb25tYXJrIG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoJ2NvbW1vbm1hcmsnKTtcbiAqXG4gKiAvLyBkZWZhdWx0IG1vZGVcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiAvLyBlbmFibGUgZXZlcnl0aGluZ1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSh7XG4gKiAgIGh0bWw6IHRydWUsXG4gKiAgIGxpbmtpZnk6IHRydWUsXG4gKiAgIHR5cG9ncmFwaGVyOiB0cnVlXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqICMjIyMjIFN5bnRheCBoaWdobGlnaHRpbmdcbiAqXG4gKiBgYGBqc1xuICogdmFyIGhsanMgPSByZXF1aXJlKCdoaWdobGlnaHQuanMnKSAvLyBodHRwczovL2hpZ2hsaWdodGpzLm9yZy9cbiAqXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuIGhsanMuaGlnaGxpZ2h0KGxhbmcsIHN0ciwgdHJ1ZSkudmFsdWU7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnJzsgLy8gdXNlIGV4dGVybmFsIGRlZmF1bHQgZXNjYXBpbmdcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBPciB3aXRoIGZ1bGwgd3JhcHBlciBvdmVycmlkZSAoaWYgeW91IG5lZWQgYXNzaWduIGNsYXNzIHRvIGA8cHJlPmApOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBobGpzID0gcmVxdWlyZSgnaGlnaGxpZ2h0LmpzJykgLy8gaHR0cHM6Ly9oaWdobGlnaHRqcy5vcmcvXG4gKlxuICogLy8gQWN0dWFsIGRlZmF1bHQgdmFsdWVzXG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKHtcbiAqICAgaGlnaGxpZ2h0OiBmdW5jdGlvbiAoc3RyLCBsYW5nKSB7XG4gKiAgICAgaWYgKGxhbmcgJiYgaGxqcy5nZXRMYW5ndWFnZShsYW5nKSkge1xuICogICAgICAgdHJ5IHtcbiAqICAgICAgICAgcmV0dXJuICc8cHJlIGNsYXNzPVwiaGxqc1wiPjxjb2RlPicgK1xuICogICAgICAgICAgICAgICAgaGxqcy5oaWdobGlnaHQobGFuZywgc3RyLCB0cnVlKS52YWx1ZSArXG4gKiAgICAgICAgICAgICAgICAnPC9jb2RlPjwvcHJlPic7XG4gKiAgICAgICB9IGNhdGNoIChfXykge31cbiAqICAgICB9XG4gKlxuICogICAgIHJldHVybiAnPHByZSBjbGFzcz1cImhsanNcIj48Y29kZT4nICsgbWQudXRpbHMuZXNjYXBlSHRtbChzdHIpICsgJzwvY29kZT48L3ByZT4nO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqKi9cbmZ1bmN0aW9uIE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFya2Rvd25JdCkpIHtcbiAgICByZXR1cm4gbmV3IE1hcmtkb3duSXQocHJlc2V0TmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHByZXNldE5hbWUpKSB7XG4gICAgICBvcHRpb25zID0gcHJlc2V0TmFtZSB8fCB7fTtcbiAgICAgIHByZXNldE5hbWUgPSAnZGVmYXVsdCc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaW5saW5lIC0+IFBhcnNlcklubGluZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW1BhcnNlcklubGluZV1dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5pbmxpbmUgPSBuZXcgUGFyc2VySW5saW5lKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjYmxvY2sgLT4gUGFyc2VyQmxvY2tcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tQYXJzZXJCbG9ja11dLiBZb3UgbWF5IG5lZWQgaXQgdG8gYWRkIG5ldyBydWxlcyB3aGVuXG4gICAqIHdyaXRpbmcgcGx1Z2lucy4gRm9yIHNpbXBsZSBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dIGFuZFxuICAgKiBbW01hcmtkb3duSXQuZW5hYmxlXV0uXG4gICAqKi9cbiAgdGhpcy5ibG9jayA9IG5ldyBQYXJzZXJCbG9jaygpO1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I2NvcmUgLT4gQ29yZVxuICAgKlxuICAgKiBJbnN0YW5jZSBvZiBbW0NvcmVdXSBjaGFpbiBleGVjdXRvci4gWW91IG1heSBuZWVkIGl0IHRvIGFkZCBuZXcgcnVsZXMgd2hlblxuICAgKiB3cml0aW5nIHBsdWdpbnMuIEZvciBzaW1wbGUgcnVsZXMgY29udHJvbCB1c2UgW1tNYXJrZG93bkl0LmRpc2FibGVdXSBhbmRcbiAgICogW1tNYXJrZG93bkl0LmVuYWJsZV1dLlxuICAgKiovXG4gIHRoaXMuY29yZSA9IG5ldyBQYXJzZXJDb3JlKCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjcmVuZGVyZXIgLT4gUmVuZGVyZXJcbiAgICpcbiAgICogSW5zdGFuY2Ugb2YgW1tSZW5kZXJlcl1dLiBVc2UgaXQgdG8gbW9kaWZ5IG91dHB1dCBsb29rLiBPciB0byBhZGQgcmVuZGVyaW5nXG4gICAqIHJ1bGVzIGZvciBuZXcgdG9rZW4gdHlwZXMsIGdlbmVyYXRlZCBieSBwbHVnaW5zLlxuICAgKlxuICAgKiAjIyMjIyBFeGFtcGxlXG4gICAqXG4gICAqIGBgYGphdmFzY3JpcHRcbiAgICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpO1xuICAgKlxuICAgKiBmdW5jdGlvbiBteVRva2VuKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNlbGYpIHtcbiAgICogICAvLy4uLlxuICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAqIH07XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzWydteV90b2tlbiddID0gbXlUb2tlblxuICAgKiBgYGBcbiAgICpcbiAgICogU2VlIFtbUmVuZGVyZXJdXSBkb2NzIGFuZCBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpLlxuICAgKiovXG4gIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNsaW5raWZ5IC0+IExpbmtpZnlJdFxuICAgKlxuICAgKiBbbGlua2lmeS1pdF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L2xpbmtpZnktaXQpIGluc3RhbmNlLlxuICAgKiBVc2VkIGJ5IFtsaW5raWZ5XShodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvYmxvYi9tYXN0ZXIvbGliL3J1bGVzX2NvcmUvbGlua2lmeS5qcylcbiAgICogcnVsZS5cbiAgICoqL1xuICB0aGlzLmxpbmtpZnkgPSBuZXcgTGlua2lmeUl0KCk7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjdmFsaWRhdGVMaW5rKHVybCkgLT4gQm9vbGVhblxuICAgKlxuICAgKiBMaW5rIHZhbGlkYXRpb24gZnVuY3Rpb24uIENvbW1vbk1hcmsgYWxsb3dzIHRvbyBtdWNoIGluIGxpbmtzLiBCeSBkZWZhdWx0XG4gICAqIHdlIGRpc2FibGUgYGphdmFzY3JpcHQ6YCwgYHZic2NyaXB0OmAsIGBmaWxlOmAgc2NoZW1hcywgYW5kIGFsbW9zdCBhbGwgYGRhdGE6Li4uYCBzY2hlbWFzXG4gICAqIGV4Y2VwdCBzb21lIGVtYmVkZGVkIGltYWdlIHR5cGVzLlxuICAgKlxuICAgKiBZb3UgY2FuIGNoYW5nZSB0aGlzIGJlaGF2aW91cjpcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqIC8vIGVuYWJsZSBldmVyeXRoaW5nXG4gICAqIG1kLnZhbGlkYXRlTGluayA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH1cbiAgICogYGBgXG4gICAqKi9cbiAgdGhpcy52YWxpZGF0ZUxpbmsgPSB2YWxpZGF0ZUxpbms7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjbm9ybWFsaXplTGluayh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGVuY29kZSBsaW5rIHVybCB0byBhIG1hY2hpbmUtcmVhZGFibGUgZm9ybWF0LFxuICAgKiB3aGljaCBpbmNsdWRlcyB1cmwtZW5jb2RpbmcsIHB1bnljb2RlLCBldGMuXG4gICAqKi9cbiAgdGhpcy5ub3JtYWxpemVMaW5rID0gbm9ybWFsaXplTGluaztcblxuICAvKipcbiAgICogTWFya2Rvd25JdCNub3JtYWxpemVMaW5rVGV4dCh1cmwpIC0+IFN0cmluZ1xuICAgKlxuICAgKiBGdW5jdGlvbiB1c2VkIHRvIGRlY29kZSBsaW5rIHVybCB0byBhIGh1bWFuLXJlYWRhYmxlIGZvcm1hdGBcbiAgICoqL1xuICB0aGlzLm5vcm1hbGl6ZUxpbmtUZXh0ID0gbm9ybWFsaXplTGlua1RleHQ7XG5cblxuICAvLyBFeHBvc2UgdXRpbHMgJiBoZWxwZXJzIGZvciBlYXN5IGFjY2VzIGZyb20gcGx1Z2luc1xuXG4gIC8qKlxuICAgKiBNYXJrZG93bkl0I3V0aWxzIC0+IHV0aWxzXG4gICAqXG4gICAqIEFzc29ydGVkIHV0aWxpdHkgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvY29tbW9uL3V0aWxzLmpzKS5cbiAgICoqL1xuICB0aGlzLnV0aWxzID0gdXRpbHM7XG5cbiAgLyoqXG4gICAqIE1hcmtkb3duSXQjaGVscGVycyAtPiBoZWxwZXJzXG4gICAqXG4gICAqIExpbmsgY29tcG9uZW50cyBwYXJzZXIgZnVuY3Rpb25zLCB1c2VmdWwgdG8gd3JpdGUgcGx1Z2lucy4gU2VlIGRldGFpbHNcbiAgICogW2hlcmVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvaGVscGVycykuXG4gICAqKi9cbiAgdGhpcy5oZWxwZXJzID0gdXRpbHMuYXNzaWduKHt9LCBoZWxwZXJzKTtcblxuXG4gIHRoaXMub3B0aW9ucyA9IHt9O1xuICB0aGlzLmNvbmZpZ3VyZShwcmVzZXROYW1lKTtcblxuICBpZiAob3B0aW9ucykgeyB0aGlzLnNldChvcHRpb25zKTsgfVxufVxuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuc2V0KG9wdGlvbnMpXG4gKlxuICogU2V0IHBhcnNlciBvcHRpb25zIChpbiB0aGUgc2FtZSBmb3JtYXQgYXMgaW4gY29uc3RydWN0b3IpLiBQcm9iYWJseSwgeW91XG4gKiB3aWxsIG5ldmVyIG5lZWQgaXQsIGJ1dCB5b3UgY2FuIGNoYW5nZSBvcHRpb25zIGFmdGVyIGNvbnN0cnVjdG9yIGNhbGwuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLnNldCh7IGh0bWw6IHRydWUsIGJyZWFrczogdHJ1ZSB9KVxuICogICAgICAgICAgICAgLnNldCh7IHR5cG9ncmFwaGVyLCB0cnVlIH0pO1xuICogYGBgXG4gKlxuICogX19Ob3RlOl9fIFRvIGFjaGlldmUgdGhlIGJlc3QgcG9zc2libGUgcGVyZm9ybWFuY2UsIGRvbid0IG1vZGlmeSBhXG4gKiBgbWFya2Rvd24taXRgIGluc3RhbmNlIG9wdGlvbnMgb24gdGhlIGZseS4gSWYgeW91IG5lZWQgbXVsdGlwbGUgY29uZmlndXJhdGlvbnNcbiAqIGl0J3MgYmVzdCB0byBjcmVhdGUgbXVsdGlwbGUgaW5zdGFuY2VzIGFuZCBpbml0aWFsaXplIGVhY2ggd2l0aCBzZXBhcmF0ZVxuICogY29uZmlnLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgdXRpbHMuYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuXG4vKiogY2hhaW5hYmxlLCBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5jb25maWd1cmUocHJlc2V0cylcbiAqXG4gKiBCYXRjaCBsb2FkIG9mIGFsbCBvcHRpb25zIGFuZCBjb21wZW5lbnQgc2V0dGluZ3MuIFRoaXMgaXMgaW50ZXJuYWwgbWV0aG9kLFxuICogYW5kIHlvdSBwcm9iYWJseSB3aWxsIG5vdCBuZWVkIGl0LiBCdXQgaWYgeW91IHdpdGggLSBzZWUgYXZhaWxhYmxlIHByZXNldHNcbiAqIGFuZCBkYXRhIHN0cnVjdHVyZSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL21hcmtkb3duLWl0L21hcmtkb3duLWl0L3RyZWUvbWFzdGVyL2xpYi9wcmVzZXRzKVxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgcHJlc2V0cyBpbnN0ZWFkIG9mIGRpcmVjdCBjb25maWcgbG9hZHMuIFRoYXRcbiAqIHdpbGwgZ2l2ZSBiZXR0ZXIgY29tcGF0aWJpbGl0eSB3aXRoIG5leHQgdmVyc2lvbnMuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5jb25maWd1cmUgPSBmdW5jdGlvbiAocHJlc2V0cykge1xuICB2YXIgc2VsZiA9IHRoaXMsIHByZXNldE5hbWU7XG5cbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHByZXNldHMpKSB7XG4gICAgcHJlc2V0TmFtZSA9IHByZXNldHM7XG4gICAgcHJlc2V0cyA9IGNvbmZpZ1twcmVzZXROYW1lXTtcbiAgICBpZiAoIXByZXNldHMpIHsgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBgbWFya2Rvd24taXRgIHByZXNldCBcIicgKyBwcmVzZXROYW1lICsgJ1wiLCBjaGVjayBuYW1lJyk7IH1cbiAgfVxuXG4gIGlmICghcHJlc2V0cykgeyB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIGBtYXJrZG93bi1pdGAgcHJlc2V0LCBjYW5cXCd0IGJlIGVtcHR5Jyk7IH1cblxuICBpZiAocHJlc2V0cy5vcHRpb25zKSB7IHNlbGYuc2V0KHByZXNldHMub3B0aW9ucyk7IH1cblxuICBpZiAocHJlc2V0cy5jb21wb25lbnRzKSB7XG4gICAgT2JqZWN0LmtleXMocHJlc2V0cy5jb21wb25lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBpZiAocHJlc2V0cy5jb21wb25lbnRzW25hbWVdLnJ1bGVzKSB7XG4gICAgICAgIHNlbGZbbmFtZV0ucnVsZXIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMpO1xuICAgICAgfVxuICAgICAgaWYgKHByZXNldHMuY29tcG9uZW50c1tuYW1lXS5ydWxlczIpIHtcbiAgICAgICAgc2VsZltuYW1lXS5ydWxlcjIuZW5hYmxlT25seShwcmVzZXRzLmNvbXBvbmVudHNbbmFtZV0ucnVsZXMyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC5lbmFibGUobGlzdCwgaWdub3JlSW52YWxpZClcbiAqIC0gbGlzdCAoU3RyaW5nfEFycmF5KTogcnVsZSBuYW1lIG9yIGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGVcbiAqIC0gaWdub3JlSW52YWxpZCAoQm9vbGVhbik6IHNldCBgdHJ1ZWAgdG8gaWdub3JlIGVycm9ycyB3aGVuIHJ1bGUgbm90IGZvdW5kLlxuICpcbiAqIEVuYWJsZSBsaXN0IG9yIHJ1bGVzLiBJdCB3aWxsIGF1dG9tYXRpY2FsbHkgZmluZCBhcHByb3ByaWF0ZSBjb21wb25lbnRzLFxuICogY29udGFpbmluZyBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBydWxlIG5vdCBmb3VuZCwgYW5kIGBpZ25vcmVJbnZhbGlkYFxuICogbm90IHNldCAtIHRocm93cyBleGNlcHRpb24uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKVxuICogICAgICAgICAgICAgLmVuYWJsZShbJ3N1YicsICdzdXAnXSlcbiAqICAgICAgICAgICAgIC5kaXNhYmxlKCdzbWFydHF1b3RlcycpO1xuICogYGBgXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAobGlzdCwgaWdub3JlSW52YWxpZCkge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIFsgJ2NvcmUnLCAnYmxvY2snLCAnaW5saW5lJyBdLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzW2NoYWluXS5ydWxlci5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuICB9LCB0aGlzKTtcblxuICByZXN1bHQgPSByZXN1bHQuY29uY2F0KHRoaXMuaW5saW5lLnJ1bGVyMi5lbmFibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGVuYWJsZSB1bmtub3duIHJ1bGUocyk6ICcgKyBtaXNzZWQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBjaGFpbmFibGVcbiAqIE1hcmtkb3duSXQuZGlzYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBydWxlIG5hbWUgb3IgbGlzdCBvZiBydWxlIG5hbWVzIHRvIGRpc2FibGUuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW01hcmtkb3duSXQuZW5hYmxlXV0sIGJ1dCB0dXJuIHNwZWNpZmllZCBydWxlcyBvZmYuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICBbICdjb3JlJywgJ2Jsb2NrJywgJ2lubGluZScgXS5mb3JFYWNoKGZ1bmN0aW9uIChjaGFpbikge1xuICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpc1tjaGFpbl0ucnVsZXIuZGlzYWJsZShsaXN0LCB0cnVlKSk7XG4gIH0sIHRoaXMpO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQodGhpcy5pbmxpbmUucnVsZXIyLmRpc2FibGUobGlzdCwgdHJ1ZSkpO1xuXG4gIHZhciBtaXNzZWQgPSBsaXN0LmZpbHRlcihmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gcmVzdWx0LmluZGV4T2YobmFtZSkgPCAwOyB9KTtcblxuICBpZiAobWlzc2VkLmxlbmd0aCAmJiAhaWdub3JlSW52YWxpZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWFya2Rvd25JdC4gRmFpbGVkIHRvIGRpc2FibGUgdW5rbm93biBydWxlKHMpOiAnICsgbWlzc2VkKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqIGNoYWluYWJsZVxuICogTWFya2Rvd25JdC51c2UocGx1Z2luLCBwYXJhbXMpXG4gKlxuICogTG9hZCBzcGVjaWZpZWQgcGx1Z2luIHdpdGggZ2l2ZW4gcGFyYW1zIGludG8gY3VycmVudCBwYXJzZXIgaW5zdGFuY2UuXG4gKiBJdCdzIGp1c3QgYSBzdWdhciB0byBjYWxsIGBwbHVnaW4obWQsIHBhcmFtcylgIHdpdGggY3VycmluZy5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIGl0ZXJhdG9yID0gcmVxdWlyZSgnbWFya2Rvd24taXQtZm9yLWlubGluZScpO1xuICogdmFyIG1kID0gcmVxdWlyZSgnbWFya2Rvd24taXQnKSgpXG4gKiAgICAgICAgICAgICAudXNlKGl0ZXJhdG9yLCAnZm9vX3JlcGxhY2UnLCAndGV4dCcsIGZ1bmN0aW9uICh0b2tlbnMsIGlkeCkge1xuICogICAgICAgICAgICAgICB0b2tlbnNbaWR4XS5jb250ZW50ID0gdG9rZW5zW2lkeF0uY29udGVudC5yZXBsYWNlKC9mb28vZywgJ2JhcicpO1xuICogICAgICAgICAgICAgfSk7XG4gKiBgYGBcbiAqKi9cbk1hcmtkb3duSXQucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIChwbHVnaW4gLyosIHBhcmFtcywgLi4uICovKSB7XG4gIHZhciBhcmdzID0gWyB0aGlzIF0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICBwbHVnaW4uYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogTWFya2Rvd25JdC5wYXJzZShzcmMsIGVudikgLT4gQXJyYXlcbiAqIC0gc3JjIChTdHJpbmcpOiBzb3VyY2Ugc3RyaW5nXG4gKiAtIGVudiAoT2JqZWN0KTogZW52aXJvbm1lbnQgc2FuZGJveFxuICpcbiAqIFBhcnNlIGlucHV0IHN0cmluZyBhbmQgcmV0dXJucyBsaXN0IG9mIGJsb2NrIHRva2VucyAoc3BlY2lhbCB0b2tlbiB0eXBlXG4gKiBcImlubGluZVwiIHdpbGwgY29udGFpbiBsaXN0IG9mIGlubGluZSB0b2tlbnMpLiBZb3Ugc2hvdWxkIG5vdCBjYWxsIHRoaXNcbiAqIG1ldGhvZCBkaXJlY3RseSwgdW50aWwgeW91IHdyaXRlIGN1c3RvbSByZW5kZXJlciAoZm9yIGV4YW1wbGUsIHRvIHByb2R1Y2VcbiAqIEFTVCkuXG4gKlxuICogYGVudmAgaXMgdXNlZCB0byBwYXNzIGRhdGEgYmV0d2VlbiBcImRpc3RyaWJ1dGVkXCIgcnVsZXMgYW5kIHJldHVybiBhZGRpdGlvbmFsXG4gKiBtZXRhZGF0YSBsaWtlIHJlZmVyZW5jZSBpbmZvLCBuZWVkZWQgZm9yIHRoZSByZW5kZXJlci4gSXQgYWxzbyBjYW4gYmUgdXNlZCB0b1xuICogaW5qZWN0IGRhdGEgaW4gc3BlY2lmaWMgY2FzZXMuIFVzdWFsbHksIHlvdSB3aWxsIGJlIG9rIHRvIHBhc3MgYHt9YCxcbiAqIGFuZCB0aGVuIHBhc3MgdXBkYXRlZCBvYmplY3QgdG8gcmVuZGVyZXIuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IGRhdGEgc2hvdWxkIGJlIGEgU3RyaW5nJyk7XG4gIH1cblxuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICB0aGlzLmNvcmUucHJvY2VzcyhzdGF0ZSk7XG5cbiAgcmV0dXJuIHN0YXRlLnRva2Vucztcbn07XG5cblxuLyoqXG4gKiBNYXJrZG93bkl0LnJlbmRlcihzcmMgWywgZW52XSkgLT4gU3RyaW5nXG4gKiAtIHNyYyAoU3RyaW5nKTogc291cmNlIHN0cmluZ1xuICogLSBlbnYgKE9iamVjdCk6IGVudmlyb25tZW50IHNhbmRib3hcbiAqXG4gKiBSZW5kZXIgbWFya2Rvd24gc3RyaW5nIGludG8gaHRtbC4gSXQgZG9lcyBhbGwgbWFnaWMgZm9yIHlvdSA6KS5cbiAqXG4gKiBgZW52YCBjYW4gYmUgdXNlZCB0byBpbmplY3QgYWRkaXRpb25hbCBtZXRhZGF0YSAoYHt9YCBieSBkZWZhdWx0KS5cbiAqIEJ1dCB5b3Ugd2lsbCBub3QgbmVlZCBpdCB3aXRoIGhpZ2ggcHJvYmFiaWxpdHkuIFNlZSBhbHNvIGNvbW1lbnRcbiAqIGluIFtbTWFya2Rvd25JdC5wYXJzZV1dLlxuICoqL1xuTWFya2Rvd25JdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHNyYywgZW52KSB7XG4gIGVudiA9IGVudiB8fCB7fTtcblxuICByZXR1cm4gdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5wYXJzZShzcmMsIGVudiksIHRoaXMub3B0aW9ucywgZW52KTtcbn07XG5cblxuLyoqIGludGVybmFsXG4gKiBNYXJrZG93bkl0LnBhcnNlSW5saW5lKHNyYywgZW52KSAtPiBBcnJheVxuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogVGhlIHNhbWUgYXMgW1tNYXJrZG93bkl0LnBhcnNlXV0gYnV0IHNraXAgYWxsIGJsb2NrIHJ1bGVzLiBJdCByZXR1cm5zIHRoZVxuICogYmxvY2sgdG9rZW5zIGxpc3Qgd2l0aCB0aGUgc2luZ2xlIGBpbmxpbmVgIGVsZW1lbnQsIGNvbnRhaW5pbmcgcGFyc2VkIGlubGluZVxuICogdG9rZW5zIGluIGBjaGlsZHJlbmAgcHJvcGVydHkuIEFsc28gdXBkYXRlcyBgZW52YCBvYmplY3QuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIChzcmMsIGVudikge1xuICB2YXIgc3RhdGUgPSBuZXcgdGhpcy5jb3JlLlN0YXRlKHNyYywgdGhpcywgZW52KTtcblxuICBzdGF0ZS5pbmxpbmVNb2RlID0gdHJ1ZTtcbiAgdGhpcy5jb3JlLnByb2Nlc3Moc3RhdGUpO1xuXG4gIHJldHVybiBzdGF0ZS50b2tlbnM7XG59O1xuXG5cbi8qKlxuICogTWFya2Rvd25JdC5yZW5kZXJJbmxpbmUoc3JjIFssIGVudl0pIC0+IFN0cmluZ1xuICogLSBzcmMgKFN0cmluZyk6IHNvdXJjZSBzdHJpbmdcbiAqIC0gZW52IChPYmplY3QpOiBlbnZpcm9ubWVudCBzYW5kYm94XG4gKlxuICogU2ltaWxhciB0byBbW01hcmtkb3duSXQucmVuZGVyXV0gYnV0IGZvciBzaW5nbGUgcGFyYWdyYXBoIGNvbnRlbnQuIFJlc3VsdFxuICogd2lsbCBOT1QgYmUgd3JhcHBlZCBpbnRvIGA8cD5gIHRhZ3MuXG4gKiovXG5NYXJrZG93bkl0LnByb3RvdHlwZS5yZW5kZXJJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBlbnYpIHtcbiAgZW52ID0gZW52IHx8IHt9O1xuXG4gIHJldHVybiB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnBhcnNlSW5saW5lKHNyYywgZW52KSwgdGhpcy5vcHRpb25zLCBlbnYpO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duSXQ7XG4iLCIvKiogaW50ZXJuYWxcbiAqIGNsYXNzIFBhcnNlckJsb2NrXG4gKlxuICogQmxvY2stbGV2ZWwgdG9rZW5pemVyLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgICAgICAgICAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxudmFyIF9ydWxlcyA9IFtcbiAgLy8gRmlyc3QgMiBwYXJhbXMgLSBydWxlIG5hbWUgJiBzb3VyY2UuIFNlY29uZGFyeSBhcnJheSAtIGxpc3Qgb2YgcnVsZXMsXG4gIC8vIHdoaWNoIGNhbiBiZSB0ZXJtaW5hdGVkIGJ5IHRoaXMgb25lLlxuICBbICd0YWJsZScsICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay90YWJsZScpLCAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnIF0gXSxcbiAgWyAnY29kZScsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svY29kZScpIF0sXG4gIFsgJ2ZlbmNlJywgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2ZlbmNlJyksICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJywgJ2xpc3QnIF0gXSxcbiAgWyAnYmxvY2txdW90ZScsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svYmxvY2txdW90ZScpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnLCAnbGlzdCcgXSBdLFxuICBbICdocicsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19ibG9jay9ocicpLCAgICAgICAgIFsgJ3BhcmFncmFwaCcsICdyZWZlcmVuY2UnLCAnYmxvY2txdW90ZScsICdsaXN0JyBdIF0sXG4gIFsgJ2xpc3QnLCAgICAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2xpc3QnKSwgICAgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ3JlZmVyZW5jZScsICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3JlZmVyZW5jZScpIF0sXG4gIFsgJ2hlYWRpbmcnLCAgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2hlYWRpbmcnKSwgICAgWyAncGFyYWdyYXBoJywgJ3JlZmVyZW5jZScsICdibG9ja3F1b3RlJyBdIF0sXG4gIFsgJ2xoZWFkaW5nJywgICByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL2xoZWFkaW5nJykgXSxcbiAgWyAnaHRtbF9ibG9jaycsIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svaHRtbF9ibG9jaycpLCBbICdwYXJhZ3JhcGgnLCAncmVmZXJlbmNlJywgJ2Jsb2NrcXVvdGUnIF0gXSxcbiAgWyAncGFyYWdyYXBoJywgIHJlcXVpcmUoJy4vcnVsZXNfYmxvY2svcGFyYWdyYXBoJykgXVxuXTtcblxuXG4vKipcbiAqIG5ldyBQYXJzZXJCbG9jaygpXG4gKiovXG5mdW5jdGlvbiBQYXJzZXJCbG9jaygpIHtcbiAgLyoqXG4gICAqIFBhcnNlckJsb2NrI3J1bGVyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gS2VlcCBjb25maWd1cmF0aW9uIG9mIGJsb2NrIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IF9ydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucnVsZXIucHVzaChfcnVsZXNbaV1bMF0sIF9ydWxlc1tpXVsxXSwgeyBhbHQ6IChfcnVsZXNbaV1bMl0gfHwgW10pLnNsaWNlKCkgfSk7XG4gIH1cbn1cblxuXG4vLyBHZW5lcmF0ZSB0b2tlbnMgZm9yIGlucHV0IHJhbmdlXG4vL1xuUGFyc2VyQmxvY2sucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUpIHtcbiAgdmFyIG9rLCBpLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVyLmdldFJ1bGVzKCcnKSxcbiAgICAgIGxlbiA9IHJ1bGVzLmxlbmd0aCxcbiAgICAgIGxpbmUgPSBzdGFydExpbmUsXG4gICAgICBoYXNFbXB0eUxpbmVzID0gZmFsc2UsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nO1xuXG4gIHdoaWxlIChsaW5lIDwgZW5kTGluZSkge1xuICAgIHN0YXRlLmxpbmUgPSBsaW5lID0gc3RhdGUuc2tpcEVtcHR5TGluZXMobGluZSk7XG4gICAgaWYgKGxpbmUgPj0gZW5kTGluZSkgeyBicmVhazsgfVxuXG4gICAgLy8gVGVybWluYXRpb24gY29uZGl0aW9uIGZvciBuZXN0ZWQgY2FsbHMuXG4gICAgLy8gTmVzdGVkIGNhbGxzIGN1cnJlbnRseSB1c2VkIGZvciBibG9ja3F1b3RlcyAmIGxpc3RzXG4gICAgaWYgKHN0YXRlLnNDb3VudFtsaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgLy8gSWYgbmVzdGluZyBsZXZlbCBleGNlZWRlZCAtIHNraXAgdGFpbCB0byB0aGUgZW5kLiBUaGF0J3Mgbm90IG9yZGluYXJ5XG4gICAgLy8gc2l0dWF0aW9uIGFuZCB3ZSBzaG91bGQgbm90IGNhcmUgYWJvdXQgY29udGVudC5cbiAgICBpZiAoc3RhdGUubGV2ZWwgPj0gbWF4TmVzdGluZykge1xuICAgICAgc3RhdGUubGluZSA9IGVuZExpbmU7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBUcnkgYWxsIHBvc3NpYmxlIHJ1bGVzLlxuICAgIC8vIE9uIHN1Y2Nlc3MsIHJ1bGUgc2hvdWxkOlxuICAgIC8vXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLmxpbmVgXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnRva2Vuc2BcbiAgICAvLyAtIHJldHVybiB0cnVlXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG9rID0gcnVsZXNbaV0oc3RhdGUsIGxpbmUsIGVuZExpbmUsIGZhbHNlKTtcbiAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIHNldCBzdGF0ZS50aWdodCBpZiB3ZSBoYWQgYW4gZW1wdHkgbGluZSBiZWZvcmUgY3VycmVudCB0YWdcbiAgICAvLyBpLmUuIGxhdGVzdCBlbXB0eSBsaW5lIHNob3VsZCBub3QgY291bnRcbiAgICBzdGF0ZS50aWdodCA9ICFoYXNFbXB0eUxpbmVzO1xuXG4gICAgLy8gcGFyYWdyYXBoIG1pZ2h0IFwiZWF0XCIgb25lIG5ld2xpbmUgYWZ0ZXIgaXQgaW4gbmVzdGVkIGxpc3RzXG4gICAgaWYgKHN0YXRlLmlzRW1wdHkoc3RhdGUubGluZSAtIDEpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBsaW5lID0gc3RhdGUubGluZTtcblxuICAgIGlmIChsaW5lIDwgZW5kTGluZSAmJiBzdGF0ZS5pc0VtcHR5KGxpbmUpKSB7XG4gICAgICBoYXNFbXB0eUxpbmVzID0gdHJ1ZTtcbiAgICAgIGxpbmUrKztcbiAgICAgIHN0YXRlLmxpbmUgPSBsaW5lO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnNlckJsb2NrLnBhcnNlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKVxuICpcbiAqIFByb2Nlc3MgaW5wdXQgc3RyaW5nIGFuZCBwdXNoIGJsb2NrIHRva2VucyBpbnRvIGBvdXRUb2tlbnNgXG4gKiovXG5QYXJzZXJCbG9jay5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3JjKSB7IHJldHVybjsgfVxuXG4gIHN0YXRlID0gbmV3IHRoaXMuU3RhdGUoc3JjLCBtZCwgZW52LCBvdXRUb2tlbnMpO1xuXG4gIHRoaXMudG9rZW5pemUoc3RhdGUsIHN0YXRlLmxpbmUsIHN0YXRlLmxpbmVNYXgpO1xufTtcblxuXG5QYXJzZXJCbG9jay5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2Jsb2NrL3N0YXRlX2Jsb2NrJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJCbG9jaztcbiIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgQ29yZVxuICpcbiAqIFRvcC1sZXZlbCBydWxlcyBleGVjdXRvci4gR2x1ZXMgYmxvY2svaW5saW5lIHBhcnNlcnMgYW5kIGRvZXMgaW50ZXJtZWRpYXRlXG4gKiB0cmFuc2Zvcm1hdGlvbnMuXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIFJ1bGVyICA9IHJlcXVpcmUoJy4vcnVsZXInKTtcblxuXG52YXIgX3J1bGVzID0gW1xuICBbICdub3JtYWxpemUnLCAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9ub3JtYWxpemUnKSAgICAgIF0sXG4gIFsgJ2Jsb2NrJywgICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL2Jsb2NrJykgICAgICAgICAgXSxcbiAgWyAnaW5saW5lJywgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvaW5saW5lJykgICAgICAgICBdLFxuICBbICdsaW5raWZ5JywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfY29yZS9saW5raWZ5JykgICAgICAgIF0sXG4gIFsgJ3JlcGxhY2VtZW50cycsICAgcmVxdWlyZSgnLi9ydWxlc19jb3JlL3JlcGxhY2VtZW50cycpICAgXSxcbiAgWyAnc21hcnRxdW90ZXMnLCAgICByZXF1aXJlKCcuL3J1bGVzX2NvcmUvc21hcnRxdW90ZXMnKSAgICBdXG5dO1xuXG5cbi8qKlxuICogbmV3IENvcmUoKVxuICoqL1xuZnVuY3Rpb24gQ29yZSgpIHtcbiAgLyoqXG4gICAqIENvcmUjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgY29yZSBydWxlcy5cbiAgICoqL1xuICB0aGlzLnJ1bGVyID0gbmV3IFJ1bGVyKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnJ1bGVyLnB1c2goX3J1bGVzW2ldWzBdLCBfcnVsZXNbaV1bMV0pO1xuICB9XG59XG5cblxuLyoqXG4gKiBDb3JlLnByb2Nlc3Moc3RhdGUpXG4gKlxuICogRXhlY3V0ZXMgY29yZSBjaGFpbiBydWxlcy5cbiAqKi9cbkNvcmUucHJvdG90eXBlLnByb2Nlc3MgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgdmFyIGksIGwsIHJ1bGVzO1xuXG4gIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyk7XG5cbiAgZm9yIChpID0gMCwgbCA9IHJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgfVxufTtcblxuQ29yZS5wcm90b3R5cGUuU3RhdGUgPSByZXF1aXJlKCcuL3J1bGVzX2NvcmUvc3RhdGVfY29yZScpO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29yZTtcbiIsIi8qKiBpbnRlcm5hbFxuICogY2xhc3MgUGFyc2VySW5saW5lXG4gKlxuICogVG9rZW5pemVzIHBhcmFncmFwaCBjb250ZW50LlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBSdWxlciAgICAgICAgICAgPSByZXF1aXJlKCcuL3J1bGVyJyk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFBhcnNlciBydWxlc1xuXG52YXIgX3J1bGVzID0gW1xuICBbICd0ZXh0JywgICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS90ZXh0JykgXSxcbiAgWyAnbmV3bGluZScsICAgICAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvbmV3bGluZScpIF0sXG4gIFsgJ2VzY2FwZScsICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2VzY2FwZScpIF0sXG4gIFsgJ2JhY2t0aWNrcycsICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2JhY2t0aWNrcycpIF0sXG4gIFsgJ3N0cmlrZXRocm91Z2gnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2gnKS50b2tlbml6ZSBdLFxuICBbICdlbXBoYXNpcycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbXBoYXNpcycpLnRva2VuaXplIF0sXG4gIFsgJ2xpbmsnLCAgICAgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2xpbmsnKSBdLFxuICBbICdpbWFnZScsICAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9pbWFnZScpIF0sXG4gIFsgJ2F1dG9saW5rJywgICAgICAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL2F1dG9saW5rJykgXSxcbiAgWyAnaHRtbF9pbmxpbmUnLCAgICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvaHRtbF9pbmxpbmUnKSBdLFxuICBbICdlbnRpdHknLCAgICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbnRpdHknKSBdXG5dO1xuXG52YXIgX3J1bGVzMiA9IFtcbiAgWyAnYmFsYW5jZV9wYWlycycsICAgcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvYmFsYW5jZV9wYWlycycpIF0sXG4gIFsgJ3N0cmlrZXRocm91Z2gnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3N0cmlrZXRocm91Z2gnKS5wb3N0UHJvY2VzcyBdLFxuICBbICdlbXBoYXNpcycsICAgICAgICByZXF1aXJlKCcuL3J1bGVzX2lubGluZS9lbXBoYXNpcycpLnBvc3RQcm9jZXNzIF0sXG4gIFsgJ3RleHRfY29sbGFwc2UnLCAgIHJlcXVpcmUoJy4vcnVsZXNfaW5saW5lL3RleHRfY29sbGFwc2UnKSBdXG5dO1xuXG5cbi8qKlxuICogbmV3IFBhcnNlcklubGluZSgpXG4gKiovXG5mdW5jdGlvbiBQYXJzZXJJbmxpbmUoKSB7XG4gIHZhciBpO1xuXG4gIC8qKlxuICAgKiBQYXJzZXJJbmxpbmUjcnVsZXIgLT4gUnVsZXJcbiAgICpcbiAgICogW1tSdWxlcl1dIGluc3RhbmNlLiBLZWVwIGNvbmZpZ3VyYXRpb24gb2YgaW5saW5lIHJ1bGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXIgPSBuZXcgUnVsZXIoKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgX3J1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlci5wdXNoKF9ydWxlc1tpXVswXSwgX3J1bGVzW2ldWzFdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXJJbmxpbmUjcnVsZXIyIC0+IFJ1bGVyXG4gICAqXG4gICAqIFtbUnVsZXJdXSBpbnN0YW5jZS4gU2Vjb25kIHJ1bGVyIHVzZWQgZm9yIHBvc3QtcHJvY2Vzc2luZ1xuICAgKiAoZS5nLiBpbiBlbXBoYXNpcy1saWtlIHJ1bGVzKS5cbiAgICoqL1xuICB0aGlzLnJ1bGVyMiA9IG5ldyBSdWxlcigpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBfcnVsZXMyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5ydWxlcjIucHVzaChfcnVsZXMyW2ldWzBdLCBfcnVsZXMyW2ldWzFdKTtcbiAgfVxufVxuXG5cbi8vIFNraXAgc2luZ2xlIHRva2VuIGJ5IHJ1bm5pbmcgYWxsIHJ1bGVzIGluIHZhbGlkYXRpb24gbW9kZTtcbi8vIHJldHVybnMgYHRydWVgIGlmIGFueSBydWxlIHJlcG9ydGVkIHN1Y2Nlc3Ncbi8vXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnNraXBUb2tlbiA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICB2YXIgb2ssIGksIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nLFxuICAgICAgY2FjaGUgPSBzdGF0ZS5jYWNoZTtcblxuXG4gIGlmICh0eXBlb2YgY2FjaGVbcG9zXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5wb3MgPSBjYWNoZVtwb3NdO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZXZlbCA8IG1heE5lc3RpbmcpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIC8vIEluY3JlbWVudCBzdGF0ZS5sZXZlbCBhbmQgZGVjcmVtZW50IGl0IGxhdGVyIHRvIGxpbWl0IHJlY3Vyc2lvbi5cbiAgICAgIC8vIEl0J3MgaGFybWxlc3MgdG8gZG8gaGVyZSwgYmVjYXVzZSBubyB0b2tlbnMgYXJlIGNyZWF0ZWQuIEJ1dCBpZGVhbGx5LFxuICAgICAgLy8gd2UnZCBuZWVkIGEgc2VwYXJhdGUgcHJpdmF0ZSBzdGF0ZSB2YXJpYWJsZSBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgLy9cbiAgICAgIHN0YXRlLmxldmVsKys7XG4gICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCB0cnVlKTtcbiAgICAgIHN0YXRlLmxldmVsLS07XG5cbiAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUb28gbXVjaCBuZXN0aW5nLCBqdXN0IHNraXAgdW50aWwgdGhlIGVuZCBvZiB0aGUgcGFyYWdyYXBoLlxuICAgIC8vXG4gICAgLy8gTk9URTogdGhpcyB3aWxsIGNhdXNlIGxpbmtzIHRvIGJlaGF2ZSBpbmNvcnJlY3RseSBpbiB0aGUgZm9sbG93aW5nIGNhc2UsXG4gICAgLy8gICAgICAgd2hlbiBhbiBhbW91bnQgb2YgYFtgIGlzIGV4YWN0bHkgZXF1YWwgdG8gYG1heE5lc3RpbmcgKyAxYDpcbiAgICAvL1xuICAgIC8vICAgICAgIFtbW1tbW1tbW1tbW1tbW1tbW1tbW2Zvb10oKVxuICAgIC8vXG4gICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgd29ya2Fyb3VuZCB3aGVuIENNIHN0YW5kYXJkIHdpbGwgYWxsb3cgbmVzdGVkIGxpbmtzXG4gICAgLy8gICAgICAgKHdlIGNhbiByZXBsYWNlIGl0IGJ5IHByZXZlbnRpbmcgbGlua3MgZnJvbSBiZWluZyBwYXJzZWQgaW5cbiAgICAvLyAgICAgICB2YWxpZGF0aW9uIG1vZGUpXG4gICAgLy9cbiAgICBzdGF0ZS5wb3MgPSBzdGF0ZS5wb3NNYXg7XG4gIH1cblxuICBpZiAoIW9rKSB7IHN0YXRlLnBvcysrOyB9XG4gIGNhY2hlW3Bvc10gPSBzdGF0ZS5wb3M7XG59O1xuXG5cbi8vIEdlbmVyYXRlIHRva2VucyBmb3IgaW5wdXQgcmFuZ2Vcbi8vXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLnRva2VuaXplID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHZhciBvaywgaSxcbiAgICAgIHJ1bGVzID0gdGhpcy5ydWxlci5nZXRSdWxlcygnJyksXG4gICAgICBsZW4gPSBydWxlcy5sZW5ndGgsXG4gICAgICBlbmQgPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBtYXhOZXN0aW5nID0gc3RhdGUubWQub3B0aW9ucy5tYXhOZXN0aW5nO1xuXG4gIHdoaWxlIChzdGF0ZS5wb3MgPCBlbmQpIHtcbiAgICAvLyBUcnkgYWxsIHBvc3NpYmxlIHJ1bGVzLlxuICAgIC8vIE9uIHN1Y2Nlc3MsIHJ1bGUgc2hvdWxkOlxuICAgIC8vXG4gICAgLy8gLSB1cGRhdGUgYHN0YXRlLnBvc2BcbiAgICAvLyAtIHVwZGF0ZSBgc3RhdGUudG9rZW5zYFxuICAgIC8vIC0gcmV0dXJuIHRydWVcblxuICAgIGlmIChzdGF0ZS5sZXZlbCA8IG1heE5lc3RpbmcpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBvayA9IHJ1bGVzW2ldKHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmIChvaykgeyBicmVhazsgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvaykge1xuICAgICAgaWYgKHN0YXRlLnBvcyA+PSBlbmQpIHsgYnJlYWs7IH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjW3N0YXRlLnBvcysrXTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wZW5kaW5nKSB7XG4gICAgc3RhdGUucHVzaFBlbmRpbmcoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFBhcnNlcklubGluZS5wYXJzZShzdHIsIG1kLCBlbnYsIG91dFRva2VucylcbiAqXG4gKiBQcm9jZXNzIGlucHV0IHN0cmluZyBhbmQgcHVzaCBpbmxpbmUgdG9rZW5zIGludG8gYG91dFRva2Vuc2BcbiAqKi9cblBhcnNlcklubGluZS5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc3RyLCBtZCwgZW52LCBvdXRUb2tlbnMpIHtcbiAgdmFyIGksIHJ1bGVzLCBsZW47XG4gIHZhciBzdGF0ZSA9IG5ldyB0aGlzLlN0YXRlKHN0ciwgbWQsIGVudiwgb3V0VG9rZW5zKTtcblxuICB0aGlzLnRva2VuaXplKHN0YXRlKTtcblxuICBydWxlcyA9IHRoaXMucnVsZXIyLmdldFJ1bGVzKCcnKTtcbiAgbGVuID0gcnVsZXMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJ1bGVzW2ldKHN0YXRlKTtcbiAgfVxufTtcblxuXG5QYXJzZXJJbmxpbmUucHJvdG90eXBlLlN0YXRlID0gcmVxdWlyZSgnLi9ydWxlc19pbmxpbmUvc3RhdGVfaW5saW5lJyk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQYXJzZXJJbmxpbmU7XG4iLCIvLyBDb21tb25tYXJrIGRlZmF1bHQgb3B0aW9uc1xuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIHRydWUsICAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIHRydWUsICAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAyMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdub3JtYWxpemUnLFxuICAgICAgICAnYmxvY2snLFxuICAgICAgICAnaW5saW5lJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ2Jsb2NrcXVvdGUnLFxuICAgICAgICAnY29kZScsXG4gICAgICAgICdmZW5jZScsXG4gICAgICAgICdoZWFkaW5nJyxcbiAgICAgICAgJ2hyJyxcbiAgICAgICAgJ2h0bWxfYmxvY2snLFxuICAgICAgICAnbGhlYWRpbmcnLFxuICAgICAgICAnbGlzdCcsXG4gICAgICAgICdyZWZlcmVuY2UnLFxuICAgICAgICAncGFyYWdyYXBoJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBpbmxpbmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdhdXRvbGluaycsXG4gICAgICAgICdiYWNrdGlja3MnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAnZW50aXR5JyxcbiAgICAgICAgJ2VzY2FwZScsXG4gICAgICAgICdodG1sX2lubGluZScsXG4gICAgICAgICdpbWFnZScsXG4gICAgICAgICdsaW5rJyxcbiAgICAgICAgJ25ld2xpbmUnLFxuICAgICAgICAndGV4dCdcbiAgICAgIF0sXG4gICAgICBydWxlczI6IFtcbiAgICAgICAgJ2JhbGFuY2VfcGFpcnMnLFxuICAgICAgICAnZW1waGFzaXMnLFxuICAgICAgICAndGV4dF9jb2xsYXBzZSdcbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG4iLCIvLyBtYXJrZG93bi1pdCBkZWZhdWx0IG9wdGlvbnNcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBvcHRpb25zOiB7XG4gICAgaHRtbDogICAgICAgICBmYWxzZSwgICAgICAgIC8vIEVuYWJsZSBIVE1MIHRhZ3MgaW4gc291cmNlXG4gICAgeGh0bWxPdXQ6ICAgICBmYWxzZSwgICAgICAgIC8vIFVzZSAnLycgdG8gY2xvc2Ugc2luZ2xlIHRhZ3MgKDxiciAvPilcbiAgICBicmVha3M6ICAgICAgIGZhbHNlLCAgICAgICAgLy8gQ29udmVydCAnXFxuJyBpbiBwYXJhZ3JhcGhzIGludG8gPGJyPlxuICAgIGxhbmdQcmVmaXg6ICAgJ2xhbmd1YWdlLScsICAvLyBDU1MgbGFuZ3VhZ2UgcHJlZml4IGZvciBmZW5jZWQgYmxvY2tzXG4gICAgbGlua2lmeTogICAgICBmYWxzZSwgICAgICAgIC8vIGF1dG9jb252ZXJ0IFVSTC1saWtlIHRleHRzIHRvIGxpbmtzXG5cbiAgICAvLyBFbmFibGUgc29tZSBsYW5ndWFnZS1uZXV0cmFsIHJlcGxhY2VtZW50cyArIHF1b3RlcyBiZWF1dGlmaWNhdGlvblxuICAgIHR5cG9ncmFwaGVyOiAgZmFsc2UsXG5cbiAgICAvLyBEb3VibGUgKyBzaW5nbGUgcXVvdGVzIHJlcGxhY2VtZW50IHBhaXJzLCB3aGVuIHR5cG9ncmFwaGVyIGVuYWJsZWQsXG4gICAgLy8gYW5kIHNtYXJ0cXVvdGVzIG9uLiBDb3VsZCBiZSBlaXRoZXIgYSBTdHJpbmcgb3IgYW4gQXJyYXkuXG4gICAgLy9cbiAgICAvLyBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgJ8KrwrvigJ7igJwnIGZvciBSdXNzaWFuLCAn4oCe4oCc4oCa4oCYJyBmb3IgR2VybWFuLFxuICAgIC8vIGFuZCBbJ8KrXFx4QTAnLCAnXFx4QTDCuycsICfigLlcXHhBMCcsICdcXHhBMOKAuiddIGZvciBGcmVuY2ggKGluY2x1ZGluZyBuYnNwKS5cbiAgICBxdW90ZXM6ICdcXHUyMDFjXFx1MjAxZFxcdTIwMThcXHUyMDE5JywgLyog4oCc4oCd4oCY4oCZICovXG5cbiAgICAvLyBIaWdobGlnaHRlciBmdW5jdGlvbi4gU2hvdWxkIHJldHVybiBlc2NhcGVkIEhUTUwsXG4gICAgLy8gb3IgJycgaWYgdGhlIHNvdXJjZSBzdHJpbmcgaXMgbm90IGNoYW5nZWQgYW5kIHNob3VsZCBiZSBlc2NhcGVkIGV4dGVybmFseS5cbiAgICAvLyBJZiByZXN1bHQgc3RhcnRzIHdpdGggPHByZS4uLiBpbnRlcm5hbCB3cmFwcGVyIGlzIHNraXBwZWQuXG4gICAgLy9cbiAgICAvLyBmdW5jdGlvbiAoLypzdHIsIGxhbmcqLykgeyByZXR1cm4gJyc7IH1cbiAgICAvL1xuICAgIGhpZ2hsaWdodDogbnVsbCxcblxuICAgIG1heE5lc3Rpbmc6ICAgMTAwICAgICAgICAgICAgLy8gSW50ZXJuYWwgcHJvdGVjdGlvbiwgcmVjdXJzaW9uIGxpbWl0XG4gIH0sXG5cbiAgY29tcG9uZW50czoge1xuXG4gICAgY29yZToge30sXG4gICAgYmxvY2s6IHt9LFxuICAgIGlubGluZToge31cbiAgfVxufTtcbiIsIi8vIFwiWmVyb1wiIHByZXNldCwgd2l0aCBub3RoaW5nIGVuYWJsZWQuIFVzZWZ1bCBmb3IgbWFudWFsIGNvbmZpZ3VyaW5nIG9mIHNpbXBsZVxuLy8gbW9kZXMuIEZvciBleGFtcGxlLCB0byBwYXJzZSBib2xkL2l0YWxpYyBvbmx5LlxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG9wdGlvbnM6IHtcbiAgICBodG1sOiAgICAgICAgIGZhbHNlLCAgICAgICAgLy8gRW5hYmxlIEhUTUwgdGFncyBpbiBzb3VyY2VcbiAgICB4aHRtbE91dDogICAgIGZhbHNlLCAgICAgICAgLy8gVXNlICcvJyB0byBjbG9zZSBzaW5nbGUgdGFncyAoPGJyIC8+KVxuICAgIGJyZWFrczogICAgICAgZmFsc2UsICAgICAgICAvLyBDb252ZXJ0ICdcXG4nIGluIHBhcmFncmFwaHMgaW50byA8YnI+XG4gICAgbGFuZ1ByZWZpeDogICAnbGFuZ3VhZ2UtJywgIC8vIENTUyBsYW5ndWFnZSBwcmVmaXggZm9yIGZlbmNlZCBibG9ja3NcbiAgICBsaW5raWZ5OiAgICAgIGZhbHNlLCAgICAgICAgLy8gYXV0b2NvbnZlcnQgVVJMLWxpa2UgdGV4dHMgdG8gbGlua3NcblxuICAgIC8vIEVuYWJsZSBzb21lIGxhbmd1YWdlLW5ldXRyYWwgcmVwbGFjZW1lbnRzICsgcXVvdGVzIGJlYXV0aWZpY2F0aW9uXG4gICAgdHlwb2dyYXBoZXI6ICBmYWxzZSxcblxuICAgIC8vIERvdWJsZSArIHNpbmdsZSBxdW90ZXMgcmVwbGFjZW1lbnQgcGFpcnMsIHdoZW4gdHlwb2dyYXBoZXIgZW5hYmxlZCxcbiAgICAvLyBhbmQgc21hcnRxdW90ZXMgb24uIENvdWxkIGJlIGVpdGhlciBhIFN0cmluZyBvciBhbiBBcnJheS5cbiAgICAvL1xuICAgIC8vIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSAnwqvCu+KAnuKAnCcgZm9yIFJ1c3NpYW4sICfigJ7igJzigJrigJgnIGZvciBHZXJtYW4sXG4gICAgLy8gYW5kIFsnwqtcXHhBMCcsICdcXHhBMMK7JywgJ+KAuVxceEEwJywgJ1xceEEw4oC6J10gZm9yIEZyZW5jaCAoaW5jbHVkaW5nIG5ic3ApLlxuICAgIHF1b3RlczogJ1xcdTIwMWNcXHUyMDFkXFx1MjAxOFxcdTIwMTknLCAvKiDigJzigJ3igJjigJkgKi9cblxuICAgIC8vIEhpZ2hsaWdodGVyIGZ1bmN0aW9uLiBTaG91bGQgcmV0dXJuIGVzY2FwZWQgSFRNTCxcbiAgICAvLyBvciAnJyBpZiB0aGUgc291cmNlIHN0cmluZyBpcyBub3QgY2hhbmdlZCBhbmQgc2hvdWxkIGJlIGVzY2FwZWQgZXh0ZXJuYWx5LlxuICAgIC8vIElmIHJlc3VsdCBzdGFydHMgd2l0aCA8cHJlLi4uIGludGVybmFsIHdyYXBwZXIgaXMgc2tpcHBlZC5cbiAgICAvL1xuICAgIC8vIGZ1bmN0aW9uICgvKnN0ciwgbGFuZyovKSB7IHJldHVybiAnJzsgfVxuICAgIC8vXG4gICAgaGlnaGxpZ2h0OiBudWxsLFxuXG4gICAgbWF4TmVzdGluZzogICAyMCAgICAgICAgICAgIC8vIEludGVybmFsIHByb3RlY3Rpb24sIHJlY3Vyc2lvbiBsaW1pdFxuICB9LFxuXG4gIGNvbXBvbmVudHM6IHtcblxuICAgIGNvcmU6IHtcbiAgICAgIHJ1bGVzOiBbXG4gICAgICAgICdub3JtYWxpemUnLFxuICAgICAgICAnYmxvY2snLFxuICAgICAgICAnaW5saW5lJ1xuICAgICAgXVxuICAgIH0sXG5cbiAgICBibG9jazoge1xuICAgICAgcnVsZXM6IFtcbiAgICAgICAgJ3BhcmFncmFwaCdcbiAgICAgIF1cbiAgICB9LFxuXG4gICAgaW5saW5lOiB7XG4gICAgICBydWxlczogW1xuICAgICAgICAndGV4dCdcbiAgICAgIF0sXG4gICAgICBydWxlczI6IFtcbiAgICAgICAgJ2JhbGFuY2VfcGFpcnMnLFxuICAgICAgICAndGV4dF9jb2xsYXBzZSdcbiAgICAgIF1cbiAgICB9XG4gIH1cbn07XG4iLCIvKipcbiAqIGNsYXNzIFJlbmRlcmVyXG4gKlxuICogR2VuZXJhdGVzIEhUTUwgZnJvbSBwYXJzZWQgdG9rZW4gc3RyZWFtLiBFYWNoIGluc3RhbmNlIGhhcyBpbmRlcGVuZGVudFxuICogY29weSBvZiBydWxlcy4gVGhvc2UgY2FuIGJlIHJld3JpdHRlbiB3aXRoIGVhc2UuIEFsc28sIHlvdSBjYW4gYWRkIG5ld1xuICogcnVsZXMgaWYgeW91IGNyZWF0ZSBwbHVnaW4gYW5kIGFkZHMgbmV3IHRva2VuIHR5cGVzLlxuICoqL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhc3NpZ24gICAgICAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLmFzc2lnbjtcbnZhciB1bmVzY2FwZUFsbCAgICAgPSByZXF1aXJlKCcuL2NvbW1vbi91dGlscycpLnVuZXNjYXBlQWxsO1xudmFyIGVzY2FwZUh0bWwgICAgICA9IHJlcXVpcmUoJy4vY29tbW9uL3V0aWxzJykuZXNjYXBlSHRtbDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG52YXIgZGVmYXVsdF9ydWxlcyA9IHt9O1xuXG5cbmRlZmF1bHRfcnVsZXMuY29kZV9pbmxpbmUgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHgsIG9wdGlvbnMsIGVudiwgc2xmKSB7XG4gIHZhciB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIHJldHVybiAgJzxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+Jztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5jb2RlX2Jsb2NrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICByZXR1cm4gICc8cHJlJyArIHNsZi5yZW5kZXJBdHRycyh0b2tlbikgKyAnPjxjb2RlPicgK1xuICAgICAgICAgIGVzY2FwZUh0bWwodG9rZW5zW2lkeF0uY29udGVudCkgK1xuICAgICAgICAgICc8L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblxuZGVmYXVsdF9ydWxlcy5mZW5jZSA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCBzbGYpIHtcbiAgdmFyIHRva2VuID0gdG9rZW5zW2lkeF0sXG4gICAgICBpbmZvID0gdG9rZW4uaW5mbyA/IHVuZXNjYXBlQWxsKHRva2VuLmluZm8pLnRyaW0oKSA6ICcnLFxuICAgICAgbGFuZ05hbWUgPSAnJyxcbiAgICAgIGhpZ2hsaWdodGVkLCBpLCB0bXBBdHRycywgdG1wVG9rZW47XG5cbiAgaWYgKGluZm8pIHtcbiAgICBsYW5nTmFtZSA9IGluZm8uc3BsaXQoL1xccysvZylbMF07XG4gIH1cblxuICBpZiAob3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICBoaWdobGlnaHRlZCA9IG9wdGlvbnMuaGlnaGxpZ2h0KHRva2VuLmNvbnRlbnQsIGxhbmdOYW1lKSB8fCBlc2NhcGVIdG1sKHRva2VuLmNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGhpZ2hsaWdodGVkID0gZXNjYXBlSHRtbCh0b2tlbi5jb250ZW50KTtcbiAgfVxuXG4gIGlmIChoaWdobGlnaHRlZC5pbmRleE9mKCc8cHJlJykgPT09IDApIHtcbiAgICByZXR1cm4gaGlnaGxpZ2h0ZWQgKyAnXFxuJztcbiAgfVxuXG4gIC8vIElmIGxhbmd1YWdlIGV4aXN0cywgaW5qZWN0IGNsYXNzIGdlbnRseSwgd2l0aG91dCBtb2RpZnlpbmcgb3JpZ2luYWwgdG9rZW4uXG4gIC8vIE1heSBiZSwgb25lIGRheSB3ZSB3aWxsIGFkZCAuY2xvbmUoKSBmb3IgdG9rZW4gYW5kIHNpbXBsaWZ5IHRoaXMgcGFydCwgYnV0XG4gIC8vIG5vdyB3ZSBwcmVmZXIgdG8ga2VlcCB0aGluZ3MgbG9jYWwuXG4gIGlmIChpbmZvKSB7XG4gICAgaSAgICAgICAgPSB0b2tlbi5hdHRySW5kZXgoJ2NsYXNzJyk7XG4gICAgdG1wQXR0cnMgPSB0b2tlbi5hdHRycyA/IHRva2VuLmF0dHJzLnNsaWNlKCkgOiBbXTtcblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgdG1wQXR0cnMucHVzaChbICdjbGFzcycsIG9wdGlvbnMubGFuZ1ByZWZpeCArIGxhbmdOYW1lIF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXBBdHRyc1tpXVsxXSArPSAnICcgKyBvcHRpb25zLmxhbmdQcmVmaXggKyBsYW5nTmFtZTtcbiAgICB9XG5cbiAgICAvLyBGYWtlIHRva2VuIGp1c3QgdG8gcmVuZGVyIGF0dHJpYnV0ZXNcbiAgICB0bXBUb2tlbiA9IHtcbiAgICAgIGF0dHJzOiB0bXBBdHRyc1xuICAgIH07XG5cbiAgICByZXR1cm4gICc8cHJlPjxjb2RlJyArIHNsZi5yZW5kZXJBdHRycyh0bXBUb2tlbikgKyAnPidcbiAgICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICAgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gIH1cblxuXG4gIHJldHVybiAgJzxwcmU+PGNvZGUnICsgc2xmLnJlbmRlckF0dHJzKHRva2VuKSArICc+J1xuICAgICAgICArIGhpZ2hsaWdodGVkXG4gICAgICAgICsgJzwvY29kZT48L3ByZT5cXG4nO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmltYWdlID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zLCBlbnYsIHNsZikge1xuICB2YXIgdG9rZW4gPSB0b2tlbnNbaWR4XTtcblxuICAvLyBcImFsdFwiIGF0dHIgTVVTVCBiZSBzZXQsIGV2ZW4gaWYgZW1wdHkuIEJlY2F1c2UgaXQncyBtYW5kYXRvcnkgYW5kXG4gIC8vIHNob3VsZCBiZSBwbGFjZWQgb24gcHJvcGVyIHBvc2l0aW9uIGZvciB0ZXN0cy5cbiAgLy9cbiAgLy8gUmVwbGFjZSBjb250ZW50IHdpdGggYWN0dWFsIHZhbHVlXG5cbiAgdG9rZW4uYXR0cnNbdG9rZW4uYXR0ckluZGV4KCdhbHQnKV1bMV0gPVxuICAgIHNsZi5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW4uY2hpbGRyZW4sIG9wdGlvbnMsIGVudik7XG5cbiAgcmV0dXJuIHNsZi5yZW5kZXJUb2tlbih0b2tlbnMsIGlkeCwgb3B0aW9ucyk7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMuaGFyZGJyZWFrID0gZnVuY3Rpb24gKHRva2VucywgaWR4LCBvcHRpb25zIC8qLCBlbnYgKi8pIHtcbiAgcmV0dXJuIG9wdGlvbnMueGh0bWxPdXQgPyAnPGJyIC8+XFxuJyA6ICc8YnI+XFxuJztcbn07XG5kZWZhdWx0X3J1bGVzLnNvZnRicmVhayA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCwgb3B0aW9ucyAvKiwgZW52ICovKSB7XG4gIHJldHVybiBvcHRpb25zLmJyZWFrcyA/IChvcHRpb25zLnhodG1sT3V0ID8gJzxiciAvPlxcbicgOiAnPGJyPlxcbicpIDogJ1xcbic7XG59O1xuXG5cbmRlZmF1bHRfcnVsZXMudGV4dCA9IGZ1bmN0aW9uICh0b2tlbnMsIGlkeCAvKiwgb3B0aW9ucywgZW52ICovKSB7XG4gIHJldHVybiBlc2NhcGVIdG1sKHRva2Vuc1tpZHhdLmNvbnRlbnQpO1xufTtcblxuXG5kZWZhdWx0X3J1bGVzLmh0bWxfYmxvY2sgPSBmdW5jdGlvbiAodG9rZW5zLCBpZHggLyosIG9wdGlvbnMsIGVudiAqLykge1xuICByZXR1cm4gdG9rZW5zW2lkeF0uY29udGVudDtcbn07XG5kZWZhdWx0X3J1bGVzLmh0bWxfaW5saW5lID0gZnVuY3Rpb24gKHRva2VucywgaWR4IC8qLCBvcHRpb25zLCBlbnYgKi8pIHtcbiAgcmV0dXJuIHRva2Vuc1tpZHhdLmNvbnRlbnQ7XG59O1xuXG5cbi8qKlxuICogbmV3IFJlbmRlcmVyKClcbiAqXG4gKiBDcmVhdGVzIG5ldyBbW1JlbmRlcmVyXV0gaW5zdGFuY2UgYW5kIGZpbGwgW1tSZW5kZXJlciNydWxlc11dIHdpdGggZGVmYXVsdHMuXG4gKiovXG5mdW5jdGlvbiBSZW5kZXJlcigpIHtcblxuICAvKipcbiAgICogUmVuZGVyZXIjcnVsZXMgLT4gT2JqZWN0XG4gICAqXG4gICAqIENvbnRhaW5zIHJlbmRlciBydWxlcyBmb3IgdG9rZW5zLiBDYW4gYmUgdXBkYXRlZCBhbmQgZXh0ZW5kZWQuXG4gICAqXG4gICAqICMjIyMjIEV4YW1wbGVcbiAgICpcbiAgICogYGBgamF2YXNjcmlwdFxuICAgKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gICAqXG4gICAqIG1kLnJlbmRlcmVyLnJ1bGVzLnN0cm9uZ19vcGVuICA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICc8Yj4nOyB9O1xuICAgKiBtZC5yZW5kZXJlci5ydWxlcy5zdHJvbmdfY2xvc2UgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnPC9iPic7IH07XG4gICAqXG4gICAqIHZhciByZXN1bHQgPSBtZC5yZW5kZXJJbmxpbmUoLi4uKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEVhY2ggcnVsZSBpcyBjYWxsZWQgYXMgaW5kZXBlbmRlbnQgc3RhdGljIGZ1bmN0aW9uIHdpdGggZml4ZWQgc2lnbmF0dXJlOlxuICAgKlxuICAgKiBgYGBqYXZhc2NyaXB0XG4gICAqIGZ1bmN0aW9uIG15X3Rva2VuX3JlbmRlcih0b2tlbnMsIGlkeCwgb3B0aW9ucywgZW52LCByZW5kZXJlcikge1xuICAgKiAgIC8vIC4uLlxuICAgKiAgIHJldHVybiByZW5kZXJlZEhUTUw7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIFNlZSBbc291cmNlIGNvZGVdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXJrZG93bi1pdC9tYXJrZG93bi1pdC9ibG9iL21hc3Rlci9saWIvcmVuZGVyZXIuanMpXG4gICAqIGZvciBtb3JlIGRldGFpbHMgYW5kIGV4YW1wbGVzLlxuICAgKiovXG4gIHRoaXMucnVsZXMgPSBhc3NpZ24oe30sIGRlZmF1bHRfcnVsZXMpO1xufVxuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyQXR0cnModG9rZW4pIC0+IFN0cmluZ1xuICpcbiAqIFJlbmRlciB0b2tlbiBhdHRyaWJ1dGVzIHRvIHN0cmluZy5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJBdHRycyA9IGZ1bmN0aW9uIHJlbmRlckF0dHJzKHRva2VuKSB7XG4gIHZhciBpLCBsLCByZXN1bHQ7XG5cbiAgaWYgKCF0b2tlbi5hdHRycykgeyByZXR1cm4gJyc7IH1cblxuICByZXN1bHQgPSAnJztcblxuICBmb3IgKGkgPSAwLCBsID0gdG9rZW4uYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcmVzdWx0ICs9ICcgJyArIGVzY2FwZUh0bWwodG9rZW4uYXR0cnNbaV1bMF0pICsgJz1cIicgKyBlc2NhcGVIdG1sKHRva2VuLmF0dHJzW2ldWzFdKSArICdcIic7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKipcbiAqIFJlbmRlcmVyLnJlbmRlclRva2VuKHRva2VucywgaWR4LCBvcHRpb25zKSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb2YgdG9rZW5zXG4gKiAtIGlkeCAoTnVtYmVkKTogdG9rZW4gaW5kZXggdG8gcmVuZGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqXG4gKiBEZWZhdWx0IHRva2VuIHJlbmRlcmVyLiBDYW4gYmUgb3ZlcnJpZGVuIGJ5IGN1c3RvbSBmdW5jdGlvblxuICogaW4gW1tSZW5kZXJlciNydWxlc11dLlxuICoqL1xuUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRva2VuID0gZnVuY3Rpb24gcmVuZGVyVG9rZW4odG9rZW5zLCBpZHgsIG9wdGlvbnMpIHtcbiAgdmFyIG5leHRUb2tlbixcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgbmVlZExmID0gZmFsc2UsXG4gICAgICB0b2tlbiA9IHRva2Vuc1tpZHhdO1xuXG4gIC8vIFRpZ2h0IGxpc3QgcGFyYWdyYXBoc1xuICBpZiAodG9rZW4uaGlkZGVuKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLy8gSW5zZXJ0IGEgbmV3bGluZSBiZXR3ZWVuIGhpZGRlbiBwYXJhZ3JhcGggYW5kIHN1YnNlcXVlbnQgb3BlbmluZ1xuICAvLyBibG9jay1sZXZlbCB0YWcuXG4gIC8vXG4gIC8vIEZvciBleGFtcGxlLCBoZXJlIHdlIHNob3VsZCBpbnNlcnQgYSBuZXdsaW5lIGJlZm9yZSBibG9ja3F1b3RlOlxuICAvLyAgLSBhXG4gIC8vICAgID5cbiAgLy9cbiAgaWYgKHRva2VuLmJsb2NrICYmIHRva2VuLm5lc3RpbmcgIT09IC0xICYmIGlkeCAmJiB0b2tlbnNbaWR4IC0gMV0uaGlkZGVuKSB7XG4gICAgcmVzdWx0ICs9ICdcXG4nO1xuICB9XG5cbiAgLy8gQWRkIHRva2VuIG5hbWUsIGUuZy4gYDxpbWdgXG4gIHJlc3VsdCArPSAodG9rZW4ubmVzdGluZyA9PT0gLTEgPyAnPC8nIDogJzwnKSArIHRva2VuLnRhZztcblxuICAvLyBFbmNvZGUgYXR0cmlidXRlcywgZS5nLiBgPGltZyBzcmM9XCJmb29cImBcbiAgcmVzdWx0ICs9IHRoaXMucmVuZGVyQXR0cnModG9rZW4pO1xuXG4gIC8vIEFkZCBhIHNsYXNoIGZvciBzZWxmLWNsb3NpbmcgdGFncywgZS5nLiBgPGltZyBzcmM9XCJmb29cIiAvYFxuICBpZiAodG9rZW4ubmVzdGluZyA9PT0gMCAmJiBvcHRpb25zLnhodG1sT3V0KSB7XG4gICAgcmVzdWx0ICs9ICcgLyc7XG4gIH1cblxuICAvLyBDaGVjayBpZiB3ZSBuZWVkIHRvIGFkZCBhIG5ld2xpbmUgYWZ0ZXIgdGhpcyB0YWdcbiAgaWYgKHRva2VuLmJsb2NrKSB7XG4gICAgbmVlZExmID0gdHJ1ZTtcblxuICAgIGlmICh0b2tlbi5uZXN0aW5nID09PSAxKSB7XG4gICAgICBpZiAoaWR4ICsgMSA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgbmV4dFRva2VuID0gdG9rZW5zW2lkeCArIDFdO1xuXG4gICAgICAgIGlmIChuZXh0VG9rZW4udHlwZSA9PT0gJ2lubGluZScgfHwgbmV4dFRva2VuLmhpZGRlbikge1xuICAgICAgICAgIC8vIEJsb2NrLWxldmVsIHRhZyBjb250YWluaW5nIGFuIGlubGluZSB0YWcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcblxuICAgICAgICB9IGVsc2UgaWYgKG5leHRUb2tlbi5uZXN0aW5nID09PSAtMSAmJiBuZXh0VG9rZW4udGFnID09PSB0b2tlbi50YWcpIHtcbiAgICAgICAgICAvLyBPcGVuaW5nIHRhZyArIGNsb3NpbmcgdGFnIG9mIHRoZSBzYW1lIHR5cGUuIEUuZy4gYDxsaT48L2xpPmAuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBuZWVkTGYgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlc3VsdCArPSBuZWVkTGYgPyAnPlxcbicgOiAnPic7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSZW5kZXJlci5yZW5kZXJJbmxpbmUodG9rZW5zLCBvcHRpb25zLCBlbnYpIC0+IFN0cmluZ1xuICogLSB0b2tlbnMgKEFycmF5KTogbGlzdCBvbiBibG9jayB0b2tlbnMgdG8gcmVudGVyXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHBhcmFtcyBvZiBwYXJzZXIgaW5zdGFuY2VcbiAqIC0gZW52IChPYmplY3QpOiBhZGRpdGlvbmFsIGRhdGEgZnJvbSBwYXJzZWQgaW5wdXQgKHJlZmVyZW5jZXMsIGZvciBleGFtcGxlKVxuICpcbiAqIFRoZSBzYW1lIGFzIFtbUmVuZGVyZXIucmVuZGVyXV0sIGJ1dCBmb3Igc2luZ2xlIHRva2VuIG9mIGBpbmxpbmVgIHR5cGUuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVySW5saW5lID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciB0eXBlLFxuICAgICAgcmVzdWx0ID0gJycsXG4gICAgICBydWxlcyA9IHRoaXMucnVsZXM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHR5cGUgPSB0b2tlbnNbaV0udHlwZTtcblxuICAgIGlmICh0eXBlb2YgcnVsZXNbdHlwZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXN1bHQgKz0gcnVsZXNbdHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiBpbnRlcm5hbFxuICogUmVuZGVyZXIucmVuZGVySW5saW5lQXNUZXh0KHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBTcGVjaWFsIGtsdWRnZSBmb3IgaW1hZ2UgYGFsdGAgYXR0cmlidXRlcyB0byBjb25mb3JtIENvbW1vbk1hcmsgc3BlYy5cbiAqIERvbid0IHRyeSB0byB1c2UgaXQhIFNwZWMgcmVxdWlyZXMgdG8gc2hvdyBgYWx0YCBjb250ZW50IHdpdGggc3RyaXBwZWQgbWFya3VwLFxuICogaW5zdGVhZCBvZiBzaW1wbGUgZXNjYXBpbmcuXG4gKiovXG5SZW5kZXJlci5wcm90b3R5cGUucmVuZGVySW5saW5lQXNUZXh0ID0gZnVuY3Rpb24gKHRva2Vucywgb3B0aW9ucywgZW52KSB7XG4gIHZhciByZXN1bHQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHRva2Vuc1tpXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgIHJlc3VsdCArPSB0b2tlbnNbaV0uY29udGVudDtcbiAgICB9IGVsc2UgaWYgKHRva2Vuc1tpXS50eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJJbmxpbmVBc1RleHQodG9rZW5zW2ldLmNoaWxkcmVuLCBvcHRpb25zLCBlbnYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKlxuICogUmVuZGVyZXIucmVuZGVyKHRva2Vucywgb3B0aW9ucywgZW52KSAtPiBTdHJpbmdcbiAqIC0gdG9rZW5zIChBcnJheSk6IGxpc3Qgb24gYmxvY2sgdG9rZW5zIHRvIHJlbnRlclxuICogLSBvcHRpb25zIChPYmplY3QpOiBwYXJhbXMgb2YgcGFyc2VyIGluc3RhbmNlXG4gKiAtIGVudiAoT2JqZWN0KTogYWRkaXRpb25hbCBkYXRhIGZyb20gcGFyc2VkIGlucHV0IChyZWZlcmVuY2VzLCBmb3IgZXhhbXBsZSlcbiAqXG4gKiBUYWtlcyB0b2tlbiBzdHJlYW0gYW5kIGdlbmVyYXRlcyBIVE1MLiBQcm9iYWJseSwgeW91IHdpbGwgbmV2ZXIgbmVlZCB0byBjYWxsXG4gKiB0aGlzIG1ldGhvZCBkaXJlY3RseS5cbiAqKi9cblJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodG9rZW5zLCBvcHRpb25zLCBlbnYpIHtcbiAgdmFyIGksIGxlbiwgdHlwZSxcbiAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgcnVsZXMgPSB0aGlzLnJ1bGVzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHR5cGUgPSB0b2tlbnNbaV0udHlwZTtcblxuICAgIGlmICh0eXBlID09PSAnaW5saW5lJykge1xuICAgICAgcmVzdWx0ICs9IHRoaXMucmVuZGVySW5saW5lKHRva2Vuc1tpXS5jaGlsZHJlbiwgb3B0aW9ucywgZW52KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBydWxlc1t0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdCArPSBydWxlc1t0b2tlbnNbaV0udHlwZV0odG9rZW5zLCBpLCBvcHRpb25zLCBlbnYsIHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgKz0gdGhpcy5yZW5kZXJUb2tlbih0b2tlbnMsIGksIG9wdGlvbnMsIGVudik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyZXI7XG4iLCIvKipcbiAqIGNsYXNzIFJ1bGVyXG4gKlxuICogSGVscGVyIGNsYXNzLCB1c2VkIGJ5IFtbTWFya2Rvd25JdCNjb3JlXV0sIFtbTWFya2Rvd25JdCNibG9ja11dIGFuZFxuICogW1tNYXJrZG93bkl0I2lubGluZV1dIHRvIG1hbmFnZSBzZXF1ZW5jZXMgb2YgZnVuY3Rpb25zIChydWxlcyk6XG4gKlxuICogLSBrZWVwIHJ1bGVzIGluIGRlZmluZWQgb3JkZXJcbiAqIC0gYXNzaWduIHRoZSBuYW1lIHRvIGVhY2ggcnVsZVxuICogLSBlbmFibGUvZGlzYWJsZSBydWxlc1xuICogLSBhZGQvcmVwbGFjZSBydWxlc1xuICogLSBhbGxvdyBhc3NpZ24gcnVsZXMgdG8gYWRkaXRpb25hbCBuYW1lZCBjaGFpbnMgKGluIHRoZSBzYW1lKVxuICogLSBjYWNoZWluZyBsaXN0cyBvZiBhY3RpdmUgcnVsZXNcbiAqXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCB1c2UgdGhpcyBjbGFzcyBkaXJlY3RseSB1bnRpbCB3cml0ZSBwbHVnaW5zLiBGb3Igc2ltcGxlXG4gKiBydWxlcyBjb250cm9sIHVzZSBbW01hcmtkb3duSXQuZGlzYWJsZV1dLCBbW01hcmtkb3duSXQuZW5hYmxlXV0gYW5kXG4gKiBbW01hcmtkb3duSXQudXNlXV0uXG4gKiovXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBuZXcgUnVsZXIoKVxuICoqL1xuZnVuY3Rpb24gUnVsZXIoKSB7XG4gIC8vIExpc3Qgb2YgYWRkZWQgcnVsZXMuIEVhY2ggZWxlbWVudCBpczpcbiAgLy9cbiAgLy8ge1xuICAvLyAgIG5hbWU6IFhYWCxcbiAgLy8gICBlbmFibGVkOiBCb29sZWFuLFxuICAvLyAgIGZuOiBGdW5jdGlvbigpLFxuICAvLyAgIGFsdDogWyBuYW1lMiwgbmFtZTMgXVxuICAvLyB9XG4gIC8vXG4gIHRoaXMuX19ydWxlc19fID0gW107XG5cbiAgLy8gQ2FjaGVkIHJ1bGUgY2hhaW5zLlxuICAvL1xuICAvLyBGaXJzdCBsZXZlbCAtIGNoYWluIG5hbWUsICcnIGZvciBkZWZhdWx0LlxuICAvLyBTZWNvbmQgbGV2ZWwgLSBkaWdpbmFsIGFuY2hvciBmb3IgZmFzdCBmaWx0ZXJpbmcgYnkgY2hhcmNvZGVzLlxuICAvL1xuICB0aGlzLl9fY2FjaGVfXyA9IG51bGw7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgbWV0aG9kcywgc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5XG5cblxuLy8gRmluZCBydWxlIGluZGV4IGJ5IG5hbWVcbi8vXG5SdWxlci5wcm90b3R5cGUuX19maW5kX18gPSBmdW5jdGlvbiAobmFtZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX19ydWxlc19fLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuX19ydWxlc19fW2ldLm5hbWUgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59O1xuXG5cbi8vIEJ1aWxkIHJ1bGVzIGxvb2t1cCBjYWNoZVxuLy9cblJ1bGVyLnByb3RvdHlwZS5fX2NvbXBpbGVfXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2hhaW5zID0gWyAnJyBdO1xuXG4gIC8vIGNvbGxlY3QgdW5pcXVlIG5hbWVzXG4gIHNlbGYuX19ydWxlc19fLmZvckVhY2goZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICBpZiAoIXJ1bGUuZW5hYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHJ1bGUuYWx0LmZvckVhY2goZnVuY3Rpb24gKGFsdE5hbWUpIHtcbiAgICAgIGlmIChjaGFpbnMuaW5kZXhPZihhbHROYW1lKSA8IDApIHtcbiAgICAgICAgY2hhaW5zLnB1c2goYWx0TmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHNlbGYuX19jYWNoZV9fID0ge307XG5cbiAgY2hhaW5zLmZvckVhY2goZnVuY3Rpb24gKGNoYWluKSB7XG4gICAgc2VsZi5fX2NhY2hlX19bY2hhaW5dID0gW107XG4gICAgc2VsZi5fX3J1bGVzX18uZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgaWYgKCFydWxlLmVuYWJsZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgIGlmIChjaGFpbiAmJiBydWxlLmFsdC5pbmRleE9mKGNoYWluKSA8IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgIHNlbGYuX19jYWNoZV9fW2NoYWluXS5wdXNoKHJ1bGUuZm4pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5hdChuYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gbmFtZSAoU3RyaW5nKTogcnVsZSBuYW1lIHRvIHJlcGxhY2UuXG4gKiAtIGZuIChGdW5jdGlvbik6IG5ldyBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBuZXcgcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBSZXBsYWNlIHJ1bGUgYnkgbmFtZSB3aXRoIG5ldyBmdW5jdGlvbiAmIG9wdGlvbnMuIFRocm93cyBlcnJvciBpZiBuYW1lIG5vdFxuICogZm91bmQuXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBSZXBsYWNlIGV4aXN0aW5nIHR5cG9ncmFwaGVyIHJlcGxhY2VtZW50IHJ1bGUgd2l0aCBuZXcgb25lOlxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5jb3JlLnJ1bGVyLmF0KCdyZXBsYWNlbWVudHMnLCBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gKiAgIC8vLi4uXG4gKiB9KTtcbiAqIGBgYFxuICoqL1xuUnVsZXIucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX19maW5kX18obmFtZSk7XG4gIHZhciBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHsgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgcnVsZSBub3QgZm91bmQ6ICcgKyBuYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fW2luZGV4XS5mbiA9IGZuO1xuICB0aGlzLl9fcnVsZXNfX1tpbmRleF0uYWx0ID0gb3B0LmFsdCB8fCBbXTtcbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmJlZm9yZShiZWZvcmVOYW1lLCBydWxlTmFtZSwgZm4gWywgb3B0aW9uc10pXG4gKiAtIGJlZm9yZU5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYmVmb3JlIHRoaXMgb25lLlxuICogLSBydWxlTmFtZSAoU3RyaW5nKTogbmFtZSBvZiBhZGRlZCBydWxlLlxuICogLSBmbiAoRnVuY3Rpb24pOiBydWxlIGZ1bmN0aW9uLlxuICogLSBvcHRpb25zIChPYmplY3QpOiBydWxlIG9wdGlvbnMgKG5vdCBtYW5kYXRvcnkpLlxuICpcbiAqIEFkZCBuZXcgcnVsZSB0byBjaGFpbiBiZWZvcmUgb25lIHdpdGggZ2l2ZW4gbmFtZS4gU2VlIGFsc29cbiAqIFtbUnVsZXIuYWZ0ZXJdXSwgW1tSdWxlci5wdXNoXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuYmxvY2sucnVsZXIuYmVmb3JlKCdwYXJhZ3JhcGgnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYmVmb3JlID0gZnVuY3Rpb24gKGJlZm9yZU5hbWUsIHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgaW5kZXggPSB0aGlzLl9fZmluZF9fKGJlZm9yZU5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYmVmb3JlTmFtZSk7IH1cblxuICB0aGlzLl9fcnVsZXNfXy5zcGxpY2UoaW5kZXgsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmFmdGVyKGFmdGVyTmFtZSwgcnVsZU5hbWUsIGZuIFssIG9wdGlvbnNdKVxuICogLSBhZnRlck5hbWUgKFN0cmluZyk6IG5ldyBydWxlIHdpbGwgYmUgYWRkZWQgYWZ0ZXIgdGhpcyBvbmUuXG4gKiAtIHJ1bGVOYW1lIChTdHJpbmcpOiBuYW1lIG9mIGFkZGVkIHJ1bGUuXG4gKiAtIGZuIChGdW5jdGlvbik6IHJ1bGUgZnVuY3Rpb24uXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHJ1bGUgb3B0aW9ucyAobm90IG1hbmRhdG9yeSkuXG4gKlxuICogQWRkIG5ldyBydWxlIHRvIGNoYWluIGFmdGVyIG9uZSB3aXRoIGdpdmVuIG5hbWUuIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLnB1c2hdXS5cbiAqXG4gKiAjIyMjIyBPcHRpb25zOlxuICpcbiAqIC0gX19hbHRfXyAtIGFycmF5IHdpdGggbmFtZXMgb2YgXCJhbHRlcm5hdGVcIiBjaGFpbnMuXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHZhciBtZCA9IHJlcXVpcmUoJ21hcmtkb3duLWl0JykoKTtcbiAqXG4gKiBtZC5pbmxpbmUucnVsZXIuYWZ0ZXIoJ3RleHQnLCAnbXlfcnVsZScsIGZ1bmN0aW9uIHJlcGxhY2Uoc3RhdGUpIHtcbiAqICAgLy8uLi5cbiAqIH0pO1xuICogYGBgXG4gKiovXG5SdWxlci5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoYWZ0ZXJOYW1lLCBydWxlTmFtZSwgZm4sIG9wdGlvbnMpIHtcbiAgdmFyIGluZGV4ID0gdGhpcy5fX2ZpbmRfXyhhZnRlck5hbWUpO1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICBpZiAoaW5kZXggPT09IC0xKSB7IHRocm93IG5ldyBFcnJvcignUGFyc2VyIHJ1bGUgbm90IGZvdW5kOiAnICsgYWZ0ZXJOYW1lKTsgfVxuXG4gIHRoaXMuX19ydWxlc19fLnNwbGljZShpbmRleCArIDEsIDAsIHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSdWxlci5wdXNoKHJ1bGVOYW1lLCBmbiBbLCBvcHRpb25zXSlcbiAqIC0gcnVsZU5hbWUgKFN0cmluZyk6IG5hbWUgb2YgYWRkZWQgcnVsZS5cbiAqIC0gZm4gKEZ1bmN0aW9uKTogcnVsZSBmdW5jdGlvbi5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogcnVsZSBvcHRpb25zIChub3QgbWFuZGF0b3J5KS5cbiAqXG4gKiBQdXNoIG5ldyBydWxlIHRvIHRoZSBlbmQgb2YgY2hhaW4uIFNlZSBhbHNvXG4gKiBbW1J1bGVyLmJlZm9yZV1dLCBbW1J1bGVyLmFmdGVyXV0uXG4gKlxuICogIyMjIyMgT3B0aW9uczpcbiAqXG4gKiAtIF9fYWx0X18gLSBhcnJheSB3aXRoIG5hbWVzIG9mIFwiYWx0ZXJuYXRlXCIgY2hhaW5zLlxuICpcbiAqICMjIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgbWQgPSByZXF1aXJlKCdtYXJrZG93bi1pdCcpKCk7XG4gKlxuICogbWQuY29yZS5ydWxlci5wdXNoKCdteV9ydWxlJywgZnVuY3Rpb24gcmVwbGFjZShzdGF0ZSkge1xuICogICAvLy4uLlxuICogfSk7XG4gKiBgYGBcbiAqKi9cblJ1bGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHJ1bGVOYW1lLCBmbiwgb3B0aW9ucykge1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcblxuICB0aGlzLl9fcnVsZXNfXy5wdXNoKHtcbiAgICBuYW1lOiBydWxlTmFtZSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGZuOiBmbixcbiAgICBhbHQ6IG9wdC5hbHQgfHwgW11cbiAgfSk7XG5cbiAgdGhpcy5fX2NhY2hlX18gPSBudWxsO1xufTtcblxuXG4vKipcbiAqIFJ1bGVyLmVuYWJsZShsaXN0IFssIGlnbm9yZUludmFsaWRdKSAtPiBBcnJheVxuICogLSBsaXN0IChTdHJpbmd8QXJyYXkpOiBsaXN0IG9mIHJ1bGUgbmFtZXMgdG8gZW5hYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRW5hYmxlIHJ1bGVzIHdpdGggZ2l2ZW4gbmFtZXMuIElmIGFueSBydWxlIG5hbWUgbm90IGZvdW5kIC0gdGhyb3cgRXJyb3IuXG4gKiBFcnJvcnMgY2FuIGJlIGRpc2FibGVkIGJ5IHNlY29uZCBwYXJhbS5cbiAqXG4gKiBSZXR1cm5zIGxpc3Qgb2YgZm91bmQgcnVsZSBuYW1lcyAoaWYgbm8gZXhjZXB0aW9uIGhhcHBlbmVkKS5cbiAqXG4gKiBTZWUgYWxzbyBbW1J1bGVyLmRpc2FibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGxpc3QsIGlnbm9yZUludmFsaWQpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7IGxpc3QgPSBbIGxpc3QgXTsgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcblxuICAvLyBTZWFyY2ggYnkgbmFtZSBhbmQgZW5hYmxlXG4gIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBpZHggPSB0aGlzLl9fZmluZF9fKG5hbWUpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIGlmIChpZ25vcmVJbnZhbGlkKSB7IHJldHVybjsgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlcyBtYW5hZ2VyOiBpbnZhbGlkIHJ1bGUgbmFtZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHRoaXMuX19ydWxlc19fW2lkeF0uZW5hYmxlZCA9IHRydWU7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5lbmFibGVPbmx5KGxpc3QgWywgaWdub3JlSW52YWxpZF0pXG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBlbmFibGUgKHdoaXRlbGlzdCkuXG4gKiAtIGlnbm9yZUludmFsaWQgKEJvb2xlYW4pOiBzZXQgYHRydWVgIHRvIGlnbm9yZSBlcnJvcnMgd2hlbiBydWxlIG5vdCBmb3VuZC5cbiAqXG4gKiBFbmFibGUgcnVsZXMgd2l0aCBnaXZlbiBuYW1lcywgYW5kIGRpc2FibGUgZXZlcnl0aGluZyBlbHNlLiBJZiBhbnkgcnVsZSBuYW1lXG4gKiBub3QgZm91bmQgLSB0aHJvdyBFcnJvci4gRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5kaXNhYmxlXV0sIFtbUnVsZXIuZW5hYmxlXV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZW5hYmxlT25seSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB0aGlzLl9fcnVsZXNfXy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7IHJ1bGUuZW5hYmxlZCA9IGZhbHNlOyB9KTtcblxuICB0aGlzLmVuYWJsZShsaXN0LCBpZ25vcmVJbnZhbGlkKTtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5kaXNhYmxlKGxpc3QgWywgaWdub3JlSW52YWxpZF0pIC0+IEFycmF5XG4gKiAtIGxpc3QgKFN0cmluZ3xBcnJheSk6IGxpc3Qgb2YgcnVsZSBuYW1lcyB0byBkaXNhYmxlLlxuICogLSBpZ25vcmVJbnZhbGlkIChCb29sZWFuKTogc2V0IGB0cnVlYCB0byBpZ25vcmUgZXJyb3JzIHdoZW4gcnVsZSBub3QgZm91bmQuXG4gKlxuICogRGlzYWJsZSBydWxlcyB3aXRoIGdpdmVuIG5hbWVzLiBJZiBhbnkgcnVsZSBuYW1lIG5vdCBmb3VuZCAtIHRocm93IEVycm9yLlxuICogRXJyb3JzIGNhbiBiZSBkaXNhYmxlZCBieSBzZWNvbmQgcGFyYW0uXG4gKlxuICogUmV0dXJucyBsaXN0IG9mIGZvdW5kIHJ1bGUgbmFtZXMgKGlmIG5vIGV4Y2VwdGlvbiBoYXBwZW5lZCkuXG4gKlxuICogU2VlIGFsc28gW1tSdWxlci5lbmFibGVdXSwgW1tSdWxlci5lbmFibGVPbmx5XV0uXG4gKiovXG5SdWxlci5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uIChsaXN0LCBpZ25vcmVJbnZhbGlkKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkgeyBsaXN0ID0gWyBsaXN0IF07IH1cblxuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgLy8gU2VhcmNoIGJ5IG5hbWUgYW5kIGRpc2FibGVcbiAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX19maW5kX18obmFtZSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgaWYgKGlnbm9yZUludmFsaWQpIHsgcmV0dXJuOyB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1J1bGVzIG1hbmFnZXI6IGludmFsaWQgcnVsZSBuYW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5fX3J1bGVzX19baWR4XS5lbmFibGVkID0gZmFsc2U7XG4gICAgcmVzdWx0LnB1c2gobmFtZSk7XG4gIH0sIHRoaXMpO1xuXG4gIHRoaXMuX19jYWNoZV9fID0gbnVsbDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuLyoqXG4gKiBSdWxlci5nZXRSdWxlcyhjaGFpbk5hbWUpIC0+IEFycmF5XG4gKlxuICogUmV0dXJuIGFycmF5IG9mIGFjdGl2ZSBmdW5jdGlvbnMgKHJ1bGVzKSBmb3IgZ2l2ZW4gY2hhaW4gbmFtZS4gSXQgYW5hbHl6ZXNcbiAqIHJ1bGVzIGNvbmZpZ3VyYXRpb24sIGNvbXBpbGVzIGNhY2hlcyBpZiBub3QgZXhpc3RzIGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBEZWZhdWx0IGNoYWluIG5hbWUgaXMgYCcnYCAoZW1wdHkgc3RyaW5nKS4gSXQgY2FuJ3QgYmUgc2tpcHBlZC4gVGhhdCdzXG4gKiBkb25lIGludGVudGlvbmFsbHksIHRvIGtlZXAgc2lnbmF0dXJlIG1vbm9tb3JwaGljIGZvciBoaWdoIHNwZWVkLlxuICoqL1xuUnVsZXIucHJvdG90eXBlLmdldFJ1bGVzID0gZnVuY3Rpb24gKGNoYWluTmFtZSkge1xuICBpZiAodGhpcy5fX2NhY2hlX18gPT09IG51bGwpIHtcbiAgICB0aGlzLl9fY29tcGlsZV9fKCk7XG4gIH1cblxuICAvLyBDaGFpbiBjYW4gYmUgZW1wdHksIGlmIHJ1bGVzIGRpc2FibGVkLiBCdXQgd2Ugc3RpbGwgaGF2ZSB0byByZXR1cm4gQXJyYXkuXG4gIHJldHVybiB0aGlzLl9fY2FjaGVfX1tjaGFpbk5hbWVdIHx8IFtdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSdWxlcjtcbiIsIi8vIEJsb2NrIHF1b3Rlc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJsb2NrcXVvdGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBhZGp1c3RUYWIsXG4gICAgICBjaCxcbiAgICAgIGksXG4gICAgICBpbml0aWFsLFxuICAgICAgbCxcbiAgICAgIGxhc3RMaW5lRW1wdHksXG4gICAgICBsaW5lcyxcbiAgICAgIG5leHRMaW5lLFxuICAgICAgb2Zmc2V0LFxuICAgICAgb2xkQk1hcmtzLFxuICAgICAgb2xkQlNDb3VudCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZFBhcmVudFR5cGUsXG4gICAgICBvbGRTQ291bnQsXG4gICAgICBvbGRUU2hpZnQsXG4gICAgICBzcGFjZUFmdGVyTWFya2VyLFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICB3YXNPdXRkZW50ZWQsXG4gICAgICBvbGRMaW5lTWF4ID0gc3RhdGUubGluZU1heCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjaGVjayB0aGUgYmxvY2sgcXVvdGUgbWFya2VyXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKykgIT09IDB4M0UvKiA+ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIHdlIGtub3cgdGhhdCBpdCdzIGdvaW5nIHRvIGJlIGEgdmFsaWQgYmxvY2txdW90ZSxcbiAgLy8gc28gbm8gcG9pbnQgdHJ5aW5nIHRvIGZpbmQgdGhlIGVuZCBvZiBpdCBpbiBzaWxlbnQgbW9kZVxuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgLy8gc2tpcCBzcGFjZXMgYWZ0ZXIgXCI+XCIgYW5kIHJlLWNhbGN1bGF0ZSBvZmZzZXRcbiAgaW5pdGlhbCA9IG9mZnNldCA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdICsgcG9zIC0gKHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0pO1xuXG4gIC8vIHNraXAgb25lIG9wdGlvbmFsIHNwYWNlIGFmdGVyICc+J1xuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgIC8vICcgPiAgIHRlc3QgJ1xuICAgIC8vICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZTpcbiAgICBwb3MrKztcbiAgICBpbml0aWFsKys7XG4gICAgb2Zmc2V0Kys7XG4gICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgc3BhY2VBZnRlck1hcmtlciA9IHRydWU7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwOSAvKiB0YWIgKi8pIHtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcblxuICAgIGlmICgoc3RhdGUuYnNDb3VudFtzdGFydExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgIC8vICcgID5cXHQgIHRlc3QgJ1xuICAgICAgLy8gICAgICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKHRhYiBoYXMgd2lkdGg9PT0xKVxuICAgICAgcG9zKys7XG4gICAgICBpbml0aWFsKys7XG4gICAgICBvZmZzZXQrKztcbiAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyAnID5cXHQgIHRlc3QgJ1xuICAgICAgLy8gICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKyBzaGlmdCBic0NvdW50IHNsaWdodGx5XG4gICAgICAvLyAgICAgICAgIHRvIG1ha2UgZXh0cmEgc3BhY2UgYXBwZWFyXG4gICAgICBhZGp1c3RUYWIgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzcGFjZUFmdGVyTWFya2VyID0gZmFsc2U7XG4gIH1cblxuICBvbGRCTWFya3MgPSBbIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdIF07XG4gIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdID0gcG9zO1xuXG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gKyAoYWRqdXN0VGFiID8gMSA6IDApKSAlIDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBvbGRCU0NvdW50ID0gWyBzdGF0ZS5ic0NvdW50W3N0YXJ0TGluZV0gXTtcbiAgc3RhdGUuYnNDb3VudFtzdGFydExpbmVdID0gc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG5cbiAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XG5cbiAgb2xkU0NvdW50ID0gWyBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG5cbiAgb2xkVFNoaWZ0ID0gWyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSBdO1xuICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tzdGFydExpbmVdO1xuXG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdibG9ja3F1b3RlJyk7XG5cbiAgb2xkUGFyZW50VHlwZSA9IHN0YXRlLnBhcmVudFR5cGU7XG4gIHN0YXRlLnBhcmVudFR5cGUgPSAnYmxvY2txdW90ZSc7XG4gIHdhc091dGRlbnRlZCA9IGZhbHNlO1xuXG4gIC8vIFNlYXJjaCB0aGUgZW5kIG9mIHRoZSBibG9ja1xuICAvL1xuICAvLyBCbG9jayBlbmRzIHdpdGggZWl0aGVyOlxuICAvLyAgMS4gYW4gZW1wdHkgbGluZSBvdXRzaWRlOlxuICAvLyAgICAgYGBgXG4gIC8vICAgICA+IHRlc3RcbiAgLy9cbiAgLy8gICAgIGBgYFxuICAvLyAgMi4gYW4gZW1wdHkgbGluZSBpbnNpZGU6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID5cbiAgLy8gICAgIHRlc3RcbiAgLy8gICAgIGBgYFxuICAvLyAgMy4gYW5vdGhlciB0YWc6XG4gIC8vICAgICBgYGBcbiAgLy8gICAgID4gdGVzdFxuICAvLyAgICAgIC0gLSAtXG4gIC8vICAgICBgYGBcbiAgZm9yIChuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7IG5leHRMaW5lIDwgZW5kTGluZTsgbmV4dExpbmUrKykge1xuICAgIC8vIGNoZWNrIGlmIGl0J3Mgb3V0ZGVudGVkLCBpLmUuIGl0J3MgaW5zaWRlIGxpc3QgaXRlbSBhbmQgaW5kZW50ZWRcbiAgICAvLyBsZXNzIHRoYW4gc2FpZCBsaXN0IGl0ZW06XG4gICAgLy9cbiAgICAvLyBgYGBcbiAgICAvLyAxLiBhbnl0aGluZ1xuICAgIC8vICAgID4gY3VycmVudCBibG9ja3F1b3RlXG4gICAgLy8gMi4gY2hlY2tpbmcgdGhpcyBsaW5lXG4gICAgLy8gYGBgXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHdhc091dGRlbnRlZCA9IHRydWU7XG5cbiAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICBtYXggPSBzdGF0ZS5lTWFya3NbbmV4dExpbmVdO1xuXG4gICAgaWYgKHBvcyA+PSBtYXgpIHtcbiAgICAgIC8vIENhc2UgMTogbGluZSBpcyBub3QgaW5zaWRlIHRoZSBibG9ja3F1b3RlLCBhbmQgdGhpcyBsaW5lIGlzIGVtcHR5LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKSA9PT0gMHgzRS8qID4gKi8gJiYgIXdhc091dGRlbnRlZCkge1xuICAgICAgLy8gVGhpcyBsaW5lIGlzIGluc2lkZSB0aGUgYmxvY2txdW90ZS5cblxuICAgICAgLy8gc2tpcCBzcGFjZXMgYWZ0ZXIgXCI+XCIgYW5kIHJlLWNhbGN1bGF0ZSBvZmZzZXRcbiAgICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zIC0gKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcblxuICAgICAgLy8gc2tpcCBvbmUgb3B0aW9uYWwgc3BhY2UgYWZ0ZXIgJz4nXG4gICAgICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyMCAvKiBzcGFjZSAqLykge1xuICAgICAgICAvLyAnID4gICB0ZXN0ICdcbiAgICAgICAgLy8gICAgIF4gLS0gcG9zaXRpb24gc3RhcnQgb2YgbGluZSBoZXJlOlxuICAgICAgICBwb3MrKztcbiAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgYWRqdXN0VGFiID0gZmFsc2U7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDA5IC8qIHRhYiAqLykge1xuICAgICAgICBzcGFjZUFmdGVyTWFya2VyID0gdHJ1ZTtcblxuICAgICAgICBpZiAoKHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgb2Zmc2V0KSAlIDQgPT09IDMpIHtcbiAgICAgICAgICAvLyAnICA+XFx0ICB0ZXN0ICdcbiAgICAgICAgICAvLyAgICAgICBeIC0tIHBvc2l0aW9uIHN0YXJ0IG9mIGxpbmUgaGVyZSAodGFiIGhhcyB3aWR0aD09PTEpXG4gICAgICAgICAgcG9zKys7XG4gICAgICAgICAgaW5pdGlhbCsrO1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgIGFkanVzdFRhYiA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vICcgPlxcdCAgdGVzdCAnXG4gICAgICAgICAgLy8gICAgXiAtLSBwb3NpdGlvbiBzdGFydCBvZiBsaW5lIGhlcmUgKyBzaGlmdCBic0NvdW50IHNsaWdodGx5XG4gICAgICAgICAgLy8gICAgICAgICB0byBtYWtlIGV4dHJhIHNwYWNlIGFwcGVhclxuICAgICAgICAgIGFkanVzdFRhYiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNwYWNlQWZ0ZXJNYXJrZXIgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgb2xkQk1hcmtzLnB1c2goc3RhdGUuYk1hcmtzW25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5iTWFya3NbbmV4dExpbmVdID0gcG9zO1xuXG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICAgIG9mZnNldCArPSA0IC0gKG9mZnNldCArIHN0YXRlLmJzQ291bnRbbmV4dExpbmVdICsgKGFkanVzdFRhYiA/IDEgOiAwKSkgJSA0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBwb3MrKztcbiAgICAgIH1cblxuICAgICAgbGFzdExpbmVFbXB0eSA9IHBvcyA+PSBtYXg7XG5cbiAgICAgIG9sZEJTQ291bnQucHVzaChzdGF0ZS5ic0NvdW50W25leHRMaW5lXSk7XG4gICAgICBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSA9IHN0YXRlLnNDb3VudFtuZXh0TGluZV0gKyAxICsgKHNwYWNlQWZ0ZXJNYXJrZXIgPyAxIDogMCk7XG5cbiAgICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUuc0NvdW50W25leHRMaW5lXSA9IG9mZnNldCAtIGluaXRpYWw7XG5cbiAgICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgICAgc3RhdGUudFNoaWZ0W25leHRMaW5lXSA9IHBvcyAtIHN0YXRlLmJNYXJrc1tuZXh0TGluZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBDYXNlIDI6IGxpbmUgaXMgbm90IGluc2lkZSB0aGUgYmxvY2txdW90ZSwgYW5kIHRoZSBsYXN0IGxpbmUgd2FzIGVtcHR5LlxuICAgIGlmIChsYXN0TGluZUVtcHR5KSB7IGJyZWFrOyB9XG5cbiAgICAvLyBDYXNlIDM6IGFub3RoZXIgdGFnIGZvdW5kLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRlcm1pbmF0ZSkge1xuICAgICAgLy8gUXVpcmsgdG8gZW5mb3JjZSBcImhhcmQgdGVybWluYXRpb24gbW9kZVwiIGZvciBwYXJhZ3JhcGhzO1xuICAgICAgLy8gbm9ybWFsbHkgaWYgeW91IGNhbGwgYHRva2VuaXplKHN0YXRlLCBzdGFydExpbmUsIG5leHRMaW5lKWAsXG4gICAgICAvLyBwYXJhZ3JhcGhzIHdpbGwgbG9vayBiZWxvdyBuZXh0TGluZSBmb3IgcGFyYWdyYXBoIGNvbnRpbnVhdGlvbixcbiAgICAgIC8vIGJ1dCBpZiBibG9ja3F1b3RlIGlzIHRlcm1pbmF0ZWQgYnkgYW5vdGhlciB0YWcsIHRoZXkgc2hvdWxkbid0XG4gICAgICBzdGF0ZS5saW5lTWF4ID0gbmV4dExpbmU7XG5cbiAgICAgIGlmIChzdGF0ZS5ibGtJbmRlbnQgIT09IDApIHtcbiAgICAgICAgLy8gc3RhdGUuYmxrSW5kZW50IHdhcyBub24temVybywgd2Ugbm93IHNldCBpdCB0byB6ZXJvLFxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZSBhbGwgb2Zmc2V0cyB0byBhcHBlYXIgYXNcbiAgICAgICAgLy8gaWYgaW5kZW50IHdhc24ndCBjaGFuZ2VkXG4gICAgICAgIG9sZEJNYXJrcy5wdXNoKHN0YXRlLmJNYXJrc1tuZXh0TGluZV0pO1xuICAgICAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgICAgICBvbGRUU2hpZnQucHVzaChzdGF0ZS50U2hpZnRbbmV4dExpbmVdKTtcbiAgICAgICAgb2xkU0NvdW50LnB1c2goc3RhdGUuc0NvdW50W25leHRMaW5lXSk7XG4gICAgICAgIHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLT0gc3RhdGUuYmxrSW5kZW50O1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBvbGRCTWFya3MucHVzaChzdGF0ZS5iTWFya3NbbmV4dExpbmVdKTtcbiAgICBvbGRCU0NvdW50LnB1c2goc3RhdGUuYnNDb3VudFtuZXh0TGluZV0pO1xuICAgIG9sZFRTaGlmdC5wdXNoKHN0YXRlLnRTaGlmdFtuZXh0TGluZV0pO1xuICAgIG9sZFNDb3VudC5wdXNoKHN0YXRlLnNDb3VudFtuZXh0TGluZV0pO1xuXG4gICAgLy8gQSBuZWdhdGl2ZSBpbmRlbnRhdGlvbiBtZWFucyB0aGF0IHRoaXMgaXMgYSBwYXJhZ3JhcGggY29udGludWF0aW9uXG4gICAgLy9cbiAgICBzdGF0ZS5zQ291bnRbbmV4dExpbmVdID0gLTE7XG4gIH1cblxuICBvbGRJbmRlbnQgPSBzdGF0ZS5ibGtJbmRlbnQ7XG4gIHN0YXRlLmJsa0luZGVudCA9IDA7XG5cbiAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnYmxvY2txdW90ZV9vcGVuJywgJ2Jsb2NrcXVvdGUnLCAxKTtcbiAgdG9rZW4ubWFya3VwID0gJz4nO1xuICB0b2tlbi5tYXAgICAgPSBsaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG5cbiAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgbmV4dExpbmUpO1xuXG4gIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2Jsb2NrcXVvdGVfY2xvc2UnLCAnYmxvY2txdW90ZScsIC0xKTtcbiAgdG9rZW4ubWFya3VwID0gJz4nO1xuXG4gIHN0YXRlLmxpbmVNYXggPSBvbGRMaW5lTWF4O1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcbiAgbGluZXNbMV0gPSBzdGF0ZS5saW5lO1xuXG4gIC8vIFJlc3RvcmUgb3JpZ2luYWwgdFNoaWZ0OyB0aGlzIG1pZ2h0IG5vdCBiZSBuZWNlc3Nhcnkgc2luY2UgdGhlIHBhcnNlclxuICAvLyBoYXMgYWxyZWFkeSBiZWVuIGhlcmUsIGJ1dCBqdXN0IHRvIG1ha2Ugc3VyZSB3ZSBjYW4gZG8gdGhhdC5cbiAgZm9yIChpID0gMDsgaSA8IG9sZFRTaGlmdC5sZW5ndGg7IGkrKykge1xuICAgIHN0YXRlLmJNYXJrc1tpICsgc3RhcnRMaW5lXSA9IG9sZEJNYXJrc1tpXTtcbiAgICBzdGF0ZS50U2hpZnRbaSArIHN0YXJ0TGluZV0gPSBvbGRUU2hpZnRbaV07XG4gICAgc3RhdGUuc0NvdW50W2kgKyBzdGFydExpbmVdID0gb2xkU0NvdW50W2ldO1xuICAgIHN0YXRlLmJzQ291bnRbaSArIHN0YXJ0TGluZV0gPSBvbGRCU0NvdW50W2ldO1xuICB9XG4gIHN0YXRlLmJsa0luZGVudCA9IG9sZEluZGVudDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBDb2RlIGJsb2NrICg0IHNwYWNlcyBwYWRkZWQpXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvZGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZS8qLCBzaWxlbnQqLykge1xuICB2YXIgbmV4dExpbmUsIGxhc3QsIHRva2VuO1xuXG4gIGlmIChzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA8IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFzdCA9IG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgaWYgKHN0YXRlLmlzRW1wdHkobmV4dExpbmUpKSB7XG4gICAgICBuZXh0TGluZSsrO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkge1xuICAgICAgbmV4dExpbmUrKztcbiAgICAgIGxhc3QgPSBuZXh0TGluZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLmxpbmUgPSBsYXN0O1xuXG4gIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdjb2RlX2Jsb2NrJywgJ2NvZGUnLCAwKTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbGFzdCwgNCArIHN0YXRlLmJsa0luZGVudCwgdHJ1ZSk7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIGZlbmNlcyAoYGBgIGxhbmcsIH5+fiBsYW5nKVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmZW5jZShzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIG1hcmtlciwgbGVuLCBwYXJhbXMsIG5leHRMaW5lLCBtZW0sIHRva2VuLCBtYXJrdXAsXG4gICAgICBoYXZlRW5kTWFya2VyID0gZmFsc2UsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHBvcyArIDMgPiBtYXgpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAobWFya2VyICE9PSAweDdFLyogfiAqLyAmJiBtYXJrZXIgIT09IDB4NjAgLyogYCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIHNjYW4gbWFya2VyIGxlbmd0aFxuICBtZW0gPSBwb3M7XG4gIHBvcyA9IHN0YXRlLnNraXBDaGFycyhwb3MsIG1hcmtlcik7XG5cbiAgbGVuID0gcG9zIC0gbWVtO1xuXG4gIGlmIChsZW4gPCAzKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG1hcmt1cCA9IHN0YXRlLnNyYy5zbGljZShtZW0sIHBvcyk7XG4gIHBhcmFtcyA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1heCk7XG5cbiAgaWYgKHBhcmFtcy5pbmRleE9mKFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKSkgPj0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBTaW5jZSBzdGFydCBpcyBmb3VuZCwgd2UgY2FuIHJlcG9ydCBzdWNjZXNzIGhlcmUgaW4gdmFsaWRhdGlvbiBtb2RlXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICAvLyBzZWFyY2ggZW5kIG9mIGJsb2NrXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuXG4gIGZvciAoOzspIHtcbiAgICBuZXh0TGluZSsrO1xuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7XG4gICAgICAvLyB1bmNsb3NlZCBibG9jayBzaG91bGQgYmUgYXV0b2Nsb3NlZCBieSBlbmQgb2YgZG9jdW1lbnQuXG4gICAgICAvLyBhbHNvIGJsb2NrIHNlZW1zIHRvIGJlIGF1dG9jbG9zZWQgYnkgZW5kIG9mIHBhcmVudFxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9zID0gbWVtID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgLy8gbm9uLWVtcHR5IGxpbmUgd2l0aCBuZWdhdGl2ZSBpbmRlbnQgc2hvdWxkIHN0b3AgdGhlIGxpc3Q6XG4gICAgICAvLyAtIGBgYFxuICAgICAgLy8gIHRlc3RcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSBtYXJrZXIpIHsgY29udGludWU7IH1cblxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHtcbiAgICAgIC8vIGNsb3NpbmcgZmVuY2Ugc2hvdWxkIGJlIGluZGVudGVkIGxlc3MgdGhhbiA0IHNwYWNlc1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcblxuICAgIC8vIGNsb3NpbmcgY29kZSBmZW5jZSBtdXN0IGJlIGF0IGxlYXN0IGFzIGxvbmcgYXMgdGhlIG9wZW5pbmcgb25lXG4gICAgaWYgKHBvcyAtIG1lbSA8IGxlbikgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRhaWwgaGFzIHNwYWNlcyBvbmx5XG4gICAgcG9zID0gc3RhdGUuc2tpcFNwYWNlcyhwb3MpO1xuXG4gICAgaWYgKHBvcyA8IG1heCkgeyBjb250aW51ZTsgfVxuXG4gICAgaGF2ZUVuZE1hcmtlciA9IHRydWU7XG4gICAgLy8gZm91bmQhXG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBJZiBhIGZlbmNlIGhhcyBoZWFkaW5nIHNwYWNlcywgdGhleSBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGl0cyBpbm5lciBibG9ja1xuICBsZW4gPSBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXTtcblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmUgKyAoaGF2ZUVuZE1hcmtlciA/IDEgOiAwKTtcblxuICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnZmVuY2UnLCAnY29kZScsIDApO1xuICB0b2tlbi5pbmZvICAgID0gcGFyYW1zO1xuICB0b2tlbi5jb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lICsgMSwgbmV4dExpbmUsIGxlbiwgdHJ1ZSk7XG4gIHRva2VuLm1hcmt1cCAgPSBtYXJrdXA7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuXG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIGhlYWRpbmcgKCMsICMjLCAuLi4pXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIGNoLCBsZXZlbCwgdG1wLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCAgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gIGlmIChjaCAhPT0gMHgyMy8qICMgKi8gfHwgcG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBjb3VudCBoZWFkaW5nIGxldmVsXG4gIGxldmVsID0gMTtcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdCgrK3Bvcyk7XG4gIHdoaWxlIChjaCA9PT0gMHgyMy8qICMgKi8gJiYgcG9zIDwgbWF4ICYmIGxldmVsIDw9IDYpIHtcbiAgICBsZXZlbCsrO1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoKytwb3MpO1xuICB9XG5cbiAgaWYgKGxldmVsID4gNiB8fCAocG9zIDwgbWF4ICYmICFpc1NwYWNlKGNoKSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIExldCdzIGN1dCB0YWlscyBsaWtlICcgICAgIyMjICAnIGZyb20gdGhlIGVuZCBvZiBzdHJpbmdcblxuICBtYXggPSBzdGF0ZS5za2lwU3BhY2VzQmFjayhtYXgsIHBvcyk7XG4gIHRtcCA9IHN0YXRlLnNraXBDaGFyc0JhY2sobWF4LCAweDIzLCBwb3MpOyAvLyAjXG4gIGlmICh0bXAgPiBwb3MgJiYgaXNTcGFjZShzdGF0ZS5zcmMuY2hhckNvZGVBdCh0bXAgLSAxKSkpIHtcbiAgICBtYXggPSB0bXA7XG4gIH1cblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcbiAgdG9rZW4ubWFya3VwID0gJyMjIyMjIyMjJy5zbGljZSgwLCBsZXZlbCk7XG4gIHRva2VuLm1hcCAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KS50cmltKCk7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcbiAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX2Nsb3NlJywgJ2gnICsgU3RyaW5nKGxldmVsKSwgLTEpO1xuICB0b2tlbi5tYXJrdXAgPSAnIyMjIyMjIyMnLnNsaWNlKDAsIGxldmVsKTtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBIb3Jpem9udGFsIHJ1bGVcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBocihzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLCBzaWxlbnQpIHtcbiAgdmFyIG1hcmtlciwgY250LCBjaCwgdG9rZW4sXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV07XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gIC8vIENoZWNrIGhyIG1hcmtlclxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDVGLyogXyAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIG1hcmtlcnMgY2FuIGJlIG1peGVkIHdpdGggc3BhY2VzLCBidXQgdGhlcmUgc2hvdWxkIGJlIGF0IGxlYXN0IDMgb2YgdGhlbVxuXG4gIGNudCA9IDE7XG4gIHdoaWxlIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgICBpZiAoY2ggIT09IG1hcmtlciAmJiAhaXNTcGFjZShjaCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYgKGNoID09PSBtYXJrZXIpIHsgY250Kys7IH1cbiAgfVxuXG4gIGlmIChjbnQgPCAzKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgMTtcblxuICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdocicsICdocicsIDApO1xuICB0b2tlbi5tYXAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5tYXJrdXAgPSBBcnJheShjbnQgKyAxKS5qb2luKFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyKSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gSFRNTCBibG9ja1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGJsb2NrX25hbWVzID0gcmVxdWlyZSgnLi4vY29tbW9uL2h0bWxfYmxvY2tzJyk7XG52YXIgSFRNTF9PUEVOX0NMT1NFX1RBR19SRSA9IHJlcXVpcmUoJy4uL2NvbW1vbi9odG1sX3JlJykuSFRNTF9PUEVOX0NMT1NFX1RBR19SRTtcblxuLy8gQW4gYXJyYXkgb2Ygb3BlbmluZyBhbmQgY29ycmVzcG9uZGluZyBjbG9zaW5nIHNlcXVlbmNlcyBmb3IgaHRtbCB0YWdzLFxuLy8gbGFzdCBhcmd1bWVudCBkZWZpbmVzIHdoZXRoZXIgaXQgY2FuIHRlcm1pbmF0ZSBhIHBhcmFncmFwaCBvciBub3Rcbi8vXG52YXIgSFRNTF9TRVFVRU5DRVMgPSBbXG4gIFsgL148KHNjcmlwdHxwcmV8c3R5bGUpKD89KFxcc3w+fCQpKS9pLCAvPFxcLyhzY3JpcHR8cHJlfHN0eWxlKT4vaSwgdHJ1ZSBdLFxuICBbIC9ePCEtLS8sICAgICAgICAvLS0+LywgICB0cnVlIF0sXG4gIFsgL148XFw/LywgICAgICAgICAvXFw/Pi8sICAgdHJ1ZSBdLFxuICBbIC9ePCFbQS1aXS8sICAgICAvPi8sICAgICB0cnVlIF0sXG4gIFsgL148IVxcW0NEQVRBXFxbLywgL1xcXVxcXT4vLCB0cnVlIF0sXG4gIFsgbmV3IFJlZ0V4cCgnXjwvPygnICsgYmxvY2tfbmFtZXMuam9pbignfCcpICsgJykoPz0oXFxcXHN8Lz8+fCQpKScsICdpJyksIC9eJC8sIHRydWUgXSxcbiAgWyBuZXcgUmVnRXhwKEhUTUxfT1BFTl9DTE9TRV9UQUdfUkUuc291cmNlICsgJ1xcXFxzKiQnKSwgIC9eJC8sIGZhbHNlIF1cbl07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBodG1sX2Jsb2NrKHN0YXRlLCBzdGFydExpbmUsIGVuZExpbmUsIHNpbGVudCkge1xuICB2YXIgaSwgbmV4dExpbmUsIHRva2VuLCBsaW5lVGV4dCxcbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tzdGFydExpbmVdICsgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0sXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXN0YXRlLm1kLm9wdGlvbnMuaHRtbCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGluZVRleHQgPSBzdGF0ZS5zcmMuc2xpY2UocG9zLCBtYXgpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBIVE1MX1NFUVVFTkNFUy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChIVE1MX1NFUVVFTkNFU1tpXVswXS50ZXN0KGxpbmVUZXh0KSkgeyBicmVhazsgfVxuICB9XG5cbiAgaWYgKGkgPT09IEhUTUxfU0VRVUVOQ0VTLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoc2lsZW50KSB7XG4gICAgLy8gdHJ1ZSBpZiB0aGlzIHNlcXVlbmNlIGNhbiBiZSBhIHRlcm1pbmF0b3IsIGZhbHNlIG90aGVyd2lzZVxuICAgIHJldHVybiBIVE1MX1NFUVVFTkNFU1tpXVsyXTtcbiAgfVxuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICAvLyBJZiB3ZSBhcmUgaGVyZSAtIHdlIGRldGVjdGVkIEhUTUwgYmxvY2suXG4gIC8vIExldCdzIHJvbGwgZG93biB0aWxsIGJsb2NrIGVuZC5cbiAgaWYgKCFIVE1MX1NFUVVFTkNFU1tpXVsxXS50ZXN0KGxpbmVUZXh0KSkge1xuICAgIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIDwgc3RhdGUuYmxrSW5kZW50KSB7IGJyZWFrOyB9XG5cbiAgICAgIHBvcyA9IHN0YXRlLmJNYXJrc1tuZXh0TGluZV0gKyBzdGF0ZS50U2hpZnRbbmV4dExpbmVdO1xuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcbiAgICAgIGxpbmVUZXh0ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgbWF4KTtcblxuICAgICAgaWYgKEhUTUxfU0VRVUVOQ0VTW2ldWzFdLnRlc3QobGluZVRleHQpKSB7XG4gICAgICAgIGlmIChsaW5lVGV4dC5sZW5ndGggIT09IDApIHsgbmV4dExpbmUrKzsgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdGF0ZS5saW5lID0gbmV4dExpbmU7XG5cbiAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2h0bWxfYmxvY2snLCAnJywgMCk7XG4gIHRva2VuLm1hcCAgICAgPSBbIHN0YXJ0TGluZSwgbmV4dExpbmUgXTtcbiAgdG9rZW4uY29udGVudCA9IHN0YXRlLmdldExpbmVzKHN0YXJ0TGluZSwgbmV4dExpbmUsIHN0YXRlLmJsa0luZGVudCwgdHJ1ZSk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gbGhlYWRpbmcgKC0tLSwgPT09KVxuXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaGVhZGluZyhzdGF0ZSwgc3RhcnRMaW5lLCBlbmRMaW5lLyosIHNpbGVudCovKSB7XG4gIHZhciBjb250ZW50LCB0ZXJtaW5hdGUsIGksIGwsIHRva2VuLCBwb3MsIG1heCwgbGV2ZWwsIG1hcmtlcixcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSwgb2xkUGFyZW50VHlwZSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKTtcblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W3N0YXJ0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdwYXJhZ3JhcGgnOyAvLyB1c2UgcGFyYWdyYXBoIHRvIG1hdGNoIHRlcm1pbmF0b3JSdWxlc1xuXG4gIC8vIGp1bXAgbGluZS1ieS1saW5lIHVudGlsIGVtcHR5IG9uZSBvciBFT0ZcbiAgZm9yICg7IG5leHRMaW5lIDwgZW5kTGluZSAmJiAhc3RhdGUuaXNFbXB0eShuZXh0TGluZSk7IG5leHRMaW5lKyspIHtcbiAgICAvLyB0aGlzIHdvdWxkIGJlIGEgY29kZSBibG9jayBub3JtYWxseSwgYnV0IGFmdGVyIHBhcmFncmFwaFxuICAgIC8vIGl0J3MgY29uc2lkZXJlZCBhIGxhenkgY29udGludWF0aW9uIHJlZ2FyZGxlc3Mgb2Ygd2hhdCdzIHRoZXJlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPiAzKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvL1xuICAgIC8vIENoZWNrIGZvciB1bmRlcmxpbmUgaW4gc2V0ZXh0IGhlYWRlclxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPj0gc3RhdGUuYmxrSW5kZW50KSB7XG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3NbbmV4dExpbmVdICsgc3RhdGUudFNoaWZ0W25leHRMaW5lXTtcbiAgICAgIG1heCA9IHN0YXRlLmVNYXJrc1tuZXh0TGluZV07XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICBpZiAobWFya2VyID09PSAweDJELyogLSAqLyB8fCBtYXJrZXIgPT09IDB4M0QvKiA9ICovKSB7XG4gICAgICAgICAgcG9zID0gc3RhdGUuc2tpcENoYXJzKHBvcywgbWFya2VyKTtcbiAgICAgICAgICBwb3MgPSBzdGF0ZS5za2lwU3BhY2VzKHBvcyk7XG5cbiAgICAgICAgICBpZiAocG9zID49IG1heCkge1xuICAgICAgICAgICAgbGV2ZWwgPSAobWFya2VyID09PSAweDNELyogPSAqLyA/IDEgOiAyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGlmICghbGV2ZWwpIHtcbiAgICAvLyBEaWRuJ3QgZmluZCB2YWxpZCB1bmRlcmxpbmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb250ZW50ID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuXG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZSArIDE7XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdoZWFkaW5nX29wZW4nLCAnaCcgKyBTdHJpbmcobGV2ZWwpLCAxKTtcbiAgdG9rZW4ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG4gIHRva2VuLm1hcCAgICAgID0gWyBzdGFydExpbmUsIHN0YXRlLmxpbmUgXTtcblxuICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2lubGluZScsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCAgPSBjb250ZW50O1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIC0gMSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaGVhZGluZ19jbG9zZScsICdoJyArIFN0cmluZyhsZXZlbCksIC0xKTtcbiAgdG9rZW4ubWFya3VwICAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gTGlzdHNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuLy8gU2VhcmNoIGBbLSsqXVtcXG4gXWAsIHJldHVybnMgbmV4dCBwb3MgYWZ0ZXIgbWFya2VyIG9uIHN1Y2Nlc3Ncbi8vIG9yIC0xIG9uIGZhaWwuXG5mdW5jdGlvbiBza2lwQnVsbGV0TGlzdE1hcmtlcihzdGF0ZSwgc3RhcnRMaW5lKSB7XG4gIHZhciBtYXJrZXIsIHBvcywgbWF4LCBjaDtcblxuICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdO1xuICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MrKyk7XG4gIC8vIENoZWNrIGJ1bGxldFxuICBpZiAobWFya2VyICE9PSAweDJBLyogKiAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJELyogLSAqLyAmJlxuICAgICAgbWFya2VyICE9PSAweDJCLyogKyAqLykge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXgpIHtcbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICBpZiAoIWlzU3BhY2UoY2gpKSB7XG4gICAgICAvLyBcIiAtdGVzdCBcIiAtIGlzIG5vdCBhIGxpc3QgaXRlbVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwb3M7XG59XG5cbi8vIFNlYXJjaCBgXFxkK1suKV1bXFxuIF1gLCByZXR1cm5zIG5leHQgcG9zIGFmdGVyIG1hcmtlciBvbiBzdWNjZXNzXG4vLyBvciAtMSBvbiBmYWlsLlxuZnVuY3Rpb24gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpIHtcbiAgdmFyIGNoLFxuICAgICAgc3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgcG9zID0gc3RhcnQsXG4gICAgICBtYXggPSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXTtcblxuICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBhdCBsZWFzdCAyIGNoYXJzIChkaWdpdCArIGRvdClcbiAgaWYgKHBvcyArIDEgPj0gbWF4KSB7IHJldHVybiAtMTsgfVxuXG4gIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKyspO1xuXG4gIGlmIChjaCA8IDB4MzAvKiAwICovIHx8IGNoID4gMHgzOS8qIDkgKi8pIHsgcmV0dXJuIC0xOyB9XG5cbiAgZm9yICg7Oykge1xuICAgIC8vIEVPTCAtPiBmYWlsXG4gICAgaWYgKHBvcyA+PSBtYXgpIHsgcmV0dXJuIC0xOyB9XG5cbiAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcblxuICAgIGlmIChjaCA+PSAweDMwLyogMCAqLyAmJiBjaCA8PSAweDM5LyogOSAqLykge1xuXG4gICAgICAvLyBMaXN0IG1hcmtlciBzaG91bGQgaGF2ZSBubyBtb3JlIHRoYW4gOSBkaWdpdHNcbiAgICAgIC8vIChwcmV2ZW50cyBpbnRlZ2VyIG92ZXJmbG93IGluIGJyb3dzZXJzKVxuICAgICAgaWYgKHBvcyAtIHN0YXJ0ID49IDEwKSB7IHJldHVybiAtMTsgfVxuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmb3VuZCB2YWxpZCBtYXJrZXJcbiAgICBpZiAoY2ggPT09IDB4MjkvKiApICovIHx8IGNoID09PSAweDJlLyogLiAqLykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKCFpc1NwYWNlKGNoKSkge1xuICAgICAgLy8gXCIgMS50ZXN0IFwiIC0gaXMgbm90IGEgbGlzdCBpdGVtXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb3M7XG59XG5cbmZ1bmN0aW9uIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGlkeCkge1xuICB2YXIgaSwgbCxcbiAgICAgIGxldmVsID0gc3RhdGUubGV2ZWwgKyAyO1xuXG4gIGZvciAoaSA9IGlkeCArIDIsIGwgPSBzdGF0ZS50b2tlbnMubGVuZ3RoIC0gMjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChzdGF0ZS50b2tlbnNbaV0ubGV2ZWwgPT09IGxldmVsICYmIHN0YXRlLnRva2Vuc1tpXS50eXBlID09PSAncGFyYWdyYXBoX29wZW4nKSB7XG4gICAgICBzdGF0ZS50b2tlbnNbaSArIDJdLmhpZGRlbiA9IHRydWU7XG4gICAgICBzdGF0ZS50b2tlbnNbaV0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIGkgKz0gMjtcbiAgICB9XG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpc3Qoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCxcbiAgICAgIGNvbnRlbnRTdGFydCxcbiAgICAgIGksXG4gICAgICBpbmRlbnQsXG4gICAgICBpbmRlbnRBZnRlck1hcmtlcixcbiAgICAgIGluaXRpYWwsXG4gICAgICBpc09yZGVyZWQsXG4gICAgICBpdGVtTGluZXMsXG4gICAgICBsLFxuICAgICAgbGlzdExpbmVzLFxuICAgICAgbGlzdFRva0lkeCxcbiAgICAgIG1hcmtlckNoYXJDb2RlLFxuICAgICAgbWFya2VyVmFsdWUsXG4gICAgICBtYXgsXG4gICAgICBuZXh0TGluZSxcbiAgICAgIG9mZnNldCxcbiAgICAgIG9sZEluZGVudCxcbiAgICAgIG9sZExJbmRlbnQsXG4gICAgICBvbGRQYXJlbnRUeXBlLFxuICAgICAgb2xkVFNoaWZ0LFxuICAgICAgb2xkVGlnaHQsXG4gICAgICBwb3MsXG4gICAgICBwb3NBZnRlck1hcmtlcixcbiAgICAgIHByZXZFbXB0eUVuZCxcbiAgICAgIHN0YXJ0LFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdG9rZW4sXG4gICAgICBpc1Rlcm1pbmF0aW5nUGFyYWdyYXBoID0gZmFsc2UsXG4gICAgICB0aWdodCA9IHRydWU7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gbGltaXQgY29uZGl0aW9ucyB3aGVuIGxpc3QgY2FuIGludGVycnVwdFxuICAvLyBhIHBhcmFncmFwaCAodmFsaWRhdGlvbiBtb2RlIG9ubHkpXG4gIGlmIChzaWxlbnQgJiYgc3RhdGUucGFyZW50VHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAvLyBOZXh0IGxpc3QgaXRlbSBzaG91bGQgc3RpbGwgdGVybWluYXRlIHByZXZpb3VzIGxpc3QgaXRlbTtcbiAgICAvL1xuICAgIC8vIFRoaXMgY29kZSBjYW4gZmFpbCBpZiBwbHVnaW5zIHVzZSBibGtJbmRlbnQgYXMgd2VsbCBhcyBsaXN0cyxcbiAgICAvLyBidXQgSSBob3BlIHRoZSBzcGVjIGdldHMgZml4ZWQgbG9uZyBiZWZvcmUgdGhhdCBoYXBwZW5zLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnRTaGlmdFtzdGFydExpbmVdID49IHN0YXRlLmJsa0luZGVudCkge1xuICAgICAgaXNUZXJtaW5hdGluZ1BhcmFncmFwaCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gRGV0ZWN0IGxpc3QgdHlwZSBhbmQgcG9zaXRpb24gYWZ0ZXIgbWFya2VyXG4gIGlmICgocG9zQWZ0ZXJNYXJrZXIgPSBza2lwT3JkZXJlZExpc3RNYXJrZXIoc3RhdGUsIHN0YXJ0TGluZSkpID49IDApIHtcbiAgICBpc09yZGVyZWQgPSB0cnVlO1xuICAgIHN0YXJ0ID0gc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXTtcbiAgICBtYXJrZXJWYWx1ZSA9IE51bWJlcihzdGF0ZS5zcmMuc3Vic3RyKHN0YXJ0LCBwb3NBZnRlck1hcmtlciAtIHN0YXJ0IC0gMSkpO1xuXG4gICAgLy8gSWYgd2UncmUgc3RhcnRpbmcgYSBuZXcgb3JkZXJlZCBsaXN0IHJpZ2h0IGFmdGVyXG4gICAgLy8gYSBwYXJhZ3JhcGgsIGl0IHNob3VsZCBzdGFydCB3aXRoIDEuXG4gICAgaWYgKGlzVGVybWluYXRpbmdQYXJhZ3JhcGggJiYgbWFya2VyVmFsdWUgIT09IDEpIHJldHVybiBmYWxzZTtcblxuICB9IGVsc2UgaWYgKChwb3NBZnRlck1hcmtlciA9IHNraXBCdWxsZXRMaXN0TWFya2VyKHN0YXRlLCBzdGFydExpbmUpKSA+PSAwKSB7XG4gICAgaXNPcmRlcmVkID0gZmFsc2U7XG5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBzdGFydGluZyBhIG5ldyB1bm9yZGVyZWQgbGlzdCByaWdodCBhZnRlclxuICAvLyBhIHBhcmFncmFwaCwgZmlyc3QgbGluZSBzaG91bGQgbm90IGJlIGVtcHR5LlxuICBpZiAoaXNUZXJtaW5hdGluZ1BhcmFncmFwaCkge1xuICAgIGlmIChzdGF0ZS5za2lwU3BhY2VzKHBvc0FmdGVyTWFya2VyKSA+PSBzdGF0ZS5lTWFya3Nbc3RhcnRMaW5lXSkgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gV2Ugc2hvdWxkIHRlcm1pbmF0ZSBsaXN0IG9uIHN0eWxlIGNoYW5nZS4gUmVtZW1iZXIgZmlyc3Qgb25lIHRvIGNvbXBhcmUuXG4gIG1hcmtlckNoYXJDb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zQWZ0ZXJNYXJrZXIgLSAxKTtcblxuICAvLyBGb3IgdmFsaWRhdGlvbiBtb2RlIHdlIGNhbiB0ZXJtaW5hdGUgaW1tZWRpYXRlbHlcbiAgaWYgKHNpbGVudCkgeyByZXR1cm4gdHJ1ZTsgfVxuXG4gIC8vIFN0YXJ0IGxpc3RcbiAgbGlzdFRva0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGg7XG5cbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuICAgICAgID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X29wZW4nLCAnb2wnLCAxKTtcbiAgICBpZiAobWFya2VyVmFsdWUgIT09IDEpIHtcbiAgICAgIHRva2VuLmF0dHJzID0gWyBbICdzdGFydCcsIG1hcmtlclZhbHVlIF0gXTtcbiAgICB9XG5cbiAgfSBlbHNlIHtcbiAgICB0b2tlbiAgICAgICA9IHN0YXRlLnB1c2goJ2J1bGxldF9saXN0X29wZW4nLCAndWwnLCAxKTtcbiAgfVxuXG4gIHRva2VuLm1hcCAgICA9IGxpc3RMaW5lcyA9IFsgc3RhcnRMaW5lLCAwIF07XG4gIHRva2VuLm1hcmt1cCA9IFN0cmluZy5mcm9tQ2hhckNvZGUobWFya2VyQ2hhckNvZGUpO1xuXG4gIC8vXG4gIC8vIEl0ZXJhdGUgbGlzdCBpdGVtc1xuICAvL1xuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lO1xuICBwcmV2RW1wdHlFbmQgPSBmYWxzZTtcbiAgdGVybWluYXRvclJ1bGVzID0gc3RhdGUubWQuYmxvY2sucnVsZXIuZ2V0UnVsZXMoJ2xpc3QnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdsaXN0JztcblxuICB3aGlsZSAobmV4dExpbmUgPCBlbmRMaW5lKSB7XG4gICAgcG9zID0gcG9zQWZ0ZXJNYXJrZXI7XG4gICAgbWF4ID0gc3RhdGUuZU1hcmtzW25leHRMaW5lXTtcblxuICAgIGluaXRpYWwgPSBvZmZzZXQgPSBzdGF0ZS5zQ291bnRbbmV4dExpbmVdICsgcG9zQWZ0ZXJNYXJrZXIgLSAoc3RhdGUuYk1hcmtzW3N0YXJ0TGluZV0gKyBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSk7XG5cbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG5cbiAgICAgIGlmIChjaCA9PT0gMHgwOSkge1xuICAgICAgICBvZmZzZXQgKz0gNCAtIChvZmZzZXQgKyBzdGF0ZS5ic0NvdW50W25leHRMaW5lXSkgJSA0O1xuICAgICAgfSBlbHNlIGlmIChjaCA9PT0gMHgyMCkge1xuICAgICAgICBvZmZzZXQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICBjb250ZW50U3RhcnQgPSBwb3M7XG5cbiAgICBpZiAoY29udGVudFN0YXJ0ID49IG1heCkge1xuICAgICAgLy8gdHJpbW1pbmcgc3BhY2UgaW4gXCItICAgIFxcbiAgM1wiIGNhc2UsIGluZGVudCBpcyAxIGhlcmVcbiAgICAgIGluZGVudEFmdGVyTWFya2VyID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZW50QWZ0ZXJNYXJrZXIgPSBvZmZzZXQgLSBpbml0aWFsO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmUgbW9yZSB0aGFuIDQgc3BhY2VzLCB0aGUgaW5kZW50IGlzIDFcbiAgICAvLyAodGhlIHJlc3QgaXMganVzdCBpbmRlbnRlZCBjb2RlIGJsb2NrKVxuICAgIGlmIChpbmRlbnRBZnRlck1hcmtlciA+IDQpIHsgaW5kZW50QWZ0ZXJNYXJrZXIgPSAxOyB9XG5cbiAgICAvLyBcIiAgLSAgdGVzdFwiXG4gICAgLy8gIF5eXl5eIC0gY2FsY3VsYXRpbmcgdG90YWwgbGVuZ3RoIG9mIHRoaXMgdGhpbmdcbiAgICBpbmRlbnQgPSBpbml0aWFsICsgaW5kZW50QWZ0ZXJNYXJrZXI7XG5cbiAgICAvLyBSdW4gc3VicGFyc2VyICYgd3JpdGUgdG9rZW5zXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlzdF9pdGVtX29wZW4nLCAnbGknLCAxKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcbiAgICB0b2tlbi5tYXAgICAgPSBpdGVtTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gICAgb2xkSW5kZW50ID0gc3RhdGUuYmxrSW5kZW50O1xuICAgIG9sZFRpZ2h0ID0gc3RhdGUudGlnaHQ7XG4gICAgb2xkVFNoaWZ0ID0gc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV07XG4gICAgb2xkTEluZGVudCA9IHN0YXRlLnNDb3VudFtzdGFydExpbmVdO1xuICAgIHN0YXRlLmJsa0luZGVudCA9IGluZGVudDtcbiAgICBzdGF0ZS50aWdodCA9IHRydWU7XG4gICAgc3RhdGUudFNoaWZ0W3N0YXJ0TGluZV0gPSBjb250ZW50U3RhcnQgLSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcbiAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9mZnNldDtcblxuICAgIGlmIChjb250ZW50U3RhcnQgPj0gbWF4ICYmIHN0YXRlLmlzRW1wdHkoc3RhcnRMaW5lICsgMSkpIHtcbiAgICAgIC8vIHdvcmthcm91bmQgZm9yIHRoaXMgY2FzZVxuICAgICAgLy8gKGxpc3QgaXRlbSBpcyBlbXB0eSwgbGlzdCB0ZXJtaW5hdGVzIGJlZm9yZSBcImZvb1wiKTpcbiAgICAgIC8vIH5+fn5+fn5+XG4gICAgICAvLyAgIC1cbiAgICAgIC8vXG4gICAgICAvLyAgICAgZm9vXG4gICAgICAvLyB+fn5+fn5+flxuICAgICAgc3RhdGUubGluZSA9IE1hdGgubWluKHN0YXRlLmxpbmUgKyAyLCBlbmRMaW5lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUubWQuYmxvY2sudG9rZW5pemUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gSWYgYW55IG9mIGxpc3QgaXRlbSBpcyB0aWdodCwgbWFyayBsaXN0IGFzIHRpZ2h0XG4gICAgaWYgKCFzdGF0ZS50aWdodCB8fCBwcmV2RW1wdHlFbmQpIHtcbiAgICAgIHRpZ2h0ID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIEl0ZW0gYmVjb21lIGxvb3NlIGlmIGZpbmlzaCB3aXRoIGVtcHR5IGxpbmUsXG4gICAgLy8gYnV0IHdlIHNob3VsZCBmaWx0ZXIgbGFzdCBlbGVtZW50LCBiZWNhdXNlIGl0IG1lYW5zIGxpc3QgZmluaXNoXG4gICAgcHJldkVtcHR5RW5kID0gKHN0YXRlLmxpbmUgLSBzdGFydExpbmUpID4gMSAmJiBzdGF0ZS5pc0VtcHR5KHN0YXRlLmxpbmUgLSAxKTtcblxuICAgIHN0YXRlLmJsa0luZGVudCA9IG9sZEluZGVudDtcbiAgICBzdGF0ZS50U2hpZnRbc3RhcnRMaW5lXSA9IG9sZFRTaGlmdDtcbiAgICBzdGF0ZS5zQ291bnRbc3RhcnRMaW5lXSA9IG9sZExJbmRlbnQ7XG4gICAgc3RhdGUudGlnaHQgPSBvbGRUaWdodDtcblxuICAgIHRva2VuICAgICAgICA9IHN0YXRlLnB1c2goJ2xpc3RfaXRlbV9jbG9zZScsICdsaScsIC0xKTtcbiAgICB0b2tlbi5tYXJrdXAgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlckNoYXJDb2RlKTtcblxuICAgIG5leHRMaW5lID0gc3RhcnRMaW5lID0gc3RhdGUubGluZTtcbiAgICBpdGVtTGluZXNbMV0gPSBuZXh0TGluZTtcbiAgICBjb250ZW50U3RhcnQgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXTtcblxuICAgIGlmIChuZXh0TGluZSA+PSBlbmRMaW5lKSB7IGJyZWFrOyB9XG5cbiAgICAvL1xuICAgIC8vIFRyeSB0byBjaGVjayBpZiBsaXN0IGlzIHRlcm1pbmF0ZWQgb3IgY29udGludWVkLlxuICAgIC8vXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCBzdGF0ZS5ibGtJbmRlbnQpIHsgYnJlYWs7IH1cblxuICAgIC8vIGZhaWwgaWYgdGVybWluYXRpbmcgYmxvY2sgZm91bmRcbiAgICB0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdGVybWluYXRvclJ1bGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHRlcm1pbmF0b3JSdWxlc1tpXShzdGF0ZSwgbmV4dExpbmUsIGVuZExpbmUsIHRydWUpKSB7XG4gICAgICAgIHRlcm1pbmF0ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGVybWluYXRlKSB7IGJyZWFrOyB9XG5cbiAgICAvLyBmYWlsIGlmIGxpc3QgaGFzIGFub3RoZXIgdHlwZVxuICAgIGlmIChpc09yZGVyZWQpIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcE9yZGVyZWRMaXN0TWFya2VyKHN0YXRlLCBuZXh0TGluZSk7XG4gICAgICBpZiAocG9zQWZ0ZXJNYXJrZXIgPCAwKSB7IGJyZWFrOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc0FmdGVyTWFya2VyID0gc2tpcEJ1bGxldExpc3RNYXJrZXIoc3RhdGUsIG5leHRMaW5lKTtcbiAgICAgIGlmIChwb3NBZnRlck1hcmtlciA8IDApIHsgYnJlYWs7IH1cbiAgICB9XG5cbiAgICBpZiAobWFya2VyQ2hhckNvZGUgIT09IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvc0FmdGVyTWFya2VyIC0gMSkpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIC8vIEZpbmFsaXplIGxpc3RcbiAgaWYgKGlzT3JkZXJlZCkge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnb3JkZXJlZF9saXN0X2Nsb3NlJywgJ29sJywgLTEpO1xuICB9IGVsc2Uge1xuICAgIHRva2VuID0gc3RhdGUucHVzaCgnYnVsbGV0X2xpc3RfY2xvc2UnLCAndWwnLCAtMSk7XG4gIH1cbiAgdG9rZW4ubWFya3VwID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXJDaGFyQ29kZSk7XG5cbiAgbGlzdExpbmVzWzFdID0gbmV4dExpbmU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICAvLyBtYXJrIHBhcmFncmFwaHMgdGlnaHQgaWYgbmVlZGVkXG4gIGlmICh0aWdodCkge1xuICAgIG1hcmtUaWdodFBhcmFncmFwaHMoc3RhdGUsIGxpc3RUb2tJZHgpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUGFyYWdyYXBoXG5cbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcmFncmFwaChzdGF0ZSwgc3RhcnRMaW5lLyosIGVuZExpbmUqLykge1xuICB2YXIgY29udGVudCwgdGVybWluYXRlLCBpLCBsLCB0b2tlbiwgb2xkUGFyZW50VHlwZSxcbiAgICAgIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMSxcbiAgICAgIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdwYXJhZ3JhcGgnKSxcbiAgICAgIGVuZExpbmUgPSBzdGF0ZS5saW5lTWF4O1xuXG4gIG9sZFBhcmVudFR5cGUgPSBzdGF0ZS5wYXJlbnRUeXBlO1xuICBzdGF0ZS5wYXJlbnRUeXBlID0gJ3BhcmFncmFwaCc7XG5cbiAgLy8ganVtcCBsaW5lLWJ5LWxpbmUgdW50aWwgZW1wdHkgb25lIG9yIEVPRlxuICBmb3IgKDsgbmV4dExpbmUgPCBlbmRMaW5lICYmICFzdGF0ZS5pc0VtcHR5KG5leHRMaW5lKTsgbmV4dExpbmUrKykge1xuICAgIC8vIHRoaXMgd291bGQgYmUgYSBjb2RlIGJsb2NrIG5vcm1hbGx5LCBidXQgYWZ0ZXIgcGFyYWdyYXBoXG4gICAgLy8gaXQncyBjb25zaWRlcmVkIGEgbGF6eSBjb250aW51YXRpb24gcmVnYXJkbGVzcyBvZiB3aGF0J3MgdGhlcmVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+IDMpIHsgY29udGludWU7IH1cblxuICAgIC8vIHF1aXJrIGZvciBibG9ja3F1b3RlcywgdGhpcyBsaW5lIHNob3VsZCBhbHJlYWR5IGJlIGNoZWNrZWQgYnkgdGhhdCBydWxlXG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gPCAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBTb21lIHRhZ3MgY2FuIHRlcm1pbmF0ZSBwYXJhZ3JhcGggd2l0aG91dCBlbXB0eSBsaW5lLlxuICAgIHRlcm1pbmF0ZSA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDAsIGwgPSB0ZXJtaW5hdG9yUnVsZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAodGVybWluYXRvclJ1bGVzW2ldKHN0YXRlLCBuZXh0TGluZSwgZW5kTGluZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGVybWluYXRlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0ZXJtaW5hdGUpIHsgYnJlYWs7IH1cbiAgfVxuXG4gIGNvbnRlbnQgPSBzdGF0ZS5nZXRMaW5lcyhzdGFydExpbmUsIG5leHRMaW5lLCBzdGF0ZS5ibGtJbmRlbnQsIGZhbHNlKS50cmltKCk7XG5cbiAgc3RhdGUubGluZSA9IG5leHRMaW5lO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgncGFyYWdyYXBoX29wZW4nLCAncCcsIDEpO1xuICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGF0ZS5saW5lIF07XG5cbiAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcbiAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhdGUubGluZSBdO1xuICB0b2tlbi5jaGlsZHJlbiA9IFtdO1xuXG4gIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgncGFyYWdyYXBoX2Nsb3NlJywgJ3AnLCAtMSk7XG5cbiAgc3RhdGUucGFyZW50VHlwZSA9IG9sZFBhcmVudFR5cGU7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBub3JtYWxpemVSZWZlcmVuY2UgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLm5vcm1hbGl6ZVJlZmVyZW5jZTtcbnZhciBpc1NwYWNlICAgICAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZWZlcmVuY2Uoc3RhdGUsIHN0YXJ0TGluZSwgX2VuZExpbmUsIHNpbGVudCkge1xuICB2YXIgY2gsXG4gICAgICBkZXN0RW5kUG9zLFxuICAgICAgZGVzdEVuZExpbmVObyxcbiAgICAgIGVuZExpbmUsXG4gICAgICBocmVmLFxuICAgICAgaSxcbiAgICAgIGwsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgb2xkUGFyZW50VHlwZSxcbiAgICAgIHJlcyxcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RyLFxuICAgICAgdGVybWluYXRlLFxuICAgICAgdGVybWluYXRvclJ1bGVzLFxuICAgICAgdGl0bGUsXG4gICAgICBsaW5lcyA9IDAsXG4gICAgICBwb3MgPSBzdGF0ZS5iTWFya3Nbc3RhcnRMaW5lXSArIHN0YXRlLnRTaGlmdFtzdGFydExpbmVdLFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW3N0YXJ0TGluZV0sXG4gICAgICBuZXh0TGluZSA9IHN0YXJ0TGluZSArIDE7XG5cbiAgLy8gaWYgaXQncyBpbmRlbnRlZCBtb3JlIHRoYW4gMyBzcGFjZXMsIGl0IHNob3VsZCBiZSBhIGNvZGUgYmxvY2tcbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUIvKiBbICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIFNpbXBsZSBjaGVjayB0byBxdWlja2x5IGludGVycnVwdCBzY2FuIG9uIFtsaW5rXSh1cmwpIGF0IHRoZSBzdGFydCBvZiBsaW5lLlxuICAvLyBDYW4gYmUgdXNlZnVsIG9uIHByYWN0aWNlOiBodHRwczovL2dpdGh1Yi5jb20vbWFya2Rvd24taXQvbWFya2Rvd24taXQvaXNzdWVzLzU0XG4gIHdoaWxlICgrK3BvcyA8IG1heCkge1xuICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpID09PSAweDVEIC8qIF0gKi8gJiZcbiAgICAgICAgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zIC0gMSkgIT09IDB4NUMvKiBcXCAqLykge1xuICAgICAgaWYgKHBvcyArIDEgPT09IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKSAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBlbmRMaW5lID0gc3RhdGUubGluZU1heDtcblxuICAvLyBqdW1wIGxpbmUtYnktbGluZSB1bnRpbCBlbXB0eSBvbmUgb3IgRU9GXG4gIHRlcm1pbmF0b3JSdWxlcyA9IHN0YXRlLm1kLmJsb2NrLnJ1bGVyLmdldFJ1bGVzKCdyZWZlcmVuY2UnKTtcblxuICBvbGRQYXJlbnRUeXBlID0gc3RhdGUucGFyZW50VHlwZTtcbiAgc3RhdGUucGFyZW50VHlwZSA9ICdyZWZlcmVuY2UnO1xuXG4gIGZvciAoOyBuZXh0TGluZSA8IGVuZExpbmUgJiYgIXN0YXRlLmlzRW1wdHkobmV4dExpbmUpOyBuZXh0TGluZSsrKSB7XG4gICAgLy8gdGhpcyB3b3VsZCBiZSBhIGNvZGUgYmxvY2sgbm9ybWFsbHksIGJ1dCBhZnRlciBwYXJhZ3JhcGhcbiAgICAvLyBpdCdzIGNvbnNpZGVyZWQgYSBsYXp5IGNvbnRpbnVhdGlvbiByZWdhcmRsZXNzIG9mIHdoYXQncyB0aGVyZVxuICAgIGlmIChzdGF0ZS5zQ291bnRbbmV4dExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID4gMykgeyBjb250aW51ZTsgfVxuXG4gICAgLy8gcXVpcmsgZm9yIGJsb2NrcXVvdGVzLCB0aGlzIGxpbmUgc2hvdWxkIGFscmVhZHkgYmUgY2hlY2tlZCBieSB0aGF0IHJ1bGVcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IDApIHsgY29udGludWU7IH1cblxuICAgIC8vIFNvbWUgdGFncyBjYW4gdGVybWluYXRlIHBhcmFncmFwaCB3aXRob3V0IGVtcHR5IGxpbmUuXG4gICAgdGVybWluYXRlID0gZmFsc2U7XG4gICAgZm9yIChpID0gMCwgbCA9IHRlcm1pbmF0b3JSdWxlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmICh0ZXJtaW5hdG9yUnVsZXNbaV0oc3RhdGUsIG5leHRMaW5lLCBlbmRMaW5lLCB0cnVlKSkge1xuICAgICAgICB0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlcm1pbmF0ZSkgeyBicmVhazsgfVxuICB9XG5cbiAgc3RyID0gc3RhdGUuZ2V0TGluZXMoc3RhcnRMaW5lLCBuZXh0TGluZSwgc3RhdGUuYmxrSW5kZW50LCBmYWxzZSkudHJpbSgpO1xuICBtYXggPSBzdHIubGVuZ3RoO1xuXG4gIGZvciAocG9zID0gMTsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICBpZiAoY2ggPT09IDB4NUIgLyogWyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDB4NUQgLyogXSAqLykge1xuICAgICAgbGFiZWxFbmQgPSBwb3M7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDBBIC8qIFxcbiAqLykge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDVDIC8qIFxcICovKSB7XG4gICAgICBwb3MrKztcbiAgICAgIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgwQSkge1xuICAgICAgICBsaW5lcysrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChsYWJlbEVuZCA8IDAgfHwgc3RyLmNoYXJDb2RlQXQobGFiZWxFbmQgKyAxKSAhPT0gMHgzQS8qIDogKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICBeXl4gc2tpcCBvcHRpb25hbCB3aGl0ZXNwYWNlIGhlcmVcbiAgZm9yIChwb3MgPSBsYWJlbEVuZCArIDI7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGNoID09PSAweDBBKSB7XG4gICAgICBsaW5lcysrO1xuICAgIH0gZWxzZSBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgIC8qZXNsaW50IG5vLWVtcHR5OjAqL1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBbbGFiZWxdOiAgIGRlc3RpbmF0aW9uICAgJ3RpdGxlJ1xuICAvLyAgICAgICAgICAgIF5eXl5eXl5eXl5eIHBhcnNlIHRoaXNcbiAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdHIsIHBvcywgbWF4KTtcbiAgaWYgKCFyZXMub2spIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gIGlmICghc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBvcyA9IHJlcy5wb3M7XG4gIGxpbmVzICs9IHJlcy5saW5lcztcblxuICAvLyBzYXZlIGN1cnNvciBzdGF0ZSwgd2UgY291bGQgcmVxdWlyZSB0byByb2xsYmFjayBsYXRlclxuICBkZXN0RW5kUG9zID0gcG9zO1xuICBkZXN0RW5kTGluZU5vID0gbGluZXM7XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgIF5eXiBza2lwcGluZyB0aG9zZSBzcGFjZXNcbiAgc3RhcnQgPSBwb3M7XG4gIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgbGluZXMrKztcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2UoY2gpKSB7XG4gICAgICAvKmVzbGludCBuby1lbXB0eTowKi9cbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gW2xhYmVsXTogICBkZXN0aW5hdGlvbiAgICd0aXRsZSdcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2UgdGhpc1xuICByZXMgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua1RpdGxlKHN0ciwgcG9zLCBtYXgpO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgdGl0bGUgPSByZXMuc3RyO1xuICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgbGluZXMgKz0gcmVzLmxpbmVzO1xuICB9IGVsc2Uge1xuICAgIHRpdGxlID0gJyc7XG4gICAgcG9zID0gZGVzdEVuZFBvcztcbiAgICBsaW5lcyA9IGRlc3RFbmRMaW5lTm87XG4gIH1cblxuICAvLyBza2lwIHRyYWlsaW5nIHNwYWNlcyB1bnRpbCB0aGUgcmVzdCBvZiB0aGUgbGluZVxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdHIuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChwb3MgPCBtYXggJiYgc3RyLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgwQSkge1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgLy8gZ2FyYmFnZSBhdCB0aGUgZW5kIG9mIHRoZSBsaW5lIGFmdGVyIHRpdGxlLFxuICAgICAgLy8gYnV0IGl0IGNvdWxkIHN0aWxsIGJlIGEgdmFsaWQgcmVmZXJlbmNlIGlmIHdlIHJvbGwgYmFja1xuICAgICAgdGl0bGUgPSAnJztcbiAgICAgIHBvcyA9IGRlc3RFbmRQb3M7XG4gICAgICBsaW5lcyA9IGRlc3RFbmRMaW5lTm87XG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAocG9zIDwgbWF4ICYmIHN0ci5jaGFyQ29kZUF0KHBvcykgIT09IDB4MEEpIHtcbiAgICAvLyBnYXJiYWdlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBsYWJlbCA9IG5vcm1hbGl6ZVJlZmVyZW5jZShzdHIuc2xpY2UoMSwgbGFiZWxFbmQpKTtcbiAgaWYgKCFsYWJlbCkge1xuICAgIC8vIENvbW1vbk1hcmsgMC4yMCBkaXNhbGxvd3MgZW1wdHkgbGFiZWxzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gUmVmZXJlbmNlIGNhbiBub3QgdGVybWluYXRlIGFueXRoaW5nLiBUaGlzIGNoZWNrIGlzIGZvciBzYWZldHkgb25seS5cbiAgLyppc3RhbmJ1bCBpZ25vcmUgaWYqL1xuICBpZiAoc2lsZW50KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9IHt9O1xuICB9XG4gIGlmICh0eXBlb2Ygc3RhdGUuZW52LnJlZmVyZW5jZXNbbGFiZWxdID09PSAndW5kZWZpbmVkJykge1xuICAgIHN0YXRlLmVudi5yZWZlcmVuY2VzW2xhYmVsXSA9IHsgdGl0bGU6IHRpdGxlLCBocmVmOiBocmVmIH07XG4gIH1cblxuICBzdGF0ZS5wYXJlbnRUeXBlID0gb2xkUGFyZW50VHlwZTtcblxuICBzdGF0ZS5saW5lID0gc3RhcnRMaW5lICsgbGluZXMgKyAxO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQYXJzZXIgc3RhdGUgY2xhc3NcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLi90b2tlbicpO1xudmFyIGlzU3BhY2UgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbmZ1bmN0aW9uIFN0YXRlQmxvY2soc3JjLCBtZCwgZW52LCB0b2tlbnMpIHtcbiAgdmFyIGNoLCBzLCBzdGFydCwgcG9zLCBsZW4sIGluZGVudCwgb2Zmc2V0LCBpbmRlbnRfZm91bmQ7XG5cbiAgdGhpcy5zcmMgPSBzcmM7XG5cbiAgLy8gbGluayB0byBwYXJzZXIgaW5zdGFuY2VcbiAgdGhpcy5tZCAgICAgPSBtZDtcblxuICB0aGlzLmVudiA9IGVudjtcblxuICAvL1xuICAvLyBJbnRlcm5hbCBzdGF0ZSB2YXJ0aWFibGVzXG4gIC8vXG5cbiAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG5cbiAgdGhpcy5iTWFya3MgPSBbXTsgIC8vIGxpbmUgYmVnaW4gb2Zmc2V0cyBmb3IgZmFzdCBqdW1wc1xuICB0aGlzLmVNYXJrcyA9IFtdOyAgLy8gbGluZSBlbmQgb2Zmc2V0cyBmb3IgZmFzdCBqdW1wc1xuICB0aGlzLnRTaGlmdCA9IFtdOyAgLy8gb2Zmc2V0cyBvZiB0aGUgZmlyc3Qgbm9uLXNwYWNlIGNoYXJhY3RlcnMgKHRhYnMgbm90IGV4cGFuZGVkKVxuICB0aGlzLnNDb3VudCA9IFtdOyAgLy8gaW5kZW50cyBmb3IgZWFjaCBsaW5lICh0YWJzIGV4cGFuZGVkKVxuXG4gIC8vIEFuIGFtb3VudCBvZiB2aXJ0dWFsIHNwYWNlcyAodGFicyBleHBhbmRlZCkgYmV0d2VlbiBiZWdpbm5pbmdcbiAgLy8gb2YgZWFjaCBsaW5lIChiTWFya3MpIGFuZCByZWFsIGJlZ2lubmluZyBvZiB0aGF0IGxpbmUuXG4gIC8vXG4gIC8vIEl0IGV4aXN0cyBvbmx5IGFzIGEgaGFjayBiZWNhdXNlIGJsb2NrcXVvdGVzIG92ZXJyaWRlIGJNYXJrc1xuICAvLyBsb3NpbmcgaW5mb3JtYXRpb24gaW4gdGhlIHByb2Nlc3MuXG4gIC8vXG4gIC8vIEl0J3MgdXNlZCBvbmx5IHdoZW4gZXhwYW5kaW5nIHRhYnMsIHlvdSBjYW4gdGhpbmsgYWJvdXQgaXQgYXNcbiAgLy8gYW4gaW5pdGlhbCB0YWIgbGVuZ3RoLCBlLmcuIGJzQ291bnQ9MjEgYXBwbGllZCB0byBzdHJpbmcgYFxcdDEyM2BcbiAgLy8gbWVhbnMgZmlyc3QgdGFiIHNob3VsZCBiZSBleHBhbmRlZCB0byA0LTIxJTQgPT09IDMgc3BhY2VzLlxuICAvL1xuICB0aGlzLmJzQ291bnQgPSBbXTtcblxuICAvLyBibG9jayBwYXJzZXIgdmFyaWFibGVzXG4gIHRoaXMuYmxrSW5kZW50ICA9IDA7IC8vIHJlcXVpcmVkIGJsb2NrIGNvbnRlbnQgaW5kZW50XG4gICAgICAgICAgICAgICAgICAgICAgIC8vIChmb3IgZXhhbXBsZSwgaWYgd2UgYXJlIGluIGxpc3QpXG4gIHRoaXMubGluZSAgICAgICA9IDA7IC8vIGxpbmUgaW5kZXggaW4gc3JjXG4gIHRoaXMubGluZU1heCAgICA9IDA7IC8vIGxpbmVzIGNvdW50XG4gIHRoaXMudGlnaHQgICAgICA9IGZhbHNlOyAgLy8gbG9vc2UvdGlnaHQgbW9kZSBmb3IgbGlzdHNcbiAgdGhpcy5kZEluZGVudCAgID0gLTE7IC8vIGluZGVudCBvZiB0aGUgY3VycmVudCBkZCBibG9jayAoLTEgaWYgdGhlcmUgaXNuJ3QgYW55KVxuXG4gIC8vIGNhbiBiZSAnYmxvY2txdW90ZScsICdsaXN0JywgJ3Jvb3QnLCAncGFyYWdyYXBoJyBvciAncmVmZXJlbmNlJ1xuICAvLyB1c2VkIGluIGxpc3RzIHRvIGRldGVybWluZSBpZiB0aGV5IGludGVycnVwdCBhIHBhcmFncmFwaFxuICB0aGlzLnBhcmVudFR5cGUgPSAncm9vdCc7XG5cbiAgdGhpcy5sZXZlbCA9IDA7XG5cbiAgLy8gcmVuZGVyZXJcbiAgdGhpcy5yZXN1bHQgPSAnJztcblxuICAvLyBDcmVhdGUgY2FjaGVzXG4gIC8vIEdlbmVyYXRlIG1hcmtlcnMuXG4gIHMgPSB0aGlzLnNyYztcbiAgaW5kZW50X2ZvdW5kID0gZmFsc2U7XG5cbiAgZm9yIChzdGFydCA9IHBvcyA9IGluZGVudCA9IG9mZnNldCA9IDAsIGxlbiA9IHMubGVuZ3RoOyBwb3MgPCBsZW47IHBvcysrKSB7XG4gICAgY2ggPSBzLmNoYXJDb2RlQXQocG9zKTtcblxuICAgIGlmICghaW5kZW50X2ZvdW5kKSB7XG4gICAgICBpZiAoaXNTcGFjZShjaCkpIHtcbiAgICAgICAgaW5kZW50Kys7XG5cbiAgICAgICAgaWYgKGNoID09PSAweDA5KSB7XG4gICAgICAgICAgb2Zmc2V0ICs9IDQgLSBvZmZzZXQgJSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZW50X2ZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2ggPT09IDB4MEEgfHwgcG9zID09PSBsZW4gLSAxKSB7XG4gICAgICBpZiAoY2ggIT09IDB4MEEpIHsgcG9zKys7IH1cbiAgICAgIHRoaXMuYk1hcmtzLnB1c2goc3RhcnQpO1xuICAgICAgdGhpcy5lTWFya3MucHVzaChwb3MpO1xuICAgICAgdGhpcy50U2hpZnQucHVzaChpbmRlbnQpO1xuICAgICAgdGhpcy5zQ291bnQucHVzaChvZmZzZXQpO1xuICAgICAgdGhpcy5ic0NvdW50LnB1c2goMCk7XG5cbiAgICAgIGluZGVudF9mb3VuZCA9IGZhbHNlO1xuICAgICAgaW5kZW50ID0gMDtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgfVxuICB9XG5cbiAgLy8gUHVzaCBmYWtlIGVudHJ5IHRvIHNpbXBsaWZ5IGNhY2hlIGJvdW5kcyBjaGVja3NcbiAgdGhpcy5iTWFya3MucHVzaChzLmxlbmd0aCk7XG4gIHRoaXMuZU1hcmtzLnB1c2gocy5sZW5ndGgpO1xuICB0aGlzLnRTaGlmdC5wdXNoKDApO1xuICB0aGlzLnNDb3VudC5wdXNoKDApO1xuICB0aGlzLmJzQ291bnQucHVzaCgwKTtcblxuICB0aGlzLmxpbmVNYXggPSB0aGlzLmJNYXJrcy5sZW5ndGggLSAxOyAvLyBkb24ndCBjb3VudCBsYXN0IGZha2UgbGluZVxufVxuXG4vLyBQdXNoIG5ldyB0b2tlbiB0byBcInN0cmVhbVwiLlxuLy9cblN0YXRlQmxvY2sucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodHlwZSwgdGFnLCBuZXN0aW5nKSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpO1xuICB0b2tlbi5ibG9jayA9IHRydWU7XG5cbiAgaWYgKG5lc3RpbmcgPCAwKSB7IHRoaXMubGV2ZWwtLTsgfVxuICB0b2tlbi5sZXZlbCA9IHRoaXMubGV2ZWw7XG4gIGlmIChuZXN0aW5nID4gMCkgeyB0aGlzLmxldmVsKys7IH1cblxuICB0aGlzLnRva2Vucy5wdXNoKHRva2VuKTtcbiAgcmV0dXJuIHRva2VuO1xufTtcblxuU3RhdGVCbG9jay5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkobGluZSkge1xuICByZXR1cm4gdGhpcy5iTWFya3NbbGluZV0gKyB0aGlzLnRTaGlmdFtsaW5lXSA+PSB0aGlzLmVNYXJrc1tsaW5lXTtcbn07XG5cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBFbXB0eUxpbmVzID0gZnVuY3Rpb24gc2tpcEVtcHR5TGluZXMoZnJvbSkge1xuICBmb3IgKHZhciBtYXggPSB0aGlzLmxpbmVNYXg7IGZyb20gPCBtYXg7IGZyb20rKykge1xuICAgIGlmICh0aGlzLmJNYXJrc1tmcm9tXSArIHRoaXMudFNoaWZ0W2Zyb21dIDwgdGhpcy5lTWFya3NbZnJvbV0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnJvbTtcbn07XG5cbi8vIFNraXAgc3BhY2VzIGZyb20gZ2l2ZW4gcG9zaXRpb24uXG5TdGF0ZUJsb2NrLnByb3RvdHlwZS5za2lwU3BhY2VzID0gZnVuY3Rpb24gc2tpcFNwYWNlcyhwb3MpIHtcbiAgdmFyIGNoO1xuXG4gIGZvciAodmFyIG1heCA9IHRoaXMuc3JjLmxlbmd0aDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgIGNoID0gdGhpcy5zcmMuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICghaXNTcGFjZShjaCkpIHsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBzcGFjZXMgZnJvbSBnaXZlbiBwb3NpdGlvbiBpbiByZXZlcnNlLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcFNwYWNlc0JhY2sgPSBmdW5jdGlvbiBza2lwU3BhY2VzQmFjayhwb3MsIG1pbikge1xuICBpZiAocG9zIDw9IG1pbikgeyByZXR1cm4gcG9zOyB9XG5cbiAgd2hpbGUgKHBvcyA+IG1pbikge1xuICAgIGlmICghaXNTcGFjZSh0aGlzLnNyYy5jaGFyQ29kZUF0KC0tcG9zKSkpIHsgcmV0dXJuIHBvcyArIDE7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gU2tpcCBjaGFyIGNvZGVzIGZyb20gZ2l2ZW4gcG9zaXRpb25cblN0YXRlQmxvY2sucHJvdG90eXBlLnNraXBDaGFycyA9IGZ1bmN0aW9uIHNraXBDaGFycyhwb3MsIGNvZGUpIHtcbiAgZm9yICh2YXIgbWF4ID0gdGhpcy5zcmMubGVuZ3RoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgaWYgKHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gY29kZSkgeyBicmVhazsgfVxuICB9XG4gIHJldHVybiBwb3M7XG59O1xuXG4vLyBTa2lwIGNoYXIgY29kZXMgcmV2ZXJzZSBmcm9tIGdpdmVuIHBvc2l0aW9uIC0gMVxuU3RhdGVCbG9jay5wcm90b3R5cGUuc2tpcENoYXJzQmFjayA9IGZ1bmN0aW9uIHNraXBDaGFyc0JhY2socG9zLCBjb2RlLCBtaW4pIHtcbiAgaWYgKHBvcyA8PSBtaW4pIHsgcmV0dXJuIHBvczsgfVxuXG4gIHdoaWxlIChwb3MgPiBtaW4pIHtcbiAgICBpZiAoY29kZSAhPT0gdGhpcy5zcmMuY2hhckNvZGVBdCgtLXBvcykpIHsgcmV0dXJuIHBvcyArIDE7IH1cbiAgfVxuICByZXR1cm4gcG9zO1xufTtcblxuLy8gY3V0IGxpbmVzIHJhbmdlIGZyb20gc291cmNlLlxuU3RhdGVCbG9jay5wcm90b3R5cGUuZ2V0TGluZXMgPSBmdW5jdGlvbiBnZXRMaW5lcyhiZWdpbiwgZW5kLCBpbmRlbnQsIGtlZXBMYXN0TEYpIHtcbiAgdmFyIGksIGxpbmVJbmRlbnQsIGNoLCBmaXJzdCwgbGFzdCwgcXVldWUsIGxpbmVTdGFydCxcbiAgICAgIGxpbmUgPSBiZWdpbjtcblxuICBpZiAoYmVnaW4gPj0gZW5kKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcXVldWUgPSBuZXcgQXJyYXkoZW5kIC0gYmVnaW4pO1xuXG4gIGZvciAoaSA9IDA7IGxpbmUgPCBlbmQ7IGxpbmUrKywgaSsrKSB7XG4gICAgbGluZUluZGVudCA9IDA7XG4gICAgbGluZVN0YXJ0ID0gZmlyc3QgPSB0aGlzLmJNYXJrc1tsaW5lXTtcblxuICAgIGlmIChsaW5lICsgMSA8IGVuZCB8fCBrZWVwTGFzdExGKSB7XG4gICAgICAvLyBObyBuZWVkIGZvciBib3VuZHMgY2hlY2sgYmVjYXVzZSB3ZSBoYXZlIGZha2UgZW50cnkgb24gdGFpbC5cbiAgICAgIGxhc3QgPSB0aGlzLmVNYXJrc1tsaW5lXSArIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSB0aGlzLmVNYXJrc1tsaW5lXTtcbiAgICB9XG5cbiAgICB3aGlsZSAoZmlyc3QgPCBsYXN0ICYmIGxpbmVJbmRlbnQgPCBpbmRlbnQpIHtcbiAgICAgIGNoID0gdGhpcy5zcmMuY2hhckNvZGVBdChmaXJzdCk7XG5cbiAgICAgIGlmIChpc1NwYWNlKGNoKSkge1xuICAgICAgICBpZiAoY2ggPT09IDB4MDkpIHtcbiAgICAgICAgICBsaW5lSW5kZW50ICs9IDQgLSAobGluZUluZGVudCArIHRoaXMuYnNDb3VudFtsaW5lXSkgJSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVJbmRlbnQrKztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmaXJzdCAtIGxpbmVTdGFydCA8IHRoaXMudFNoaWZ0W2xpbmVdKSB7XG4gICAgICAgIC8vIHBhdGNoZWQgdFNoaWZ0IG1hc2tlZCBjaGFyYWN0ZXJzIHRvIGxvb2sgbGlrZSBzcGFjZXMgKGJsb2NrcXVvdGVzLCBsaXN0IG1hcmtlcnMpXG4gICAgICAgIGxpbmVJbmRlbnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmaXJzdCsrO1xuICAgIH1cblxuICAgIGlmIChsaW5lSW5kZW50ID4gaW5kZW50KSB7XG4gICAgICAvLyBwYXJ0aWFsbHkgZXhwYW5kaW5nIHRhYnMgaW4gY29kZSBibG9ja3MsIGUuZyAnXFx0XFx0Zm9vYmFyJ1xuICAgICAgLy8gd2l0aCBpbmRlbnQ9MiBiZWNvbWVzICcgIFxcdGZvb2JhcidcbiAgICAgIHF1ZXVlW2ldID0gbmV3IEFycmF5KGxpbmVJbmRlbnQgLSBpbmRlbnQgKyAxKS5qb2luKCcgJykgKyB0aGlzLnNyYy5zbGljZShmaXJzdCwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlW2ldID0gdGhpcy5zcmMuc2xpY2UoZmlyc3QsIGxhc3QpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBxdWV1ZS5qb2luKCcnKTtcbn07XG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gYmxvY2sgcnVsZXNcblN0YXRlQmxvY2sucHJvdG90eXBlLlRva2VuID0gVG9rZW47XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0ZUJsb2NrO1xuIiwiLy8gR0ZNIHRhYmxlLCBub24tc3RhbmRhcmRcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxuZnVuY3Rpb24gZ2V0TGluZShzdGF0ZSwgbGluZSkge1xuICB2YXIgcG9zID0gc3RhdGUuYk1hcmtzW2xpbmVdICsgc3RhdGUuYmxrSW5kZW50LFxuICAgICAgbWF4ID0gc3RhdGUuZU1hcmtzW2xpbmVdO1xuXG4gIHJldHVybiBzdGF0ZS5zcmMuc3Vic3RyKHBvcywgbWF4IC0gcG9zKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlZFNwbGl0KHN0cikge1xuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBwb3MgPSAwLFxuICAgICAgbWF4ID0gc3RyLmxlbmd0aCxcbiAgICAgIGNoLFxuICAgICAgZXNjYXBlcyA9IDAsXG4gICAgICBsYXN0UG9zID0gMCxcbiAgICAgIGJhY2tUaWNrZWQgPSBmYWxzZSxcbiAgICAgIGxhc3RCYWNrVGljayA9IDA7XG5cbiAgY2ggID0gc3RyLmNoYXJDb2RlQXQocG9zKTtcblxuICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgaWYgKGNoID09PSAweDYwLyogYCAqLykge1xuICAgICAgaWYgKGJhY2tUaWNrZWQpIHtcbiAgICAgICAgLy8gbWFrZSBcXGAgY2xvc2UgY29kZSBzZXF1ZW5jZSwgYnV0IG5vdCBvcGVuIGl0O1xuICAgICAgICAvLyB0aGUgcmVhc29uIGlzOiBgXFxgIGlzIGNvcnJlY3QgY29kZSBibG9ja1xuICAgICAgICBiYWNrVGlja2VkID0gZmFsc2U7XG4gICAgICAgIGxhc3RCYWNrVGljayA9IHBvcztcbiAgICAgIH0gZWxzZSBpZiAoZXNjYXBlcyAlIDIgPT09IDApIHtcbiAgICAgICAgYmFja1RpY2tlZCA9IHRydWU7XG4gICAgICAgIGxhc3RCYWNrVGljayA9IHBvcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09PSAweDdjLyogfCAqLyAmJiAoZXNjYXBlcyAlIDIgPT09IDApICYmICFiYWNrVGlja2VkKSB7XG4gICAgICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MsIHBvcykpO1xuICAgICAgbGFzdFBvcyA9IHBvcyArIDE7XG4gICAgfVxuXG4gICAgaWYgKGNoID09PSAweDVjLyogXFwgKi8pIHtcbiAgICAgIGVzY2FwZXMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgZXNjYXBlcyA9IDA7XG4gICAgfVxuXG4gICAgcG9zKys7XG5cbiAgICAvLyBJZiB0aGVyZSB3YXMgYW4gdW4tY2xvc2VkIGJhY2t0aWNrLCBnbyBiYWNrIHRvIGp1c3QgYWZ0ZXJcbiAgICAvLyB0aGUgbGFzdCBiYWNrdGljaywgYnV0IGFzIGlmIGl0IHdhcyBhIG5vcm1hbCBjaGFyYWN0ZXJcbiAgICBpZiAocG9zID09PSBtYXggJiYgYmFja1RpY2tlZCkge1xuICAgICAgYmFja1RpY2tlZCA9IGZhbHNlO1xuICAgICAgcG9zID0gbGFzdEJhY2tUaWNrICsgMTtcbiAgICB9XG5cbiAgICBjaCA9IHN0ci5jaGFyQ29kZUF0KHBvcyk7XG4gIH1cblxuICByZXN1bHQucHVzaChzdHIuc3Vic3RyaW5nKGxhc3RQb3MpKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdGFibGUoc3RhdGUsIHN0YXJ0TGluZSwgZW5kTGluZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgbGluZVRleHQsIHBvcywgaSwgbmV4dExpbmUsIGNvbHVtbnMsIGNvbHVtbkNvdW50LCB0b2tlbixcbiAgICAgIGFsaWducywgdCwgdGFibGVMaW5lcywgdGJvZHlMaW5lcztcblxuICAvLyBzaG91bGQgaGF2ZSBhdCBsZWFzdCB0d28gbGluZXNcbiAgaWYgKHN0YXJ0TGluZSArIDIgPiBlbmRMaW5lKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIG5leHRMaW5lID0gc3RhcnRMaW5lICsgMTtcblxuICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAvLyBpZiBpdCdzIGluZGVudGVkIG1vcmUgdGhhbiAzIHNwYWNlcywgaXQgc2hvdWxkIGJlIGEgY29kZSBibG9ja1xuICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSAtIHN0YXRlLmJsa0luZGVudCA+PSA0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIGZpcnN0IGNoYXJhY3RlciBvZiB0aGUgc2Vjb25kIGxpbmUgc2hvdWxkIGJlICd8JywgJy0nLCAnOicsXG4gIC8vIGFuZCBubyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBhbGxvd2VkIGJ1dCBzcGFjZXM7XG4gIC8vIGJhc2ljYWxseSwgdGhpcyBpcyB0aGUgZXF1aXZhbGVudCBvZiAvXlstOnxdWy06fFxcc10qJC8gcmVnZXhwXG5cbiAgcG9zID0gc3RhdGUuYk1hcmtzW25leHRMaW5lXSArIHN0YXRlLnRTaGlmdFtuZXh0TGluZV07XG4gIGlmIChwb3MgPj0gc3RhdGUuZU1hcmtzW25leHRMaW5lXSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBjaCA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcysrKTtcbiAgaWYgKGNoICE9PSAweDdDLyogfCAqLyAmJiBjaCAhPT0gMHgyRC8qIC0gKi8gJiYgY2ggIT09IDB4M0EvKiA6ICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHdoaWxlIChwb3MgPCBzdGF0ZS5lTWFya3NbbmV4dExpbmVdKSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNoICE9PSAweDdDLyogfCAqLyAmJiBjaCAhPT0gMHgyRC8qIC0gKi8gJiYgY2ggIT09IDB4M0EvKiA6ICovICYmICFpc1NwYWNlKGNoKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBzdGFydExpbmUgKyAxKTtcblxuICBjb2x1bW5zID0gbGluZVRleHQuc3BsaXQoJ3wnKTtcbiAgYWxpZ25zID0gW107XG4gIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgdCA9IGNvbHVtbnNbaV0udHJpbSgpO1xuICAgIGlmICghdCkge1xuICAgICAgLy8gYWxsb3cgZW1wdHkgY29sdW1ucyBiZWZvcmUgYW5kIGFmdGVyIHRhYmxlLCBidXQgbm90IGluIGJldHdlZW4gY29sdW1ucztcbiAgICAgIC8vIGUuZy4gYWxsb3cgYCB8LS0tfCBgLCBkaXNhbGxvdyBgIC0tLXx8LS0tIGBcbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGNvbHVtbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eOj8tKzo/JC8udGVzdCh0KSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpZiAodC5jaGFyQ29kZUF0KHQubGVuZ3RoIC0gMSkgPT09IDB4M0EvKiA6ICovKSB7XG4gICAgICBhbGlnbnMucHVzaCh0LmNoYXJDb2RlQXQoMCkgPT09IDB4M0EvKiA6ICovID8gJ2NlbnRlcicgOiAncmlnaHQnKTtcbiAgICB9IGVsc2UgaWYgKHQuY2hhckNvZGVBdCgwKSA9PT0gMHgzQS8qIDogKi8pIHtcbiAgICAgIGFsaWducy5wdXNoKCdsZWZ0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFsaWducy5wdXNoKCcnKTtcbiAgICB9XG4gIH1cblxuICBsaW5lVGV4dCA9IGdldExpbmUoc3RhdGUsIHN0YXJ0TGluZSkudHJpbSgpO1xuICBpZiAobGluZVRleHQuaW5kZXhPZignfCcpID09PSAtMSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNDb3VudFtzdGFydExpbmVdIC0gc3RhdGUuYmxrSW5kZW50ID49IDQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIGNvbHVtbnMgPSBlc2NhcGVkU3BsaXQobGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKSk7XG5cbiAgLy8gaGVhZGVyIHJvdyB3aWxsIGRlZmluZSBhbiBhbW91bnQgb2YgY29sdW1ucyBpbiB0aGUgZW50aXJlIHRhYmxlLFxuICAvLyBhbmQgYWxpZ24gcm93IHNob3VsZG4ndCBiZSBzbWFsbGVyIHRoYW4gdGhhdCAodGhlIHJlc3Qgb2YgdGhlIHJvd3MgY2FuKVxuICBjb2x1bW5Db3VudCA9IGNvbHVtbnMubGVuZ3RoO1xuICBpZiAoY29sdW1uQ291bnQgPiBhbGlnbnMubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIHRydWU7IH1cblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0YWJsZV9vcGVuJywgJ3RhYmxlJywgMSk7XG4gIHRva2VuLm1hcCA9IHRhYmxlTGluZXMgPSBbIHN0YXJ0TGluZSwgMCBdO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX29wZW4nLCAndGhlYWQnLCAxKTtcbiAgdG9rZW4ubWFwID0gWyBzdGFydExpbmUsIHN0YXJ0TGluZSArIDEgXTtcblxuICB0b2tlbiAgICAgPSBzdGF0ZS5wdXNoKCd0cl9vcGVuJywgJ3RyJywgMSk7XG4gIHRva2VuLm1hcCA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG5cbiAgZm9yIChpID0gMDsgaSA8IGNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX29wZW4nLCAndGgnLCAxKTtcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgc3RhcnRMaW5lLCBzdGFydExpbmUgKyAxIF07XG4gICAgaWYgKGFsaWduc1tpXSkge1xuICAgICAgdG9rZW4uYXR0cnMgID0gWyBbICdzdHlsZScsICd0ZXh0LWFsaWduOicgKyBhbGlnbnNbaV0gXSBdO1xuICAgIH1cblxuICAgIHRva2VuICAgICAgICAgID0gc3RhdGUucHVzaCgnaW5saW5lJywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgID0gY29sdW1uc1tpXS50cmltKCk7XG4gICAgdG9rZW4ubWFwICAgICAgPSBbIHN0YXJ0TGluZSwgc3RhcnRMaW5lICsgMSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ3RoX2Nsb3NlJywgJ3RoJywgLTEpO1xuICB9XG5cbiAgdG9rZW4gICAgID0gc3RhdGUucHVzaCgndHJfY2xvc2UnLCAndHInLCAtMSk7XG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3RoZWFkX2Nsb3NlJywgJ3RoZWFkJywgLTEpO1xuXG4gIHRva2VuICAgICA9IHN0YXRlLnB1c2goJ3Rib2R5X29wZW4nLCAndGJvZHknLCAxKTtcbiAgdG9rZW4ubWFwID0gdGJvZHlMaW5lcyA9IFsgc3RhcnRMaW5lICsgMiwgMCBdO1xuXG4gIGZvciAobmV4dExpbmUgPSBzdGFydExpbmUgKyAyOyBuZXh0TGluZSA8IGVuZExpbmU7IG5leHRMaW5lKyspIHtcbiAgICBpZiAoc3RhdGUuc0NvdW50W25leHRMaW5lXSA8IHN0YXRlLmJsa0luZGVudCkgeyBicmVhazsgfVxuXG4gICAgbGluZVRleHQgPSBnZXRMaW5lKHN0YXRlLCBuZXh0TGluZSkudHJpbSgpO1xuICAgIGlmIChsaW5lVGV4dC5pbmRleE9mKCd8JykgPT09IC0xKSB7IGJyZWFrOyB9XG4gICAgaWYgKHN0YXRlLnNDb3VudFtuZXh0TGluZV0gLSBzdGF0ZS5ibGtJbmRlbnQgPj0gNCkgeyBicmVhazsgfVxuICAgIGNvbHVtbnMgPSBlc2NhcGVkU3BsaXQobGluZVRleHQucmVwbGFjZSgvXlxcfHxcXHwkL2csICcnKSk7XG5cbiAgICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RyX29wZW4nLCAndHInLCAxKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9vcGVuJywgJ3RkJywgMSk7XG4gICAgICBpZiAoYWxpZ25zW2ldKSB7XG4gICAgICAgIHRva2VuLmF0dHJzICA9IFsgWyAnc3R5bGUnLCAndGV4dC1hbGlnbjonICsgYWxpZ25zW2ldIF0gXTtcbiAgICAgIH1cblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCdpbmxpbmUnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ICA9IGNvbHVtbnNbaV0gPyBjb2x1bW5zW2ldLnRyaW0oKSA6ICcnO1xuICAgICAgdG9rZW4uY2hpbGRyZW4gPSBbXTtcblxuICAgICAgdG9rZW4gICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZF9jbG9zZScsICd0ZCcsIC0xKTtcbiAgICB9XG4gICAgdG9rZW4gPSBzdGF0ZS5wdXNoKCd0cl9jbG9zZScsICd0cicsIC0xKTtcbiAgfVxuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3Rib2R5X2Nsb3NlJywgJ3Rib2R5JywgLTEpO1xuICB0b2tlbiA9IHN0YXRlLnB1c2goJ3RhYmxlX2Nsb3NlJywgJ3RhYmxlJywgLTEpO1xuXG4gIHRhYmxlTGluZXNbMV0gPSB0Ym9keUxpbmVzWzFdID0gbmV4dExpbmU7XG4gIHN0YXRlLmxpbmUgPSBuZXh0TGluZTtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmxvY2soc3RhdGUpIHtcbiAgdmFyIHRva2VuO1xuXG4gIGlmIChzdGF0ZS5pbmxpbmVNb2RlKSB7XG4gICAgdG9rZW4gICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ICA9IHN0YXRlLnNyYztcbiAgICB0b2tlbi5tYXAgICAgICA9IFsgMCwgMSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gW107XG4gICAgc3RhdGUudG9rZW5zLnB1c2godG9rZW4pO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLm1kLmJsb2NrLnBhcnNlKHN0YXRlLnNyYywgc3RhdGUubWQsIHN0YXRlLmVudiwgc3RhdGUudG9rZW5zKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmxpbmUoc3RhdGUpIHtcbiAgdmFyIHRva2VucyA9IHN0YXRlLnRva2VucywgdG9rLCBpLCBsO1xuXG4gIC8vIFBhcnNlIGlubGluZXNcbiAgZm9yIChpID0gMCwgbCA9IHRva2Vucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB0b2sgPSB0b2tlbnNbaV07XG4gICAgaWYgKHRvay50eXBlID09PSAnaW5saW5lJykge1xuICAgICAgc3RhdGUubWQuaW5saW5lLnBhcnNlKHRvay5jb250ZW50LCBzdGF0ZS5tZCwgc3RhdGUuZW52LCB0b2suY2hpbGRyZW4pO1xuICAgIH1cbiAgfVxufTtcbiIsIi8vIFJlcGxhY2UgbGluay1saWtlIHRleHRzIHdpdGggbGluayBub2Rlcy5cbi8vXG4vLyBDdXJyZW50bHkgcmVzdHJpY3RlZCBieSBgbWQudmFsaWRhdGVMaW5rKClgIHRvIGh0dHAvaHR0cHMvZnRwXG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBhcnJheVJlcGxhY2VBdCA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmFycmF5UmVwbGFjZUF0O1xuXG5cbmZ1bmN0aW9uIGlzTGlua09wZW4oc3RyKSB7XG4gIHJldHVybiAvXjxhWz5cXHNdL2kudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gaXNMaW5rQ2xvc2Uoc3RyKSB7XG4gIHJldHVybiAvXjxcXC9hXFxzKj4vaS50ZXN0KHN0cik7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5raWZ5KHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsLCB0b2tlbnMsIHRva2VuLCBjdXJyZW50VG9rZW4sIG5vZGVzLCBsbiwgdGV4dCwgcG9zLCBsYXN0UG9zLFxuICAgICAgbGV2ZWwsIGh0bWxMaW5rTGV2ZWwsIHVybCwgZnVsbFVybCwgdXJsVGV4dCxcbiAgICAgIGJsb2NrVG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbGlua3M7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLmxpbmtpZnkpIHsgcmV0dXJuOyB9XG5cbiAgZm9yIChqID0gMCwgbCA9IGJsb2NrVG9rZW5zLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgIGlmIChibG9ja1Rva2Vuc1tqXS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhc3RhdGUubWQubGlua2lmeS5wcmV0ZXN0KGJsb2NrVG9rZW5zW2pdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB0b2tlbnMgPSBibG9ja1Rva2Vuc1tqXS5jaGlsZHJlbjtcblxuICAgIGh0bWxMaW5rTGV2ZWwgPSAwO1xuXG4gICAgLy8gV2Ugc2NhbiBmcm9tIHRoZSBlbmQsIHRvIGtlZXAgcG9zaXRpb24gd2hlbiBuZXcgdGFncyBhZGRlZC5cbiAgICAvLyBVc2UgcmV2ZXJzZWQgbG9naWMgaW4gbGlua3Mgc3RhcnQvZW5kIG1hdGNoXG4gICAgZm9yIChpID0gdG9rZW5zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjdXJyZW50VG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIC8vIFNraXAgY29udGVudCBvZiBtYXJrZG93biBsaW5rc1xuICAgICAgaWYgKGN1cnJlbnRUb2tlbi50eXBlID09PSAnbGlua19jbG9zZScpIHtcbiAgICAgICAgaS0tO1xuICAgICAgICB3aGlsZSAodG9rZW5zW2ldLmxldmVsICE9PSBjdXJyZW50VG9rZW4ubGV2ZWwgJiYgdG9rZW5zW2ldLnR5cGUgIT09ICdsaW5rX29wZW4nKSB7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGNvbnRlbnQgb2YgaHRtbCB0YWcgbGlua3NcbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ2h0bWxfaW5saW5lJykge1xuICAgICAgICBpZiAoaXNMaW5rT3BlbihjdXJyZW50VG9rZW4uY29udGVudCkgJiYgaHRtbExpbmtMZXZlbCA+IDApIHtcbiAgICAgICAgICBodG1sTGlua0xldmVsLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTGlua0Nsb3NlKGN1cnJlbnRUb2tlbi5jb250ZW50KSkge1xuICAgICAgICAgIGh0bWxMaW5rTGV2ZWwrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGh0bWxMaW5rTGV2ZWwgPiAwKSB7IGNvbnRpbnVlOyB9XG5cbiAgICAgIGlmIChjdXJyZW50VG9rZW4udHlwZSA9PT0gJ3RleHQnICYmIHN0YXRlLm1kLmxpbmtpZnkudGVzdChjdXJyZW50VG9rZW4uY29udGVudCkpIHtcblxuICAgICAgICB0ZXh0ID0gY3VycmVudFRva2VuLmNvbnRlbnQ7XG4gICAgICAgIGxpbmtzID0gc3RhdGUubWQubGlua2lmeS5tYXRjaCh0ZXh0KTtcblxuICAgICAgICAvLyBOb3cgc3BsaXQgc3RyaW5nIHRvIG5vZGVzXG4gICAgICAgIG5vZGVzID0gW107XG4gICAgICAgIGxldmVsID0gY3VycmVudFRva2VuLmxldmVsO1xuICAgICAgICBsYXN0UG9zID0gMDtcblxuICAgICAgICBmb3IgKGxuID0gMDsgbG4gPCBsaW5rcy5sZW5ndGg7IGxuKyspIHtcblxuICAgICAgICAgIHVybCA9IGxpbmtzW2xuXS51cmw7XG4gICAgICAgICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICAgICAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdXJsVGV4dCA9IGxpbmtzW2xuXS50ZXh0O1xuXG4gICAgICAgICAgLy8gTGlua2lmaWVyIG1pZ2h0IHNlbmQgcmF3IGhvc3RuYW1lcyBsaWtlIFwiZXhhbXBsZS5jb21cIiwgd2hlcmUgdXJsXG4gICAgICAgICAgLy8gc3RhcnRzIHdpdGggZG9tYWluIG5hbWUuIFNvIHdlIHByZXBlbmQgaHR0cDovLyBpbiB0aG9zZSBjYXNlcyxcbiAgICAgICAgICAvLyBhbmQgcmVtb3ZlIGl0IGFmdGVyd2FyZHMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICBpZiAoIWxpbmtzW2xuXS5zY2hlbWEpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnaHR0cDovLycgKyB1cmxUZXh0KS5yZXBsYWNlKC9eaHR0cDpcXC9cXC8vLCAnJyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsaW5rc1tsbl0uc2NoZW1hID09PSAnbWFpbHRvOicgJiYgIS9ebWFpbHRvOi9pLnRlc3QodXJsVGV4dCkpIHtcbiAgICAgICAgICAgIHVybFRleHQgPSBzdGF0ZS5tZC5ub3JtYWxpemVMaW5rVGV4dCgnbWFpbHRvOicgKyB1cmxUZXh0KS5yZXBsYWNlKC9ebWFpbHRvOi8sICcnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsVGV4dCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmtUZXh0KHVybFRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcyA9IGxpbmtzW2xuXS5pbmRleDtcblxuICAgICAgICAgIGlmIChwb3MgPiBsYXN0UG9zKSB7XG4gICAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHRleHQuc2xpY2UobGFzdFBvcywgcG9zKTtcbiAgICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ2xpbmtfb3BlbicsICdhJywgMSk7XG4gICAgICAgICAgdG9rZW4uYXR0cnMgICA9IFsgWyAnaHJlZicsIGZ1bGxVcmwgXSBdO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbCsrO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIHRva2VuICAgICAgICAgPSBuZXcgc3RhdGUuVG9rZW4oJ3RleHQnLCAnJywgMCk7XG4gICAgICAgICAgdG9rZW4uY29udGVudCA9IHVybFRleHQ7XG4gICAgICAgICAgdG9rZW4ubGV2ZWwgICA9IGxldmVsO1xuICAgICAgICAgIG5vZGVzLnB1c2godG9rZW4pO1xuXG4gICAgICAgICAgdG9rZW4gICAgICAgICA9IG5ldyBzdGF0ZS5Ub2tlbignbGlua19jbG9zZScsICdhJywgLTEpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSAtLWxldmVsO1xuICAgICAgICAgIHRva2VuLm1hcmt1cCAgPSAnbGlua2lmeSc7XG4gICAgICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcblxuICAgICAgICAgIGxhc3RQb3MgPSBsaW5rc1tsbl0ubGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UG9zIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICB0b2tlbiAgICAgICAgID0gbmV3IHN0YXRlLlRva2VuKCd0ZXh0JywgJycsIDApO1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSB0ZXh0LnNsaWNlKGxhc3RQb3MpO1xuICAgICAgICAgIHRva2VuLmxldmVsICAgPSBsZXZlbDtcbiAgICAgICAgICBub2Rlcy5wdXNoKHRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlcGxhY2UgY3VycmVudCBub2RlXG4gICAgICAgIGJsb2NrVG9rZW5zW2pdLmNoaWxkcmVuID0gdG9rZW5zID0gYXJyYXlSZXBsYWNlQXQodG9rZW5zLCBpLCBub2Rlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIiwiLy8gTm9ybWFsaXplIGlucHV0IHN0cmluZ1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIE5FV0xJTkVTX1JFICA9IC9cXHJbXFxuXFx1MDA4NV0/fFtcXHUyNDI0XFx1MjAyOFxcdTAwODVdL2c7XG52YXIgTlVMTF9SRSAgICAgID0gL1xcdTAwMDAvZztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlubGluZShzdGF0ZSkge1xuICB2YXIgc3RyO1xuXG4gIC8vIE5vcm1hbGl6ZSBuZXdsaW5lc1xuICBzdHIgPSBzdGF0ZS5zcmMucmVwbGFjZShORVdMSU5FU19SRSwgJ1xcbicpO1xuXG4gIC8vIFJlcGxhY2UgTlVMTCBjaGFyYWN0ZXJzXG4gIHN0ciA9IHN0ci5yZXBsYWNlKE5VTExfUkUsICdcXHVGRkZEJyk7XG5cbiAgc3RhdGUuc3JjID0gc3RyO1xufTtcbiIsIi8vIFNpbXBsZSB0eXBvZ3JhcGh5YyByZXBsYWNlbWVudHNcbi8vXG4vLyAoYykgKEMpIOKGkiDCqVxuLy8gKHRtKSAoVE0pIOKGkiDihKJcbi8vIChyKSAoUikg4oaSIMKuXG4vLyArLSDihpIgwrFcbi8vIChwKSAoUCkgLT4gwqdcbi8vIC4uLiDihpIg4oCmIChhbHNvID8uLi4uIOKGkiA/Li4sICEuLi4uIOKGkiAhLi4pXG4vLyA/Pz8/Pz8/PyDihpIgPz8/LCAhISEhISDihpIgISEhLCBgLCxgIOKGkiBgLGBcbi8vIC0tIOKGkiAmbmRhc2g7LCAtLS0g4oaSICZtZGFzaDtcbi8vXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRPRE86XG4vLyAtIGZyYWN0aW9uYWxzIDEvMiwgMS80LCAzLzQgLT4gwr0sIMK8LCDCvlxuLy8gLSBtaWx0aXBsaWNhdGlvbiAyIHggNCAtPiAyIMOXIDRcblxudmFyIFJBUkVfUkUgPSAvXFwrLXxcXC5cXC58XFw/XFw/XFw/XFw/fCEhISF8LCx8LS0vO1xuXG4vLyBXb3JrYXJvdW5kIGZvciBwaGFudG9tanMgLSBuZWVkIHJlZ2V4IHdpdGhvdXQgL2cgZmxhZyxcbi8vIG9yIHJvb3QgY2hlY2sgd2lsbCBmYWlsIGV2ZXJ5IHNlY29uZCB0aW1lXG52YXIgU0NPUEVEX0FCQlJfVEVTVF9SRSA9IC9cXCgoY3x0bXxyfHApXFwpL2k7XG5cbnZhciBTQ09QRURfQUJCUl9SRSA9IC9cXCgoY3x0bXxyfHApXFwpL2lnO1xudmFyIFNDT1BFRF9BQkJSID0ge1xuICBjOiAnwqknLFxuICByOiAnwq4nLFxuICBwOiAnwqcnLFxuICB0bTogJ+KEoidcbn07XG5cbmZ1bmN0aW9uIHJlcGxhY2VGbihtYXRjaCwgbmFtZSkge1xuICByZXR1cm4gU0NPUEVEX0FCQlJbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZV9zY29wZWQoaW5saW5lVG9rZW5zKSB7XG4gIHZhciBpLCB0b2tlbiwgaW5zaWRlX2F1dG9saW5rID0gMDtcblxuICBmb3IgKGkgPSBpbmxpbmVUb2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB0b2tlbiA9IGlubGluZVRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbi50eXBlID09PSAndGV4dCcgJiYgIWluc2lkZV9hdXRvbGluaykge1xuICAgICAgdG9rZW4uY29udGVudCA9IHRva2VuLmNvbnRlbnQucmVwbGFjZShTQ09QRURfQUJCUl9SRSwgcmVwbGFjZUZuKTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfb3BlbicgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmstLTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rKys7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VfcmFyZShpbmxpbmVUb2tlbnMpIHtcbiAgdmFyIGksIHRva2VuLCBpbnNpZGVfYXV0b2xpbmsgPSAwO1xuXG4gIGZvciAoaSA9IGlubGluZVRva2Vucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHRva2VuID0gaW5saW5lVG9rZW5zW2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICd0ZXh0JyAmJiAhaW5zaWRlX2F1dG9saW5rKSB7XG4gICAgICBpZiAoUkFSRV9SRS50ZXN0KHRva2VuLmNvbnRlbnQpKSB7XG4gICAgICAgIHRva2VuLmNvbnRlbnQgPSB0b2tlbi5jb250ZW50XG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCstL2csICfCsScpXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLCAuLi4sIC4uLi4uLi4gLT4g4oCmXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCA/Li4uLi4gJiAhLi4uLi4gLT4gPy4uICYgIS4uXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXC57Mix9L2csICfigKYnKS5yZXBsYWNlKC8oWz8hXSnigKYvZywgJyQxLi4nKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKFs/IV0pezQsfS9nLCAnJDEkMSQxJykucmVwbGFjZSgvLHsyLH0vZywgJywnKVxuICAgICAgICAgICAgICAgICAgICAvLyBlbS1kYXNoXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxbXi1dKS0tLShbXi1dfCQpL21nLCAnJDFcXHUyMDE0JDInKVxuICAgICAgICAgICAgICAgICAgICAvLyBlbi1kYXNoXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXnxcXHMpLS0oXFxzfCQpL21nLCAnJDFcXHUyMDEzJDInKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF58W14tXFxzXSktLShbXi1cXHNdfCQpL21nLCAnJDFcXHUyMDEzJDInKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfb3BlbicgJiYgdG9rZW4uaW5mbyA9PT0gJ2F1dG8nKSB7XG4gICAgICBpbnNpZGVfYXV0b2xpbmstLTtcbiAgICB9XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmtfY2xvc2UnICYmIHRva2VuLmluZm8gPT09ICdhdXRvJykge1xuICAgICAgaW5zaWRlX2F1dG9saW5rKys7XG4gICAgfVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXBsYWNlKHN0YXRlKSB7XG4gIHZhciBibGtJZHg7XG5cbiAgaWYgKCFzdGF0ZS5tZC5vcHRpb25zLnR5cG9ncmFwaGVyKSB7IHJldHVybjsgfVxuXG4gIGZvciAoYmxrSWR4ID0gc3RhdGUudG9rZW5zLmxlbmd0aCAtIDE7IGJsa0lkeCA+PSAwOyBibGtJZHgtLSkge1xuXG4gICAgaWYgKHN0YXRlLnRva2Vuc1tibGtJZHhdLnR5cGUgIT09ICdpbmxpbmUnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBpZiAoU0NPUEVEX0FCQlJfVEVTVF9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICByZXBsYWNlX3Njb3BlZChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgaWYgKFJBUkVfUkUudGVzdChzdGF0ZS50b2tlbnNbYmxrSWR4XS5jb250ZW50KSkge1xuICAgICAgcmVwbGFjZV9yYXJlKHN0YXRlLnRva2Vuc1tibGtJZHhdLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgfVxufTtcbiIsIi8vIENvbnZlcnQgc3RyYWlnaHQgcXVvdGF0aW9uIG1hcmtzIHRvIHR5cG9ncmFwaGljIG9uZXNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcblxudmFyIFFVT1RFX1RFU1RfUkUgPSAvWydcIl0vO1xudmFyIFFVT1RFX1JFID0gL1snXCJdL2c7XG52YXIgQVBPU1RST1BIRSA9ICdcXHUyMDE5JzsgLyog4oCZICovXG5cblxuZnVuY3Rpb24gcmVwbGFjZUF0KHN0ciwgaW5kZXgsIGNoKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKDAsIGluZGV4KSArIGNoICsgc3RyLnN1YnN0cihpbmRleCArIDEpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzX2lubGluZXModG9rZW5zLCBzdGF0ZSkge1xuICB2YXIgaSwgdG9rZW4sIHRleHQsIHQsIHBvcywgbWF4LCB0aGlzTGV2ZWwsIGl0ZW0sIGxhc3RDaGFyLCBuZXh0Q2hhcixcbiAgICAgIGlzTGFzdFB1bmN0Q2hhciwgaXNOZXh0UHVuY3RDaGFyLCBpc0xhc3RXaGl0ZVNwYWNlLCBpc05leHRXaGl0ZVNwYWNlLFxuICAgICAgY2FuT3BlbiwgY2FuQ2xvc2UsIGosIGlzU2luZ2xlLCBzdGFjaywgb3BlblF1b3RlLCBjbG9zZVF1b3RlO1xuXG4gIHN0YWNrID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgdGhpc0xldmVsID0gdG9rZW5zW2ldLmxldmVsO1xuXG4gICAgZm9yIChqID0gc3RhY2subGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChzdGFja1tqXS5sZXZlbCA8PSB0aGlzTGV2ZWwpIHsgYnJlYWs7IH1cbiAgICB9XG4gICAgc3RhY2subGVuZ3RoID0gaiArIDE7XG5cbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ3RleHQnKSB7IGNvbnRpbnVlOyB9XG5cbiAgICB0ZXh0ID0gdG9rZW4uY29udGVudDtcbiAgICBwb3MgPSAwO1xuICAgIG1heCA9IHRleHQubGVuZ3RoO1xuXG4gICAgLyplc2xpbnQgbm8tbGFiZWxzOjAsYmxvY2stc2NvcGVkLXZhcjowKi9cbiAgICBPVVRFUjpcbiAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICBRVU9URV9SRS5sYXN0SW5kZXggPSBwb3M7XG4gICAgICB0ID0gUVVPVEVfUkUuZXhlYyh0ZXh0KTtcbiAgICAgIGlmICghdCkgeyBicmVhazsgfVxuXG4gICAgICBjYW5PcGVuID0gY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgcG9zID0gdC5pbmRleCArIDE7XG4gICAgICBpc1NpbmdsZSA9ICh0WzBdID09PSBcIidcIik7XG5cbiAgICAgIC8vIEZpbmQgcHJldmlvdXMgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBsYXN0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmICh0LmluZGV4IC0gMSA+PSAwKSB7XG4gICAgICAgIGxhc3RDaGFyID0gdGV4dC5jaGFyQ29kZUF0KHQuaW5kZXggLSAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSA9PT0gJ3NvZnRicmVhaycgfHwgdG9rZW5zW2pdLnR5cGUgPT09ICdoYXJkYnJlYWsnKSBicmVhazsgLy8gbGFzdENoYXIgZGVmYXVsdHMgdG8gMHgyMFxuICAgICAgICAgIGlmICh0b2tlbnNbal0udHlwZSAhPT0gJ3RleHQnKSBjb250aW51ZTtcblxuICAgICAgICAgIGxhc3RDaGFyID0gdG9rZW5zW2pdLmNvbnRlbnQuY2hhckNvZGVBdCh0b2tlbnNbal0uY29udGVudC5sZW5ndGggLSAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaW5kIG5leHQgY2hhcmFjdGVyLFxuICAgICAgLy8gZGVmYXVsdCB0byBzcGFjZSBpZiBpdCdzIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgIC8vXG4gICAgICBuZXh0Q2hhciA9IDB4MjA7XG5cbiAgICAgIGlmIChwb3MgPCBtYXgpIHtcbiAgICAgICAgbmV4dENoYXIgPSB0ZXh0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgdG9rZW5zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlID09PSAnc29mdGJyZWFrJyB8fCB0b2tlbnNbal0udHlwZSA9PT0gJ2hhcmRicmVhaycpIGJyZWFrOyAvLyBuZXh0Q2hhciBkZWZhdWx0cyB0byAweDIwXG4gICAgICAgICAgaWYgKHRva2Vuc1tqXS50eXBlICE9PSAndGV4dCcpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgbmV4dENoYXIgPSB0b2tlbnNbal0uY29udGVudC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlzTGFzdFB1bmN0Q2hhciA9IGlzTWRBc2NpaVB1bmN0KGxhc3RDaGFyKSB8fCBpc1B1bmN0Q2hhcihTdHJpbmcuZnJvbUNoYXJDb2RlKGxhc3RDaGFyKSk7XG4gICAgICBpc05leHRQdW5jdENoYXIgPSBpc01kQXNjaWlQdW5jdChuZXh0Q2hhcikgfHwgaXNQdW5jdENoYXIoU3RyaW5nLmZyb21DaGFyQ29kZShuZXh0Q2hhcikpO1xuXG4gICAgICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcbiAgICAgIGlzTmV4dFdoaXRlU3BhY2UgPSBpc1doaXRlU3BhY2UobmV4dENoYXIpO1xuXG4gICAgICBpZiAoaXNOZXh0V2hpdGVTcGFjZSkge1xuICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGlzTmV4dFB1bmN0Q2hhcikge1xuICAgICAgICBpZiAoIShpc0xhc3RXaGl0ZVNwYWNlIHx8IGlzTGFzdFB1bmN0Q2hhcikpIHtcbiAgICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcbiAgICAgICAgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNMYXN0UHVuY3RDaGFyKSB7XG4gICAgICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgICAgIGNhbkNsb3NlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRDaGFyID09PSAweDIyIC8qIFwiICovICYmIHRbMF0gPT09ICdcIicpIHtcbiAgICAgICAgaWYgKGxhc3RDaGFyID49IDB4MzAgLyogMCAqLyAmJiBsYXN0Q2hhciA8PSAweDM5IC8qIDkgKi8pIHtcbiAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IDFcIlwiIC0gY291bnQgZmlyc3QgcXVvdGUgYXMgYW4gaW5jaFxuICAgICAgICAgIGNhbkNsb3NlID0gY2FuT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5PcGVuICYmIGNhbkNsb3NlKSB7XG4gICAgICAgIC8vIHRyZWF0IHRoaXMgYXMgdGhlIG1pZGRsZSBvZiB0aGUgd29yZFxuICAgICAgICBjYW5PcGVuID0gZmFsc2U7XG4gICAgICAgIGNhbkNsb3NlID0gaXNOZXh0UHVuY3RDaGFyO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNhbk9wZW4gJiYgIWNhbkNsb3NlKSB7XG4gICAgICAgIC8vIG1pZGRsZSBvZiB3b3JkXG4gICAgICAgIGlmIChpc1NpbmdsZSkge1xuICAgICAgICAgIHRva2VuLmNvbnRlbnQgPSByZXBsYWNlQXQodG9rZW4uY29udGVudCwgdC5pbmRleCwgQVBPU1RST1BIRSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYW5DbG9zZSkge1xuICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGEgY2xvc2luZyBxdW90ZSwgcmV3aW5kIHRoZSBzdGFjayB0byBnZXQgYSBtYXRjaFxuICAgICAgICBmb3IgKGogPSBzdGFjay5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgIGl0ZW0gPSBzdGFja1tqXTtcbiAgICAgICAgICBpZiAoc3RhY2tbal0ubGV2ZWwgPCB0aGlzTGV2ZWwpIHsgYnJlYWs7IH1cbiAgICAgICAgICBpZiAoaXRlbS5zaW5nbGUgPT09IGlzU2luZ2xlICYmIHN0YWNrW2pdLmxldmVsID09PSB0aGlzTGV2ZWwpIHtcbiAgICAgICAgICAgIGl0ZW0gPSBzdGFja1tqXTtcblxuICAgICAgICAgICAgaWYgKGlzU2luZ2xlKSB7XG4gICAgICAgICAgICAgIG9wZW5RdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzJdO1xuICAgICAgICAgICAgICBjbG9zZVF1b3RlID0gc3RhdGUubWQub3B0aW9ucy5xdW90ZXNbM107XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvcGVuUXVvdGUgPSBzdGF0ZS5tZC5vcHRpb25zLnF1b3Rlc1swXTtcbiAgICAgICAgICAgICAgY2xvc2VRdW90ZSA9IHN0YXRlLm1kLm9wdGlvbnMucXVvdGVzWzFdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRva2VuLmNvbnRlbnQgKmJlZm9yZSogdG9rZW5zW2l0ZW0udG9rZW5dLmNvbnRlbnQsXG4gICAgICAgICAgICAvLyBiZWNhdXNlLCBpZiB0aGV5IGFyZSBwb2ludGluZyBhdCB0aGUgc2FtZSB0b2tlbiwgcmVwbGFjZUF0XG4gICAgICAgICAgICAvLyBjb3VsZCBtZXNzIHVwIGluZGljZXMgd2hlbiBxdW90ZSBsZW5ndGggIT0gMVxuICAgICAgICAgICAgdG9rZW4uY29udGVudCA9IHJlcGxhY2VBdCh0b2tlbi5jb250ZW50LCB0LmluZGV4LCBjbG9zZVF1b3RlKTtcbiAgICAgICAgICAgIHRva2Vuc1tpdGVtLnRva2VuXS5jb250ZW50ID0gcmVwbGFjZUF0KFxuICAgICAgICAgICAgICB0b2tlbnNbaXRlbS50b2tlbl0uY29udGVudCwgaXRlbS5wb3MsIG9wZW5RdW90ZSk7XG5cbiAgICAgICAgICAgIHBvcyArPSBjbG9zZVF1b3RlLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpZiAoaXRlbS50b2tlbiA9PT0gaSkgeyBwb3MgKz0gb3BlblF1b3RlLmxlbmd0aCAtIDE7IH1cblxuICAgICAgICAgICAgdGV4dCA9IHRva2VuLmNvbnRlbnQ7XG4gICAgICAgICAgICBtYXggPSB0ZXh0Lmxlbmd0aDtcblxuICAgICAgICAgICAgc3RhY2subGVuZ3RoID0gajtcbiAgICAgICAgICAgIGNvbnRpbnVlIE9VVEVSO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuT3Blbikge1xuICAgICAgICBzdGFjay5wdXNoKHtcbiAgICAgICAgICB0b2tlbjogaSxcbiAgICAgICAgICBwb3M6IHQuaW5kZXgsXG4gICAgICAgICAgc2luZ2xlOiBpc1NpbmdsZSxcbiAgICAgICAgICBsZXZlbDogdGhpc0xldmVsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChjYW5DbG9zZSAmJiBpc1NpbmdsZSkge1xuICAgICAgICB0b2tlbi5jb250ZW50ID0gcmVwbGFjZUF0KHRva2VuLmNvbnRlbnQsIHQuaW5kZXgsIEFQT1NUUk9QSEUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc21hcnRxdW90ZXMoc3RhdGUpIHtcbiAgLyplc2xpbnQgbWF4LWRlcHRoOjAqL1xuICB2YXIgYmxrSWR4O1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy50eXBvZ3JhcGhlcikgeyByZXR1cm47IH1cblxuICBmb3IgKGJsa0lkeCA9IHN0YXRlLnRva2Vucy5sZW5ndGggLSAxOyBibGtJZHggPj0gMDsgYmxrSWR4LS0pIHtcblxuICAgIGlmIChzdGF0ZS50b2tlbnNbYmxrSWR4XS50eXBlICE9PSAnaW5saW5lJyB8fFxuICAgICAgICAhUVVPVEVfVEVTVF9SRS50ZXN0KHN0YXRlLnRva2Vuc1tibGtJZHhdLmNvbnRlbnQpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBwcm9jZXNzX2lubGluZXMoc3RhdGUudG9rZW5zW2Jsa0lkeF0uY2hpbGRyZW4sIHN0YXRlKTtcbiAgfVxufTtcbiIsIi8vIENvcmUgc3RhdGUgb2JqZWN0XG4vL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVG9rZW4gPSByZXF1aXJlKCcuLi90b2tlbicpO1xuXG5cbmZ1bmN0aW9uIFN0YXRlQ29yZShzcmMsIG1kLCBlbnYpIHtcbiAgdGhpcy5zcmMgPSBzcmM7XG4gIHRoaXMuZW52ID0gZW52O1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLmlubGluZU1vZGUgPSBmYWxzZTtcbiAgdGhpcy5tZCA9IG1kOyAvLyBsaW5rIHRvIHBhcnNlciBpbnN0YW5jZVxufVxuXG4vLyByZS1leHBvcnQgVG9rZW4gY2xhc3MgdG8gdXNlIGluIGNvcmUgcnVsZXNcblN0YXRlQ29yZS5wcm90b3R5cGUuVG9rZW4gPSBUb2tlbjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YXRlQ29yZTtcbiIsIi8vIFByb2Nlc3MgYXV0b2xpbmtzICc8cHJvdG9jb2w6Li4uPidcblxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qZXNsaW50IG1heC1sZW46MCovXG52YXIgRU1BSUxfUkUgICAgPSAvXjwoW2EtekEtWjAtOS4hIyQlJicqK1xcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKik+LztcbnZhciBBVVRPTElOS19SRSA9IC9ePChbYS16QS1aXVthLXpBLVowLTkrLlxcLV17MSwzMX0pOihbXjw+XFx4MDAtXFx4MjBdKik+LztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGF1dG9saW5rKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHRhaWwsIGxpbmtNYXRjaCwgZW1haWxNYXRjaCwgdXJsLCBmdWxsVXJsLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcztcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgzQy8qIDwgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgdGFpbCA9IHN0YXRlLnNyYy5zbGljZShwb3MpO1xuXG4gIGlmICh0YWlsLmluZGV4T2YoJz4nKSA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKEFVVE9MSU5LX1JFLnRlc3QodGFpbCkpIHtcbiAgICBsaW5rTWF0Y2ggPSB0YWlsLm1hdGNoKEFVVE9MSU5LX1JFKTtcblxuICAgIHVybCA9IGxpbmtNYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsodXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gbGlua01hdGNoWzBdLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChFTUFJTF9SRS50ZXN0KHRhaWwpKSB7XG4gICAgZW1haWxNYXRjaCA9IHRhaWwubWF0Y2goRU1BSUxfUkUpO1xuXG4gICAgdXJsID0gZW1haWxNYXRjaFswXS5zbGljZSgxLCAtMSk7XG4gICAgZnVsbFVybCA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsoJ21haWx0bzonICsgdXJsKTtcbiAgICBpZiAoIXN0YXRlLm1kLnZhbGlkYXRlTGluayhmdWxsVXJsKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghc2lsZW50KSB7XG4gICAgICB0b2tlbiAgICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICAgIHRva2VuLmF0dHJzICAgPSBbIFsgJ2hyZWYnLCBmdWxsVXJsIF0gXTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUubWQubm9ybWFsaXplTGlua1RleHQodXJsKTtcblxuICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2xpbmtfY2xvc2UnLCAnYScsIC0xKTtcbiAgICAgIHRva2VuLm1hcmt1cCAgPSAnYXV0b2xpbmsnO1xuICAgICAgdG9rZW4uaW5mbyAgICA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBzdGF0ZS5wb3MgKz0gZW1haWxNYXRjaFswXS5sZW5ndGg7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuIiwiLy8gUGFyc2UgYmFja3RpY2tzXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiYWNrdGljayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBzdGFydCwgbWF4LCBtYXJrZXIsIG1hdGNoU3RhcnQsIG1hdGNoRW5kLCB0b2tlbixcbiAgICAgIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcblxuICBpZiAoY2ggIT09IDB4NjAvKiBgICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHN0YXJ0ID0gcG9zO1xuICBwb3MrKztcbiAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIHdoaWxlIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg2MC8qIGAgKi8pIHsgcG9zKys7IH1cblxuICBtYXJrZXIgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcyk7XG5cbiAgbWF0Y2hTdGFydCA9IG1hdGNoRW5kID0gcG9zO1xuXG4gIHdoaWxlICgobWF0Y2hTdGFydCA9IHN0YXRlLnNyYy5pbmRleE9mKCdgJywgbWF0Y2hFbmQpKSAhPT0gLTEpIHtcbiAgICBtYXRjaEVuZCA9IG1hdGNoU3RhcnQgKyAxO1xuXG4gICAgd2hpbGUgKG1hdGNoRW5kIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KG1hdGNoRW5kKSA9PT0gMHg2MC8qIGAgKi8pIHsgbWF0Y2hFbmQrKzsgfVxuXG4gICAgaWYgKG1hdGNoRW5kIC0gbWF0Y2hTdGFydCA9PT0gbWFya2VyLmxlbmd0aCkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ2NvZGVfaW5saW5lJywgJ2NvZGUnLCAwKTtcbiAgICAgICAgdG9rZW4ubWFya3VwICA9IG1hcmtlcjtcbiAgICAgICAgdG9rZW4uY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShwb3MsIG1hdGNoU3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvWyBcXG5dKy9nLCAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpO1xuICAgICAgfVxuICAgICAgc3RhdGUucG9zID0gbWF0Y2hFbmQ7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IG1hcmtlcjsgfVxuICBzdGF0ZS5wb3MgKz0gbWFya2VyLmxlbmd0aDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gRm9yIGVhY2ggb3BlbmluZyBlbXBoYXNpcy1saWtlIG1hcmtlciBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyBvbmVcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5rX3BhaXJzKHN0YXRlKSB7XG4gIHZhciBpLCBqLCBsYXN0RGVsaW0sIGN1cnJEZWxpbSxcbiAgICAgIGRlbGltaXRlcnMgPSBzdGF0ZS5kZWxpbWl0ZXJzLFxuICAgICAgbWF4ID0gc3RhdGUuZGVsaW1pdGVycy5sZW5ndGg7XG5cbiAgZm9yIChpID0gMDsgaSA8IG1heDsgaSsrKSB7XG4gICAgbGFzdERlbGltID0gZGVsaW1pdGVyc1tpXTtcblxuICAgIGlmICghbGFzdERlbGltLmNsb3NlKSB7IGNvbnRpbnVlOyB9XG5cbiAgICBqID0gaSAtIGxhc3REZWxpbS5qdW1wIC0gMTtcblxuICAgIHdoaWxlIChqID49IDApIHtcbiAgICAgIGN1cnJEZWxpbSA9IGRlbGltaXRlcnNbal07XG5cbiAgICAgIGlmIChjdXJyRGVsaW0ub3BlbiAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5tYXJrZXIgPT09IGxhc3REZWxpbS5tYXJrZXIgJiZcbiAgICAgICAgICBjdXJyRGVsaW0uZW5kIDwgMCAmJlxuICAgICAgICAgIGN1cnJEZWxpbS5sZXZlbCA9PT0gbGFzdERlbGltLmxldmVsKSB7XG5cbiAgICAgICAgLy8gdHlwZW9mcyBhcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBwbHVnaW5zXG4gICAgICAgIHZhciBvZGRfbWF0Y2ggPSAoY3VyckRlbGltLmNsb3NlIHx8IGxhc3REZWxpbS5vcGVuKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGN1cnJEZWxpbS5sZW5ndGggIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbGFzdERlbGltLmxlbmd0aCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChjdXJyRGVsaW0ubGVuZ3RoICsgbGFzdERlbGltLmxlbmd0aCkgJSAzID09PSAwO1xuXG4gICAgICAgIGlmICghb2RkX21hdGNoKSB7XG4gICAgICAgICAgbGFzdERlbGltLmp1bXAgPSBpIC0gajtcbiAgICAgICAgICBsYXN0RGVsaW0ub3BlbiA9IGZhbHNlO1xuICAgICAgICAgIGN1cnJEZWxpbS5lbmQgID0gaTtcbiAgICAgICAgICBjdXJyRGVsaW0uanVtcCA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaiAtPSBjdXJyRGVsaW0uanVtcCArIDE7XG4gICAgfVxuICB9XG59O1xuIiwiLy8gUHJvY2VzcyAqdGhpcyogYW5kIF90aGF0X1xuLy9cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBJbnNlcnQgZWFjaCBtYXJrZXIgYXMgYSBzZXBhcmF0ZSB0ZXh0IHRva2VuLCBhbmQgYWRkIGl0IHRvIGRlbGltaXRlciBsaXN0XG4vL1xubW9kdWxlLmV4cG9ydHMudG9rZW5pemUgPSBmdW5jdGlvbiBlbXBoYXNpcyhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBpLCBzY2FubmVkLCB0b2tlbixcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg1RiAvKiBfICovICYmIG1hcmtlciAhPT0gMHgyQSAvKiAqICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHNjYW5uZWQgPSBzdGF0ZS5zY2FuRGVsaW1zKHN0YXRlLnBvcywgbWFya2VyID09PSAweDJBKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc2Nhbm5lZC5sZW5ndGg7IGkrKykge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCd0ZXh0JywgJycsIDApO1xuICAgIHRva2VuLmNvbnRlbnQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG1hcmtlcik7XG5cbiAgICBzdGF0ZS5kZWxpbWl0ZXJzLnB1c2goe1xuICAgICAgLy8gQ2hhciBjb2RlIG9mIHRoZSBzdGFydGluZyBtYXJrZXIgKG51bWJlcikuXG4gICAgICAvL1xuICAgICAgbWFya2VyOiBtYXJrZXIsXG5cbiAgICAgIC8vIFRvdGFsIGxlbmd0aCBvZiB0aGVzZSBzZXJpZXMgb2YgZGVsaW1pdGVycy5cbiAgICAgIC8vXG4gICAgICBsZW5ndGg6IHNjYW5uZWQubGVuZ3RoLFxuXG4gICAgICAvLyBBbiBhbW91bnQgb2YgY2hhcmFjdGVycyBiZWZvcmUgdGhpcyBvbmUgdGhhdCdzIGVxdWl2YWxlbnQgdG9cbiAgICAgIC8vIGN1cnJlbnQgb25lLiBJbiBwbGFpbiBFbmdsaXNoOiBpZiB0aGlzIGRlbGltaXRlciBkb2VzIG5vdCBvcGVuXG4gICAgICAvLyBhbiBlbXBoYXNpcywgbmVpdGhlciBkbyBwcmV2aW91cyBganVtcGAgY2hhcmFjdGVycy5cbiAgICAgIC8vXG4gICAgICAvLyBVc2VkIHRvIHNraXAgc2VxdWVuY2VzIGxpa2UgXCIqKioqKlwiIGluIG9uZSBzdGVwLCBmb3IgMXN0IGFzdGVyaXNrXG4gICAgICAvLyB2YWx1ZSB3aWxsIGJlIDAsIGZvciAybmQgaXQncyAxIGFuZCBzbyBvbi5cbiAgICAgIC8vXG4gICAgICBqdW1wOiAgIGksXG5cbiAgICAgIC8vIEEgcG9zaXRpb24gb2YgdGhlIHRva2VuIHRoaXMgZGVsaW1pdGVyIGNvcnJlc3BvbmRzIHRvLlxuICAgICAgLy9cbiAgICAgIHRva2VuOiAgc3RhdGUudG9rZW5zLmxlbmd0aCAtIDEsXG5cbiAgICAgIC8vIFRva2VuIGxldmVsLlxuICAgICAgLy9cbiAgICAgIGxldmVsOiAgc3RhdGUubGV2ZWwsXG5cbiAgICAgIC8vIElmIHRoaXMgZGVsaW1pdGVyIGlzIG1hdGNoZWQgYXMgYSB2YWxpZCBvcGVuZXIsIGBlbmRgIHdpbGwgYmVcbiAgICAgIC8vIGVxdWFsIHRvIGl0cyBwb3NpdGlvbiwgb3RoZXJ3aXNlIGl0J3MgYC0xYC5cbiAgICAgIC8vXG4gICAgICBlbmQ6ICAgIC0xLFxuXG4gICAgICAvLyBCb29sZWFuIGZsYWdzIHRoYXQgZGV0ZXJtaW5lIGlmIHRoaXMgZGVsaW1pdGVyIGNvdWxkIG9wZW4gb3IgY2xvc2VcbiAgICAgIC8vIGFuIGVtcGhhc2lzLlxuICAgICAgLy9cbiAgICAgIG9wZW46ICAgc2Nhbm5lZC5jYW5fb3BlbixcbiAgICAgIGNsb3NlOiAgc2Nhbm5lZC5jYW5fY2xvc2VcbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRlLnBvcyArPSBzY2FubmVkLmxlbmd0aDtcblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLy8gV2FsayB0aHJvdWdoIGRlbGltaXRlciBsaXN0IGFuZCByZXBsYWNlIHRleHQgdG9rZW5zIHdpdGggdGFnc1xuLy9cbm1vZHVsZS5leHBvcnRzLnBvc3RQcm9jZXNzID0gZnVuY3Rpb24gZW1waGFzaXMoc3RhdGUpIHtcbiAgdmFyIGksXG4gICAgICBzdGFydERlbGltLFxuICAgICAgZW5kRGVsaW0sXG4gICAgICB0b2tlbixcbiAgICAgIGNoLFxuICAgICAgaXNTdHJvbmcsXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IG1heCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgc3RhcnREZWxpbSA9IGRlbGltaXRlcnNbaV07XG5cbiAgICBpZiAoc3RhcnREZWxpbS5tYXJrZXIgIT09IDB4NUYvKiBfICovICYmIHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDJBLyogKiAqLykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyBvbmx5IG9wZW5pbmcgbWFya2Vyc1xuICAgIGlmIChzdGFydERlbGltLmVuZCA9PT0gLTEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGVuZERlbGltID0gZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZF07XG5cbiAgICAvLyBJZiB0aGUgcHJldmlvdXMgZGVsaW1pdGVyIGhhcyB0aGUgc2FtZSBtYXJrZXIgYW5kIGlzIGFkamFjZW50IHRvIHRoaXMgb25lLFxuICAgIC8vIG1lcmdlIHRob3NlIGludG8gb25lIHN0cm9uZyBkZWxpbWl0ZXIuXG4gICAgLy9cbiAgICAvLyBgPGVtPjxlbT53aGF0ZXZlcjwvZW0+PC9lbT5gIC0+IGA8c3Ryb25nPndoYXRldmVyPC9zdHJvbmc+YFxuICAgIC8vXG4gICAgaXNTdHJvbmcgPSBpID4gMCAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tpIC0gMV0uZW5kID09PSBzdGFydERlbGltLmVuZCArIDEgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSAtIDFdLnRva2VuID09PSBzdGFydERlbGltLnRva2VuIC0gMSAmJlxuICAgICAgICAgICAgICAgZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZCArIDFdLnRva2VuID09PSBlbmREZWxpbS50b2tlbiArIDEgJiZcbiAgICAgICAgICAgICAgIGRlbGltaXRlcnNbaSAtIDFdLm1hcmtlciA9PT0gc3RhcnREZWxpbS5tYXJrZXI7XG5cbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3RhcnREZWxpbS5tYXJrZXIpO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tzdGFydERlbGltLnRva2VuXTtcbiAgICB0b2tlbi50eXBlICAgID0gaXNTdHJvbmcgPyAnc3Ryb25nX29wZW4nIDogJ2VtX29wZW4nO1xuICAgIHRva2VuLnRhZyAgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmcnIDogJ2VtJztcbiAgICB0b2tlbi5uZXN0aW5nID0gMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gaXNTdHJvbmcgPyBjaCArIGNoIDogY2g7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9IGlzU3Ryb25nID8gJ3N0cm9uZ19jbG9zZScgOiAnZW1fY2xvc2UnO1xuICAgIHRva2VuLnRhZyAgICAgPSBpc1N0cm9uZyA/ICdzdHJvbmcnIDogJ2VtJztcbiAgICB0b2tlbi5uZXN0aW5nID0gLTE7XG4gICAgdG9rZW4ubWFya3VwICA9IGlzU3Ryb25nID8gY2ggKyBjaCA6IGNoO1xuICAgIHRva2VuLmNvbnRlbnQgPSAnJztcblxuICAgIGlmIChpc1N0cm9uZykge1xuICAgICAgc3RhdGUudG9rZW5zW2RlbGltaXRlcnNbaSAtIDFdLnRva2VuXS5jb250ZW50ID0gJyc7XG4gICAgICBzdGF0ZS50b2tlbnNbZGVsaW1pdGVyc1tzdGFydERlbGltLmVuZCArIDFdLnRva2VuXS5jb250ZW50ID0gJyc7XG4gICAgICBpLS07XG4gICAgfVxuICB9XG59O1xuIiwiLy8gUHJvY2VzcyBodG1sIGVudGl0eSAtICYjMTIzOywgJiN4QUY7LCAmcXVvdDssIC4uLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbnRpdGllcyAgICAgICAgICA9IHJlcXVpcmUoJy4uL2NvbW1vbi9lbnRpdGllcycpO1xudmFyIGhhcyAgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaGFzO1xudmFyIGlzVmFsaWRFbnRpdHlDb2RlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNWYWxpZEVudGl0eUNvZGU7XG52YXIgZnJvbUNvZGVQb2ludCAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5mcm9tQ29kZVBvaW50O1xuXG5cbnZhciBESUdJVEFMX1JFID0gL14mIygoPzp4W2EtZjAtOV17MSw4fXxbMC05XXsxLDh9KSk7L2k7XG52YXIgTkFNRURfUkUgICA9IC9eJihbYS16XVthLXowLTldezEsMzF9KTsvaTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVudGl0eShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgY29kZSwgbWF0Y2gsIHBvcyA9IHN0YXRlLnBvcywgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI2LyogJiAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAocG9zICsgMSA8IG1heCkge1xuICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zICsgMSk7XG5cbiAgICBpZiAoY2ggPT09IDB4MjMgLyogIyAqLykge1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChESUdJVEFMX1JFKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgIGNvZGUgPSBtYXRjaFsxXVswXS50b0xvd2VyQ2FzZSgpID09PSAneCcgPyBwYXJzZUludChtYXRjaFsxXS5zbGljZSgxKSwgMTYpIDogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcbiAgICAgICAgICBzdGF0ZS5wZW5kaW5nICs9IGlzVmFsaWRFbnRpdHlDb2RlKGNvZGUpID8gZnJvbUNvZGVQb2ludChjb2RlKSA6IGZyb21Db2RlUG9pbnQoMHhGRkZEKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2ggPSBzdGF0ZS5zcmMuc2xpY2UocG9zKS5tYXRjaChOQU1FRF9SRSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKGhhcyhlbnRpdGllcywgbWF0Y2hbMV0pKSB7XG4gICAgICAgICAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBlbnRpdGllc1ttYXRjaFsxXV07IH1cbiAgICAgICAgICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSAnJic7IH1cbiAgc3RhdGUucG9zKys7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFByb2Nlc3MgZXNjYXBlZCBjaGFycyBhbmQgaGFyZGJyZWFrc1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1NwYWNlID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNTcGFjZTtcblxudmFyIEVTQ0FQRUQgPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykgeyBFU0NBUEVELnB1c2goMCk7IH1cblxuJ1xcXFwhXCIjJCUmXFwnKCkqKywuLzo7PD0+P0BbXV5fYHt8fX4tJ1xuICAuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNoKSB7IEVTQ0FQRURbY2guY2hhckNvZGVBdCgwKV0gPSAxOyB9KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVzY2FwZShzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBjaCwgcG9zID0gc3RhdGUucG9zLCBtYXggPSBzdGF0ZS5wb3NNYXg7XG5cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4NUMvKiBcXCAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MrKztcblxuICBpZiAocG9zIDwgbWF4KSB7XG4gICAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgaWYgKGNoIDwgMjU2ICYmIEVTQ0FQRURbY2hdICE9PSAwKSB7XG4gICAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyY1twb3NdOyB9XG4gICAgICBzdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChjaCA9PT0gMHgwQSkge1xuICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgc3RhdGUucHVzaCgnaGFyZGJyZWFrJywgJ2JyJywgMCk7XG4gICAgICB9XG5cbiAgICAgIHBvcysrO1xuICAgICAgLy8gc2tpcCBsZWFkaW5nIHdoaXRlc3BhY2VzIGZyb20gbmV4dCBsaW5lXG4gICAgICB3aGlsZSAocG9zIDwgbWF4KSB7XG4gICAgICAgIGNoID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNoKSkgeyBicmVhazsgfVxuICAgICAgICBwb3MrKztcbiAgICAgIH1cblxuICAgICAgc3RhdGUucG9zID0gcG9zO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSAnXFxcXCc7IH1cbiAgc3RhdGUucG9zKys7XG4gIHJldHVybiB0cnVlO1xufTtcbiIsIi8vIFByb2Nlc3MgaHRtbCB0YWdzXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgSFRNTF9UQUdfUkUgPSByZXF1aXJlKCcuLi9jb21tb24vaHRtbF9yZScpLkhUTUxfVEFHX1JFO1xuXG5cbmZ1bmN0aW9uIGlzTGV0dGVyKGNoKSB7XG4gIC8qZXNsaW50IG5vLWJpdHdpc2U6MCovXG4gIHZhciBsYyA9IGNoIHwgMHgyMDsgLy8gdG8gbG93ZXIgY2FzZVxuICByZXR1cm4gKGxjID49IDB4NjEvKiBhICovKSAmJiAobGMgPD0gMHg3YS8qIHogKi8pO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHRtbF9pbmxpbmUoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgY2gsIG1hdGNoLCBtYXgsIHRva2VuLFxuICAgICAgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmICghc3RhdGUubWQub3B0aW9ucy5odG1sKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIENoZWNrIHN0YXJ0XG4gIG1heCA9IHN0YXRlLnBvc01heDtcbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgIT09IDB4M0MvKiA8ICovIHx8XG4gICAgICBwb3MgKyAyID49IG1heCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFF1aWNrIGZhaWwgb24gc2Vjb25kIGNoYXJcbiAgY2ggPSBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgaWYgKGNoICE9PSAweDIxLyogISAqLyAmJlxuICAgICAgY2ggIT09IDB4M0YvKiA/ICovICYmXG4gICAgICBjaCAhPT0gMHgyRi8qIC8gKi8gJiZcbiAgICAgICFpc0xldHRlcihjaCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBtYXRjaCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLm1hdGNoKEhUTUxfVEFHX1JFKTtcbiAgaWYgKCFtYXRjaCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBpZiAoIXNpbGVudCkge1xuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS5wdXNoKCdodG1sX2lubGluZScsICcnLCAwKTtcbiAgICB0b2tlbi5jb250ZW50ID0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgfVxuICBzdGF0ZS5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZXNzICFbaW1hZ2VdKDxzcmM+IFwidGl0bGVcIilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW1hZ2Uoc3RhdGUsIHNpbGVudCkge1xuICB2YXIgYXR0cnMsXG4gICAgICBjb2RlLFxuICAgICAgY29udGVudCxcbiAgICAgIGxhYmVsLFxuICAgICAgbGFiZWxFbmQsXG4gICAgICBsYWJlbFN0YXJ0LFxuICAgICAgcG9zLFxuICAgICAgcmVmLFxuICAgICAgcmVzLFxuICAgICAgdGl0bGUsXG4gICAgICB0b2tlbixcbiAgICAgIHRva2VucyxcbiAgICAgIHN0YXJ0LFxuICAgICAgaHJlZiA9ICcnLFxuICAgICAgb2xkUG9zID0gc3RhdGUucG9zLFxuICAgICAgbWF4ID0gc3RhdGUucG9zTWF4O1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChzdGF0ZS5wb3MpICE9PSAweDIxLyogISAqLykgeyByZXR1cm4gZmFsc2U7IH1cbiAgaWYgKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHN0YXRlLnBvcyArIDEpICE9PSAweDVCLyogWyAqLykgeyByZXR1cm4gZmFsc2U7IH1cblxuICBsYWJlbFN0YXJ0ID0gc3RhdGUucG9zICsgMjtcbiAgbGFiZWxFbmQgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBzdGF0ZS5wb3MgKyAxLCBmYWxzZSk7XG5cbiAgLy8gcGFyc2VyIGZhaWxlZCB0byBmaW5kICddJywgc28gaXQncyBub3QgYSB2YWxpZCBsaW5rXG4gIGlmIChsYWJlbEVuZCA8IDApIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4MjgvKiAoICovKSB7XG4gICAgLy9cbiAgICAvLyBJbmxpbmUgbGlua1xuICAgIC8vXG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBwb3MrKztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cbiAgICBpZiAocG9zID49IG1heCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgXl5eXl5eIHBhcnNpbmcgbGluayBkZXN0aW5hdGlvblxuICAgIHN0YXJ0ID0gcG9zO1xuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rRGVzdGluYXRpb24oc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHJlcy5vaykge1xuICAgICAgaHJlZiA9IHN0YXRlLm1kLm5vcm1hbGl6ZUxpbmsocmVzLnN0cik7XG4gICAgICBpZiAoc3RhdGUubWQudmFsaWRhdGVMaW5rKGhyZWYpKSB7XG4gICAgICAgIHBvcyA9IHJlcy5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBocmVmID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICBeXiBza2lwcGluZyB0aGVzZSBzcGFjZXNcbiAgICBzdGFydCA9IHBvcztcbiAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICBpZiAoIWlzU3BhY2UoY29kZSkgJiYgY29kZSAhPT0gMHgwQSkgeyBicmVhazsgfVxuICAgIH1cblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgICAgICAgICAgICBeXl5eXl5eIHBhcnNpbmcgbGluayB0aXRsZVxuICAgIHJlcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rVGl0bGUoc3RhdGUuc3JjLCBwb3MsIHN0YXRlLnBvc01heCk7XG4gICAgaWYgKHBvcyA8IG1heCAmJiBzdGFydCAhPT0gcG9zICYmIHJlcy5vaykge1xuICAgICAgdGl0bGUgPSByZXMuc3RyO1xuICAgICAgcG9zID0gcmVzLnBvcztcblxuICAgICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgICAgZm9yICg7IHBvcyA8IG1heDsgcG9zKyspIHtcbiAgICAgICAgY29kZSA9IHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcyk7XG4gICAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlID0gJyc7XG4gICAgfVxuXG4gICAgaWYgKHBvcyA+PSBtYXggfHwgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSAhPT0gMHgyOS8qICkgKi8pIHtcbiAgICAgIHN0YXRlLnBvcyA9IG9sZFBvcztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcG9zKys7XG4gIH0gZWxzZSB7XG4gICAgLy9cbiAgICAvLyBMaW5rIHJlZmVyZW5jZVxuICAgIC8vXG4gICAgaWYgKHR5cGVvZiBzdGF0ZS5lbnYucmVmZXJlbmNlcyA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IDB4NUIvKiBbICovKSB7XG4gICAgICBzdGFydCA9IHBvcyArIDE7XG4gICAgICBwb3MgPSBzdGF0ZS5tZC5oZWxwZXJzLnBhcnNlTGlua0xhYmVsKHN0YXRlLCBwb3MpO1xuICAgICAgaWYgKHBvcyA+PSAwKSB7XG4gICAgICAgIGxhYmVsID0gc3RhdGUuc3JjLnNsaWNlKHN0YXJ0LCBwb3MrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICB9XG5cbiAgICAvLyBjb3ZlcnMgbGFiZWwgPT09ICcnIGFuZCBsYWJlbCA9PT0gdW5kZWZpbmVkXG4gICAgLy8gKGNvbGxhcHNlZCByZWZlcmVuY2UgbGluayBhbmQgc2hvcnRjdXQgcmVmZXJlbmNlIGxpbmsgcmVzcGVjdGl2ZWx5KVxuICAgIGlmICghbGFiZWwpIHsgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2UobGFiZWxTdGFydCwgbGFiZWxFbmQpOyB9XG5cbiAgICByZWYgPSBzdGF0ZS5lbnYucmVmZXJlbmNlc1tub3JtYWxpemVSZWZlcmVuY2UobGFiZWwpXTtcbiAgICBpZiAoIXJlZikge1xuICAgICAgc3RhdGUucG9zID0gb2xkUG9zO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBocmVmID0gcmVmLmhyZWY7XG4gICAgdGl0bGUgPSByZWYudGl0bGU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBmb3VuZCB0aGUgZW5kIG9mIHRoZSBsaW5rLCBhbmQga25vdyBmb3IgYSBmYWN0IGl0J3MgYSB2YWxpZCBsaW5rO1xuICAvLyBzbyBhbGwgdGhhdCdzIGxlZnQgdG8gZG8gaXMgdG8gY2FsbCB0b2tlbml6ZXIuXG4gIC8vXG4gIGlmICghc2lsZW50KSB7XG4gICAgY29udGVudCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7XG5cbiAgICBzdGF0ZS5tZC5pbmxpbmUucGFyc2UoXG4gICAgICBjb250ZW50LFxuICAgICAgc3RhdGUubWQsXG4gICAgICBzdGF0ZS5lbnYsXG4gICAgICB0b2tlbnMgPSBbXVxuICAgICk7XG5cbiAgICB0b2tlbiAgICAgICAgICA9IHN0YXRlLnB1c2goJ2ltYWdlJywgJ2ltZycsIDApO1xuICAgIHRva2VuLmF0dHJzICAgID0gYXR0cnMgPSBbIFsgJ3NyYycsIGhyZWYgXSwgWyAnYWx0JywgJycgXSBdO1xuICAgIHRva2VuLmNoaWxkcmVuID0gdG9rZW5zO1xuICAgIHRva2VuLmNvbnRlbnQgID0gY29udGVudDtcblxuICAgIGlmICh0aXRsZSkge1xuICAgICAgYXR0cnMucHVzaChbICd0aXRsZScsIHRpdGxlIF0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLnBvcyA9IHBvcztcbiAgc3RhdGUucG9zTWF4ID0gbWF4O1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBQcm9jZXNzIFtsaW5rXSg8dG8+IFwic3R1ZmZcIilcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbm9ybWFsaXplUmVmZXJlbmNlICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5ub3JtYWxpemVSZWZlcmVuY2U7XG52YXIgaXNTcGFjZSAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc1NwYWNlO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGluayhzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBhdHRycyxcbiAgICAgIGNvZGUsXG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRW5kLFxuICAgICAgbGFiZWxTdGFydCxcbiAgICAgIHBvcyxcbiAgICAgIHJlcyxcbiAgICAgIHJlZixcbiAgICAgIHRpdGxlLFxuICAgICAgdG9rZW4sXG4gICAgICBocmVmID0gJycsXG4gICAgICBvbGRQb3MgPSBzdGF0ZS5wb3MsXG4gICAgICBtYXggPSBzdGF0ZS5wb3NNYXgsXG4gICAgICBzdGFydCA9IHN0YXRlLnBvcyxcbiAgICAgIHBhcnNlUmVmZXJlbmNlID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhdGUucG9zKSAhPT0gMHg1Qi8qIFsgKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgbGFiZWxTdGFydCA9IHN0YXRlLnBvcyArIDE7XG4gIGxhYmVsRW5kID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtMYWJlbChzdGF0ZSwgc3RhdGUucG9zLCB0cnVlKTtcblxuICAvLyBwYXJzZXIgZmFpbGVkIHRvIGZpbmQgJ10nLCBzbyBpdCdzIG5vdCBhIHZhbGlkIGxpbmtcbiAgaWYgKGxhYmVsRW5kIDwgMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBwb3MgPSBsYWJlbEVuZCArIDE7XG4gIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHgyOC8qICggKi8pIHtcbiAgICAvL1xuICAgIC8vIElubGluZSBsaW5rXG4gICAgLy9cblxuICAgIC8vIG1pZ2h0IGhhdmUgZm91bmQgYSB2YWxpZCBzaG9ydGN1dCBsaW5rLCBkaXNhYmxlIHJlZmVyZW5jZSBwYXJzaW5nXG4gICAgcGFyc2VSZWZlcmVuY2UgPSBmYWxzZTtcblxuICAgIC8vIFtsaW5rXSggIDxocmVmPiAgXCJ0aXRsZVwiICApXG4gICAgLy8gICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHBvcysrO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuICAgIGlmIChwb3MgPj0gbWF4KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICBeXl5eXl4gcGFyc2luZyBsaW5rIGRlc3RpbmF0aW9uXG4gICAgc3RhcnQgPSBwb3M7XG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtEZXN0aW5hdGlvbihzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocmVzLm9rKSB7XG4gICAgICBocmVmID0gc3RhdGUubWQubm9ybWFsaXplTGluayhyZXMuc3RyKTtcbiAgICAgIGlmIChzdGF0ZS5tZC52YWxpZGF0ZUxpbmsoaHJlZikpIHtcbiAgICAgICAgcG9zID0gcmVzLnBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhyZWYgPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgIC8vICAgICAgICAgICAgICAgIF5eIHNraXBwaW5nIHRoZXNlIHNwYWNlc1xuICAgIHN0YXJ0ID0gcG9zO1xuICAgIGZvciAoOyBwb3MgPCBtYXg7IHBvcysrKSB7XG4gICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICghaXNTcGFjZShjb2RlKSAmJiBjb2RlICE9PSAweDBBKSB7IGJyZWFrOyB9XG4gICAgfVxuXG4gICAgLy8gW2xpbmtdKCAgPGhyZWY+ICBcInRpdGxlXCIgIClcbiAgICAvLyAgICAgICAgICAgICAgICAgIF5eXl5eXl4gcGFyc2luZyBsaW5rIHRpdGxlXG4gICAgcmVzID0gc3RhdGUubWQuaGVscGVycy5wYXJzZUxpbmtUaXRsZShzdGF0ZS5zcmMsIHBvcywgc3RhdGUucG9zTWF4KTtcbiAgICBpZiAocG9zIDwgbWF4ICYmIHN0YXJ0ICE9PSBwb3MgJiYgcmVzLm9rKSB7XG4gICAgICB0aXRsZSA9IHJlcy5zdHI7XG4gICAgICBwb3MgPSByZXMucG9zO1xuXG4gICAgICAvLyBbbGlua10oICA8aHJlZj4gIFwidGl0bGVcIiAgKVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgXl4gc2tpcHBpbmcgdGhlc2Ugc3BhY2VzXG4gICAgICBmb3IgKDsgcG9zIDwgbWF4OyBwb3MrKykge1xuICAgICAgICBjb2RlID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKTtcbiAgICAgICAgaWYgKCFpc1NwYWNlKGNvZGUpICYmIGNvZGUgIT09IDB4MEEpIHsgYnJlYWs7IH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGUgPSAnJztcbiAgICB9XG5cbiAgICBpZiAocG9zID49IG1heCB8fCBzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDI5LyogKSAqLykge1xuICAgICAgLy8gcGFyc2luZyBhIHZhbGlkIHNob3J0Y3V0IGxpbmsgZmFpbGVkLCBmYWxsYmFjayB0byByZWZlcmVuY2VcbiAgICAgIHBhcnNlUmVmZXJlbmNlID0gdHJ1ZTtcbiAgICB9XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocGFyc2VSZWZlcmVuY2UpIHtcbiAgICAvL1xuICAgIC8vIExpbmsgcmVmZXJlbmNlXG4gICAgLy9cbiAgICBpZiAodHlwZW9mIHN0YXRlLmVudi5yZWZlcmVuY2VzID09PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmIChwb3MgPCBtYXggJiYgc3RhdGUuc3JjLmNoYXJDb2RlQXQocG9zKSA9PT0gMHg1Qi8qIFsgKi8pIHtcbiAgICAgIHN0YXJ0ID0gcG9zICsgMTtcbiAgICAgIHBvcyA9IHN0YXRlLm1kLmhlbHBlcnMucGFyc2VMaW5rTGFiZWwoc3RhdGUsIHBvcyk7XG4gICAgICBpZiAocG9zID49IDApIHtcbiAgICAgICAgbGFiZWwgPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhcnQsIHBvcysrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyA9IGxhYmVsRW5kICsgMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcG9zID0gbGFiZWxFbmQgKyAxO1xuICAgIH1cblxuICAgIC8vIGNvdmVycyBsYWJlbCA9PT0gJycgYW5kIGxhYmVsID09PSB1bmRlZmluZWRcbiAgICAvLyAoY29sbGFwc2VkIHJlZmVyZW5jZSBsaW5rIGFuZCBzaG9ydGN1dCByZWZlcmVuY2UgbGluayByZXNwZWN0aXZlbHkpXG4gICAgaWYgKCFsYWJlbCkgeyBsYWJlbCA9IHN0YXRlLnNyYy5zbGljZShsYWJlbFN0YXJ0LCBsYWJlbEVuZCk7IH1cblxuICAgIHJlZiA9IHN0YXRlLmVudi5yZWZlcmVuY2VzW25vcm1hbGl6ZVJlZmVyZW5jZShsYWJlbCldO1xuICAgIGlmICghcmVmKSB7XG4gICAgICBzdGF0ZS5wb3MgPSBvbGRQb3M7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGhyZWYgPSByZWYuaHJlZjtcbiAgICB0aXRsZSA9IHJlZi50aXRsZTtcbiAgfVxuXG4gIC8vXG4gIC8vIFdlIGZvdW5kIHRoZSBlbmQgb2YgdGhlIGxpbmssIGFuZCBrbm93IGZvciBhIGZhY3QgaXQncyBhIHZhbGlkIGxpbms7XG4gIC8vIHNvIGFsbCB0aGF0J3MgbGVmdCB0byBkbyBpcyB0byBjYWxsIHRva2VuaXplci5cbiAgLy9cbiAgaWYgKCFzaWxlbnQpIHtcbiAgICBzdGF0ZS5wb3MgPSBsYWJlbFN0YXJ0O1xuICAgIHN0YXRlLnBvc01heCA9IGxhYmVsRW5kO1xuXG4gICAgdG9rZW4gICAgICAgID0gc3RhdGUucHVzaCgnbGlua19vcGVuJywgJ2EnLCAxKTtcbiAgICB0b2tlbi5hdHRycyAgPSBhdHRycyA9IFsgWyAnaHJlZicsIGhyZWYgXSBdO1xuICAgIGlmICh0aXRsZSkge1xuICAgICAgYXR0cnMucHVzaChbICd0aXRsZScsIHRpdGxlIF0pO1xuICAgIH1cblxuICAgIHN0YXRlLm1kLmlubGluZS50b2tlbml6ZShzdGF0ZSk7XG5cbiAgICB0b2tlbiAgICAgICAgPSBzdGF0ZS5wdXNoKCdsaW5rX2Nsb3NlJywgJ2EnLCAtMSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgPSBwb3M7XG4gIHN0YXRlLnBvc01heCA9IG1heDtcbiAgcmV0dXJuIHRydWU7XG59O1xuIiwiLy8gUHJvY2Vlc3MgJ1xcbidcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNTcGFjZSA9IHJlcXVpcmUoJy4uL2NvbW1vbi91dGlscycpLmlzU3BhY2U7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBuZXdsaW5lKHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBtYXgsIG1heCwgcG9zID0gc3RhdGUucG9zO1xuXG4gIGlmIChzdGF0ZS5zcmMuY2hhckNvZGVBdChwb3MpICE9PSAweDBBLyogXFxuICovKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIHBtYXggPSBzdGF0ZS5wZW5kaW5nLmxlbmd0aCAtIDE7XG4gIG1heCA9IHN0YXRlLnBvc01heDtcblxuICAvLyAnICBcXG4nIC0+IGhhcmRicmVha1xuICAvLyBMb29rdXAgaW4gcGVuZGluZyBjaGFycyBpcyBiYWQgcHJhY3RpY2UhIERvbid0IGNvcHkgdG8gb3RoZXIgcnVsZXMhXG4gIC8vIFBlbmRpbmcgc3RyaW5nIGlzIHN0b3JlZCBpbiBjb25jYXQgbW9kZSwgaW5kZXhlZCBsb29rdXBzIHdpbGwgY2F1c2VcbiAgLy8gY29udmVydGlvbiB0byBmbGF0IG1vZGUuXG4gIGlmICghc2lsZW50KSB7XG4gICAgaWYgKHBtYXggPj0gMCAmJiBzdGF0ZS5wZW5kaW5nLmNoYXJDb2RlQXQocG1heCkgPT09IDB4MjApIHtcbiAgICAgIGlmIChwbWF4ID49IDEgJiYgc3RhdGUucGVuZGluZy5jaGFyQ29kZUF0KHBtYXggLSAxKSA9PT0gMHgyMCkge1xuICAgICAgICBzdGF0ZS5wZW5kaW5nID0gc3RhdGUucGVuZGluZy5yZXBsYWNlKC8gKyQvLCAnJyk7XG4gICAgICAgIHN0YXRlLnB1c2goJ2hhcmRicmVhaycsICdicicsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucGVuZGluZyA9IHN0YXRlLnBlbmRpbmcuc2xpY2UoMCwgLTEpO1xuICAgICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wdXNoKCdzb2Z0YnJlYWsnLCAnYnInLCAwKTtcbiAgICB9XG4gIH1cblxuICBwb3MrKztcblxuICAvLyBza2lwIGhlYWRpbmcgc3BhY2VzIGZvciBuZXh0IGxpbmVcbiAgd2hpbGUgKHBvcyA8IG1heCAmJiBpc1NwYWNlKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7IHBvcysrOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuICByZXR1cm4gdHJ1ZTtcbn07XG4iLCIvLyBJbmxpbmUgcGFyc2VyIHN0YXRlXG5cbid1c2Ugc3RyaWN0JztcblxuXG52YXIgVG9rZW4gICAgICAgICAgPSByZXF1aXJlKCcuLi90b2tlbicpO1xudmFyIGlzV2hpdGVTcGFjZSAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNXaGl0ZVNwYWNlO1xudmFyIGlzUHVuY3RDaGFyICAgID0gcmVxdWlyZSgnLi4vY29tbW9uL3V0aWxzJykuaXNQdW5jdENoYXI7XG52YXIgaXNNZEFzY2lpUHVuY3QgPSByZXF1aXJlKCcuLi9jb21tb24vdXRpbHMnKS5pc01kQXNjaWlQdW5jdDtcblxuXG5mdW5jdGlvbiBTdGF0ZUlubGluZShzcmMsIG1kLCBlbnYsIG91dFRva2Vucykge1xuICB0aGlzLnNyYyA9IHNyYztcbiAgdGhpcy5lbnYgPSBlbnY7XG4gIHRoaXMubWQgPSBtZDtcbiAgdGhpcy50b2tlbnMgPSBvdXRUb2tlbnM7XG5cbiAgdGhpcy5wb3MgPSAwO1xuICB0aGlzLnBvc01heCA9IHRoaXMuc3JjLmxlbmd0aDtcbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHRoaXMucGVuZGluZyA9ICcnO1xuICB0aGlzLnBlbmRpbmdMZXZlbCA9IDA7XG5cbiAgdGhpcy5jYWNoZSA9IHt9OyAgICAgICAgLy8gU3RvcmVzIHsgc3RhcnQ6IGVuZCB9IHBhaXJzLiBVc2VmdWwgZm9yIGJhY2t0cmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvcHRpbWl6YXRpb24gb2YgcGFpcnMgcGFyc2UgKGVtcGhhc2lzLCBzdHJpa2VzKS5cblxuICB0aGlzLmRlbGltaXRlcnMgPSBbXTsgICAvLyBFbXBoYXNpcy1saWtlIGRlbGltaXRlcnNcbn1cblxuXG4vLyBGbHVzaCBwZW5kaW5nIHRleHRcbi8vXG5TdGF0ZUlubGluZS5wcm90b3R5cGUucHVzaFBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0b2tlbiA9IG5ldyBUb2tlbigndGV4dCcsICcnLCAwKTtcbiAgdG9rZW4uY29udGVudCA9IHRoaXMucGVuZGluZztcbiAgdG9rZW4ubGV2ZWwgPSB0aGlzLnBlbmRpbmdMZXZlbDtcbiAgdGhpcy50b2tlbnMucHVzaCh0b2tlbik7XG4gIHRoaXMucGVuZGluZyA9ICcnO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5cbi8vIFB1c2ggbmV3IHRva2VuIHRvIFwic3RyZWFtXCIuXG4vLyBJZiBwZW5kaW5nIHRleHQgZXhpc3RzIC0gZmx1c2ggaXQgYXMgdGV4dCB0b2tlblxuLy9cblN0YXRlSW5saW5lLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHR5cGUsIHRhZywgbmVzdGluZykge1xuICBpZiAodGhpcy5wZW5kaW5nKSB7XG4gICAgdGhpcy5wdXNoUGVuZGluZygpO1xuICB9XG5cbiAgdmFyIHRva2VuID0gbmV3IFRva2VuKHR5cGUsIHRhZywgbmVzdGluZyk7XG5cbiAgaWYgKG5lc3RpbmcgPCAwKSB7IHRoaXMubGV2ZWwtLTsgfVxuICB0b2tlbi5sZXZlbCA9IHRoaXMubGV2ZWw7XG4gIGlmIChuZXN0aW5nID4gMCkgeyB0aGlzLmxldmVsKys7IH1cblxuICB0aGlzLnBlbmRpbmdMZXZlbCA9IHRoaXMubGV2ZWw7XG4gIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59O1xuXG5cbi8vIFNjYW4gYSBzZXF1ZW5jZSBvZiBlbXBoYXNpcy1saWtlIG1hcmtlcnMsIGFuZCBkZXRlcm1pbmUgd2hldGhlclxuLy8gaXQgY2FuIHN0YXJ0IGFuIGVtcGhhc2lzIHNlcXVlbmNlIG9yIGVuZCBhbiBlbXBoYXNpcyBzZXF1ZW5jZS5cbi8vXG4vLyAgLSBzdGFydCAtIHBvc2l0aW9uIHRvIHNjYW4gZnJvbSAoaXQgc2hvdWxkIHBvaW50IGF0IGEgdmFsaWQgbWFya2VyKTtcbi8vICAtIGNhblNwbGl0V29yZCAtIGRldGVybWluZSBpZiB0aGVzZSBtYXJrZXJzIGNhbiBiZSBmb3VuZCBpbnNpZGUgYSB3b3JkXG4vL1xuU3RhdGVJbmxpbmUucHJvdG90eXBlLnNjYW5EZWxpbXMgPSBmdW5jdGlvbiAoc3RhcnQsIGNhblNwbGl0V29yZCkge1xuICB2YXIgcG9zID0gc3RhcnQsIGxhc3RDaGFyLCBuZXh0Q2hhciwgY291bnQsIGNhbl9vcGVuLCBjYW5fY2xvc2UsXG4gICAgICBpc0xhc3RXaGl0ZVNwYWNlLCBpc0xhc3RQdW5jdENoYXIsXG4gICAgICBpc05leHRXaGl0ZVNwYWNlLCBpc05leHRQdW5jdENoYXIsXG4gICAgICBsZWZ0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIHJpZ2h0X2ZsYW5raW5nID0gdHJ1ZSxcbiAgICAgIG1heCA9IHRoaXMucG9zTWF4LFxuICAgICAgbWFya2VyID0gdGhpcy5zcmMuY2hhckNvZGVBdChzdGFydCk7XG5cbiAgLy8gdHJlYXQgYmVnaW5uaW5nIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBsYXN0Q2hhciA9IHN0YXJ0ID4gMCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQoc3RhcnQgLSAxKSA6IDB4MjA7XG5cbiAgd2hpbGUgKHBvcyA8IG1heCAmJiB0aGlzLnNyYy5jaGFyQ29kZUF0KHBvcykgPT09IG1hcmtlcikgeyBwb3MrKzsgfVxuXG4gIGNvdW50ID0gcG9zIC0gc3RhcnQ7XG5cbiAgLy8gdHJlYXQgZW5kIG9mIHRoZSBsaW5lIGFzIGEgd2hpdGVzcGFjZVxuICBuZXh0Q2hhciA9IHBvcyA8IG1heCA/IHRoaXMuc3JjLmNoYXJDb2RlQXQocG9zKSA6IDB4MjA7XG5cbiAgaXNMYXN0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobGFzdENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobGFzdENoYXIpKTtcbiAgaXNOZXh0UHVuY3RDaGFyID0gaXNNZEFzY2lpUHVuY3QobmV4dENoYXIpIHx8IGlzUHVuY3RDaGFyKFN0cmluZy5mcm9tQ2hhckNvZGUobmV4dENoYXIpKTtcblxuICBpc0xhc3RXaGl0ZVNwYWNlID0gaXNXaGl0ZVNwYWNlKGxhc3RDaGFyKTtcbiAgaXNOZXh0V2hpdGVTcGFjZSA9IGlzV2hpdGVTcGFjZShuZXh0Q2hhcik7XG5cbiAgaWYgKGlzTmV4dFdoaXRlU3BhY2UpIHtcbiAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNOZXh0UHVuY3RDaGFyKSB7XG4gICAgaWYgKCEoaXNMYXN0V2hpdGVTcGFjZSB8fCBpc0xhc3RQdW5jdENoYXIpKSB7XG4gICAgICBsZWZ0X2ZsYW5raW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzTGFzdFdoaXRlU3BhY2UpIHtcbiAgICByaWdodF9mbGFua2luZyA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzTGFzdFB1bmN0Q2hhcikge1xuICAgIGlmICghKGlzTmV4dFdoaXRlU3BhY2UgfHwgaXNOZXh0UHVuY3RDaGFyKSkge1xuICAgICAgcmlnaHRfZmxhbmtpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNhblNwbGl0V29yZCkge1xuICAgIGNhbl9vcGVuICA9IGxlZnRfZmxhbmtpbmcgICYmICghcmlnaHRfZmxhbmtpbmcgfHwgaXNMYXN0UHVuY3RDaGFyKTtcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZyAmJiAoIWxlZnRfZmxhbmtpbmcgIHx8IGlzTmV4dFB1bmN0Q2hhcik7XG4gIH0gZWxzZSB7XG4gICAgY2FuX29wZW4gID0gbGVmdF9mbGFua2luZztcbiAgICBjYW5fY2xvc2UgPSByaWdodF9mbGFua2luZztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2FuX29wZW46ICBjYW5fb3BlbixcbiAgICBjYW5fY2xvc2U6IGNhbl9jbG9zZSxcbiAgICBsZW5ndGg6ICAgIGNvdW50XG4gIH07XG59O1xuXG5cbi8vIHJlLWV4cG9ydCBUb2tlbiBjbGFzcyB0byB1c2UgaW4gYmxvY2sgcnVsZXNcblN0YXRlSW5saW5lLnByb3RvdHlwZS5Ub2tlbiA9IFRva2VuO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVJbmxpbmU7XG4iLCIvLyB+fnN0cmlrZSB0aHJvdWdofn5cbi8vXG4ndXNlIHN0cmljdCc7XG5cblxuLy8gSW5zZXJ0IGVhY2ggbWFya2VyIGFzIGEgc2VwYXJhdGUgdGV4dCB0b2tlbiwgYW5kIGFkZCBpdCB0byBkZWxpbWl0ZXIgbGlzdFxuLy9cbm1vZHVsZS5leHBvcnRzLnRva2VuaXplID0gZnVuY3Rpb24gc3RyaWtldGhyb3VnaChzdGF0ZSwgc2lsZW50KSB7XG4gIHZhciBpLCBzY2FubmVkLCB0b2tlbiwgbGVuLCBjaCxcbiAgICAgIHN0YXJ0ID0gc3RhdGUucG9zLFxuICAgICAgbWFya2VyID0gc3RhdGUuc3JjLmNoYXJDb2RlQXQoc3RhcnQpO1xuXG4gIGlmIChzaWxlbnQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKG1hcmtlciAhPT0gMHg3RS8qIH4gKi8pIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgc2Nhbm5lZCA9IHN0YXRlLnNjYW5EZWxpbXMoc3RhdGUucG9zLCB0cnVlKTtcbiAgbGVuID0gc2Nhbm5lZC5sZW5ndGg7XG4gIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShtYXJrZXIpO1xuXG4gIGlmIChsZW4gPCAyKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIGlmIChsZW4gJSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoO1xuICAgIGxlbi0tO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnB1c2goJ3RleHQnLCAnJywgMCk7XG4gICAgdG9rZW4uY29udGVudCA9IGNoICsgY2g7XG5cbiAgICBzdGF0ZS5kZWxpbWl0ZXJzLnB1c2goe1xuICAgICAgbWFya2VyOiBtYXJrZXIsXG4gICAgICBqdW1wOiAgIGksXG4gICAgICB0b2tlbjogIHN0YXRlLnRva2Vucy5sZW5ndGggLSAxLFxuICAgICAgbGV2ZWw6ICBzdGF0ZS5sZXZlbCxcbiAgICAgIGVuZDogICAgLTEsXG4gICAgICBvcGVuOiAgIHNjYW5uZWQuY2FuX29wZW4sXG4gICAgICBjbG9zZTogIHNjYW5uZWQuY2FuX2Nsb3NlXG4gICAgfSk7XG4gIH1cblxuICBzdGF0ZS5wb3MgKz0gc2Nhbm5lZC5sZW5ndGg7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8vIFdhbGsgdGhyb3VnaCBkZWxpbWl0ZXIgbGlzdCBhbmQgcmVwbGFjZSB0ZXh0IHRva2VucyB3aXRoIHRhZ3Ncbi8vXG5tb2R1bGUuZXhwb3J0cy5wb3N0UHJvY2VzcyA9IGZ1bmN0aW9uIHN0cmlrZXRocm91Z2goc3RhdGUpIHtcbiAgdmFyIGksIGosXG4gICAgICBzdGFydERlbGltLFxuICAgICAgZW5kRGVsaW0sXG4gICAgICB0b2tlbixcbiAgICAgIGxvbmVNYXJrZXJzID0gW10sXG4gICAgICBkZWxpbWl0ZXJzID0gc3RhdGUuZGVsaW1pdGVycyxcbiAgICAgIG1heCA9IHN0YXRlLmRlbGltaXRlcnMubGVuZ3RoO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuICAgIHN0YXJ0RGVsaW0gPSBkZWxpbWl0ZXJzW2ldO1xuXG4gICAgaWYgKHN0YXJ0RGVsaW0ubWFya2VyICE9PSAweDdFLyogfiAqLykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0RGVsaW0uZW5kID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZW5kRGVsaW0gPSBkZWxpbWl0ZXJzW3N0YXJ0RGVsaW0uZW5kXTtcblxuICAgIHRva2VuICAgICAgICAgPSBzdGF0ZS50b2tlbnNbc3RhcnREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX29wZW4nO1xuICAgIHRva2VuLnRhZyAgICAgPSAncyc7XG4gICAgdG9rZW4ubmVzdGluZyA9IDE7XG4gICAgdG9rZW4ubWFya3VwICA9ICd+fic7XG4gICAgdG9rZW4uY29udGVudCA9ICcnO1xuXG4gICAgdG9rZW4gICAgICAgICA9IHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbl07XG4gICAgdG9rZW4udHlwZSAgICA9ICdzX2Nsb3NlJztcbiAgICB0b2tlbi50YWcgICAgID0gJ3MnO1xuICAgIHRva2VuLm5lc3RpbmcgPSAtMTtcbiAgICB0b2tlbi5tYXJrdXAgID0gJ35+JztcbiAgICB0b2tlbi5jb250ZW50ID0gJyc7XG5cbiAgICBpZiAoc3RhdGUudG9rZW5zW2VuZERlbGltLnRva2VuIC0gMV0udHlwZSA9PT0gJ3RleHQnICYmXG4gICAgICAgIHN0YXRlLnRva2Vuc1tlbmREZWxpbS50b2tlbiAtIDFdLmNvbnRlbnQgPT09ICd+Jykge1xuXG4gICAgICBsb25lTWFya2Vycy5wdXNoKGVuZERlbGltLnRva2VuIC0gMSk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgYSBtYXJrZXIgc2VxdWVuY2UgaGFzIGFuIG9kZCBudW1iZXIgb2YgY2hhcmFjdGVycywgaXQncyBzcGxpdHRlZFxuICAvLyBsaWtlIHRoaXM6IGB+fn5+fmAgLT4gYH5gICsgYH5+YCArIGB+fmAsIGxlYXZpbmcgb25lIG1hcmtlciBhdCB0aGVcbiAgLy8gc3RhcnQgb2YgdGhlIHNlcXVlbmNlLlxuICAvL1xuICAvLyBTbywgd2UgaGF2ZSB0byBtb3ZlIGFsbCB0aG9zZSBtYXJrZXJzIGFmdGVyIHN1YnNlcXVlbnQgc19jbG9zZSB0YWdzLlxuICAvL1xuICB3aGlsZSAobG9uZU1hcmtlcnMubGVuZ3RoKSB7XG4gICAgaSA9IGxvbmVNYXJrZXJzLnBvcCgpO1xuICAgIGogPSBpICsgMTtcblxuICAgIHdoaWxlIChqIDwgc3RhdGUudG9rZW5zLmxlbmd0aCAmJiBzdGF0ZS50b2tlbnNbal0udHlwZSA9PT0gJ3NfY2xvc2UnKSB7XG4gICAgICBqKys7XG4gICAgfVxuXG4gICAgai0tO1xuXG4gICAgaWYgKGkgIT09IGopIHtcbiAgICAgIHRva2VuID0gc3RhdGUudG9rZW5zW2pdO1xuICAgICAgc3RhdGUudG9rZW5zW2pdID0gc3RhdGUudG9rZW5zW2ldO1xuICAgICAgc3RhdGUudG9rZW5zW2ldID0gdG9rZW47XG4gICAgfVxuICB9XG59O1xuIiwiLy8gU2tpcCB0ZXh0IGNoYXJhY3RlcnMgZm9yIHRleHQgdG9rZW4sIHBsYWNlIHRob3NlIHRvIHBlbmRpbmcgYnVmZmVyXG4vLyBhbmQgaW5jcmVtZW50IGN1cnJlbnQgcG9zXG5cbid1c2Ugc3RyaWN0JztcblxuXG4vLyBSdWxlIHRvIHNraXAgcHVyZSB0ZXh0XG4vLyAne30kJUB+Kz06JyByZXNlcnZlZCBmb3IgZXh0ZW50aW9uc1xuXG4vLyAhLCBcIiwgIywgJCwgJSwgJiwgJywgKCwgKSwgKiwgKywgLCwgLSwgLiwgLywgOiwgOywgPCwgPSwgPiwgPywgQCwgWywgXFwsIF0sIF4sIF8sIGAsIHssIHwsIH0sIG9yIH5cblxuLy8gISEhISBEb24ndCBjb25mdXNlIHdpdGggXCJNYXJrZG93biBBU0NJSSBQdW5jdHVhdGlvblwiIGNoYXJzXG4vLyBodHRwOi8vc3BlYy5jb21tb25tYXJrLm9yZy8wLjE1LyNhc2NpaS1wdW5jdHVhdGlvbi1jaGFyYWN0ZXJcbmZ1bmN0aW9uIGlzVGVybWluYXRvckNoYXIoY2gpIHtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMHgwQS8qIFxcbiAqLzpcbiAgICBjYXNlIDB4MjEvKiAhICovOlxuICAgIGNhc2UgMHgyMy8qICMgKi86XG4gICAgY2FzZSAweDI0LyogJCAqLzpcbiAgICBjYXNlIDB4MjUvKiAlICovOlxuICAgIGNhc2UgMHgyNi8qICYgKi86XG4gICAgY2FzZSAweDJBLyogKiAqLzpcbiAgICBjYXNlIDB4MkIvKiArICovOlxuICAgIGNhc2UgMHgyRC8qIC0gKi86XG4gICAgY2FzZSAweDNBLyogOiAqLzpcbiAgICBjYXNlIDB4M0MvKiA8ICovOlxuICAgIGNhc2UgMHgzRC8qID0gKi86XG4gICAgY2FzZSAweDNFLyogPiAqLzpcbiAgICBjYXNlIDB4NDAvKiBAICovOlxuICAgIGNhc2UgMHg1Qi8qIFsgKi86XG4gICAgY2FzZSAweDVDLyogXFwgKi86XG4gICAgY2FzZSAweDVELyogXSAqLzpcbiAgICBjYXNlIDB4NUUvKiBeICovOlxuICAgIGNhc2UgMHg1Ri8qIF8gKi86XG4gICAgY2FzZSAweDYwLyogYCAqLzpcbiAgICBjYXNlIDB4N0IvKiB7ICovOlxuICAgIGNhc2UgMHg3RC8qIH0gKi86XG4gICAgY2FzZSAweDdFLyogfiAqLzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcztcblxuICB3aGlsZSAocG9zIDwgc3RhdGUucG9zTWF4ICYmICFpc1Rlcm1pbmF0b3JDaGFyKHN0YXRlLnNyYy5jaGFyQ29kZUF0KHBvcykpKSB7XG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAocG9zID09PSBzdGF0ZS5wb3MpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgaWYgKCFzaWxlbnQpIHsgc3RhdGUucGVuZGluZyArPSBzdGF0ZS5zcmMuc2xpY2Uoc3RhdGUucG9zLCBwb3MpOyB9XG5cbiAgc3RhdGUucG9zID0gcG9zO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLy8gQWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb24sIGZvciBtZW1vcnkuXG4vL1xuLy8gSXQgY29zdHMgMTAlIG9mIHBlcmZvcm1hbmNlLCBidXQgYWxsb3dzIGV4dGVuZCB0ZXJtaW5hdG9ycyBsaXN0LCBpZiBwbGFjZSBpdFxuLy8gdG8gYFBhcmNlcklubGluZWAgcHJvcGVydHkuIFByb2JhYmx5LCB3aWxsIHN3aXRjaCB0byBpdCBzb21ldGltZSwgc3VjaFxuLy8gZmxleGliaWxpdHkgcmVxdWlyZWQuXG5cbi8qXG52YXIgVEVSTUlOQVRPUl9SRSA9IC9bXFxuISMkJSYqK1xcLTo8PT5AW1xcXFxcXF1eX2B7fX5dLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0KHN0YXRlLCBzaWxlbnQpIHtcbiAgdmFyIHBvcyA9IHN0YXRlLnBvcyxcbiAgICAgIGlkeCA9IHN0YXRlLnNyYy5zbGljZShwb3MpLnNlYXJjaChURVJNSU5BVE9SX1JFKTtcblxuICAvLyBmaXJzdCBjaGFyIGlzIHRlcm1pbmF0b3IgLT4gZW1wdHkgdGV4dFxuICBpZiAoaWR4ID09PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gIC8vIG5vIHRlcm1pbmF0b3IgLT4gdGV4dCB0aWxsIGVuZCBvZiBzdHJpbmdcbiAgaWYgKGlkeCA8IDApIHtcbiAgICBpZiAoIXNpbGVudCkgeyBzdGF0ZS5wZW5kaW5nICs9IHN0YXRlLnNyYy5zbGljZShwb3MpOyB9XG4gICAgc3RhdGUucG9zID0gc3RhdGUuc3JjLmxlbmd0aDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghc2lsZW50KSB7IHN0YXRlLnBlbmRpbmcgKz0gc3RhdGUuc3JjLnNsaWNlKHBvcywgcG9zICsgaWR4KTsgfVxuXG4gIHN0YXRlLnBvcyArPSBpZHg7XG5cbiAgcmV0dXJuIHRydWU7XG59OyovXG4iLCIvLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIGludG8gb25lLCBhbmQgcmUtY2FsY3VsYXRlIGFsbCB0b2tlbiBsZXZlbHNcbi8vXG4ndXNlIHN0cmljdCc7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0ZXh0X2NvbGxhcHNlKHN0YXRlKSB7XG4gIHZhciBjdXJyLCBsYXN0LFxuICAgICAgbGV2ZWwgPSAwLFxuICAgICAgdG9rZW5zID0gc3RhdGUudG9rZW5zLFxuICAgICAgbWF4ID0gc3RhdGUudG9rZW5zLmxlbmd0aDtcblxuICBmb3IgKGN1cnIgPSBsYXN0ID0gMDsgY3VyciA8IG1heDsgY3VycisrKSB7XG4gICAgLy8gcmUtY2FsY3VsYXRlIGxldmVsc1xuICAgIGxldmVsICs9IHRva2Vuc1tjdXJyXS5uZXN0aW5nO1xuICAgIHRva2Vuc1tjdXJyXS5sZXZlbCA9IGxldmVsO1xuXG4gICAgaWYgKHRva2Vuc1tjdXJyXS50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgY3VyciArIDEgPCBtYXggJiZcbiAgICAgICAgdG9rZW5zW2N1cnIgKyAxXS50eXBlID09PSAndGV4dCcpIHtcblxuICAgICAgLy8gY29sbGFwc2UgdHdvIGFkamFjZW50IHRleHQgbm9kZXNcbiAgICAgIHRva2Vuc1tjdXJyICsgMV0uY29udGVudCA9IHRva2Vuc1tjdXJyXS5jb250ZW50ICsgdG9rZW5zW2N1cnIgKyAxXS5jb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VyciAhPT0gbGFzdCkgeyB0b2tlbnNbbGFzdF0gPSB0b2tlbnNbY3Vycl07IH1cblxuICAgICAgbGFzdCsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjdXJyICE9PSBsYXN0KSB7XG4gICAgdG9rZW5zLmxlbmd0aCA9IGxhc3Q7XG4gIH1cbn07XG4iLCIvLyBUb2tlbiBjbGFzc1xuXG4ndXNlIHN0cmljdCc7XG5cblxuLyoqXG4gKiBjbGFzcyBUb2tlblxuICoqL1xuXG4vKipcbiAqIG5ldyBUb2tlbih0eXBlLCB0YWcsIG5lc3RpbmcpXG4gKlxuICogQ3JlYXRlIG5ldyB0b2tlbiBhbmQgZmlsbCBwYXNzZWQgcHJvcGVydGllcy5cbiAqKi9cbmZ1bmN0aW9uIFRva2VuKHR5cGUsIHRhZywgbmVzdGluZykge1xuICAvKipcbiAgICogVG9rZW4jdHlwZSAtPiBTdHJpbmdcbiAgICpcbiAgICogVHlwZSBvZiB0aGUgdG9rZW4gKHN0cmluZywgZS5nLiBcInBhcmFncmFwaF9vcGVuXCIpXG4gICAqKi9cbiAgdGhpcy50eXBlICAgICA9IHR5cGU7XG5cbiAgLyoqXG4gICAqIFRva2VuI3RhZyAtPiBTdHJpbmdcbiAgICpcbiAgICogaHRtbCB0YWcgbmFtZSwgZS5nLiBcInBcIlxuICAgKiovXG4gIHRoaXMudGFnICAgICAgPSB0YWc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2F0dHJzIC0+IEFycmF5XG4gICAqXG4gICAqIEh0bWwgYXR0cmlidXRlcy4gRm9ybWF0OiBgWyBbIG5hbWUxLCB2YWx1ZTEgXSwgWyBuYW1lMiwgdmFsdWUyIF0gXWBcbiAgICoqL1xuICB0aGlzLmF0dHJzICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jbWFwIC0+IEFycmF5XG4gICAqXG4gICAqIFNvdXJjZSBtYXAgaW5mby4gRm9ybWF0OiBgWyBsaW5lX2JlZ2luLCBsaW5lX2VuZCBdYFxuICAgKiovXG4gIHRoaXMubWFwICAgICAgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBUb2tlbiNuZXN0aW5nIC0+IE51bWJlclxuICAgKlxuICAgKiBMZXZlbCBjaGFuZ2UgKG51bWJlciBpbiB7LTEsIDAsIDF9IHNldCksIHdoZXJlOlxuICAgKlxuICAgKiAtICBgMWAgbWVhbnMgdGhlIHRhZyBpcyBvcGVuaW5nXG4gICAqIC0gIGAwYCBtZWFucyB0aGUgdGFnIGlzIHNlbGYtY2xvc2luZ1xuICAgKiAtIGAtMWAgbWVhbnMgdGhlIHRhZyBpcyBjbG9zaW5nXG4gICAqKi9cbiAgdGhpcy5uZXN0aW5nICA9IG5lc3Rpbmc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2xldmVsIC0+IE51bWJlclxuICAgKlxuICAgKiBuZXN0aW5nIGxldmVsLCB0aGUgc2FtZSBhcyBgc3RhdGUubGV2ZWxgXG4gICAqKi9cbiAgdGhpcy5sZXZlbCAgICA9IDA7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NoaWxkcmVuIC0+IEFycmF5XG4gICAqXG4gICAqIEFuIGFycmF5IG9mIGNoaWxkIG5vZGVzIChpbmxpbmUgYW5kIGltZyB0b2tlbnMpXG4gICAqKi9cbiAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFRva2VuI2NvbnRlbnQgLT4gU3RyaW5nXG4gICAqXG4gICAqIEluIGEgY2FzZSBvZiBzZWxmLWNsb3NpbmcgdGFnIChjb2RlLCBodG1sLCBmZW5jZSwgZXRjLiksXG4gICAqIGl0IGhhcyBjb250ZW50cyBvZiB0aGlzIHRhZy5cbiAgICoqL1xuICB0aGlzLmNvbnRlbnQgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21hcmt1cCAtPiBTdHJpbmdcbiAgICpcbiAgICogJyonIG9yICdfJyBmb3IgZW1waGFzaXMsIGZlbmNlIHN0cmluZyBmb3IgZmVuY2UsIGV0Yy5cbiAgICoqL1xuICB0aGlzLm1hcmt1cCAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI2luZm8gLT4gU3RyaW5nXG4gICAqXG4gICAqIGZlbmNlIGluZm9zdHJpbmdcbiAgICoqL1xuICB0aGlzLmluZm8gICAgID0gJyc7XG5cbiAgLyoqXG4gICAqIFRva2VuI21ldGEgLT4gT2JqZWN0XG4gICAqXG4gICAqIEEgcGxhY2UgZm9yIHBsdWdpbnMgdG8gc3RvcmUgYW4gYXJiaXRyYXJ5IGRhdGFcbiAgICoqL1xuICB0aGlzLm1ldGEgICAgID0gbnVsbDtcblxuICAvKipcbiAgICogVG9rZW4jYmxvY2sgLT4gQm9vbGVhblxuICAgKlxuICAgKiBUcnVlIGZvciBibG9jay1sZXZlbCB0b2tlbnMsIGZhbHNlIGZvciBpbmxpbmUgdG9rZW5zLlxuICAgKiBVc2VkIGluIHJlbmRlcmVyIHRvIGNhbGN1bGF0ZSBsaW5lIGJyZWFrc1xuICAgKiovXG4gIHRoaXMuYmxvY2sgICAgPSBmYWxzZTtcblxuICAvKipcbiAgICogVG9rZW4jaGlkZGVuIC0+IEJvb2xlYW5cbiAgICpcbiAgICogSWYgaXQncyB0cnVlLCBpZ25vcmUgdGhpcyBlbGVtZW50IHdoZW4gcmVuZGVyaW5nLiBVc2VkIGZvciB0aWdodCBsaXN0c1xuICAgKiB0byBoaWRlIHBhcmFncmFwaHMuXG4gICAqKi9cbiAgdGhpcy5oaWRkZW4gICA9IGZhbHNlO1xufVxuXG5cbi8qKlxuICogVG9rZW4uYXR0ckluZGV4KG5hbWUpIC0+IE51bWJlclxuICpcbiAqIFNlYXJjaCBhdHRyaWJ1dGUgaW5kZXggYnkgbmFtZS5cbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRySW5kZXggPSBmdW5jdGlvbiBhdHRySW5kZXgobmFtZSkge1xuICB2YXIgYXR0cnMsIGksIGxlbjtcblxuICBpZiAoIXRoaXMuYXR0cnMpIHsgcmV0dXJuIC0xOyB9XG5cbiAgYXR0cnMgPSB0aGlzLmF0dHJzO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IGF0dHJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGF0dHJzW2ldWzBdID09PSBuYW1lKSB7IHJldHVybiBpOyB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufTtcblxuXG4vKipcbiAqIFRva2VuLmF0dHJQdXNoKGF0dHJEYXRhKVxuICpcbiAqIEFkZCBgWyBuYW1lLCB2YWx1ZSBdYCBhdHRyaWJ1dGUgdG8gbGlzdC4gSW5pdCBhdHRycyBpZiBuZWNlc3NhcnlcbiAqKi9cblRva2VuLnByb3RvdHlwZS5hdHRyUHVzaCA9IGZ1bmN0aW9uIGF0dHJQdXNoKGF0dHJEYXRhKSB7XG4gIGlmICh0aGlzLmF0dHJzKSB7XG4gICAgdGhpcy5hdHRycy5wdXNoKGF0dHJEYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmF0dHJzID0gWyBhdHRyRGF0YSBdO1xuICB9XG59O1xuXG5cbi8qKlxuICogVG9rZW4uYXR0clNldChuYW1lLCB2YWx1ZSlcbiAqXG4gKiBTZXQgYG5hbWVgIGF0dHJpYnV0ZSB0byBgdmFsdWVgLiBPdmVycmlkZSBvbGQgdmFsdWUgaWYgZXhpc3RzLlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJTZXQgPSBmdW5jdGlvbiBhdHRyU2V0KG5hbWUsIHZhbHVlKSB7XG4gIHZhciBpZHggPSB0aGlzLmF0dHJJbmRleChuYW1lKSxcbiAgICAgIGF0dHJEYXRhID0gWyBuYW1lLCB2YWx1ZSBdO1xuXG4gIGlmIChpZHggPCAwKSB7XG4gICAgdGhpcy5hdHRyUHVzaChhdHRyRGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdID0gYXR0ckRhdGE7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRyR2V0KG5hbWUpXG4gKlxuICogR2V0IHRoZSB2YWx1ZSBvZiBhdHRyaWJ1dGUgYG5hbWVgLCBvciBudWxsIGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuICoqL1xuVG9rZW4ucHJvdG90eXBlLmF0dHJHZXQgPSBmdW5jdGlvbiBhdHRyR2V0KG5hbWUpIHtcbiAgdmFyIGlkeCA9IHRoaXMuYXR0ckluZGV4KG5hbWUpLCB2YWx1ZSA9IG51bGw7XG4gIGlmIChpZHggPj0gMCkge1xuICAgIHZhbHVlID0gdGhpcy5hdHRyc1tpZHhdWzFdO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cblxuLyoqXG4gKiBUb2tlbi5hdHRySm9pbihuYW1lLCB2YWx1ZSlcbiAqXG4gKiBKb2luIHZhbHVlIHRvIGV4aXN0aW5nIGF0dHJpYnV0ZSB2aWEgc3BhY2UuIE9yIGNyZWF0ZSBuZXcgYXR0cmlidXRlIGlmIG5vdFxuICogZXhpc3RzLiBVc2VmdWwgdG8gb3BlcmF0ZSB3aXRoIHRva2VuIGNsYXNzZXMuXG4gKiovXG5Ub2tlbi5wcm90b3R5cGUuYXR0ckpvaW4gPSBmdW5jdGlvbiBhdHRySm9pbihuYW1lLCB2YWx1ZSkge1xuICB2YXIgaWR4ID0gdGhpcy5hdHRySW5kZXgobmFtZSk7XG5cbiAgaWYgKGlkeCA8IDApIHtcbiAgICB0aGlzLmF0dHJQdXNoKFsgbmFtZSwgdmFsdWUgXSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hdHRyc1tpZHhdWzFdID0gdGhpcy5hdHRyc1tpZHhdWzFdICsgJyAnICsgdmFsdWU7XG4gIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUb2tlbjtcbiIsIlxuJ3VzZSBzdHJpY3QnO1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxudmFyIGRlY29kZUNhY2hlID0ge307XG5cbmZ1bmN0aW9uIGdldERlY29kZUNhY2hlKGV4Y2x1ZGUpIHtcbiAgdmFyIGksIGNoLCBjYWNoZSA9IGRlY29kZUNhY2hlW2V4Y2x1ZGVdO1xuICBpZiAoY2FjaGUpIHsgcmV0dXJuIGNhY2hlOyB9XG5cbiAgY2FjaGUgPSBkZWNvZGVDYWNoZVtleGNsdWRlXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcbiAgICBjYWNoZS5wdXNoKGNoKTtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBleGNsdWRlLmxlbmd0aDsgaSsrKSB7XG4gICAgY2ggPSBleGNsdWRlLmNoYXJDb2RlQXQoaSk7XG4gICAgY2FjaGVbY2hdID0gJyUnICsgKCcwJyArIGNoLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XG4gIH1cblxuICByZXR1cm4gY2FjaGU7XG59XG5cblxuLy8gRGVjb2RlIHBlcmNlbnQtZW5jb2RlZCBzdHJpbmcuXG4vL1xuZnVuY3Rpb24gZGVjb2RlKHN0cmluZywgZXhjbHVkZSkge1xuICB2YXIgY2FjaGU7XG5cbiAgaWYgKHR5cGVvZiBleGNsdWRlICE9PSAnc3RyaW5nJykge1xuICAgIGV4Y2x1ZGUgPSBkZWNvZGUuZGVmYXVsdENoYXJzO1xuICB9XG5cbiAgY2FjaGUgPSBnZXREZWNvZGVDYWNoZShleGNsdWRlKTtcblxuICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoLyglW2EtZjAtOV17Mn0pKy9naSwgZnVuY3Rpb24oc2VxKSB7XG4gICAgdmFyIGksIGwsIGIxLCBiMiwgYjMsIGI0LCBjaHIsXG4gICAgICAgIHJlc3VsdCA9ICcnO1xuXG4gICAgZm9yIChpID0gMCwgbCA9IHNlcS5sZW5ndGg7IGkgPCBsOyBpICs9IDMpIHtcbiAgICAgIGIxID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyAxLCBpICsgMyksIDE2KTtcblxuICAgICAgaWYgKGIxIDwgMHg4MCkge1xuICAgICAgICByZXN1bHQgKz0gY2FjaGVbYjFdO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RTApID09PSAweEMwICYmIChpICsgMyA8IGwpKSB7XG4gICAgICAgIC8vIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjaHIgPSAoKGIxIDw8IDYpICYgMHg3QzApIHwgKGIyICYgMHgzRik7XG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHg4MCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSAzO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgoYjEgJiAweEYwKSA9PT0gMHhFMCAmJiAoaSArIDYgPCBsKSkge1xuICAgICAgICAvLyAxMTEweHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgICBiMiA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgNCwgaSArIDYpLCAxNik7XG4gICAgICAgIGIzID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA3LCBpICsgOSksIDE2KTtcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODAgJiYgKGIzICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjaHIgPSAoKGIxIDw8IDEyKSAmIDB4RjAwMCkgfCAoKGIyIDw8IDYpICYgMHhGQzApIHwgKGIzICYgMHgzRik7XG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHg4MDAgfHwgKGNociA+PSAweEQ4MDAgJiYgY2hyIDw9IDB4REZGRikpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZFxcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpICs9IDY7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKChiMSAmIDB4RjgpID09PSAweEYwICYmIChpICsgOSA8IGwpKSB7XG4gICAgICAgIC8vIDExMTExMHh4IDEweHh4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICAgIGIyID0gcGFyc2VJbnQoc2VxLnNsaWNlKGkgKyA0LCBpICsgNiksIDE2KTtcbiAgICAgICAgYjMgPSBwYXJzZUludChzZXEuc2xpY2UoaSArIDcsIGkgKyA5KSwgMTYpO1xuICAgICAgICBiNCA9IHBhcnNlSW50KHNlcS5zbGljZShpICsgMTAsIGkgKyAxMiksIDE2KTtcblxuICAgICAgICBpZiAoKGIyICYgMHhDMCkgPT09IDB4ODAgJiYgKGIzICYgMHhDMCkgPT09IDB4ODAgJiYgKGI0ICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICBjaHIgPSAoKGIxIDw8IDE4KSAmIDB4MUMwMDAwKSB8ICgoYjIgPDwgMTIpICYgMHgzRjAwMCkgfCAoKGIzIDw8IDYpICYgMHhGQzApIHwgKGI0ICYgMHgzRik7XG5cbiAgICAgICAgICBpZiAoY2hyIDwgMHgxMDAwMCB8fCBjaHIgPiAweDEwRkZGRikge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICdcXHVmZmZkXFx1ZmZmZFxcdWZmZmRcXHVmZmZkJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hyIC09IDB4MTAwMDA7XG4gICAgICAgICAgICByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEQ4MDAgKyAoY2hyID4+IDEwKSwgMHhEQzAwICsgKGNociAmIDB4M0ZGKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaSArPSA5O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSAnXFx1ZmZmZCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59XG5cblxuZGVjb2RlLmRlZmF1bHRDaGFycyAgID0gJzsvPzpAJj0rJCwjJztcbmRlY29kZS5jb21wb25lbnRDaGFycyA9ICcnO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZGVjb2RlO1xuIiwiXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIGVuY29kZUNhY2hlID0ge307XG5cblxuLy8gQ3JlYXRlIGEgbG9va3VwIGFycmF5IHdoZXJlIGFueXRoaW5nIGJ1dCBjaGFyYWN0ZXJzIGluIGBjaGFyc2Agc3RyaW5nXG4vLyBhbmQgYWxwaGFudW1lcmljIGNoYXJzIGlzIHBlcmNlbnQtZW5jb2RlZC5cbi8vXG5mdW5jdGlvbiBnZXRFbmNvZGVDYWNoZShleGNsdWRlKSB7XG4gIHZhciBpLCBjaCwgY2FjaGUgPSBlbmNvZGVDYWNoZVtleGNsdWRlXTtcbiAgaWYgKGNhY2hlKSB7IHJldHVybiBjYWNoZTsgfVxuXG4gIGNhY2hlID0gZW5jb2RlQ2FjaGVbZXhjbHVkZV0gPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgMTI4OyBpKyspIHtcbiAgICBjaCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XG5cbiAgICBpZiAoL15bMC05YS16XSQvaS50ZXN0KGNoKSkge1xuICAgICAgLy8gYWx3YXlzIGFsbG93IHVuZW5jb2RlZCBhbHBoYW51bWVyaWMgY2hhcmFjdGVyc1xuICAgICAgY2FjaGUucHVzaChjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlLnB1c2goJyUnICsgKCcwJyArIGkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpLnNsaWNlKC0yKSk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IGV4Y2x1ZGUubGVuZ3RoOyBpKyspIHtcbiAgICBjYWNoZVtleGNsdWRlLmNoYXJDb2RlQXQoaSldID0gZXhjbHVkZVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZTtcbn1cblxuXG4vLyBFbmNvZGUgdW5zYWZlIGNoYXJhY3RlcnMgd2l0aCBwZXJjZW50LWVuY29kaW5nLCBza2lwcGluZyBhbHJlYWR5XG4vLyBlbmNvZGVkIHNlcXVlbmNlcy5cbi8vXG4vLyAgLSBzdHJpbmcgICAgICAgLSBzdHJpbmcgdG8gZW5jb2RlXG4vLyAgLSBleGNsdWRlICAgICAgLSBsaXN0IG9mIGNoYXJhY3RlcnMgdG8gaWdub3JlIChpbiBhZGRpdGlvbiB0byBhLXpBLVowLTkpXG4vLyAgLSBrZWVwRXNjYXBlZCAgLSBkb24ndCBlbmNvZGUgJyUnIGluIGEgY29ycmVjdCBlc2NhcGUgc2VxdWVuY2UgKGRlZmF1bHQ6IHRydWUpXG4vL1xuZnVuY3Rpb24gZW5jb2RlKHN0cmluZywgZXhjbHVkZSwga2VlcEVzY2FwZWQpIHtcbiAgdmFyIGksIGwsIGNvZGUsIG5leHRDb2RlLCBjYWNoZSxcbiAgICAgIHJlc3VsdCA9ICcnO1xuXG4gIGlmICh0eXBlb2YgZXhjbHVkZSAhPT0gJ3N0cmluZycpIHtcbiAgICAvLyBlbmNvZGUoc3RyaW5nLCBrZWVwRXNjYXBlZClcbiAgICBrZWVwRXNjYXBlZCAgPSBleGNsdWRlO1xuICAgIGV4Y2x1ZGUgPSBlbmNvZGUuZGVmYXVsdENoYXJzO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBrZWVwRXNjYXBlZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBrZWVwRXNjYXBlZCA9IHRydWU7XG4gIH1cblxuICBjYWNoZSA9IGdldEVuY29kZUNhY2hlKGV4Y2x1ZGUpO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY29kZSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGtlZXBFc2NhcGVkICYmIGNvZGUgPT09IDB4MjUgLyogJSAqLyAmJiBpICsgMiA8IGwpIHtcbiAgICAgIGlmICgvXlswLTlhLWZdezJ9JC9pLnRlc3Qoc3RyaW5nLnNsaWNlKGkgKyAxLCBpICsgMykpKSB7XG4gICAgICAgIHJlc3VsdCArPSBzdHJpbmcuc2xpY2UoaSwgaSArIDMpO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICByZXN1bHQgKz0gY2FjaGVbY29kZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY29kZSA+PSAweEQ4MDAgJiYgY29kZSA8PSAweERGRkYpIHtcbiAgICAgIGlmIChjb2RlID49IDB4RDgwMCAmJiBjb2RlIDw9IDB4REJGRiAmJiBpICsgMSA8IGwpIHtcbiAgICAgICAgbmV4dENvZGUgPSBzdHJpbmcuY2hhckNvZGVBdChpICsgMSk7XG4gICAgICAgIGlmIChuZXh0Q29kZSA+PSAweERDMDAgJiYgbmV4dENvZGUgPD0gMHhERkZGKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdbaV0gKyBzdHJpbmdbaSArIDFdKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSAnJUVGJUJGJUJEJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc3VsdCArPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5nW2ldKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmVuY29kZS5kZWZhdWx0Q2hhcnMgICA9IFwiOy8/OkAmPSskLC1fLiF+KicoKSNcIjtcbmVuY29kZS5jb21wb25lbnRDaGFycyA9IFwiLV8uIX4qJygpXCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBlbmNvZGU7XG4iLCJcbid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvcm1hdCh1cmwpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIHJlc3VsdCArPSB1cmwucHJvdG9jb2wgfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuc2xhc2hlcyA/ICcvLycgOiAnJztcbiAgcmVzdWx0ICs9IHVybC5hdXRoID8gdXJsLmF1dGggKyAnQCcgOiAnJztcblxuICBpZiAodXJsLmhvc3RuYW1lICYmIHVybC5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xKSB7XG4gICAgLy8gaXB2NiBhZGRyZXNzXG4gICAgcmVzdWx0ICs9ICdbJyArIHVybC5ob3N0bmFtZSArICddJztcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gdXJsLmhvc3RuYW1lIHx8ICcnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5wb3J0ID8gJzonICsgdXJsLnBvcnQgOiAnJztcbiAgcmVzdWx0ICs9IHVybC5wYXRobmFtZSB8fCAnJztcbiAgcmVzdWx0ICs9IHVybC5zZWFyY2ggfHwgJyc7XG4gIHJlc3VsdCArPSB1cmwuaGFzaCB8fCAnJztcblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGUgPSByZXF1aXJlKCcuL2VuY29kZScpO1xubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbm1vZHVsZS5leHBvcnRzLmZvcm1hdCA9IHJlcXVpcmUoJy4vZm9ybWF0Jyk7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSAgPSByZXF1aXJlKCcuL3BhcnNlJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vL1xuLy8gQ2hhbmdlcyBmcm9tIGpveWVudC9ub2RlOlxuLy9cbi8vIDEuIE5vIGxlYWRpbmcgc2xhc2ggaW4gcGF0aHMsXG4vLyAgICBlLmcuIGluIGB1cmwucGFyc2UoJ2h0dHA6Ly9mb28/YmFyJylgIHBhdGhuYW1lIGlzIGBgLCBub3QgYC9gXG4vL1xuLy8gMi4gQmFja3NsYXNoZXMgYXJlIG5vdCByZXBsYWNlZCB3aXRoIHNsYXNoZXMsXG4vLyAgICBzbyBgaHR0cDpcXFxcZXhhbXBsZS5vcmdcXGAgaXMgdHJlYXRlZCBsaWtlIGEgcmVsYXRpdmUgcGF0aFxuLy9cbi8vIDMuIFRyYWlsaW5nIGNvbG9uIGlzIHRyZWF0ZWQgbGlrZSBhIHBhcnQgb2YgdGhlIHBhdGgsXG4vLyAgICBpLmUuIGluIGBodHRwOi8vZXhhbXBsZS5vcmc6Zm9vYCBwYXRobmFtZSBpcyBgOmZvb2Bcbi8vXG4vLyA0LiBOb3RoaW5nIGlzIFVSTC1lbmNvZGVkIGluIHRoZSByZXN1bHRpbmcgb2JqZWN0LFxuLy8gICAgKGluIGpveWVudC9ub2RlIHNvbWUgY2hhcnMgaW4gYXV0aCBhbmQgcGF0aHMgYXJlIGVuY29kZWQpXG4vL1xuLy8gNS4gYHVybC5wYXJzZSgpYCBkb2VzIG5vdCBoYXZlIGBwYXJzZVF1ZXJ5U3RyaW5nYCBhcmd1bWVudFxuLy9cbi8vIDYuIFJlbW92ZWQgZXh0cmFuZW91cyByZXN1bHQgcHJvcGVydGllczogYGhvc3RgLCBgcGF0aGAsIGBxdWVyeWAsIGV0Yy4sXG4vLyAgICB3aGljaCBjYW4gYmUgY29uc3RydWN0ZWQgdXNpbmcgb3RoZXIgcGFydHMgb2YgdGhlIHVybC5cbi8vXG5cblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsgJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnIF0sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsgJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJyBdLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbICdcXCcnIF0uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbICclJywgJy8nLCAnPycsICc7JywgJyMnIF0uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsgJy8nLCAnPycsICcjJyBdLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tc2NyaXB0LXVybCAqL1xuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNjcmlwdC11cmwgKi9cblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHVybCBpbnN0YW5jZW9mIFVybCkgeyByZXR1cm4gdXJsOyB9XG5cbiAgdmFyIHUgPSBuZXcgVXJsKCk7XG4gIHUucGFyc2UodXJsLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICB2YXIgaSwgbCwgbG93ZXJQcm90bywgaGVjLCBzbGFzaGVzLFxuICAgICAgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBwcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAoaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAocmVzdFtob3N0RW5kIC0gMV0gPT09ICc6JykgeyBob3N0RW5kLS07IH1cbiAgICB2YXIgaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KGhvc3QpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIHsgY29udGludWU7IH1cbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9IG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfVxuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgfVxuICB9XG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9XG4gIGlmIChyZXN0KSB7IHRoaXMucGF0aG5hbWUgPSByZXN0OyB9XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJyc7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oaG9zdCkge1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgeyB0aGlzLmhvc3RuYW1lID0gaG9zdDsgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1cmxQYXJzZTtcbiIsIi8qISBodHRwczovL210aHMuYmUvcHVueWNvZGUgdjEuNC4xIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiZcblx0XHQhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0IW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChcblx0XHRmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC5zZWxmID09PSBmcmVlR2xvYmFsXG5cdCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nLCAvLyBSRkMgMzQ5MCBzZXBhcmF0b3JzXG5cblx0LyoqIEVycm9yIG1lc3NhZ2VzICovXG5cdGVycm9ycyA9IHtcblx0XHQnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxuXHRcdCdub3QtYmFzaWMnOiAnSWxsZWdhbCBpbnB1dCA+PSAweDgwIChub3QgYSBiYXNpYyBjb2RlIHBvaW50KScsXG5cdFx0J2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcblx0fSxcblxuXHQvKiogQ29udmVuaWVuY2Ugc2hvcnRjdXRzICovXG5cdGJhc2VNaW51c1RNaW4gPSBiYXNlIC0gdE1pbixcblx0Zmxvb3IgPSBNYXRoLmZsb29yLFxuXHRzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLFxuXG5cdC8qKiBUZW1wb3JhcnkgdmFyaWFibGUgKi9cblx0a2V5O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG5cdCAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cblx0ICovXG5cdGZ1bmN0aW9uIGVycm9yKHR5cGUpIHtcblx0XHR0aHJvdyBuZXcgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcblx0ICogQHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuXHRcdHZhciBrID0gMDtcblx0XHRkZWx0YSA9IGZpcnN0VGltZSA/IGZsb29yKGRlbHRhIC8gZGFtcCkgOiBkZWx0YSA+PiAxO1xuXHRcdGRlbHRhICs9IGZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcblx0XHRmb3IgKC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IGJhc2VNaW51c1RNaW4gKiB0TWF4ID4+IDE7IGsgKz0gYmFzZSkge1xuXHRcdFx0ZGVsdGEgPSBmbG9vcihkZWx0YSAvIGJhc2VNaW51c1RNaW4pO1xuXHRcdH1cblx0XHRyZXR1cm4gZmxvb3IoayArIChiYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNrZXcpKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMgdG8gYSBzdHJpbmcgb2YgVW5pY29kZVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcblx0XHQvLyBEb24ndCB1c2UgVUNTLTJcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoLFxuXHRcdCAgICBvdXQsXG5cdFx0ICAgIGkgPSAwLFxuXHRcdCAgICBuID0gaW5pdGlhbE4sXG5cdFx0ICAgIGJpYXMgPSBpbml0aWFsQmlhcyxcblx0XHQgICAgYmFzaWMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIGluZGV4LFxuXHRcdCAgICBvbGRpLFxuXHRcdCAgICB3LFxuXHRcdCAgICBrLFxuXHRcdCAgICBkaWdpdCxcblx0XHQgICAgdCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGJhc2VNaW51c1Q7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzOiBsZXQgYGJhc2ljYCBiZSB0aGUgbnVtYmVyIG9mIGlucHV0IGNvZGVcblx0XHQvLyBwb2ludHMgYmVmb3JlIHRoZSBsYXN0IGRlbGltaXRlciwgb3IgYDBgIGlmIHRoZXJlIGlzIG5vbmUsIHRoZW4gY29weVxuXHRcdC8vIHRoZSBmaXJzdCBiYXNpYyBjb2RlIHBvaW50cyB0byB0aGUgb3V0cHV0LlxuXG5cdFx0YmFzaWMgPSBpbnB1dC5sYXN0SW5kZXhPZihkZWxpbWl0ZXIpO1xuXHRcdGlmIChiYXNpYyA8IDApIHtcblx0XHRcdGJhc2ljID0gMDtcblx0XHR9XG5cblx0XHRmb3IgKGogPSAwOyBqIDwgYmFzaWM7ICsraikge1xuXHRcdFx0Ly8gaWYgaXQncyBub3QgYSBiYXNpYyBjb2RlIHBvaW50XG5cdFx0XHRpZiAoaW5wdXQuY2hhckNvZGVBdChqKSA+PSAweDgwKSB7XG5cdFx0XHRcdGVycm9yKCdub3QtYmFzaWMnKTtcblx0XHRcdH1cblx0XHRcdG91dHB1dC5wdXNoKGlucHV0LmNoYXJDb2RlQXQoaikpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZGVjb2RpbmcgbG9vcDogc3RhcnQganVzdCBhZnRlciB0aGUgbGFzdCBkZWxpbWl0ZXIgaWYgYW55IGJhc2ljIGNvZGVcblx0XHQvLyBwb2ludHMgd2VyZSBjb3BpZWQ7IHN0YXJ0IGF0IHRoZSBiZWdpbm5pbmcgb3RoZXJ3aXNlLlxuXG5cdFx0Zm9yIChpbmRleCA9IGJhc2ljID4gMCA/IGJhc2ljICsgMSA6IDA7IGluZGV4IDwgaW5wdXRMZW5ndGg7IC8qIG5vIGZpbmFsIGV4cHJlc3Npb24gKi8pIHtcblxuXHRcdFx0Ly8gYGluZGV4YCBpcyB0aGUgaW5kZXggb2YgdGhlIG5leHQgY2hhcmFjdGVyIHRvIGJlIGNvbnN1bWVkLlxuXHRcdFx0Ly8gRGVjb2RlIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXIgaW50byBgZGVsdGFgLFxuXHRcdFx0Ly8gd2hpY2ggZ2V0cyBhZGRlZCB0byBgaWAuIFRoZSBvdmVyZmxvdyBjaGVja2luZyBpcyBlYXNpZXJcblx0XHRcdC8vIGlmIHdlIGluY3JlYXNlIGBpYCBhcyB3ZSBnbywgdGhlbiBzdWJ0cmFjdCBvZmYgaXRzIHN0YXJ0aW5nXG5cdFx0XHQvLyB2YWx1ZSBhdCB0aGUgZW5kIHRvIG9idGFpbiBgZGVsdGFgLlxuXHRcdFx0Zm9yIChvbGRpID0gaSwgdyA9IDEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXG5cdFx0XHRcdGlmIChpbmRleCA+PSBpbnB1dExlbmd0aCkge1xuXHRcdFx0XHRcdGVycm9yKCdpbnZhbGlkLWlucHV0Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkaWdpdCA9IGJhc2ljVG9EaWdpdChpbnB1dC5jaGFyQ29kZUF0KGluZGV4KyspKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPj0gYmFzZSB8fCBkaWdpdCA+IGZsb29yKChtYXhJbnQgLSBpKSAvIHcpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpICs9IGRpZ2l0ICogdztcblx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0IDwgdCkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRpZiAodyA+IGZsb29yKG1heEludCAvIGJhc2VNaW51c1QpKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR3ICo9IGJhc2VNaW51c1Q7XG5cblx0XHRcdH1cblxuXHRcdFx0b3V0ID0gb3V0cHV0Lmxlbmd0aCArIDE7XG5cdFx0XHRiaWFzID0gYWRhcHQoaSAtIG9sZGksIG91dCwgb2xkaSA9PSAwKTtcblxuXHRcdFx0Ly8gYGlgIHdhcyBzdXBwb3NlZCB0byB3cmFwIGFyb3VuZCBmcm9tIGBvdXRgIHRvIGAwYCxcblx0XHRcdC8vIGluY3JlbWVudGluZyBgbmAgZWFjaCB0aW1lLCBzbyB3ZSdsbCBmaXggdGhhdCBub3c6XG5cdFx0XHRpZiAoZmxvb3IoaSAvIG91dCkgPiBtYXhJbnQgLSBuKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRuICs9IGZsb29yKGkgLyBvdXQpO1xuXHRcdFx0aSAlPSBvdXQ7XG5cblx0XHRcdC8vIEluc2VydCBgbmAgYXQgcG9zaXRpb24gYGlgIG9mIHRoZSBvdXRwdXRcblx0XHRcdG91dHB1dC5zcGxpY2UoaSsrLCAwLCBuKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKG91dHB1dCk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcblx0ICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG5cdFx0dmFyIG4sXG5cdFx0ICAgIGRlbHRhLFxuXHRcdCAgICBoYW5kbGVkQ1BDb3VudCxcblx0XHQgICAgYmFzaWNMZW5ndGgsXG5cdFx0ICAgIGJpYXMsXG5cdFx0ICAgIGosXG5cdFx0ICAgIG0sXG5cdFx0ICAgIHEsXG5cdFx0ICAgIGssXG5cdFx0ICAgIHQsXG5cdFx0ICAgIGN1cnJlbnRWYWx1ZSxcblx0XHQgICAgb3V0cHV0ID0gW10sXG5cdFx0ICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG5cdFx0ICAgIGlucHV0TGVuZ3RoLFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLFxuXHRcdCAgICBiYXNlTWludXNULFxuXHRcdCAgICBxTWludXNUO1xuXG5cdFx0Ly8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuXHRcdGlucHV0ID0gdWNzMmRlY29kZShpbnB1dCk7XG5cblx0XHQvLyBDYWNoZSB0aGUgbGVuZ3RoXG5cdFx0aW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG5cblx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuXHRcdG4gPSBpbml0aWFsTjtcblx0XHRkZWx0YSA9IDA7XG5cdFx0YmlhcyA9IGluaXRpYWxCaWFzO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xuXHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcblxuXHRcdC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXHRcdC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cblxuXHRcdC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIC0gaWYgaXQgaXMgbm90IGVtcHR5IC0gd2l0aCBhIGRlbGltaXRlclxuXHRcdGlmIChiYXNpY0xlbmd0aCkge1xuXHRcdFx0b3V0cHV0LnB1c2goZGVsaW1pdGVyKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGVuY29kaW5nIGxvb3A6XG5cdFx0d2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcblxuXHRcdFx0Ly8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dFxuXHRcdFx0Ly8gbGFyZ2VyIG9uZTpcblx0XHRcdGZvciAobSA9IG1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuXHRcdFx0XHRcdG0gPSBjdXJyZW50VmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuXHRcdFx0Ly8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcblx0XHRcdGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcblx0XHRcdGlmIChtIC0gbiA+IGZsb29yKChtYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG5cdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0fVxuXG5cdFx0XHRkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuXHRcdFx0biA9IG07XG5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG5cdFx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBtYXhJbnQpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuXHRcdFx0XHRcdC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXG5cdFx0XHRcdFx0Zm9yIChxID0gZGVsdGEsIGsgPSBiYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gYmFzZSkge1xuXHRcdFx0XHRcdFx0dCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG5cdFx0XHRcdFx0XHRpZiAocSA8IHQpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRxTWludXNUID0gcSAtIHQ7XG5cdFx0XHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaChcblx0XHRcdFx0XHRcdFx0c3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdHEgPSBmbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxLCAwKSkpO1xuXHRcdFx0XHRcdGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG5cdFx0XHRcdFx0ZGVsdGEgPSAwO1xuXHRcdFx0XHRcdCsraGFuZGxlZENQQ291bnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0KytkZWx0YTtcblx0XHRcdCsrbjtcblxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3Ncblx0ICogdG8gVW5pY29kZS4gT25seSB0aGUgUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBpbnB1dCB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLlxuXHQgKiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW5cblx0ICogY29udmVydGVkIHRvIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlZCBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXG5cdCAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuXHQgKiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG5cdCAqIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXG5cdCAqIGVtYWlsIGFkZHJlc3MuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuNC4xJyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgT2JqZWN0XG5cdFx0ICovXG5cdFx0J3VjczInOiB7XG5cdFx0XHQnZGVjb2RlJzogdWNzMmRlY29kZSxcblx0XHRcdCdlbmNvZGUnOiB1Y3MyZW5jb2RlXG5cdFx0fSxcblx0XHQnZGVjb2RlJzogZGVjb2RlLFxuXHRcdCdlbmNvZGUnOiBlbmNvZGUsXG5cdFx0J3RvQVNDSUknOiB0b0FTQ0lJLFxuXHRcdCd0b1VuaWNvZGUnOiB0b1VuaWNvZGVcblx0fTtcblxuXHQvKiogRXhwb3NlIGBwdW55Y29kZWAgKi9cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoJ3B1bnljb2RlJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gcHVueWNvZGU7XG5cdFx0fSk7XG5cdH0gZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgZnJlZU1vZHVsZSkge1xuXHRcdGlmIChtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuXHRcdFx0Ly8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHRmb3IgKGtleSBpbiBwdW55Y29kZSkge1xuXHRcdFx0XHRwdW55Y29kZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gcHVueWNvZGVba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2Uge1xuXHRcdC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi44LjZcbiAqIHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG52YXIgc2NoZWR1bGVyID0gcmVxdWlyZSgnc2NoZWR1bGVyJyk7XG52YXIgdHJhY2luZyA9IHJlcXVpcmUoJ3NjaGVkdWxlci90cmFjaW5nJyk7XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIFJlbHlpbmcgb24gdGhlIGBpbnZhcmlhbnQoKWAgaW1wbGVtZW50YXRpb24gbGV0cyB1c1xuLy8gcHJlc2VydmUgdGhlIGZvcm1hdCBhbmQgcGFyYW1zIGluIHRoZSB3d3cgYnVpbGRzLlxuXG4hUmVhY3QgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTSB3YXMgbG9hZGVkIGJlZm9yZSBSZWFjdC4gTWFrZSBzdXJlIHlvdSBsb2FkIHRoZSBSZWFjdCBwYWNrYWdlIGJlZm9yZSBsb2FkaW5nIFJlYWN0RE9NLicpIDogdm9pZCAwO1xuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrSW1wbCA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gIHRyeSB7XG4gICAgZnVuYy5hcHBseShjb250ZXh0LCBmdW5jQXJncyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhpcy5vbkVycm9yKGVycm9yKTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bmludHVpdGl2ZSwgdGhvdWdoLCBiZWNhdXNlIGV2ZW4gdGhvdWdoIFJlYWN0IGhhcyBjYXVnaHQgdGhlIGVycm9yLCBmcm9tXG4gIC8vIHRoZSBkZXZlbG9wZXIncyBwZXJzcGVjdGl2ZSwgdGhlIGVycm9yIGlzIHVuY2F1Z2h0LlxuICAvL1xuICAvLyBUbyBwcmVzZXJ2ZSB0aGUgZXhwZWN0ZWQgXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IsIHdlIGRvbid0IHVzZSBhXG4gIC8vIHRyeS1jYXRjaCBpbiBERVYuIEluc3RlYWQsIHdlIHN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggYSBmYWtlIGV2ZW50IHRvIGEgZmFrZVxuICAvLyBET00gbm9kZSwgYW5kIGNhbGwgdGhlIHVzZXItcHJvdmlkZWQgY2FsbGJhY2sgZnJvbSBpbnNpZGUgYW4gZXZlbnQgaGFuZGxlclxuICAvLyBmb3IgdGhhdCBmYWtlIGV2ZW50LiBJZiB0aGUgY2FsbGJhY2sgdGhyb3dzLCB0aGUgZXJyb3IgaXMgXCJjYXB0dXJlZFwiIHVzaW5nXG4gIC8vIGEgZ2xvYmFsIGV2ZW50IGhhbmRsZXIuIEJ1dCBiZWNhdXNlIHRoZSBlcnJvciBoYXBwZW5zIGluIGEgZGlmZmVyZW50XG4gIC8vIGV2ZW50IGxvb3AgY29udGV4dCwgaXQgZG9lcyBub3QgaW50ZXJydXB0IHRoZSBub3JtYWwgcHJvZ3JhbSBmbG93LlxuICAvLyBFZmZlY3RpdmVseSwgdGhpcyBnaXZlcyB1cyB0cnktY2F0Y2ggYmVoYXZpb3Igd2l0aG91dCBhY3R1YWxseSB1c2luZ1xuICAvLyB0cnktY2F0Y2guIE5lYXQhXG5cbiAgLy8gQ2hlY2sgdGhhdCB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgQVBJcyB3ZSBuZWVkIHRvIGltcGxlbWVudCBvdXIgc3BlY2lhbFxuICAvLyBERVYgdmVyc2lvbiBvZiBpbnZva2VHdWFyZGVkQ2FsbGJhY2tcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG5cbiAgICB2YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2ID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIC8vIElmIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3Qgd2Uga25vdyBmb3Igc3VyZSB3ZSB3aWxsIGNyYXNoIGluIHRoaXMgbWV0aG9kXG4gICAgICAvLyB3aGVuIHdlIGNhbGwgZG9jdW1lbnQuY3JlYXRlRXZlbnQoKS4gSG93ZXZlciB0aGlzIGNhbiBjYXVzZSBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9yczogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29raW5jdWJhdG9yL2NyZWF0ZS1yZWFjdC1hcHAvaXNzdWVzLzM0ODJcbiAgICAgIC8vIFNvIHdlIHByZWVtcHRpdmVseSB0aHJvdyB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UgaW5zdGVhZC5cbiAgICAgICEodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgYGRvY3VtZW50YCBnbG9iYWwgd2FzIGRlZmluZWQgd2hlbiBSZWFjdCB3YXMgaW5pdGlhbGl6ZWQsIGJ1dCBpcyBub3QgZGVmaW5lZCBhbnltb3JlLiBUaGlzIGNhbiBoYXBwZW4gaW4gYSB0ZXN0IGVudmlyb25tZW50IGlmIGEgY29tcG9uZW50IHNjaGVkdWxlcyBhbiB1cGRhdGUgZnJvbSBhbiBhc3luY2hyb25vdXMgY2FsbGJhY2ssIGJ1dCB0aGUgdGVzdCBoYXMgYWxyZWFkeSBmaW5pc2hlZCBydW5uaW5nLiBUbyBzb2x2ZSB0aGlzLCB5b3UgY2FuIGVpdGhlciB1bm1vdW50IHRoZSBjb21wb25lbnQgYXQgdGhlIGVuZCBvZiB5b3VyIHRlc3QgKGFuZCBlbnN1cmUgdGhhdCBhbnkgYXN5bmNocm9ub3VzIG9wZXJhdGlvbnMgZ2V0IGNhbmNlbGVkIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGApLCBvciB5b3UgY2FuIGNoYW5nZSB0aGUgdGVzdCBpdHNlbGYgdG8gYmUgYXN5bmNocm9ub3VzLicpIDogdm9pZCAwO1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuXG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB0aGUgdmFsdWUgb2Ygd2luZG93LmV2ZW50IHNvIHRoYXQgd2UgY2FuIHJlc2V0IGl0XG4gICAgICAvLyBkdXJpbmcgdGhlIGNhbGxiYWNrIHRvIGxldCB1c2VyIGNvZGUgYWNjZXNzIHdpbmRvdy5ldmVudCBpbiB0aGVcbiAgICAgIC8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdC5cbiAgICAgIHZhciB3aW5kb3dFdmVudCA9IHdpbmRvdy5ldmVudDtcblxuICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGRlc2NyaXB0b3Igb2Ygd2luZG93LmV2ZW50IHRvIHJlc3RvcmUgaXQgYWZ0ZXIgZXZlbnRcbiAgICAgIC8vIGRpc3BhdGNoaW5nOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjg4XG4gICAgICB2YXIgd2luZG93RXZlbnREZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3csICdldmVudCcpO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gV2UgY2hlY2sgZm9yIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnZXZlbnQnKSB0byBwcmV2ZW50IHRoZVxuICAgICAgICAvLyB3aW5kb3cuZXZlbnQgYXNzaWdubWVudCBpbiBib3RoIElFIDw9IDEwIGFzIHRoZXkgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gXCJNZW1iZXIgbm90IGZvdW5kXCIgaW4gc3RyaWN0IG1vZGUsIGFuZCBpbiBGaXJlZm94IHdoaWNoIGRvZXMgbm90XG4gICAgICAgIC8vIHN1cHBvcnQgd2luZG93LmV2ZW50LlxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdy5ldmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lmhhc093blByb3BlcnR5KCdldmVudCcpKSB7XG4gICAgICAgICAgd2luZG93LmV2ZW50ID0gd2luZG93RXZlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuICAgICAgdmFyIGRpZFNldEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgaXNDcm9zc09yaWdpbkVycm9yID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZVdpbmRvd0Vycm9yKGV2ZW50KSB7XG4gICAgICAgIGVycm9yID0gZXZlbnQuZXJyb3I7XG4gICAgICAgIGRpZFNldEVycm9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGVycm9yID09PSBudWxsICYmIGV2ZW50LmNvbG5vID09PSAwICYmIGV2ZW50LmxpbmVubyA9PT0gMCkge1xuICAgICAgICAgIGlzQ3Jvc3NPcmlnaW5FcnJvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAvLyBTb21lIG90aGVyIGVycm9yIGhhbmRsZXIgaGFzIHByZXZlbnRlZCBkZWZhdWx0LlxuICAgICAgICAgIC8vIEJyb3dzZXJzIHNpbGVuY2UgdGhlIGVycm9yIHJlcG9ydCBpZiB0aGlzIGhhcHBlbnMuXG4gICAgICAgICAgLy8gV2UnbGwgcmVtZW1iZXIgdGhpcyB0byBsYXRlciBkZWNpZGUgd2hldGhlciB0byBsb2cgaXQgb3Igbm90LlxuICAgICAgICAgIGlmIChlcnJvciAhPSBudWxsICYmIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGVycm9yLl9zdXBwcmVzc0xvZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSBjYXRjaCAoaW5uZXIpIHtcbiAgICAgICAgICAgICAgLy8gSWdub3JlLlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBmYWtlIGV2ZW50IHR5cGUuXG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgKG5hbWUgPyBuYW1lIDogJ2ludm9rZWd1YXJkZWRjYWxsYmFjaycpO1xuXG4gICAgICAvLyBBdHRhY2ggb3VyIGV2ZW50IGhhbmRsZXJzXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuXG4gICAgICAvLyBTeW5jaHJvbm91c2x5IGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50LiBJZiB0aGUgdXNlci1wcm92aWRlZCBmdW5jdGlvblxuICAgICAgLy8gZXJyb3JzLCBpdCB3aWxsIHRyaWdnZXIgb3VyIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuXG4gICAgICBpZiAod2luZG93RXZlbnREZXNjcmlwdG9yKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdldmVudCcsIHdpbmRvd0V2ZW50RGVzY3JpcHRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICBpZiAoIWRpZFNldEVycm9yKSB7XG4gICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGVycm9yZWQsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgbmV2ZXIgZmlyZWQuXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMsIGJ1dCBSZWFjdCAnICsgXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiICsgJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnICsgJ2V4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgRGV2VG9vbHMsIHdoaWNoIHJlcXVpcmVzIHNvbWUgJyArIFwiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiICsgJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJyArICdvciBzd2l0Y2hpbmcgdG8gYSBtb2Rlcm4gYnJvd3Nlci4gSWYgeW91IHN1c3BlY3QgdGhhdCB0aGlzIGlzICcgKyAnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDcm9zc09yaWdpbkVycm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWNyb3Nzb3JpZ2luLWVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25FcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVXaW5kb3dFcnJvcik7XG4gICAgfTtcblxuICAgIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwgPSBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXY7XG4gIH1cbn1cblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGwkMSA9IGludm9rZUd1YXJkZWRDYWxsYmFja0ltcGw7XG5cbi8vIFVzZWQgYnkgRmliZXIgdG8gc2ltdWxhdGUgYSB0cnktY2F0Y2guXG52YXIgaGFzRXJyb3IgPSBmYWxzZTtcbnZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbi8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG52YXIgaGFzUmV0aHJvd0Vycm9yID0gZmFsc2U7XG52YXIgcmV0aHJvd0Vycm9yID0gbnVsbDtcblxudmFyIHJlcG9ydGVyID0ge1xuICBvbkVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAqIFJldHVybnMgYW4gZXJyb3IgaWYgaXQgdGhyb3dzLCBvdGhlcndpc2UgbnVsbC5cbiAqXG4gKiBJbiBwcm9kdWN0aW9uLCB0aGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgdHJ5LWNhdGNoLiBUaGUgcmVhc29uIHdlIGRvbid0XG4gKiB1c2UgYSB0cnktY2F0Y2ggZGlyZWN0bHkgaXMgc28gdGhhdCB3ZSBjYW4gc3dhcCBvdXQgYSBkaWZmZXJlbnRcbiAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tJbXBsJDEuYXBwbHkocmVwb3J0ZXIsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gKiBUT0RPOiBTZWUgaWYgY2F1Z2h0RXJyb3IgYW5kIHJldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcihuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBpZiAoaGFzRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgaWYgKCFoYXNSZXRocm93RXJyb3IpIHtcbiAgICAgIGhhc1JldGhyb3dFcnJvciA9IHRydWU7XG4gICAgICByZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAqIHdlIHdpbGwgcmV0aHJvdyB0byBiZSBoYW5kbGVkIGJ5IHRoZSB0b3AgbGV2ZWwgZXJyb3IgaGFuZGxlci5cbiAqL1xuZnVuY3Rpb24gcmV0aHJvd0NhdWdodEVycm9yKCkge1xuICBpZiAoaGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gcmV0aHJvd0Vycm9yO1xuICAgIGhhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHJldGhyb3dFcnJvciA9IG51bGw7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzQ2F1Z2h0RXJyb3IoKSB7XG4gIHJldHVybiBoYXNFcnJvcjtcbn1cblxuZnVuY3Rpb24gY2xlYXJDYXVnaHRFcnJvcigpIHtcbiAgaWYgKGhhc0Vycm9yKSB7XG4gICAgdmFyIGVycm9yID0gY2F1Z2h0RXJyb3I7XG4gICAgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBjYXVnaHRFcnJvciA9IG51bGw7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9IGVsc2Uge1xuICAgIGludmFyaWFudChmYWxzZSwgJ2NsZWFyQ2F1Z2h0RXJyb3Igd2FzIGNhbGxlZCBidXQgbm8gZXJyb3Igd2FzIGNhcHR1cmVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgZXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghZXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYGV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IGV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW5zIHRoYXQgZG8gbm90IGV4aXN0IGluIHRoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgaWYgKHBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIXBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnQgcGx1Z2lucyBtdXN0IGltcGxlbWVudCBhbiBgZXh0cmFjdEV2ZW50c2AgbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBwbHVnaW5zW3BsdWdpbkluZGV4XSA9IHBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogRmFpbGVkIHRvIHB1Ymxpc2ggZXZlbnQgYCVzYCBmb3IgcGx1Z2luIGAlc2AuJywgZXZlbnROYW1lLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgZGlzcGF0Y2hlZCBieSB0aGUgc3VwcGxpZWQgcGx1Z2luLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBEaXNwYXRjaCBjb25maWd1cmF0aW9uIGZvciB0aGUgZXZlbnQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IHdhcyBzdWNjZXNzZnVsbHkgcHVibGlzaGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaEV2ZW50Rm9yUGx1Z2luKGRpc3BhdGNoQ29uZmlnLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIWV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIGV2ZW50IG5hbWUsIGAlc2AuJywgZXZlbnROYW1lKSA6IHZvaWQgMDtcbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzW2V2ZW50TmFtZV0gPSBkaXNwYXRjaENvbmZpZztcblxuICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMgPSBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztcbiAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIgcGhhc2VOYW1lIGluIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKSB7XG4gICAgICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkocGhhc2VOYW1lKSkge1xuICAgICAgICB2YXIgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZSA9IHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3BoYXNlTmFtZV07XG4gICAgICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGEgcmVnaXN0cmF0aW9uIG5hbWUgdGhhdCBpcyB1c2VkIHRvIGlkZW50aWZ5IGRpc3BhdGNoZWQgZXZlbnRzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIFJlZ2lzdHJhdGlvbiBuYW1lIHRvIGFkZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFyZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSByZWdpc3RyYXRpb24gbmFtZSwgYCVzYC4nLCByZWdpc3RyYXRpb25OYW1lKSA6IHZvaWQgMDtcbiAgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcblxuICB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gcmVnaXN0cmF0aW9uTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdID0gcmVnaXN0cmF0aW9uTmFtZTtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSAnb25Eb3VibGVDbGljaycpIHtcbiAgICAgIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMub25kYmxjbGljayA9IHJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVnaXN0ZXJzIHBsdWdpbnMgc28gdGhhdCB0aGV5IGNhbiBleHRyYWN0IGFuZCBkaXNwYXRjaCBldmVudHMuXG4gKlxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWJ9XG4gKi9cblxuLyoqXG4gKiBPcmRlcmVkIGxpc3Qgb2YgaW5qZWN0ZWQgcGx1Z2lucy5cbiAqL1xudmFyIHBsdWdpbnMgPSBbXTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gZXZlbnQgbmFtZSB0byBkaXNwYXRjaCBjb25maWdcbiAqL1xudmFyIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBwbHVnaW4gbW9kdWxlXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lTW9kdWxlcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSByZWdpc3RyYXRpb24gbmFtZSB0byBldmVudCBuYW1lXG4gKi9cbnZhciByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGxvd2VyY2FzZSByZWdpc3RyYXRpb24gbmFtZXMgdG8gdGhlIHByb3Blcmx5IGNhc2VkIHZlcnNpb24sXG4gKiB1c2VkIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBldmVudCBoYW5kbGVycy4gQXZhaWxhYmxlXG4gKiBvbmx5IGluIHRydWUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyA9IHt9O1xuLy8gVHJ1c3QgdGhlIGRldmVsb3BlciB0byBvbmx5IHVzZSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzIGluIHRydWVcblxuLyoqXG4gKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gKiB0byBiZSBkZWNvdXBsZWQgZnJvbSBpbmplY3Rpb24gb2YgdGhlIGFjdHVhbCBwbHVnaW5zIHNvIHRoYXQgb3JkZXJpbmcgaXNcbiAqIGFsd2F5cyBkZXRlcm1pbmlzdGljIHJlZ2FyZGxlc3Mgb2YgcGFja2FnaW5nLCBvbi10aGUtZmx5IGluamVjdGlvbiwgZXRjLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgISFldmVudFBsdWdpbk9yZGVyID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuIG9uY2UuIFlvdSBhcmUgbGlrZWx5IHRyeWluZyB0byBsb2FkIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgLy8gQ2xvbmUgdGhlIG9yZGVyaW5nIHNvIGl0IGNhbm5vdCBiZSBkeW5hbWljYWxseSBtdXRhdGVkLlxuICBldmVudFBsdWdpbk9yZGVyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKTtcbiAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbn1cblxuLyoqXG4gKiBJbmplY3RzIHBsdWdpbnMgdG8gYmUgdXNlZCBieSBgRXZlbnRQbHVnaW5IdWJgLiBUaGUgcGx1Z2luIG5hbWVzIG11c3QgYmVcbiAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gKlxuICogUGx1Z2lucyBjYW4gYmUgaW5qZWN0ZWQgYXMgcGFydCBvZiBwYWdlIGluaXRpYWxpemF0aW9uIG9yIG9uLXRoZS1mbHkuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZShpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gIHZhciBpc09yZGVyaW5nRGlydHkgPSBmYWxzZTtcbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgaWYgKCFuYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSB8fCBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSAhPT0gcGx1Z2luTW9kdWxlKSB7XG4gICAgICAhIW5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCB0d28gZGlmZmVyZW50IGV2ZW50IHBsdWdpbnMgdXNpbmcgdGhlIHNhbWUgbmFtZSwgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICAgIG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmdXaXRob3V0U3RhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB3YXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmdXaXRob3V0U3RhY2soY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmIChhcmdzLmxlbmd0aCA+IDgpIHtcbiAgICAgIC8vIENoZWNrIGJlZm9yZSB0aGUgY29uZGl0aW9uIHRvIGNhdGNoIHZpb2xhdGlvbnMgZWFybHkuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dhcm5pbmdXaXRob3V0U3RhY2soKSBjdXJyZW50bHkgc3VwcG9ydHMgYXQgbW9zdCA4IGFyZ3VtZW50cy4nKTtcbiAgICB9XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgICAgfSk7XG4gICAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTtcblxuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUuZXJyb3IsIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxudmFyIHdhcm5pbmdXaXRob3V0U3RhY2skMSA9IHdhcm5pbmdXaXRob3V0U3RhY2s7XG5cbnZhciBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlID0gbnVsbDtcbnZhciBnZXRJbnN0YW5jZUZyb21Ob2RlID0gbnVsbDtcbnZhciBnZXROb2RlRnJvbUluc3RhbmNlID0gbnVsbDtcblxuZnVuY3Rpb24gc2V0Q29tcG9uZW50VHJlZShnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlSW1wbCwgZ2V0SW5zdGFuY2VGcm9tTm9kZUltcGwsIGdldE5vZGVGcm9tSW5zdGFuY2VJbXBsKSB7XG4gIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlSW1wbDtcbiAgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9IGdldEluc3RhbmNlRnJvbU5vZGVJbXBsO1xuICBnZXROb2RlRnJvbUluc3RhbmNlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZUltcGw7XG4gIHtcbiAgICAhKGdldE5vZGVGcm9tSW5zdGFuY2UgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSkgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdFdmVudFBsdWdpblV0aWxzLnNldENvbXBvbmVudFRyZWUoLi4uKTogSW5qZWN0ZWQgJyArICdtb2R1bGUgaXMgbWlzc2luZyBnZXROb2RlRnJvbUluc3RhbmNlIG9yIGdldEluc3RhbmNlRnJvbU5vZGUuJykgOiB2b2lkIDA7XG4gIH1cbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gdm9pZCAwO1xue1xuICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG5cbiAgICB2YXIgbGlzdGVuZXJzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKTtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgdmFyIGluc3RhbmNlc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaEluc3RhbmNlcyk7XG4gICAgdmFyIGluc3RhbmNlc0xlbiA9IGluc3RhbmNlc0lzQXJyID8gZGlzcGF0Y2hJbnN0YW5jZXMubGVuZ3RoIDogZGlzcGF0Y2hJbnN0YW5jZXMgPyAxIDogMDtcblxuICAgICEoaW5zdGFuY2VzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIGluc3RhbmNlc0xlbiA9PT0gbGlzdGVuZXJzTGVuKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKSA6IHZvaWQgMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBpbnN0IEludGVybmFsIGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGxpc3RlbmVyLCBpbnN0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZSB8fCAndW5rbm93bi1ldmVudCc7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBnZXROb2RlRnJvbUluc3RhbmNlKGluc3QpO1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IodHlwZSwgbGlzdGVuZXIsIHVuZGVmaW5lZCwgZXZlbnQpO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuICB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJbnN0YW5jZXMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICB9XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG59XG5cbi8qKlxuICogQHNlZSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbFxuICovXG5cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2FjY3VtdWxhdGVJbnRvKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicpIDogdm9pZCAwO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayBpbnZva2VkIHdpdGggZWFjaCBlbGVtZW50IG9yIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7P30gW3Njb3BlXSBTY29wZSB1c2VkIGFzIGB0aGlzYCBpbiBhIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQWNjdW11bGF0ZWQoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50KTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIHZhciBsaXN0ZW5lciA9IHZvaWQgMDtcblxuICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuICBpZiAoIXN0YXRlTm9kZSkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcbiAgaWYgKCFwcm9wcykge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGlzdGVuZXIgPSBwcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgISghbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG4vKipcbiAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudHMgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb3QgZXZlcnkgcGx1Z2luIGluIHRoZSBvcmRlcmluZyBtYXkgYmUgbG9hZGVkIGF0IHJ1bnRpbWUuXG4gICAgdmFyIHBvc3NpYmxlUGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgIHZhciBleHRyYWN0ZWRFdmVudHMgPSBwb3NzaWJsZVBsdWdpbi5leHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIGlmIChleHRyYWN0ZWRFdmVudHMpIHtcbiAgICAgICAgZXZlbnRzID0gYWNjdW11bGF0ZUludG8oZXZlbnRzLCBleHRyYWN0ZWRFdmVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZXZlbnRzO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudHNJbkJhdGNoKGV2ZW50cykge1xuICBpZiAoZXZlbnRzICE9PSBudWxsKSB7XG4gICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gIH1cblxuICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cbiAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbiAgaWYgKCFwcm9jZXNzaW5nRXZlbnRRdWV1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIHJldGhyb3dDYXVnaHRFcnJvcigpO1xufVxuXG5mdW5jdGlvbiBydW5FeHRyYWN0ZWRFdmVudHNJbkJhdGNoKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudHMgPSBleHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgcnVuRXZlbnRzSW5CYXRjaChldmVudHMpO1xufVxuXG52YXIgRnVuY3Rpb25Db21wb25lbnQgPSAwO1xudmFyIENsYXNzQ29tcG9uZW50ID0gMTtcbnZhciBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gMjsgLy8gQmVmb3JlIHdlIGtub3cgd2hldGhlciBpdCBpcyBmdW5jdGlvbiBvciBjbGFzc1xudmFyIEhvc3RSb290ID0gMzsgLy8gUm9vdCBvZiBhIGhvc3QgdHJlZS4gQ291bGQgYmUgbmVzdGVkIGluc2lkZSBhbm90aGVyIG5vZGUuXG52YXIgSG9zdFBvcnRhbCA9IDQ7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG52YXIgSG9zdENvbXBvbmVudCA9IDU7XG52YXIgSG9zdFRleHQgPSA2O1xudmFyIEZyYWdtZW50ID0gNztcbnZhciBNb2RlID0gODtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSA5O1xudmFyIENvbnRleHRQcm92aWRlciA9IDEwO1xudmFyIEZvcndhcmRSZWYgPSAxMTtcbnZhciBQcm9maWxlciA9IDEyO1xudmFyIFN1c3BlbnNlQ29tcG9uZW50ID0gMTM7XG52YXIgTWVtb0NvbXBvbmVudCA9IDE0O1xudmFyIFNpbXBsZU1lbW9Db21wb25lbnQgPSAxNTtcbnZhciBMYXp5Q29tcG9uZW50ID0gMTY7XG52YXIgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50ID0gMTc7XG52YXIgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50ID0gMTg7XG5cbnZhciByYW5kb21LZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbnZhciBpbnRlcm5hbEluc3RhbmNlS2V5ID0gJ19fcmVhY3RJbnRlcm5hbEluc3RhbmNlJCcgKyByYW5kb21LZXk7XG52YXIgaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5ID0gJ19fcmVhY3RFdmVudEhhbmRsZXJzJCcgKyByYW5kb21LZXk7XG5cbmZ1bmN0aW9uIHByZWNhY2hlRmliZXJOb2RlKGhvc3RJbnN0LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgd2hpbGUgKCFub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyLCB0aGlzIHdpbGwgYWx3YXlzIGJlIHRoZSBkZWVwZXN0IHJvb3QuXG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEobm9kZSkge1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGluc3QpIHtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyIHRoaXMsIGlzIGp1c3QgdGhlIHN0YXRlIG5vZGUgcmlnaHQgbm93LiBXZSBhc3N1bWUgaXQgd2lsbCBiZVxuICAgIC8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxuICAgIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGaWJlclByb3BzKG5vZGUsIHByb3BzKSB7XG4gIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSA9IHByb3BzO1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnQoaW5zdCkge1xuICBkbyB7XG4gICAgaW5zdCA9IGluc3QucmV0dXJuO1xuICAgIC8vIFRPRE86IElmIHRoaXMgaXMgYSBIb3N0Um9vdCB3ZSBtaWdodCB3YW50IHRvIGJhaWwgb3V0LlxuICAgIC8vIFRoYXQgaXMgZGVwZW5kaW5nIG9uIGlmIHdlIHdhbnQgbmVzdGVkIHN1YnRyZWVzIChsYXllcnMpIHRvIGJ1YmJsZVxuICAgIC8vIGV2ZW50cyB0byB0aGVpciBwYXJlbnQuIFdlIGNvdWxkIGFsc28gZ28gdGhyb3VnaCBwYXJlbnROb2RlIG9uIHRoZVxuICAgIC8vIGhvc3Qgbm9kZSBidXQgdGhhdCB3b3VsZG4ndCB3b3JrIGZvciBSZWFjdCBOYXRpdmUgYW5kIGRvZXNuJ3QgbGV0IHVzXG4gICAgLy8gZG8gdGhlIHBvcnRhbCBmZWF0dXJlLlxuICB9IHdoaWxlIChpbnN0ICYmIGluc3QudGFnICE9PSBIb3N0Q29tcG9uZW50KTtcbiAgaWYgKGluc3QpIHtcbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3Igb2YgQSBhbmQgQiwgb3IgbnVsbCBpZiB0aGV5IGFyZSBpblxuICogZGlmZmVyZW50IHRyZWVzLlxuICovXG5mdW5jdGlvbiBnZXRMb3dlc3RDb21tb25BbmNlc3RvcihpbnN0QSwgaW5zdEIpIHtcbiAgdmFyIGRlcHRoQSA9IDA7XG4gIGZvciAodmFyIHRlbXBBID0gaW5zdEE7IHRlbXBBOyB0ZW1wQSA9IGdldFBhcmVudCh0ZW1wQSkpIHtcbiAgICBkZXB0aEErKztcbiAgfVxuICB2YXIgZGVwdGhCID0gMDtcbiAgZm9yICh2YXIgdGVtcEIgPSBpbnN0QjsgdGVtcEI7IHRlbXBCID0gZ2V0UGFyZW50KHRlbXBCKSkge1xuICAgIGRlcHRoQisrO1xuICB9XG5cbiAgLy8gSWYgQSBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhBIC0gZGVwdGhCID4gMCkge1xuICAgIGluc3RBID0gZ2V0UGFyZW50KGluc3RBKTtcbiAgICBkZXB0aEEtLTtcbiAgfVxuXG4gIC8vIElmIEIgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQiAtIGRlcHRoQSA+IDApIHtcbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gICAgZGVwdGhCLS07XG4gIH1cblxuICAvLyBXYWxrIGluIGxvY2tzdGVwIHVudGlsIHdlIGZpbmQgYSBtYXRjaC5cbiAgdmFyIGRlcHRoID0gZGVwdGhBO1xuICB3aGlsZSAoZGVwdGgtLSkge1xuICAgIGlmIChpbnN0QSA9PT0gaW5zdEIgfHwgaW5zdEEgPT09IGluc3RCLmFsdGVybmF0ZSkge1xuICAgICAgcmV0dXJuIGluc3RBO1xuICAgIH1cbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiBpZiBBIGlzIGFuIGFuY2VzdG9yIG9mIEIuXG4gKi9cblxuXG4vKipcbiAqIFJldHVybiB0aGUgcGFyZW50IGluc3RhbmNlIG9mIHRoZSBwYXNzZWQtaW4gaW5zdGFuY2UuXG4gKi9cblxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBnZXRQYXJlbnQoaW5zdCk7XG4gIH1cbiAgdmFyIGkgPSB2b2lkIDA7XG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhbaV0sICdjYXB0dXJlZCcsIGFyZyk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoW2ldLCAnYnViYmxlZCcsIGFyZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAqXG4gKiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlIG5vdGhpbmdcbiAqIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuICB2YXIgcGF0aEZyb20gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIWZyb20pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoZnJvbSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZyb20uYWx0ZXJuYXRlO1xuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoRnJvbS5wdXNoKGZyb20pO1xuICAgIGZyb20gPSBnZXRQYXJlbnQoZnJvbSk7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghdG8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodG8gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBfYWx0ZXJuYXRlID0gdG8uYWx0ZXJuYXRlO1xuICAgIGlmIChfYWx0ZXJuYXRlICE9PSBudWxsICYmIF9hbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IGdldFBhcmVudCh0byk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoRnJvbS5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhGcm9tW2ldLCAnYnViYmxlZCcsIGFyZ0Zyb20pO1xuICB9XG4gIGZvciAodmFyIF9pID0gcGF0aFRvLmxlbmd0aDsgX2ktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFRvW19pXSwgJ2NhcHR1cmVkJywgYXJnVG8pO1xuICB9XG59XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVuIGFcbiAqIHNpbmdsZSBvbmUuXG4gKi9cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoaW5zdCwgcGhhc2UsIGV2ZW50KSB7XG4gIHtcbiAgICAhaW5zdCA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpIDogdm9pZCAwO1xuICB9XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChpbnN0ICYmIGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5fdGFyZ2V0SW5zdCwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5cblxuZnVuY3Rpb24gYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pIHtcbiAgdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8vIERvIG5vdCB1c2VzIHRoZSBiZWxvdyB0d28gbWV0aG9kcyBkaXJlY3RseSFcbi8vIEluc3RlYWQgdXNlIGNvbnN0YW50cyBleHBvcnRlZCBmcm9tIERPTVRvcExldmVsRXZlbnRUeXBlcyBpbiBSZWFjdERPTS5cbi8vIChJdCBpcyB0aGUgb25seSBtb2R1bGUgdGhhdCBpcyBhbGxvd2VkIHRvIGFjY2VzcyB0aGVzZSBtZXRob2RzLilcblxuZnVuY3Rpb24gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlO1xufVxuXG5mdW5jdGlvbiB1bnNhZmVDYXN0RE9NVG9wTGV2ZWxUeXBlVG9TdHJpbmcodG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGU7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChjYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbi8qKlxuICogVG8gaWRlbnRpZnkgdG9wIGxldmVsIGV2ZW50cyBpbiBSZWFjdERPTSwgd2UgdXNlIGNvbnN0YW50cyBkZWZpbmVkIGJ5IHRoaXNcbiAqIG1vZHVsZS4gVGhpcyBpcyB0aGUgb25seSBtb2R1bGUgdGhhdCB1c2VzIHRoZSB1bnNhZmUqIG1ldGhvZHMgdG8gZXhwcmVzc1xuICogdGhhdCB0aGUgY29uc3RhbnRzIGFjdHVhbGx5IGNvcnJlc3BvbmQgdG8gdGhlIGJyb3dzZXIgZXZlbnQgbmFtZXMuIFRoaXMgbGV0c1xuICogdXMgc2F2ZSBzb21lIGJ1bmRsZSBzaXplIGJ5IGF2b2lkaW5nIGEgdG9wIGxldmVsIHR5cGUgLT4gZXZlbnQgbmFtZSBtYXAuXG4gKiBUaGUgcmVzdCBvZiBSZWFjdERPTSBjb2RlIHNob3VsZCBpbXBvcnQgdG9wIGxldmVsIHR5cGVzIGZyb20gdGhpcyBmaWxlLlxuICovXG52YXIgVE9QX0FCT1JUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdhYm9ydCcpO1xudmFyIFRPUF9BTklNQVRJT05fRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKSk7XG52YXIgVE9QX0FOSU1BVElPTl9JVEVSQVRJT04gPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpKTtcbnZhciBUT1BfQU5JTUFUSU9OX1NUQVJUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpKTtcbnZhciBUT1BfQkxVUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnYmx1cicpO1xudmFyIFRPUF9DQU5fUExBWSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY2FucGxheScpO1xudmFyIFRPUF9DQU5fUExBWV9USFJPVUdIID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjYW5wbGF5dGhyb3VnaCcpO1xudmFyIFRPUF9DQU5DRUwgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NhbmNlbCcpO1xudmFyIFRPUF9DSEFOR0UgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NoYW5nZScpO1xudmFyIFRPUF9DTElDSyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY2xpY2snKTtcbnZhciBUT1BfQ0xPU0UgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2Nsb3NlJyk7XG52YXIgVE9QX0NPTVBPU0lUSU9OX0VORCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnY29tcG9zaXRpb25lbmQnKTtcbnZhciBUT1BfQ09NUE9TSVRJT05fU1RBUlQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NvbXBvc2l0aW9uc3RhcnQnKTtcbnZhciBUT1BfQ09NUE9TSVRJT05fVVBEQVRFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjb21wb3NpdGlvbnVwZGF0ZScpO1xudmFyIFRPUF9DT05URVhUX01FTlUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NvbnRleHRtZW51Jyk7XG52YXIgVE9QX0NPUFkgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2NvcHknKTtcbnZhciBUT1BfQ1VUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdjdXQnKTtcbnZhciBUT1BfRE9VQkxFX0NMSUNLID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkYmxjbGljaycpO1xudmFyIFRPUF9BVVhfQ0xJQ0sgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2F1eGNsaWNrJyk7XG52YXIgVE9QX0RSQUcgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWcnKTtcbnZhciBUT1BfRFJBR19FTkQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2RyYWdlbmQnKTtcbnZhciBUT1BfRFJBR19FTlRFUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ2VudGVyJyk7XG52YXIgVE9QX0RSQUdfRVhJVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ2V4aXQnKTtcbnZhciBUT1BfRFJBR19MRUFWRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ2xlYXZlJyk7XG52YXIgVE9QX0RSQUdfT1ZFUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ292ZXInKTtcbnZhciBUT1BfRFJBR19TVEFSVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZHJhZ3N0YXJ0Jyk7XG52YXIgVE9QX0RST1AgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2Ryb3AnKTtcbnZhciBUT1BfRFVSQVRJT05fQ0hBTkdFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdkdXJhdGlvbmNoYW5nZScpO1xudmFyIFRPUF9FTVBUSUVEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdlbXB0aWVkJyk7XG52YXIgVE9QX0VOQ1JZUFRFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZW5jcnlwdGVkJyk7XG52YXIgVE9QX0VOREVEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdlbmRlZCcpO1xudmFyIFRPUF9FUlJPUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnZXJyb3InKTtcbnZhciBUT1BfRk9DVVMgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2ZvY3VzJyk7XG52YXIgVE9QX0dPVF9QT0lOVEVSX0NBUFRVUkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2dvdHBvaW50ZXJjYXB0dXJlJyk7XG52YXIgVE9QX0lOUFVUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdpbnB1dCcpO1xudmFyIFRPUF9JTlZBTElEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdpbnZhbGlkJyk7XG52YXIgVE9QX0tFWV9ET1dOID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdrZXlkb3duJyk7XG52YXIgVE9QX0tFWV9QUkVTUyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgna2V5cHJlc3MnKTtcbnZhciBUT1BfS0VZX1VQID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdrZXl1cCcpO1xudmFyIFRPUF9MT0FEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdsb2FkJyk7XG52YXIgVE9QX0xPQURfU1RBUlQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2xvYWRzdGFydCcpO1xudmFyIFRPUF9MT0FERURfREFUQSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbG9hZGVkZGF0YScpO1xudmFyIFRPUF9MT0FERURfTUVUQURBVEEgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ2xvYWRlZG1ldGFkYXRhJyk7XG52YXIgVE9QX0xPU1RfUE9JTlRFUl9DQVBUVVJFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdsb3N0cG9pbnRlcmNhcHR1cmUnKTtcbnZhciBUT1BfTU9VU0VfRE9XTiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbW91c2Vkb3duJyk7XG52YXIgVE9QX01PVVNFX01PVkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlbW92ZScpO1xudmFyIFRPUF9NT1VTRV9PVVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlb3V0Jyk7XG52YXIgVE9QX01PVVNFX09WRVIgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ21vdXNlb3ZlcicpO1xudmFyIFRPUF9NT1VTRV9VUCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnbW91c2V1cCcpO1xudmFyIFRPUF9QQVNURSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncGFzdGUnKTtcbnZhciBUT1BfUEFVU0UgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BhdXNlJyk7XG52YXIgVE9QX1BMQVkgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BsYXknKTtcbnZhciBUT1BfUExBWUlORyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncGxheWluZycpO1xudmFyIFRPUF9QT0lOVEVSX0NBTkNFTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncG9pbnRlcmNhbmNlbCcpO1xudmFyIFRPUF9QT0lOVEVSX0RPV04gPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJkb3duJyk7XG5cblxudmFyIFRPUF9QT0lOVEVSX01PVkUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3BvaW50ZXJtb3ZlJyk7XG52YXIgVE9QX1BPSU5URVJfT1VUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwb2ludGVyb3V0Jyk7XG52YXIgVE9QX1BPSU5URVJfT1ZFUiA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncG9pbnRlcm92ZXInKTtcbnZhciBUT1BfUE9JTlRFUl9VUCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncG9pbnRlcnVwJyk7XG52YXIgVE9QX1BST0dSRVNTID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdwcm9ncmVzcycpO1xudmFyIFRPUF9SQVRFX0NIQU5HRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncmF0ZWNoYW5nZScpO1xudmFyIFRPUF9SRVNFVCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgncmVzZXQnKTtcbnZhciBUT1BfU0NST0xMID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzY3JvbGwnKTtcbnZhciBUT1BfU0VFS0VEID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzZWVrZWQnKTtcbnZhciBUT1BfU0VFS0lORyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc2Vla2luZycpO1xudmFyIFRPUF9TRUxFQ1RJT05fQ0hBTkdFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzZWxlY3Rpb25jaGFuZ2UnKTtcbnZhciBUT1BfU1RBTExFRCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnc3RhbGxlZCcpO1xudmFyIFRPUF9TVUJNSVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3N1Ym1pdCcpO1xudmFyIFRPUF9TVVNQRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCdzdXNwZW5kJyk7XG52YXIgVE9QX1RFWFRfSU5QVVQgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RleHRJbnB1dCcpO1xudmFyIFRPUF9USU1FX1VQREFURSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndGltZXVwZGF0ZScpO1xudmFyIFRPUF9UT0dHTEUgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RvZ2dsZScpO1xudmFyIFRPUF9UT1VDSF9DQU5DRUwgPSB1bnNhZmVDYXN0U3RyaW5nVG9ET01Ub3BMZXZlbFR5cGUoJ3RvdWNoY2FuY2VsJyk7XG52YXIgVE9QX1RPVUNIX0VORCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndG91Y2hlbmQnKTtcbnZhciBUT1BfVE9VQ0hfTU9WRSA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgndG91Y2htb3ZlJyk7XG52YXIgVE9QX1RPVUNIX1NUQVJUID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd0b3VjaHN0YXJ0Jyk7XG52YXIgVE9QX1RSQU5TSVRJT05fRU5EID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykpO1xudmFyIFRPUF9WT0xVTUVfQ0hBTkdFID0gdW5zYWZlQ2FzdFN0cmluZ1RvRE9NVG9wTGV2ZWxUeXBlKCd2b2x1bWVjaGFuZ2UnKTtcbnZhciBUT1BfV0FJVElORyA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnd2FpdGluZycpO1xudmFyIFRPUF9XSEVFTCA9IHVuc2FmZUNhc3RTdHJpbmdUb0RPTVRvcExldmVsVHlwZSgnd2hlZWwnKTtcblxuLy8gTGlzdCBvZiBldmVudHMgdGhhdCBuZWVkIHRvIGJlIGluZGl2aWR1YWxseSBhdHRhY2hlZCB0byBtZWRpYSBlbGVtZW50cy5cbi8vIE5vdGUgdGhhdCBldmVudHMgaW4gdGhpcyBsaXN0IHdpbGwgKm5vdCogYmUgbGlzdGVuZWQgdG8gYXQgdGhlIHRvcCBsZXZlbFxuLy8gdW5sZXNzIHRoZXkncmUgZXhwbGljaXRseSB3aGl0ZWxpc3RlZCBpbiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvYC5cbnZhciBtZWRpYUV2ZW50VHlwZXMgPSBbVE9QX0FCT1JULCBUT1BfQ0FOX1BMQVksIFRPUF9DQU5fUExBWV9USFJPVUdILCBUT1BfRFVSQVRJT05fQ0hBTkdFLCBUT1BfRU1QVElFRCwgVE9QX0VOQ1JZUFRFRCwgVE9QX0VOREVELCBUT1BfRVJST1IsIFRPUF9MT0FERURfREFUQSwgVE9QX0xPQURFRF9NRVRBREFUQSwgVE9QX0xPQURfU1RBUlQsIFRPUF9QQVVTRSwgVE9QX1BMQVksIFRPUF9QTEFZSU5HLCBUT1BfUFJPR1JFU1MsIFRPUF9SQVRFX0NIQU5HRSwgVE9QX1NFRUtFRCwgVE9QX1NFRUtJTkcsIFRPUF9TVEFMTEVELCBUT1BfU1VTUEVORCwgVE9QX1RJTUVfVVBEQVRFLCBUT1BfVk9MVU1FX0NIQU5HRSwgVE9QX1dBSVRJTkddO1xuXG5mdW5jdGlvbiBnZXRSYXdFdmVudE5hbWUodG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB1bnNhZmVDYXN0RE9NVG9wTGV2ZWxUeXBlVG9TdHJpbmcodG9wTGV2ZWxUeXBlKTtcbn1cblxuLyoqXG4gKiBUaGVzZSB2YXJpYWJsZXMgc3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG5cbnZhciByb290ID0gbnVsbDtcbnZhciBzdGFydFRleHQgPSBudWxsO1xudmFyIGZhbGxiYWNrVGV4dCA9IG51bGw7XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBzdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgcm9vdCA9IG51bGw7XG4gIHN0YXJ0VGV4dCA9IG51bGw7XG4gIGZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoKSB7XG4gIGlmIChmYWxsYmFja1RleHQpIHtcbiAgICByZXR1cm4gZmFsbGJhY2tUZXh0O1xuICB9XG5cbiAgdmFyIHN0YXJ0ID0gdm9pZCAwO1xuICB2YXIgc3RhcnRWYWx1ZSA9IHN0YXJ0VGV4dDtcbiAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gIHZhciBlbmQgPSB2b2lkIDA7XG4gIHZhciBlbmRWYWx1ZSA9IGdldFRleHQoKTtcbiAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBmYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgaWYgKCd2YWx1ZScgaW4gcm9vdCkge1xuICAgIHJldHVybiByb290LnZhbHVlO1xuICB9XG4gIHJldHVybiByb290LnRleHRDb250ZW50O1xufVxuXG4vKiBlc2xpbnQgdmFsaWQtdHlwZW9mOiAwICovXG5cbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG5mdW5jdGlvbiBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZSgpIHtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0SW5zdCBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IG5hdGl2ZUV2ZW50VGFyZ2V0IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHtcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICBkZWxldGUgdGhpcy5uYXRpdmVFdmVudDtcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gICAgZGVsZXRlIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkO1xuICAgIGRlbGV0ZSB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc1RydWU7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICBzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5jYW5jZWxCdWJibGUgIT09ICd1bmtub3duJykge1xuICAgICAgLy8gVGhlIENoYW5nZUV2ZW50UGx1Z2luIHJlZ2lzdGVycyBhIFwicHJvcGVydHljaGFuZ2VcIiBldmVudCBmb3JcbiAgICAgIC8vIElFLiBUaGlzIGV2ZW50IGRvZXMgbm90IHN1cHBvcnQgYnViYmxpbmcgb3IgY2FuY2VsbGluZywgYW5kXG4gICAgICAvLyBhbnkgcmVmZXJlbmNlcyB0byBjYW5jZWxCdWJibGUgdGhyb3cgXCJNZW1iZXIgbm90IGZvdW5kXCIuICBBXG4gICAgICAvLyB0eXBlb2YgY2hlY2sgb2YgXCJ1bmtub3duXCIgY2lyY3VtdmVudHMgdGhpcyBpc3N1ZSAoYW5kIGlzIGFsc29cbiAgICAgIC8vIElFIHNwZWNpZmljKS5cbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBmdW5jdGlvblRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlLFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciBgZGVzdHJ1Y3RvcmAgb24gZWFjaCBpbnN0YW5jZSBpdCByZWxlYXNlcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgICB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBwcm9wTmFtZSwgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgSW50ZXJmYWNlW3Byb3BOYW1lXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gbnVsbDtcbiAgICB0aGlzLl90YXJnZXRJbnN0ID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZTtcbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZnVuY3Rpb25UaGF0UmV0dXJuc0ZhbHNlO1xuICAgIHRoaXMuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgICB0aGlzLl9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG4gICAge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdpc0RlZmF1bHRQcmV2ZW50ZWQnLCBmdW5jdGlvblRoYXRSZXR1cm5zRmFsc2UpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKCdpc1Byb3BhZ2F0aW9uU3RvcHBlZCcsIGZ1bmN0aW9uVGhhdFJldHVybnNGYWxzZSkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZnVuY3Rpb24gKCkge30pKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZnVuY3Rpb24gKCkge30pKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqL1xuU3ludGhldGljRXZlbnQuZXh0ZW5kID0gZnVuY3Rpb24gKEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBmdW5jdGlvbiBDbGFzcygpIHtcbiAgICByZXR1cm4gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmV4dGVuZCA9IFN1cGVyLmV4dGVuZDtcbiAgYWRkRXZlbnRQb29saW5nVG8oQ2xhc3MpO1xuXG4gIHJldHVybiBDbGFzcztcbn07XG5cbmFkZEV2ZW50UG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50KTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSB7P29iamVjdH0gZ2V0VmFsXG4gKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgICF3YXJuaW5nQ29uZGl0aW9uID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBcIiArIFwieW91J3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gXCIgKyAnSWYgeW91IG11c3Qga2VlcCB0aGUgb3JpZ2luYWwgc3ludGhldGljIGV2ZW50IGFyb3VuZCwgdXNlIGV2ZW50LnBlcnNpc3QoKS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGFjdGlvbiwgcHJvcE5hbWUsIHJlc3VsdCkgOiB2b2lkIDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9vbGVkRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnBvcCgpO1xuICAgIEV2ZW50Q29uc3RydWN0b3IuY2FsbChpbnN0YW5jZSwgZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIG5ldyBFdmVudENvbnN0cnVjdG9yKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VQb29sZWRFdmVudChldmVudCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gICEoZXZlbnQgaW5zdGFuY2VvZiBFdmVudENvbnN0cnVjdG9yKSA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGV2ZW50IGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiB2b2lkIDA7XG4gIGV2ZW50LmRlc3RydWN0b3IoKTtcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCA8IEVWRU5UX1BPT0xfU0laRSkge1xuICAgIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnB1c2goZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50UG9vbGluZ1RvKEV2ZW50Q29uc3RydWN0b3IpIHtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wgPSBbXTtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQgPSBnZXRQb29sZWRFdmVudDtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5yZWxlYXNlID0gcmVsZWFzZVBvb2xlZEV2ZW50O1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xudmFyIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQgPSBTeW50aGV0aWNFdmVudC5leHRlbmQoe1xuICBkYXRhOiBudWxsXG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbnZhciBTeW50aGV0aWNJbnB1dEV2ZW50ID0gU3ludGhldGljRXZlbnQuZXh0ZW5kKHtcbiAgZGF0YTogbnVsbFxufSk7XG5cbnZhciBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl07IC8vIFRhYiwgUmV0dXJuLCBFc2MsIFNwYWNlXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcblxudmFyIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQgPSBjYW5Vc2VET00gJiYgJ0NvbXBvc2l0aW9uRXZlbnQnIGluIHdpbmRvdztcblxudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5pZiAoY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB7XG4gIGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbn1cblxuLy8gV2Via2l0IG9mZmVycyBhIHZlcnkgdXNlZnVsIGB0ZXh0SW5wdXRgIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgdG9cbi8vIGRpcmVjdGx5IHJlcHJlc2VudCBgYmVmb3JlSW5wdXRgLiBUaGUgSUUgYHRleHRpbnB1dGAgZXZlbnQgaXMgbm90IGFzXG4vLyB1c2VmdWwsIHNvIHdlIGRvbid0IHVzZSBpdC5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IGNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZTtcblxuLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cbnZhciB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA9IGNhblVzZURPTSAmJiAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHwgZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50TW9kZSA+IDggJiYgZG9jdW1lbnRNb2RlIDw9IDExKTtcblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkJlZm9yZUlucHV0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25CZWZvcmVJbnB1dENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtUT1BfQ09NUE9TSVRJT05fRU5ELCBUT1BfS0VZX1BSRVNTLCBUT1BfVEVYVF9JTlBVVCwgVE9QX1BBU1RFXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvbkVuZCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25FbmRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0JMVVIsIFRPUF9DT01QT1NJVElPTl9FTkQsIFRPUF9LRVlfRE9XTiwgVE9QX0tFWV9QUkVTUywgVE9QX0tFWV9VUCwgVE9QX01PVVNFX0RPV05dXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25TdGFydCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25TdGFydENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtUT1BfQkxVUiwgVE9QX0NPTVBPU0lUSU9OX1NUQVJULCBUT1BfS0VZX0RPV04sIFRPUF9LRVlfUFJFU1MsIFRPUF9LRVlfVVAsIFRPUF9NT1VTRV9ET1dOXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblVwZGF0ZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX0JMVVIsIFRPUF9DT01QT1NJVElPTl9VUERBVEUsIFRPUF9LRVlfRE9XTiwgVE9QX0tFWV9QUkVTUywgVE9QX0tFWV9VUCwgVE9QX01PVVNFX0RPV05dXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSBUT1BfQ09NUE9TSVRJT05fU1RBUlQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX0VORDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgVE9QX0NPTVBPU0lUSU9OX1VQREFURTpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IFRPUF9LRVlfRE9XTiAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgVE9QX0tFWV9VUDpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlIFRPUF9LRVlfRE9XTjpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSBUT1BfS0VZX1BSRVNTOlxuICAgIGNhc2UgVE9QX01PVVNFX0RPV046XG4gICAgY2FzZSBUT1BfQkxVUjpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBjb21wb3NpdGlvbiBldmVudCB3YXMgdHJpZ2dlcmVkIGJ5IEtvcmVhbiBJTUUuXG4gKiBPdXIgZmFsbGJhY2sgbW9kZSBkb2VzIG5vdCB3b3JrIHdlbGwgd2l0aCBJRSdzIEtvcmVhbiBJTUUsXG4gKiBzbyBqdXN0IHVzZSBuYXRpdmUgY29tcG9zaXRpb24gZXZlbnRzIHdoZW4gS29yZWFuIElNRSBpcyB1c2VkLlxuICogQWx0aG91Z2ggQ29tcG9zaXRpb25FdmVudC5sb2NhbGUgcHJvcGVydHkgaXMgZGVwcmVjYXRlZCxcbiAqIGl0IGlzIGF2YWlsYWJsZSBpbiBJRSwgd2hlcmUgb3VyIGZhbGxiYWNrIG1vZGUgaXMgZW5hYmxlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG5hdGl2ZUV2ZW50LmxvY2FsZSA9PT0gJ2tvJztcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIHN0YXR1cywgaWYgYW55LlxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlID0gdm9pZCAwO1xuICB2YXIgZmFsbGJhY2tEYXRhID0gdm9pZCAwO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgJiYgIWlzVXNpbmdLb3JlYW5JTUUobmF0aXZlRXZlbnQpKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghaXNDb21wb3NpbmcgJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGlzQ29tcG9zaW5nID0gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChpc0NvbXBvc2luZykge1xuICAgICAgICBmYWxsYmFja0RhdGEgPSBnZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RvcExldmVsVHlwZX0gdG9wTGV2ZWxUeXBlIE51bWJlciBmcm9tIGBUb3BMZXZlbFR5cGVgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSBUT1BfQ09NUE9TSVRJT05fRU5EOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgVE9QX0tFWV9QUkVTUzpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSBUT1BfVEVYVF9JTlBVVDpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBpZ25vcmUgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHRvcExldmVsVHlwZSBOdW1iZXIgZnJvbSBgVG9wTGV2ZWxFdmVudFR5cGVzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfQ09NUE9TSVRJT05fRU5EIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlIFRPUF9QQVNURTpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgVE9QX0tFWV9QUkVTUzpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmICghaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIC8vIElFIGZpcmVzIHRoZSBga2V5cHJlc3NgIGV2ZW50IHdoZW4gYSB1c2VyIHR5cGVzIGFuIGVtb2ppIHZpYVxuICAgICAgICAvLyBUb3VjaCBrZXlib2FyZCBvZiBXaW5kb3dzLiAgSW4gc3VjaCBhIGNhc2UsIHRoZSBgY2hhcmAgcHJvcGVydHlcbiAgICAgICAgLy8gaG9sZHMgYW4gZW1vamkgY2hhcmFjdGVyIGxpa2UgYFxcdUQ4M0RcXHVERTBBYC4gIEJlY2F1c2UgaXRzIGxlbmd0aFxuICAgICAgICAvLyBpcyAyLCB0aGUgcHJvcGVydHkgYHdoaWNoYCBkb2VzIG5vdCByZXByZXNlbnQgYW4gZW1vamkgY29ycmVjdGx5LlxuICAgICAgICAvLyBJbiBzdWNoIGEgY2FzZSwgd2UgZGlyZWN0bHkgcmV0dXJuIHRoZSBgY2hhcmAgcHJvcGVydHkgaW5zdGVhZCBvZlxuICAgICAgICAvLyB1c2luZyBgd2hpY2hgLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuY2hhciAmJiBuYXRpdmVFdmVudC5jaGFyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlRXZlbnQuY2hhcjtcbiAgICAgICAgfSBlbHNlIGlmIChuYXRpdmVFdmVudC53aGljaCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSBUT1BfQ09NUE9TSVRJT05fRU5EOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhICYmICFpc1VzaW5nS29yZWFuSU1FKG5hdGl2ZUV2ZW50KSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycyA9IHZvaWQgMDtcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgY29tcG9zaXRpb24gPSBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICB2YXIgYmVmb3JlSW5wdXQgPSBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBpZiAoY29tcG9zaXRpb24gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBiZWZvcmVJbnB1dDtcbiAgICB9XG5cbiAgICBpZiAoYmVmb3JlSW5wdXQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb21wb3NpdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gW2NvbXBvc2l0aW9uLCBiZWZvcmVJbnB1dF07XG4gIH1cbn07XG5cbi8vIFVzZSB0byByZXN0b3JlIGNvbnRyb2xsZWQgc3RhdGUgYWZ0ZXIgYSBjaGFuZ2UgZXZlbnQgaGFzIGZpcmVkLlxuXG52YXIgcmVzdG9yZUltcGwgPSBudWxsO1xudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIC8vIFVubW91bnRlZFxuICAgIHJldHVybjtcbiAgfVxuICAhKHR5cGVvZiByZXN0b3JlSW1wbCA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRSZXN0b3JlSW1wbGVtZW50YXRpb24oKSBuZWVkcyB0byBiZSBjYWxsZWQgdG8gaGFuZGxlIGEgdGFyZ2V0IGZvciBjb250cm9sbGVkIGV2ZW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSk7XG4gIHJlc3RvcmVJbXBsKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gc2V0UmVzdG9yZUltcGxlbWVudGF0aW9uKGltcGwpIHtcbiAgcmVzdG9yZUltcGwgPSBpbXBsO1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCkge1xuICBpZiAocmVzdG9yZVRhcmdldCkge1xuICAgIGlmIChyZXN0b3JlUXVldWUpIHtcbiAgICAgIHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlVGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG59XG5cbmZ1bmN0aW9uIG5lZWRzU3RhdGVSZXN0b3JlKCkge1xuICByZXR1cm4gcmVzdG9yZVRhcmdldCAhPT0gbnVsbCB8fCByZXN0b3JlUXVldWUgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRhcmdldCA9IHJlc3RvcmVUYXJnZXQ7XG4gIHZhciBxdWV1ZWRUYXJnZXRzID0gcmVzdG9yZVF1ZXVlO1xuICByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbiAgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuICBpZiAocXVldWVkVGFyZ2V0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVkVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQocXVldWVkVGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbi8vIFVzZWQgYXMgYSB3YXkgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcyB3aGVuIHdlIGRvbid0IGhhdmUgYSByZWZlcmVuY2UgdG9cbi8vIHRoZSByZW5kZXJlci4gU3VjaCBhcyB3aGVuIHdlJ3JlIGRpc3BhdGNoaW5nIGV2ZW50cyBvciBpZiB0aGlyZCBwYXJ0eVxuLy8gbGlicmFyaWVzIG5lZWQgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcy4gRXZlbnR1YWxseSwgdGhpcyBBUEkgd2lsbCBnbyBhd2F5IHdoZW5cbi8vIGV2ZXJ5dGhpbmcgaXMgYmF0Y2hlZCBieSBkZWZhdWx0LiBXZSdsbCB0aGVuIGhhdmUgYSBzaW1pbGFyIEFQSSB0byBvcHQtb3V0IG9mXG4vLyBzY2hlZHVsZWQgd29yayBhbmQgaW5zdGVhZCBkbyBzeW5jaHJvbm91cyB3b3JrLlxuXG4vLyBEZWZhdWx0c1xudmFyIF9iYXRjaGVkVXBkYXRlc0ltcGwgPSBmdW5jdGlvbiAoZm4sIGJvb2trZWVwaW5nKSB7XG4gIHJldHVybiBmbihib29ra2VlcGluZyk7XG59O1xudmFyIF9pbnRlcmFjdGl2ZVVwZGF0ZXNJbXBsID0gZnVuY3Rpb24gKGZuLCBhLCBiKSB7XG4gIHJldHVybiBmbihhLCBiKTtcbn07XG52YXIgX2ZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbCA9IGZ1bmN0aW9uICgpIHt9O1xuXG52YXIgaXNCYXRjaGluZyA9IGZhbHNlO1xuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKSB7XG4gIGlmIChpc0JhdGNoaW5nKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuXG4gICAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbiAgfVxuICBpc0JhdGNoaW5nID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gX2JhdGNoZWRVcGRhdGVzSW1wbChmbiwgYm9va2tlZXBpbmcpO1xuICB9IGZpbmFsbHkge1xuICAgIC8vIEhlcmUgd2Ugd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoIGlzIGltcG9ydGFudFxuICAgIC8vIHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjk4XG4gICAgLy8gVGhlbiB3ZSByZXN0b3JlIHN0YXRlIG9mIGFueSBjb250cm9sbGVkIGNvbXBvbmVudC5cbiAgICBpc0JhdGNoaW5nID0gZmFsc2U7XG4gICAgdmFyIGNvbnRyb2xsZWRDb21wb25lbnRzSGF2ZVBlbmRpbmdVcGRhdGVzID0gbmVlZHNTdGF0ZVJlc3RvcmUoKTtcbiAgICBpZiAoY29udHJvbGxlZENvbXBvbmVudHNIYXZlUGVuZGluZ1VwZGF0ZXMpIHtcbiAgICAgIC8vIElmIGEgY29udHJvbGxlZCBldmVudCB3YXMgZmlyZWQsIHdlIG1heSBuZWVkIHRvIHJlc3RvcmUgdGhlIHN0YXRlIG9mXG4gICAgICAvLyB0aGUgRE9NIG5vZGUgYmFjayB0byB0aGUgY29udHJvbGxlZCB2YWx1ZS4gVGhpcyBpcyBuZWNlc3Nhcnkgd2hlbiBSZWFjdFxuICAgICAgLy8gYmFpbHMgb3V0IG9mIHRoZSB1cGRhdGUgd2l0aG91dCB0b3VjaGluZyB0aGUgRE9NLlxuICAgICAgX2ZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbCgpO1xuICAgICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJhY3RpdmVVcGRhdGVzKGZuLCBhLCBiKSB7XG4gIHJldHVybiBfaW50ZXJhY3RpdmVVcGRhdGVzSW1wbChmbiwgYSwgYik7XG59XG5cblxuXG5mdW5jdGlvbiBzZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKGJhdGNoZWRVcGRhdGVzSW1wbCwgaW50ZXJhY3RpdmVVcGRhdGVzSW1wbCwgZmx1c2hJbnRlcmFjdGl2ZVVwZGF0ZXNJbXBsKSB7XG4gIF9iYXRjaGVkVXBkYXRlc0ltcGwgPSBiYXRjaGVkVXBkYXRlc0ltcGw7XG4gIF9pbnRlcmFjdGl2ZVVwZGF0ZXNJbXBsID0gaW50ZXJhY3RpdmVVcGRhdGVzSW1wbDtcbiAgX2ZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbCA9IGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzSW1wbDtcbn1cblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1pbnB1dC1lbGVtZW50Lmh0bWwjaW5wdXQtdHlwZS1hdHRyLXN1bW1hcnlcbiAqL1xudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gIGNvbG9yOiB0cnVlLFxuICBkYXRlOiB0cnVlLFxuICBkYXRldGltZTogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcbiAgZW1haWw6IHRydWUsXG4gIG1vbnRoOiB0cnVlLFxuICBudW1iZXI6IHRydWUsXG4gIHBhc3N3b3JkOiB0cnVlLFxuICByYW5nZTogdHJ1ZSxcbiAgc2VhcmNoOiB0cnVlLFxuICB0ZWw6IHRydWUsXG4gIHRleHQ6IHRydWUsXG4gIHRpbWU6IHRydWUsXG4gIHVybDogdHJ1ZSxcbiAgd2VlazogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gISFzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV07XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBIVE1MIG5vZGVUeXBlIHZhbHVlcyB0aGF0IHJlcHJlc2VudCB0aGUgdHlwZSBvZiB0aGUgbm9kZVxuICovXG5cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcbnZhciBET0NVTUVOVF9OT0RFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XG4gIC8vIEZhbGxiYWNrIHRvIG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgZm9yIElFOVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNTA2XG4gIHZhciB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQgfHwgbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCB3aW5kb3c7XG5cbiAgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuICBpZiAodGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xuICB9XG5cbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCkge1xuICBpZiAoIWNhblVzZURPTSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZSA9ICcnO1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNDaGVja2FibGUobm9kZSkpIHtcbiAgICB2YWx1ZSA9IG5vZGUuY2hlY2tlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgdmFsdWVGaWVsZCk7XG5cbiAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTtcblxuICAvLyBpZiBzb21lb25lIGhhcyBhbHJlYWR5IGRlZmluZWQgYSB2YWx1ZSBvciBTYWZhcmksIHRoZW4gYmFpbFxuICAvLyBhbmQgZG9uJ3QgdHJhY2sgdmFsdWUgd2lsbCBjYXVzZSBvdmVyIHJlcG9ydGluZyBvZiBjaGFuZ2VzLFxuICAvLyBidXQgaXQncyBiZXR0ZXIgdGhlbiBhIGhhcmQgZmFpbHVyZVxuICAvLyAobmVlZGVkIGZvciBjZXJ0YWluIHRlc3RzIHRoYXQgc3B5T24gaW5wdXQgdmFsdWVzIGFuZCBTYWZhcmkpXG4gIGlmIChub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8IHR5cGVvZiBkZXNjcmlwdG9yID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBnZXQgPSBkZXNjcmlwdG9yLmdldCxcbiAgICAgIHNldCA9IGRlc2NyaXB0b3Iuc2V0O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldC5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICBzZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgLy8gV2UgY291bGQndmUgcGFzc2VkIHRoaXMgdGhlIGZpcnN0IHRpbWVcbiAgLy8gYnV0IGl0IHRyaWdnZXJzIGEgYnVnIGluIElFMTEgYW5kIEVkZ2UgMTQvMTUuXG4gIC8vIENhbGxpbmcgZGVmaW5lUHJvcGVydHkoKSBhZ2FpbiBzaG91bGQgYmUgZXF1aXZhbGVudC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTc2OFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZVxuICB9KTtcblxuICB2YXIgdHJhY2tlciA9IHtcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSxcbiAgICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRldGFjaFRyYWNrZXIobm9kZSk7XG4gICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFja2VyO1xufVxuXG5mdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gIGlmIChnZXRUcmFja2VyKG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogT25jZSBpdCdzIGp1c3QgRmliZXIgd2UgY2FuIG1vdmUgdGhpcyB0byBub2RlLl93cmFwcGVyU3RhdGVcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHJhY2tlciA9IGdldFRyYWNrZXIobm9kZSk7XG4gIC8vIGlmIHRoZXJlIGlzIG5vIHRyYWNrZXIgYXQgdGhpcyBwb2ludCBpdCdzIHVubGlrZWx5XG4gIC8vIHRoYXQgdHJ5aW5nIGFnYWluIHdpbGwgc3VjY2VlZFxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAobmV4dFZhbHVlICE9PSBsYXN0VmFsdWUpIHtcbiAgICB0cmFja2VyLnNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuLy8gUHJldmVudCBuZXdlciByZW5kZXJlcnMgZnJvbSBSVEUgd2hlbiB1c2VkIHdpdGggb2xkZXIgcmVhY3QgcGFja2FnZSB2ZXJzaW9ucy5cbi8vIEN1cnJlbnQgb3duZXIgYW5kIGRpc3BhdGNoZXIgdXNlZCB0byBzaGFyZSB0aGUgc2FtZSByZWYsXG4vLyBidXQgUFIgIzE0NTQ4IHNwbGl0IHRoZW0gb3V0IHRvIGJldHRlciBzdXBwb3J0IHRoZSByZWFjdC1kZWJ1Zy10b29scyBwYWNrYWdlLlxuaWYgKCFSZWFjdFNoYXJlZEludGVybmFscy5oYXNPd25Qcm9wZXJ0eSgnUmVhY3RDdXJyZW50RGlzcGF0Y2hlcicpKSB7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xufVxuXG52YXIgQkVGT1JFX1NMQVNIX1JFID0gL14oLiopW1xcXFxcXC9dLztcblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgdmFyIHNvdXJjZUluZm8gPSAnJztcbiAgaWYgKHNvdXJjZSkge1xuICAgIHZhciBwYXRoID0gc291cmNlLmZpbGVOYW1lO1xuICAgIHZhciBmaWxlTmFtZSA9IHBhdGgucmVwbGFjZShCRUZPUkVfU0xBU0hfUkUsICcnKTtcbiAgICB7XG4gICAgICAvLyBJbiBERVYsIGluY2x1ZGUgY29kZSBmb3IgYSBjb21tb24gc3BlY2lhbCBjYXNlOlxuICAgICAgLy8gcHJlZmVyIFwiZm9sZGVyL2luZGV4LmpzXCIgaW5zdGVhZCBvZiBqdXN0IFwiaW5kZXguanNcIi5cbiAgICAgIGlmICgvXmluZGV4XFwuLy50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKEJFRk9SRV9TTEFTSF9SRSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHZhciBwYXRoQmVmb3JlU2xhc2ggPSBtYXRjaFsxXTtcbiAgICAgICAgICBpZiAocGF0aEJlZm9yZVNsYXNoKSB7XG4gICAgICAgICAgICB2YXIgZm9sZGVyTmFtZSA9IHBhdGhCZWZvcmVTbGFzaC5yZXBsYWNlKEJFRk9SRV9TTEFTSF9SRSwgJycpO1xuICAgICAgICAgICAgZmlsZU5hbWUgPSBmb2xkZXJOYW1lICsgJy8nICsgZmlsZU5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZUluZm8gPSAnIChhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJztcbiAgfSBlbHNlIGlmIChvd25lck5hbWUpIHtcbiAgICBzb3VyY2VJbmZvID0gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknO1xuICB9XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgc291cmNlSW5mbztcbn07XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlO1xuXG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gcmVmaW5lUmVzb2x2ZWRMYXp5Q29tcG9uZW50KGxhenlDb21wb25lbnQpIHtcbiAgcmV0dXJuIGxhenlDb21wb25lbnQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQgPyBsYXp5Q29tcG9uZW50Ll9yZXN1bHQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgJygnICsgZnVuY3Rpb25OYW1lICsgJyknIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ0NvbmN1cnJlbnRNb2RlJztcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHJldHVybiAnQ29udGV4dC5Db25zdW1lcic7XG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHJldHVybiAnQ29udGV4dC5Qcm92aWRlcic7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdGhlbmFibGUgPSB0eXBlO1xuICAgICAgICAgIHZhciByZXNvbHZlZFRoZW5hYmxlID0gcmVmaW5lUmVzb2x2ZWRMYXp5Q29tcG9uZW50KHRoZW5hYmxlKTtcbiAgICAgICAgICBpZiAocmVzb2x2ZWRUaGVuYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUocmVzb2x2ZWRUaGVuYWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICByZXR1cm4gJyc7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBvd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgICAgdmFyIHNvdXJjZSA9IGZpYmVyLl9kZWJ1Z1NvdXJjZTtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIudHlwZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBpbmZvID0gJyc7XG4gIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG4gIGRvIHtcbiAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIobm9kZSk7XG4gICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICB9IHdoaWxlIChub2RlKTtcbiAgcmV0dXJuIGluZm87XG59XG5cbnZhciBjdXJyZW50ID0gbnVsbDtcbnZhciBwaGFzZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZUluRGV2T3JOdWxsKCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgb3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3duZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKSB7XG4gIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICAvLyBTYWZlIGJlY2F1c2UgaWYgY3VycmVudCBmaWJlciBleGlzdHMsIHdlIGFyZSByZWNvbmNpbGluZyxcbiAgICAvLyBhbmQgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSB0aGUgd29yay1pbi1wcm9ncmVzcyB2ZXJzaW9uLlxuICAgIHJldHVybiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoY3VycmVudCk7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiByZXNldEN1cnJlbnRGaWJlcigpIHtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcbiAgICBjdXJyZW50ID0gbnVsbDtcbiAgICBwaGFzZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudEZpYmVyKGZpYmVyKSB7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgY3VycmVudCA9IGZpYmVyO1xuICAgIHBoYXNlID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50UGhhc2UobGlmZUN5Y2xlUGhhc2UpIHtcbiAge1xuICAgIHBoYXNlID0gbGlmZUN5Y2xlUGhhc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSB3YXJuaW5nV2l0aG91dFN0YWNrJDE7XG5cbntcbiAgd2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC93YXJuaW5nLWFuZC1pbnZhcmlhbnQtYXJnc1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEuYXBwbHkodW5kZWZpbmVkLCBbZmFsc2UsIGZvcm1hdCArICclcyddLmNvbmNhdChhcmdzLCBbc3RhY2tdKSk7XG4gIH07XG59XG5cbnZhciB3YXJuaW5nJDEgPSB3YXJuaW5nO1xuXG4vLyBBIHJlc2VydmVkIGF0dHJpYnV0ZS5cbi8vIEl0IGlzIGhhbmRsZWQgYnkgUmVhY3Qgc2VwYXJhdGVseSBhbmQgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbnZhciBSRVNFUlZFRCA9IDA7XG5cbi8vIEEgc2ltcGxlIHN0cmluZyBhdHRyaWJ1dGUuXG4vLyBBdHRyaWJ1dGVzIHRoYXQgYXJlbid0IGluIHRoZSB3aGl0ZWxpc3QgYXJlIHByZXN1bWVkIHRvIGhhdmUgdGhpcyB0eXBlLlxudmFyIFNUUklORyA9IDE7XG5cbi8vIEEgc3RyaW5nIGF0dHJpYnV0ZSB0aGF0IGFjY2VwdHMgYm9vbGVhbnMgaW4gUmVhY3QuIEluIEhUTUwsIHRoZXNlIGFyZSBjYWxsZWRcbi8vIFwiZW51bWVyYXRlZFwiIGF0dHJpYnV0ZXMgd2l0aCBcInRydWVcIiBhbmQgXCJmYWxzZVwiIGFzIHBvc3NpYmxlIHZhbHVlcy5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHNldCB0byBhIFwidHJ1ZVwiIHN0cmluZy5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcImZhbHNlXCIgc3RyaW5nLlxudmFyIEJPT0xFQU5JU0hfU1RSSU5HID0gMjtcblxuLy8gQSByZWFsIGJvb2xlYW4gYXR0cmlidXRlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG52YXIgQk9PTEVBTiA9IDM7XG5cbi8vIEFuIGF0dHJpYnV0ZSB0aGF0IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbi8vIFdoZW4gdHJ1ZSwgaXQgc2hvdWxkIGJlIHByZXNlbnQgKHNldCBlaXRoZXIgdG8gYW4gZW1wdHkgc3RyaW5nIG9yIGl0cyBuYW1lKS5cbi8vIFdoZW4gZmFsc2UsIGl0IHNob3VsZCBiZSBvbWl0dGVkLlxuLy8gRm9yIGFueSBvdGhlciB2YWx1ZSwgc2hvdWxkIGJlIHByZXNlbnQgd2l0aCB0aGF0IHZhbHVlLlxudmFyIE9WRVJMT0FERURfQk9PTEVBTiA9IDQ7XG5cbi8vIEFuIGF0dHJpYnV0ZSB0aGF0IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMuXG4vLyBXaGVuIGZhbHN5LCBpdCBzaG91bGQgYmUgcmVtb3ZlZC5cbnZhciBOVU1FUklDID0gNTtcblxuLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmUgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxudmFyIFBPU0lUSVZFX05VTUVSSUMgPSA2O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG52YXIgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiA9ICc6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEJztcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ1xcXFwtLjAtOVxcXFx1MDBCN1xcXFx1MDMwMC1cXFxcdTAzNkZcXFxcdTIwM0YtXFxcXHUyMDQwJztcblxuXG52YXIgUk9PVF9BVFRSSUJVVEVfTkFNRSA9ICdkYXRhLXJlYWN0cm9vdCc7XG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGlsbGVnYWxBdHRyaWJ1dGVOYW1lQ2FjaGUsIGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEO1xuICB9XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobmFtZS5sZW5ndGggPiAyICYmIChuYW1lWzBdID09PSAnbycgfHwgbmFtZVswXSA9PT0gJ08nKSAmJiAobmFtZVsxXSA9PT0gJ24nIHx8IG5hbWVbMV0gPT09ICdOJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgIC8vICRGbG93SXNzdWUgc3ltYm9sIGlzIHBlcmZlY3RseSB2YWxpZCBoZXJlXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAhcHJvcGVydHlJbmZvLmFjY2VwdHNCb29sZWFucztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcHJlZml4ID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICAgICAgICAgIHJldHVybiBwcmVmaXggIT09ICdkYXRhLScgJiYgcHJlZml4ICE9PSAnYXJpYS0nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHByb3BlcnR5SW5mby50eXBlKSB7XG4gICAgICBjYXNlIEJPT0xFQU46XG4gICAgICAgIHJldHVybiAhdmFsdWU7XG4gICAgICBjYXNlIE9WRVJMT0FERURfQk9PTEVBTjpcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcbiAgICAgIGNhc2UgTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKTtcbiAgICAgIGNhc2UgUE9TSVRJVkVfTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA8IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKG5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIHR5cGUsIG11c3RVc2VQcm9wZXJ0eSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlTmFtZXNwYWNlKSB7XG4gIHRoaXMuYWNjZXB0c0Jvb2xlYW5zID0gdHlwZSA9PT0gQk9PTEVBTklTSF9TVFJJTkcgfHwgdHlwZSA9PT0gQk9PTEVBTiB8fCB0eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU47XG4gIHRoaXMuYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZU5hbWU7XG4gIHRoaXMuYXR0cmlidXRlTmFtZXNwYWNlID0gYXR0cmlidXRlTmFtZXNwYWNlO1xuICB0aGlzLm11c3RVc2VQcm9wZXJ0eSA9IG11c3RVc2VQcm9wZXJ0eTtcbiAgdGhpcy5wcm9wZXJ0eU5hbWUgPSBuYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4vLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuLy8gbmFtZSB3YXJuaW5ncy5cbnZhciBwcm9wZXJ0aWVzID0ge307XG5cbi8vIFRoZXNlIHByb3BzIGFyZSByZXNlcnZlZCBieSBSZWFjdC4gVGhleSBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxuWydjaGlsZHJlbicsICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4vLyBUT0RPOiBUaGlzIHByZXZlbnRzIHRoZSBhc3NpZ25tZW50IG9mIGRlZmF1bHRWYWx1ZSB0byByZWd1bGFyXG4vLyBlbGVtZW50cyAobm90IGp1c3QgaW5wdXRzKS4gTm93IHRoYXQgUmVhY3RET01JbnB1dCBhc3NpZ25zIHRvIHRoZVxuLy8gZGVmYXVsdFZhbHVlIHByb3BlcnR5IC0tIGRvIHdlIG5lZWQgdGhpcz9cbidkZWZhdWx0VmFsdWUnLCAnZGVmYXVsdENoZWNrZWQnLCAnaW5uZXJIVE1MJywgJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnLCAnc3R5bGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFJFU0VSVkVELCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gQSBmZXcgUmVhY3Qgc3RyaW5nIGF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBuYW1lLlxuLy8gVGhpcyBpcyBhIG1hcHBpbmcgZnJvbSBSZWFjdCBwcm9wIG5hbWVzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZXMuXG5bWydhY2NlcHRDaGFyc2V0JywgJ2FjY2VwdC1jaGFyc2V0J10sIFsnY2xhc3NOYW1lJywgJ2NsYXNzJ10sIFsnaHRtbEZvcicsICdmb3InXSwgWydodHRwRXF1aXYnLCAnaHR0cC1lcXVpdiddXS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBuYW1lID0gX3JlZlswXSxcbiAgICAgIGF0dHJpYnV0ZU5hbWUgPSBfcmVmWzFdO1xuXG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG5bJ2NvbnRlbnRFZGl0YWJsZScsICdkcmFnZ2FibGUnLCAnc3BlbGxDaGVjaycsICd2YWx1ZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIFRoZXNlIGFyZSBcImVudW1lcmF0ZWRcIiBTVkcgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cbi8vIFNpbmNlIHRoZXNlIGFyZSBTVkcgYXR0cmlidXRlcywgdGhlaXIgYXR0cmlidXRlIG5hbWVzIGFyZSBjYXNlLXNlbnNpdGl2ZS5cblsnYXV0b1JldmVyc2UnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmb2N1c2FibGUnLCAncHJlc2VydmVBbHBoYSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5bJ2FsbG93RnVsbFNjcmVlbicsICdhc3luYycsXG4vLyBOb3RlOiB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZSB0aGF0IHByZXZlbnRzIGl0IGZyb20gYmVpbmcgd3JpdHRlbiB0byB0aGUgRE9NXG4vLyBvbiB0aGUgY2xpZW50IHNpZGUgYmVjYXVzZSB0aGUgYnJvd3NlcnMgYXJlIGluY29uc2lzdGVudC4gSW5zdGVhZCB3ZSBjYWxsIGZvY3VzKCkuXG4nYXV0b0ZvY3VzJywgJ2F1dG9QbGF5JywgJ2NvbnRyb2xzJywgJ2RlZmF1bHQnLCAnZGVmZXInLCAnZGlzYWJsZWQnLCAnZm9ybU5vVmFsaWRhdGUnLCAnaGlkZGVuJywgJ2xvb3AnLCAnbm9Nb2R1bGUnLCAnbm9WYWxpZGF0ZScsICdvcGVuJywgJ3BsYXlzSW5saW5lJywgJ3JlYWRPbmx5JywgJ3JlcXVpcmVkJywgJ3JldmVyc2VkJywgJ3Njb3BlZCcsICdzZWFtbGVzcycsXG4vLyBNaWNyb2RhdGFcbidpdGVtU2NvcGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIFRoZXNlIGFyZSB0aGUgZmV3IFJlYWN0IHByb3BzIHRoYXQgd2Ugc2V0IGFzIERPTSBwcm9wZXJ0aWVzXG4vLyByYXRoZXIgdGhhbiBhdHRyaWJ1dGVzLiBUaGVzZSBhcmUgYWxsIGJvb2xlYW5zLlxuWydjaGVja2VkJyxcbi8vIE5vdGU6IGBvcHRpb24uc2VsZWN0ZWRgIGlzIG5vdCB1cGRhdGVkIGlmIGBzZWxlY3QubXVsdGlwbGVgIGlzXG4vLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLiBXZSBoYXZlIHNwZWNpYWwgbG9naWMgZm9yIGhhbmRsaW5nIHRoaXMuXG4nbXVsdGlwbGUnLCAnbXV0ZWQnLCAnc2VsZWN0ZWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU4sIHRydWUsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwpO1xufSAvLyBhdHRyaWJ1dGVOYW1lc3BhY2Vcbik7XG5cbi8vIFRoZXNlIGFyZSBIVE1MIGF0dHJpYnV0ZXMgdGhhdCBhcmUgXCJvdmVybG9hZGVkIGJvb2xlYW5zXCI6IHRoZXkgYmVoYXZlIGxpa2Vcbi8vIGJvb2xlYW5zLCBidXQgY2FuIGFsc28gYWNjZXB0IGEgc3RyaW5nIHZhbHVlLlxuWydjYXB0dXJlJywgJ2Rvd25sb2FkJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBPVkVSTE9BREVEX0JPT0xFQU4sIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vLyBUaGVzZSBhcmUgSFRNTCBhdHRyaWJ1dGVzIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1iZXJzLlxuWydjb2xzJywgJ3Jvd3MnLCAnc2l6ZScsICdzcGFuJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBQT1NJVElWRV9OVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cblsncm93U3BhbicsICdzdGFydCddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgTlVNRVJJQywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBuYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59O1xuXG4vLyBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLCBuYW1lc3BhY2luZyxcbi8vIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC4gUmVndWxhciBhdHRyaWJ1dGVzIHRoYXQganVzdCBhY2NlcHQgc3RyaW5nc1xuLy8gYW5kIGhhdmUgdGhlIHNhbWUgbmFtZXMgYXJlIG9taXR0ZWQsIGp1c3QgbGlrZSBpbiB0aGUgSFRNTCB3aGl0ZWxpc3QuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcHBpbmcgdGhlIE1ETiBkb2N1bWVudGF0aW9uLlxuWydhY2NlbnQtaGVpZ2h0JywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhcmFiaWMtZm9ybScsICdiYXNlbGluZS1zaGlmdCcsICdjYXAtaGVpZ2h0JywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnZW5hYmxlLWJhY2tncm91bmQnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdnbHlwaC1uYW1lJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCAnaG9yaXotYWR2LXgnLCAnaG9yaXotb3JpZ2luLXgnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2xldHRlci1zcGFjaW5nJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnb3ZlcmxpbmUtcG9zaXRpb24nLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJywgJ3BhaW50LW9yZGVyJywgJ3Bhbm9zZS0xJywgJ3BvaW50ZXItZXZlbnRzJywgJ3JlbmRlcmluZy1pbnRlbnQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLWJpZGknLCAndW5pY29kZS1yYW5nZScsICd1bml0cy1wZXItZW0nLCAndi1hbHBoYWJldGljJywgJ3YtaGFuZ2luZycsICd2LWlkZW9ncmFwaGljJywgJ3YtbWF0aGVtYXRpY2FsJywgJ3ZlY3Rvci1lZmZlY3QnLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd29yZC1zcGFjaW5nJywgJ3dyaXRpbmctbW9kZScsICd4bWxuczp4bGluaycsICd4LWhlaWdodCddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgbnVsbCk7XG59IC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuKTtcblxuLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhsaW5rIG5hbWVzcGFjZS5cblsneGxpbms6YWN0dWF0ZScsICd4bGluazphcmNyb2xlJywgJ3hsaW5rOmhyZWYnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyk7XG59KTtcblxuLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhtbCBuYW1lc3BhY2UuXG5bJ3htbDpiYXNlJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScpO1xufSk7XG5cbi8vIFRoZXNlIGF0dHJpYnV0ZSBleGlzdHMgYm90aCBpbiBIVE1MIGFuZCBTVkcuXG4vLyBUaGUgYXR0cmlidXRlIG5hbWUgaXMgY2FzZS1zZW5zaXRpdmUgaW4gU1ZHIHNvIHdlIGNhbid0IGp1c3QgdXNlXG4vLyB0aGUgUmVhY3QgbmFtZSBsaWtlIHdlIGRvIGZvciBhdHRyaWJ1dGVzIHRoYXQgZXhpc3Qgb25seSBpbiBIVE1MLlxuWyd0YWJJbmRleCcsICdjcm9zc09yaWdpbiddLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgcHJvcGVydGllc1thdHRyaWJ1dGVOYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQoYXR0cmlidXRlTmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsKTtcbn0gLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4pO1xuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSBcImV4cGVjdGVkXCIgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuXG4gKiBTb21lIHByb3BlcnRpZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCBleHBlY3RlZCwgcHJvcGVydHlJbmZvKSB7XG4gIHtcbiAgICBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG5cbiAgICAgIHJldHVybiBub2RlW3Byb3BlcnR5TmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG5cbiAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG51bGw7XG5cbiAgICAgIGlmIChwcm9wZXJ0eUluZm8udHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOKSB7XG4gICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgIGlmIChzaG91bGRSZW1vdmVBdHRyaWJ1dGUobmFtZSwgZXhwZWN0ZWQsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICAgICAgLy8gV2UgaGFkIGFuIGF0dHJpYnV0ZSBidXQgc2hvdWxkbid0IGhhdmUgaGFkIG9uZSwgc28gcmVhZCBpdFxuICAgICAgICAgIC8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICByZXR1cm4gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby50eXBlID09PSBCT09MRUFOKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBhc3N1bWUgaXRzIG5hbWVzcGFjZWQgbmFtZSBpcyB0aGUgc2FtZSBhcyBvdXIgY29uZmlnLlxuICAgICAgICAvLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4gICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuICAgICAgICBzdHJpbmdWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIGV4cGVjdGVkLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUgPT09IG51bGwgPyBleHBlY3RlZCA6IHN0cmluZ1ZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHJpbmdWYWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBhdHRyaWJ1dGUgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSB0aGlyZCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy4gU29tZVxuICogYXR0cmlidXRlcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBleHBlY3RlZCkge1xuICB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChzaG91bGRJZ25vcmVBdHRyaWJ1dGUobmFtZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykpIHtcbiAgICB2YWx1ZSA9IG51bGw7XG4gIH1cbiAgLy8gSWYgdGhlIHByb3AgaXNuJ3QgaW4gdGhlIHNwZWNpYWwgbGlzdCwgdHJlYXQgaXQgYXMgYSBzaW1wbGUgYXR0cmlidXRlLlxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcgfHwgcHJvcGVydHlJbmZvID09PSBudWxsKSB7XG4gICAgaWYgKGlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICAgIHZhciBfYXR0cmlidXRlTmFtZSA9IG5hbWU7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoX2F0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG11c3RVc2VQcm9wZXJ0eSA9IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHk7XG5cbiAgaWYgKG11c3RVc2VQcm9wZXJ0eSkge1xuICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuXG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICB2YXIgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuXG4gICAgICBub2RlW3Byb3BlcnR5TmFtZV0gPSB0eXBlID09PSBCT09MRUFOID8gZmFsc2UgOiAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udHJhcnkgdG8gYHNldEF0dHJpYnV0ZWAsIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBwcm9wZXJseVxuICAgICAgLy8gYHRvU3RyaW5nYGVkIGJ5IElFOC85LlxuICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICAvLyBUaGUgcmVzdCBhcmUgdHJlYXRlZCBhcyBhdHRyaWJ1dGVzIHdpdGggc3BlY2lhbCBjYXNlcy5cbiAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSxcbiAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2U7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF90eXBlID0gcHJvcGVydHlJbmZvLnR5cGU7XG5cbiAgICB2YXIgYXR0cmlidXRlVmFsdWUgPSB2b2lkIDA7XG4gICAgaWYgKF90eXBlID09PSBCT09MRUFOIHx8IF90eXBlID09PSBPVkVSTE9BREVEX0JPT0xFQU4gJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIGF0dHJpYnV0ZVZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZU5hbWVzcGFjZSkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhhdHRyaWJ1dGVOYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBGbG93IGRvZXMgbm90IGFsbG93IHN0cmluZyBjb25jYXRlbmF0aW9uIG9mIG1vc3Qgbm9uLXN0cmluZyB0eXBlcy4gVG8gd29ya1xuLy8gYXJvdW5kIHRoaXMgbGltaXRhdGlvbiwgd2UgdXNlIGFuIG9wYXF1ZSB0eXBlIHRoYXQgY2FuIG9ubHkgYmUgb2J0YWluZWQgYnlcbi8vIHBhc3NpbmcgdGhlIHZhbHVlIHRocm91Z2ggZ2V0VG9TdHJpbmdWYWx1ZSBmaXJzdC5cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRUb1N0cmluZ1ZhbHVlKHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZnVuY3Rpb24sIHN5bWJvbCBhcmUgYXNzaWduZWQgYXMgZW1wdHkgc3RyaW5nc1xuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBudWxsO1xuXG52YXIgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBudWxsXG59O1xuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbiAgdmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICAgYnV0dG9uOiB0cnVlLFxuICAgIGNoZWNrYm94OiB0cnVlLFxuICAgIGltYWdlOiB0cnVlLFxuICAgIGhpZGRlbjogdHJ1ZSxcbiAgICByYWRpbzogdHJ1ZSxcbiAgICByZXNldDogdHJ1ZSxcbiAgICBzdWJtaXQ6IHRydWVcbiAgfTtcblxuICB2YXIgcHJvcFR5cGVzID0ge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfSxcbiAgICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAocHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQgfHwgcHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICAgKiB0aGlzIG91dHNpZGUgb2YgdGhlIFJlYWN0RE9NIGNvbnRyb2xsZWQgZm9ybSBjb21wb25lbnRzLlxuICAgKi9cbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMpIHtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIHRhZ05hbWUsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRTdGFja0FkZGVuZHVtKTtcbiAgfTtcbn1cblxudmFyIGVuYWJsZVVzZXJUaW1pbmdBUEkgPSB0cnVlO1xuXG4vLyBIZWxwcyBpZGVudGlmeSBzaWRlIGVmZmVjdHMgaW4gYmVnaW4tcGhhc2UgbGlmZWN5Y2xlIGhvb2tzIGFuZCBzZXRTdGF0ZSByZWR1Y2VyczpcbnZhciBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgPSBmYWxzZTtcblxuLy8gSW4gc29tZSBjYXNlcywgU3RyaWN0TW9kZSBzaG91bGQgYWxzbyBkb3VibGUtcmVuZGVyIGxpZmVjeWNsZXMuXG4vLyBUaGlzIGNhbiBiZSBjb25mdXNpbmcgZm9yIHRlc3RzIHRob3VnaCxcbi8vIEFuZCBpdCBjYW4gYmUgYmFkIGZvciBwZXJmb3JtYW5jZSBpbiBwcm9kdWN0aW9uLlxuLy8gVGhpcyBmZWF0dXJlIGZsYWcgY2FuIGJlIHVzZWQgdG8gY29udHJvbCB0aGUgYmVoYXZpb3I6XG52YXIgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSA9IHRydWU7XG5cbi8vIFRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIGRlYnVnZ2VyLCB3ZVxuLy8gcmVwbGF5IHRoZSBiZWdpbiBwaGFzZSBvZiBhIGZhaWxlZCBjb21wb25lbnQgaW5zaWRlIGludm9rZUd1YXJkZWRDYWxsYmFjay5cbnZhciByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjayA9IHRydWU7XG5cbi8vIFdhcm4gYWJvdXQgZGVwcmVjYXRlZCwgYXN5bmMtdW5zYWZlIGxpZmVjeWNsZXM7IHJlbGF0ZXMgdG8gUkZDICM2OlxudmFyIHdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzID0gZmFsc2U7XG5cbi8vIEdhdGhlciBhZHZhbmNlZCB0aW1pbmcgbWV0cmljcyBmb3IgUHJvZmlsZXIgc3VidHJlZXMuXG52YXIgZW5hYmxlUHJvZmlsZXJUaW1lciA9IHRydWU7XG5cbi8vIFRyYWNlIHdoaWNoIGludGVyYWN0aW9ucyB0cmlnZ2VyIGVhY2ggY29tbWl0LlxudmFyIGVuYWJsZVNjaGVkdWxlclRyYWNpbmcgPSB0cnVlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cbnZhciBlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyID0gZmFsc2U7IC8vIFRPRE86IHRydWU/IEhlcmUgaXQgbWlnaHQganVzdCBiZSBmYWxzZS5cblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cblxuLy8gUmVhY3QgRmlyZTogcHJldmVudCB0aGUgdmFsdWUgYW5kIGNoZWNrZWQgYXR0cmlidXRlcyBmcm9tIHN5bmNpbmdcbi8vIHdpdGggdGhlaXIgcmVsYXRlZCBET00gcHJvcGVydGllc1xudmFyIGRpc2FibGVJbnB1dEF0dHJpYnV0ZVN5bmNpbmcgPSBmYWxzZTtcblxuLy8gVGhlc2UgQVBJcyB3aWxsIG5vIGxvbmdlciBiZSBcInVuc3RhYmxlXCIgaW4gdGhlIHVwY29taW5nIDE2LjcgcmVsZWFzZSxcbi8vIENvbnRyb2wgdGhpcyBiZWhhdmlvciB3aXRoIGEgZmxhZyB0byBzdXBwb3J0IDE2LjYgbWlub3IgcmVsZWFzZXMgaW4gdGhlIG1lYW53aGlsZS5cbnZhciBlbmFibGVTdGFibGVDb25jdXJyZW50TW9kZUFQSXMgPSBmYWxzZTtcblxudmFyIHdhcm5BYm91dFNob3J0aGFuZFByb3BlcnR5Q29sbGlzaW9uID0gZmFsc2U7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaXNDb250cm9sbGVkKHByb3BzKSB7XG4gIHZhciB1c2VzQ2hlY2tlZCA9IHByb3BzLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcHJvcHMudHlwZSA9PT0gJ3JhZGlvJztcbiAgcmV0dXJuIHVzZXNDaGVja2VkID8gcHJvcHMuY2hlY2tlZCAhPSBudWxsIDogcHJvcHMudmFsdWUgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciBjaGVja2VkID0gcHJvcHMuY2hlY2tlZDtcblxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZFxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcyk7XG5cbiAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5DaGVja2VkRGVmYXVsdENoZWNrZWQpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwgPyAnJyA6IHByb3BzLmRlZmF1bHRWYWx1ZTtcblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICBpbml0aWFsVmFsdWU6IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlKSxcbiAgICBjb250cm9sbGVkOiBpc0NvbnRyb2xsZWQocHJvcHMpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsICdjaGVja2VkJywgY2hlY2tlZCwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgdmFyIF9jb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgX2NvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFfY29udHJvbGxlZCAmJiAhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQ2hlY2tlZChlbGVtZW50LCBwcm9wcyk7XG5cbiAgdmFyIHZhbHVlID0gZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy52YWx1ZSk7XG4gIHZhciB0eXBlID0gcHJvcHMudHlwZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnIHx8XG4gICAgICAvLyBXZSBleHBsaWNpdGx5IHdhbnQgdG8gY29lcmNlIHRvIG51bWJlciBoZXJlIGlmIHBvc3NpYmxlLlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICBub2RlLnZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnZhbHVlICE9PSB0b1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIG5vZGUudmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdWJtaXQnIHx8IHR5cGUgPT09ICdyZXNldCcpIHtcbiAgICAvLyBTdWJtaXQvcmVzZXQgaW5wdXRzIG5lZWQgdGhlIGF0dHJpYnV0ZSByZW1vdmVkIGNvbXBsZXRlbHkgdG8gYXZvaWRcbiAgICAvLyBibGFuay10ZXh0IGJ1dHRvbnMuXG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGRpc2FibGVJbnB1dEF0dHJpYnV0ZVN5bmNpbmcpIHtcbiAgICAvLyBXaGVuIG5vdCBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIFJlYWN0IG9ubHkgYXNzaWducyBhIG5ldyB2YWx1ZVxuICAgIC8vIHdoZW5ldmVyIHRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcCBoYXMgY2hhbmdlZC4gV2hlbiBub3QgcHJlc2VudCxcbiAgICAvLyBSZWFjdCBkb2VzIG5vdGhpbmdcbiAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIHRoZSB2YWx1ZSBjb21lcyBmcm9tIGEgY2FzY2FkZSBvZlxuICAgIC8vIHByb3BlcnRpZXM6XG4gICAgLy8gIDEuIFRoZSB2YWx1ZSBSZWFjdCBwcm9wZXJ0eVxuICAgIC8vICAyLiBUaGUgZGVmYXVsdFZhbHVlIFJlYWN0IHByb3BlcnR5XG4gICAgLy8gIDMuIE90aGVyd2lzZSB0aGVyZSBzaG91bGQgYmUgbm8gY2hhbmdlXG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHRWYWx1ZScpKSB7XG4gICAgICBzZXREZWZhdWx0VmFsdWUobm9kZSwgcHJvcHMudHlwZSwgZ2V0VG9TdHJpbmdWYWx1ZShwcm9wcy5kZWZhdWx0VmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZGlzYWJsZUlucHV0QXR0cmlidXRlU3luY2luZykge1xuICAgIC8vIFdoZW4gbm90IHN5bmNpbmcgdGhlIGNoZWNrZWQgYXR0cmlidXRlLCB0aGUgYXR0cmlidXRlIGlzIGRpcmVjdGx5XG4gICAgLy8gY29udHJvbGxhYmxlIGZyb20gdGhlIGRlZmF1bHRWYWx1ZSBSZWFjdCBwcm9wZXJ0eS4gSXQgbmVlZHMgdG8gYmVcbiAgICAvLyB1cGRhdGVkIGFzIG5ldyBwcm9wcyBjb21lIGluLlxuICAgIGlmIChwcm9wcy5kZWZhdWx0Q2hlY2tlZCA9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnY2hlY2tlZCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSwgaXQgb25seSBjaGFuZ2VzIHdoZW4gaXQgbmVlZHNcbiAgICAvLyB0byBiZSByZW1vdmVkLCBzdWNoIGFzIHRyYW5zaXRpb25pbmcgZnJvbSBhIGNoZWNrYm94IGludG8gYSB0ZXh0IGlucHV0XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcywgaXNIeWRyYXRpbmcpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuXG4gIC8vIERvIG5vdCBhc3NpZ24gdmFsdWUgaWYgaXQgaXMgYWxyZWFkeSBzZXQuIFRoaXMgcHJldmVudHMgdXNlciB0ZXh0IGlucHV0XG4gIC8vIGZyb20gYmVpbmcgbG9zdCBkdXJpbmcgU1NSIGh5ZHJhdGlvbi5cbiAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd2YWx1ZScpIHx8IHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0VmFsdWUnKSkge1xuICAgIHZhciB0eXBlID0gcHJvcHMudHlwZTtcbiAgICB2YXIgaXNCdXR0b24gPSB0eXBlID09PSAnc3VibWl0JyB8fCB0eXBlID09PSAncmVzZXQnO1xuXG4gICAgLy8gQXZvaWQgc2V0dGluZyB2YWx1ZSBhdHRyaWJ1dGUgb24gc3VibWl0L3Jlc2V0IGlucHV0cyBhcyBpdCBvdmVycmlkZXMgdGhlXG4gICAgLy8gZGVmYXVsdCB2YWx1ZSBwcm92aWRlZCBieSB0aGUgYnJvd3Nlci4gU2VlOiAjMTI4NzJcbiAgICBpZiAoaXNCdXR0b24gJiYgKHByb3BzLnZhbHVlID09PSB1bmRlZmluZWQgfHwgcHJvcHMudmFsdWUgPT09IG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9pbml0aWFsVmFsdWUgPSB0b1N0cmluZyhub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKTtcblxuICAgIC8vIERvIG5vdCBhc3NpZ24gdmFsdWUgaWYgaXQgaXMgYWxyZWFkeSBzZXQuIFRoaXMgcHJldmVudHMgdXNlciB0ZXh0IGlucHV0XG4gICAgLy8gZnJvbSBiZWluZyBsb3N0IGR1cmluZyBTU1IgaHlkcmF0aW9uLlxuICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgIGlmIChkaXNhYmxlSW5wdXRBdHRyaWJ1dGVTeW5jaW5nKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpO1xuXG4gICAgICAgIC8vIFdoZW4gbm90IHN5bmNpbmcgdGhlIHZhbHVlIGF0dHJpYnV0ZSwgdGhlIHZhbHVlIHByb3BlcnR5IHBvaW50c1xuICAgICAgICAvLyBkaXJlY3RseSB0byB0aGUgUmVhY3QgcHJvcC4gT25seSBhc3NpZ24gaXQgaWYgaXQgZXhpc3RzLlxuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIEFsd2F5cyBhc3NpZ24gb24gYnV0dG9ucyBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGFzc2lnbiBhblxuICAgICAgICAgIC8vIGVtcHR5IHN0cmluZyB0byBjbGVhciBidXR0b24gdGV4dC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIE90aGVyd2lzZSwgZG8gbm90IHJlLWFzc2lnbiB0aGUgdmFsdWUgcHJvcGVydHkgaWYgaXMgZW1wdHkuIFRoaXNcbiAgICAgICAgICAvLyBwb3RlbnRpYWxseSBhdm9pZHMgYSBET00gd3JpdGUgYW5kIHByZXZlbnRzIEZpcmVmb3ggKH42MC4wLjEpIGZyb21cbiAgICAgICAgICAvLyBwcmVtYXR1cmVseSBtYXJraW5nIHJlcXVpcmVkIGlucHV0cyBhcyBpbnZhbGlkLiBFcXVhbGl0eSBpcyBjb21wYXJlZFxuICAgICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IHZhbHVlIGluIGNhc2UgdGhlIGJyb3dzZXIgcHJvdmlkZWQgdmFsdWUgaXMgbm90IGFuXG4gICAgICAgICAgLy8gZW1wdHkgc3RyaW5nLlxuICAgICAgICAgIGlmIChpc0J1dHRvbiB8fCB2YWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdoZW4gc3luY2luZyB0aGUgdmFsdWUgYXR0cmlidXRlLCB0aGUgdmFsdWUgcHJvcGVydHkgc2hvdWxkIHVzZVxuICAgICAgICAvLyB0aGUgd3JhcHBlclN0YXRlLl9pbml0aWFsVmFsdWUgcHJvcGVydHkuIFRoaXMgdXNlczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gICAxLiBUaGUgdmFsdWUgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgICAgIC8vICAgMi4gVGhlIGRlZmF1bHRWYWx1ZSBSZWFjdCBwcm9wZXJ0eSB3aGVuIHByZXNlbnRcbiAgICAgICAgLy8gICAzLiBBbiBlbXB0eSBzdHJpbmdcbiAgICAgICAgaWYgKF9pbml0aWFsVmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgICAgICBub2RlLnZhbHVlID0gX2luaXRpYWxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaXNhYmxlSW5wdXRBdHRyaWJ1dGVTeW5jaW5nKSB7XG4gICAgICAvLyBXaGVuIG5vdCBzeW5jaW5nIHRoZSB2YWx1ZSBhdHRyaWJ1dGUsIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlXG4gICAgICAvLyBkaXJlY3RseSBmcm9tIHRoZSBkZWZhdWx0VmFsdWUgUmVhY3QgcHJvcGVydHkgKHdoZW4gcHJlc2VudClcbiAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICBpZiAoZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSB0b1N0cmluZyhkZWZhdWx0VmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgc3luY2hyb25pemVkIHRvIHRoZSBwcm9wZXJ0eSxcbiAgICAgIC8vIHNvIHdlIGFzc2lnbiBkZWZhdWx0VmFsdWUgdG8gdGhlIHNhbWUgdGhpbmcgYXMgdGhlIHZhbHVlIHByb3BlcnR5XG4gICAgICAvLyBhc3NpZ25tZW50IHN0ZXAgYWJvdmUuXG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IF9pbml0aWFsVmFsdWU7XG4gICAgfVxuICB9XG5cbiAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gJyc7XG4gIH1cblxuICBpZiAoZGlzYWJsZUlucHV0QXR0cmlidXRlU3luY2luZykge1xuICAgIC8vIFdoZW4gbm90IHN5bmNpbmcgdGhlIGNoZWNrZWQgYXR0cmlidXRlLCB0aGUgY2hlY2tlZCBwcm9wZXJ0eVxuICAgIC8vIG5ldmVyIGdldHMgYXNzaWduZWQuIEl0IG11c3QgYmUgbWFudWFsbHkgc2V0LiBXZSBkb24ndCB3YW50XG4gICAgLy8gdG8gZG8gdGhpcyB3aGVuIGh5ZHJhdGluZyBzbyB0aGF0IGV4aXN0aW5nIHVzZXIgaW5wdXQgaXNuJ3RcbiAgICAvLyBtb2RpZmllZFxuICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpO1xuICAgIH1cblxuICAgIC8vIE9ubHkgYXNzaWduIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSBpZiBpdCBpcyBkZWZpbmVkLiBUaGlzIHNhdmVzXG4gICAgLy8gYSBET00gd3JpdGUgd2hlbiBjb250cm9sbGluZyB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUgaXNuJ3QgbmVlZGVkXG4gICAgLy8gKHRleHQgaW5wdXRzLCBzdWJtaXQvcmVzZXQpXG4gICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdkZWZhdWx0Q2hlY2tlZCcpKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gV2hlbiBzeW5jaW5nIHRoZSBjaGVja2VkIGF0dHJpYnV0ZSwgYm90aCB0aGUgY2hlY2tlZCBwcm9wZXJ0eSBhbmRcbiAgICAvLyBhdHRyaWJ1dGUgYXJlIGFzc2lnbmVkIGF0IHRoZSBzYW1lIHRpbWUgdXNpbmcgZGVmYXVsdENoZWNrZWQuIFRoaXMgdXNlczpcbiAgICAvL1xuICAgIC8vICAgMS4gVGhlIGNoZWNrZWQgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgLy8gICAyLiBUaGUgZGVmYXVsdENoZWNrZWQgUmVhY3QgcHJvcGVydHkgd2hlbiBwcmVzZW50XG4gICAgLy8gICAzLiBPdGhlcndpc2UsIGZhbHNlXG4gICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIW5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZDtcbiAgfVxuXG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlclByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG5cbiAgICAgIC8vIFdlIG5lZWQgdXBkYXRlIHRoZSB0cmFja2VkIHZhbHVlIG9uIHRoZSBuYW1lZCBjb3VzaW4gc2luY2UgdGhlIHZhbHVlXG4gICAgICAvLyB3YXMgY2hhbmdlZCBidXQgdGhlIGlucHV0IHNhdyBubyBldmVudCBvciB2YWx1ZSBzZXRcbiAgICAgIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG90aGVyTm9kZSk7XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxuLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuLy8gQ2hyb21lIHJhaXNlcyBcIlRoZSBzcGVjaWZpZWQgdmFsdWUgPHg+IGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIi5cbi8vXG4vLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuLy8gd2hlbiB0aGUgdXNlciBpcyBpbnB1dHRpbmcgdGV4dFxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuZnVuY3Rpb24gc2V0RGVmYXVsdFZhbHVlKG5vZGUsIHR5cGUsIHZhbHVlKSB7XG4gIGlmIChcbiAgLy8gRm9jdXNlZCBudW1iZXIgaW5wdXRzIHN5bmNocm9uaXplIG9uIGJsdXIuIFNlZSBDaGFuZ2VFdmVudFBsdWdpbi5qc1xuICB0eXBlICE9PSAnbnVtYmVyJyB8fCBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5kZWZhdWx0VmFsdWUgIT09IHRvU3RyaW5nKHZhbHVlKSkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBldmVudFR5cGVzJDEgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25DaGFuZ2UnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNoYW5nZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtUT1BfQkxVUiwgVE9QX0NIQU5HRSwgVE9QX0NMSUNLLCBUT1BfRk9DVVMsIFRPUF9JTlBVVCwgVE9QX0tFWV9ET1dOLCBUT1BfS0VZX1VQLCBUT1BfU0VMRUNUSU9OX0NIQU5HRV1cbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMS5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gIC8vIEZsYWcgdGhpcyBldmVudCBsb29wIGFzIG5lZWRpbmcgc3RhdGUgcmVzdG9yZS5cbiAgZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIHJ1bkV2ZW50c0luQmF0Y2goZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCkge1xuICB2YXIgdGFyZ2V0Tm9kZSA9IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KTtcbiAgaWYgKHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKHRhcmdldE5vZGUpKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfQ0hBTkdFKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfRk9DVVMpIHtcbiAgICAvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfQkxVUikge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX1NFTEVDVElPTl9DSEFOR0UgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfS0VZX1VQIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX0tFWV9ET1dOKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9DTElDSykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0lOUFVUIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX0NIQU5HRSkge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cihub2RlKSB7XG4gIHZhciBzdGF0ZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZTtcblxuICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sbGVkIHx8IG5vZGUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWRpc2FibGVJbnB1dEF0dHJpYnV0ZVN5bmNpbmcpIHtcbiAgICAvLyBJZiBjb250cm9sbGVkLCBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSB0byB0aGUgY3VycmVudCB2YWx1ZSBvbiBibHVyXG4gICAgc2V0RGVmYXVsdFZhbHVlKG5vZGUsICdudW1iZXInLCBub2RlLnZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMSxcblxuICBfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOiBpc0lucHV0RXZlbnRTdXBwb3J0ZWQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jID0gdm9pZCAwLFxuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSB2b2lkIDA7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gVE9QX0JMVVIpIHtcbiAgICAgIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIodGFyZ2V0Tm9kZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGlzIGluamVjdGFibGUgaW50byBgRXZlbnRQbHVnaW5IdWJgLCB0aGF0IHNwZWNpZmllcyBhXG4gKiBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIG9mIGBFdmVudFBsdWdpbmBzLiBBIGNvbnZlbmllbnQgd2F5IHRvIHJlYXNvbiBhYm91dFxuICogcGx1Z2lucywgd2l0aG91dCBoYXZpbmcgdG8gcGFja2FnZSBldmVyeSBvbmUgb2YgdGhlbS4gVGhpcyBpcyBiZXR0ZXIgdGhhblxuICogaGF2aW5nIHBsdWdpbnMgYmUgb3JkZXJlZCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGluamVjdGVkIGJlY2F1c2VcbiAqIHRoYXQgb3JkZXJpbmcgd291bGQgYmUgaW5mbHVlbmNlZCBieSB0aGUgcGFja2FnaW5nIG9yZGVyLlxuICogYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBtdXN0IG9jY3VyIGJlZm9yZSBgU2ltcGxlRXZlbnRQbHVnaW5gIHNvIHRoYXRcbiAqIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBldmVudHMgaXMgY29udmVuaWVudCBpbiBgU2ltcGxlRXZlbnRQbHVnaW5gIGhhbmRsZXJzLlxuICovXG52YXIgRE9NRXZlbnRQbHVnaW5PcmRlciA9IFsnUmVzcG9uZGVyRXZlbnRQbHVnaW4nLCAnU2ltcGxlRXZlbnRQbHVnaW4nLCAnRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJywgJ0NoYW5nZUV2ZW50UGx1Z2luJywgJ1NlbGVjdEV2ZW50UGx1Z2luJywgJ0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nXTtcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSBTeW50aGV0aWNFdmVudC5leHRlbmQoe1xuICB2aWV3OiBudWxsLFxuICBkZXRhaWw6IG51bGxcbn0pO1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTtcblxuLy8gT2xkZXIgYnJvd3NlcnMgKFNhZmFyaSA8PSAxMCwgaU9TIFNhZmFyaSA8PSAxMC4yKSBkbyBub3Qgc3VwcG9ydFxuLy8gZ2V0TW9kaWZpZXJTdGF0ZS4gSWYgZ2V0TW9kaWZpZXJTdGF0ZSBpcyBub3Qgc3VwcG9ydGVkLCB3ZSBtYXAgaXQgdG8gYSBzZXQgb2Zcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQuIEluIHRoaXMgY2FzZSwgTG9jay1rZXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxudmFyIHByZXZpb3VzU2NyZWVuWCA9IDA7XG52YXIgcHJldmlvdXNTY3JlZW5ZID0gMDtcbi8vIFVzZSBmbGFncyB0byBzaWduYWwgbW92ZW1lbnRYL1kgaGFzIGFscmVhZHkgYmVlbiBzZXRcbnZhciBpc01vdmVtZW50WFNldCA9IGZhbHNlO1xudmFyIGlzTW92ZW1lbnRZU2V0ID0gZmFsc2U7XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIHBhZ2VYOiBudWxsLFxuICBwYWdlWTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IG51bGwsXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfSxcbiAgbW92ZW1lbnRYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoJ21vdmVtZW50WCcgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5tb3ZlbWVudFg7XG4gICAgfVxuXG4gICAgdmFyIHNjcmVlblggPSBwcmV2aW91c1NjcmVlblg7XG4gICAgcHJldmlvdXNTY3JlZW5YID0gZXZlbnQuc2NyZWVuWDtcblxuICAgIGlmICghaXNNb3ZlbWVudFhTZXQpIHtcbiAgICAgIGlzTW92ZW1lbnRYU2V0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJyA/IGV2ZW50LnNjcmVlblggLSBzY3JlZW5YIDogMDtcbiAgfSxcbiAgbW92ZW1lbnRZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoJ21vdmVtZW50WScgaW4gZXZlbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5tb3ZlbWVudFk7XG4gICAgfVxuXG4gICAgdmFyIHNjcmVlblkgPSBwcmV2aW91c1NjcmVlblk7XG4gICAgcHJldmlvdXNTY3JlZW5ZID0gZXZlbnQuc2NyZWVuWTtcblxuICAgIGlmICghaXNNb3ZlbWVudFlTZXQpIHtcbiAgICAgIGlzTW92ZW1lbnRZU2V0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJyA/IGV2ZW50LnNjcmVlblkgLSBzY3JlZW5ZIDogMDtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBQb2ludGVyRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY1BvaW50ZXJFdmVudCA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZXh0ZW5kKHtcbiAgcG9pbnRlcklkOiBudWxsLFxuICB3aWR0aDogbnVsbCxcbiAgaGVpZ2h0OiBudWxsLFxuICBwcmVzc3VyZTogbnVsbCxcbiAgdGFuZ2VudGlhbFByZXNzdXJlOiBudWxsLFxuICB0aWx0WDogbnVsbCxcbiAgdGlsdFk6IG51bGwsXG4gIHR3aXN0OiBudWxsLFxuICBwb2ludGVyVHlwZTogbnVsbCxcbiAgaXNQcmltYXJ5OiBudWxsXG59KTtcblxudmFyIGV2ZW50VHlwZXMkMiA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9NT1VTRV9PVVQsIFRPUF9NT1VTRV9PVkVSXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX01PVVNFX09VVCwgVE9QX01PVVNFX09WRVJdXG4gIH0sXG4gIHBvaW50ZXJFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvblBvaW50ZXJFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbVE9QX1BPSU5URVJfT1VULCBUT1BfUE9JTlRFUl9PVkVSXVxuICB9LFxuICBwb2ludGVyTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Qb2ludGVyTGVhdmUnLFxuICAgIGRlcGVuZGVuY2llczogW1RPUF9QT0lOVEVSX09VVCwgVE9QX1BPSU5URVJfT1ZFUl1cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQyLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgaXNPdmVyRXZlbnQgPSB0b3BMZXZlbFR5cGUgPT09IFRPUF9NT1VTRV9PVkVSIHx8IHRvcExldmVsVHlwZSA9PT0gVE9QX1BPSU5URVJfT1ZFUjtcbiAgICB2YXIgaXNPdXRFdmVudCA9IHRvcExldmVsVHlwZSA9PT0gVE9QX01PVVNFX09VVCB8fCB0b3BMZXZlbFR5cGUgPT09IFRPUF9QT0lOVEVSX09VVDtcblxuICAgIGlmIChpc092ZXJFdmVudCAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghaXNPdXRFdmVudCAmJiAhaXNPdmVyRXZlbnQpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2Ugb3IgcG9pbnRlciBpbiBvciBvdXQgLSBpZ25vcmluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aW4gPSB2b2lkIDA7XG4gICAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAgIC8vIGBuYXRpdmVFdmVudFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgICAgd2luID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbSA9IHZvaWQgMDtcbiAgICB2YXIgdG8gPSB2b2lkIDA7XG4gICAgaWYgKGlzT3V0RXZlbnQpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50SW50ZXJmYWNlID0gdm9pZCAwLFxuICAgICAgICBsZWF2ZUV2ZW50VHlwZSA9IHZvaWQgMCxcbiAgICAgICAgZW50ZXJFdmVudFR5cGUgPSB2b2lkIDAsXG4gICAgICAgIGV2ZW50VHlwZVByZWZpeCA9IHZvaWQgMDtcblxuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IFRPUF9NT1VTRV9PVVQgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfTU9VU0VfT1ZFUikge1xuICAgICAgZXZlbnRJbnRlcmZhY2UgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgbGVhdmVFdmVudFR5cGUgPSBldmVudFR5cGVzJDIubW91c2VMZWF2ZTtcbiAgICAgIGVudGVyRXZlbnRUeXBlID0gZXZlbnRUeXBlcyQyLm1vdXNlRW50ZXI7XG4gICAgICBldmVudFR5cGVQcmVmaXggPSAnbW91c2UnO1xuICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSBUT1BfUE9JTlRFUl9PVVQgfHwgdG9wTGV2ZWxUeXBlID09PSBUT1BfUE9JTlRFUl9PVkVSKSB7XG4gICAgICBldmVudEludGVyZmFjZSA9IFN5bnRoZXRpY1BvaW50ZXJFdmVudDtcbiAgICAgIGxlYXZlRXZlbnRUeXBlID0gZXZlbnRUeXBlcyQyLnBvaW50ZXJMZWF2ZTtcbiAgICAgIGVudGVyRXZlbnRUeXBlID0gZXZlbnRUeXBlcyQyLnBvaW50ZXJFbnRlcjtcbiAgICAgIGV2ZW50VHlwZVByZWZpeCA9ICdwb2ludGVyJztcbiAgICB9XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlJDEoZnJvbSk7XG4gICAgdmFyIHRvTm9kZSA9IHRvID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlJDEodG8pO1xuXG4gICAgdmFyIGxlYXZlID0gZXZlbnRJbnRlcmZhY2UuZ2V0UG9vbGVkKGxlYXZlRXZlbnRUeXBlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSBldmVudFR5cGVQcmVmaXggKyAnbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBldmVudEludGVyZmFjZS5nZXRQb29sZWQoZW50ZXJFdmVudFR5cGUsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSBldmVudFR5cGVQcmVmaXggKyAnZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cbn07XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgO1xufVxuXG52YXIgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkkMS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cblxuLyoqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXI7XG59XG5cbmZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyID0gdmFsdWU7XG59XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzLiBUaGV5J3JlIHVzZWQgYnkgUmVhY3QgRGV2IFRvb2xzLlxudmFyIE5vRWZmZWN0ID0gLyogICAgICAgICAgICAgICovMDtcbnZhciBQZXJmb3JtZWRXb3JrID0gLyogICAgICAgICAqLzE7XG5cbi8vIFlvdSBjYW4gY2hhbmdlIHRoZSByZXN0IChhbmQgYWRkIG1vcmUpLlxudmFyIFBsYWNlbWVudCA9IC8qICAgICAgICAgICAgICovMjtcbnZhciBVcGRhdGUgPSAvKiAgICAgICAgICAgICAgICAqLzQ7XG52YXIgUGxhY2VtZW50QW5kVXBkYXRlID0gLyogICAgKi82O1xudmFyIERlbGV0aW9uID0gLyogICAgICAgICAgICAgICovODtcbnZhciBDb250ZW50UmVzZXQgPSAvKiAgICAgICAgICAqLzE2O1xudmFyIENhbGxiYWNrID0gLyogICAgICAgICAgICAgICovMzI7XG52YXIgRGlkQ2FwdHVyZSA9IC8qICAgICAgICAgICAgKi82NDtcbnZhciBSZWYgPSAvKiAgICAgICAgICAgICAgICAgICAqLzEyODtcbnZhciBTbmFwc2hvdCA9IC8qICAgICAgICAgICAgICAqLzI1NjtcbnZhciBQYXNzaXZlID0gLyogICAgICAgICAgICAgICAqLzUxMjtcblxuLy8gUGFzc2l2ZSAmIFVwZGF0ZSAmIENhbGxiYWNrICYgUmVmICYgU25hcHNob3RcbnZhciBMaWZlY3ljbGVFZmZlY3RNYXNrID0gLyogICAqLzkzMjtcblxuLy8gVW5pb24gb2YgYWxsIGhvc3QgZWZmZWN0c1xudmFyIEhvc3RFZmZlY3RNYXNrID0gLyogICAgICAgICovMTAyMztcblxudmFyIEluY29tcGxldGUgPSAvKiAgICAgICAgICAgICovMTAyNDtcbnZhciBTaG91bGRDYXB0dXJlID0gLyogICAgICAgICAqLzIwNDg7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5cbnZhciBNT1VOVElORyA9IDE7XG52YXIgTU9VTlRFRCA9IDI7XG52YXIgVU5NT1VOVEVEID0gMztcblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIGlmICgobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpICE9PSBOb0VmZmVjdCkge1xuICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5yZXR1cm4pIHtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIGlmICgobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpICE9PSBOb0VmZmVjdCkge1xuICAgICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyB3YXMgYSBuZXN0ZWQgSG9zdFJvb3Qgd2hlbiB1c2VkIHdpdGhcbiAgICAvLyByZW5kZXJDb250YWluZXJJbnRvU3VidHJlZS5cbiAgICByZXR1cm4gTU9VTlRFRDtcbiAgfVxuICAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gIHJldHVybiBVTk1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkKGZpYmVyKSB7XG4gIHJldHVybiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBpc01vdW50ZWQoY29tcG9uZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICFpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyRmliZXIudHlwZSkgfHwgJ0EgY29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgIShpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIHN0YXRlID0gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKTtcbiAgICAhKHN0YXRlICE9PSBVTk1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgIGlmIChzdGF0ZSA9PT0gTU9VTlRJTkcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgLy8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4gIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cbiAgdmFyIGEgPSBmaWJlcjtcbiAgdmFyIGIgPSBhbHRlcm5hdGU7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEEgPSBhLnJldHVybjtcbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEgPyBwYXJlbnRBLmFsdGVybmF0ZSA6IG51bGw7XG4gICAgaWYgKCFwYXJlbnRBIHx8ICFwYXJlbnRCKSB7XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgIC8vIGFzc3VtZSB0aGF0IHRoZSBjaGlsZCBpcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlbiB3ZSBiYWlsb3V0IG9uIGxvd1xuICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgIWRpZEZpbmRDaGlsZCA/IGludmFyaWFudChmYWxzZSwgJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGEuYWx0ZXJuYXRlID09PSBiKSA/IGludmFyaWFudChmYWxzZSwgJ1JldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVyc1xcJyBhbHRlcm5hdGVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB9XG4gIC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cbiAgIShhLnRhZyA9PT0gSG9zdFJvb3QpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICBpZiAoYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSkge1xuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxuICByZXR1cm4gYWx0ZXJuYXRlO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgJiYgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZS5yZXR1cm4gfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50QnViYmxlTGlzdGVuZXIoZWxlbWVudCwgZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBhZGRFdmVudENhcHR1cmVMaXN0ZW5lcihlbGVtZW50LCBldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtYW5pbWF0aW9ucy8jQW5pbWF0aW9uRXZlbnQtaW50ZXJmYWNlXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BbmltYXRpb25FdmVudFxuICovXG52YXIgU3ludGhldGljQW5pbWF0aW9uRXZlbnQgPSBTeW50aGV0aWNFdmVudC5leHRlbmQoe1xuICBhbmltYXRpb25OYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jbGlwYm9hcmQtYXBpcy9cbiAqL1xudmFyIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50ID0gU3ludGhldGljRXZlbnQuZXh0ZW5kKHtcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/IGV2ZW50LmNsaXBib2FyZERhdGEgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBGb2N1c0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY0ZvY3VzRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIHJlbGF0ZWRUYXJnZXQ6IG51bGxcbn0pO1xuXG4vKipcbiAqIGBjaGFyQ29kZWAgcmVwcmVzZW50cyB0aGUgYWN0dWFsIFwiY2hhcmFjdGVyIGNvZGVcIiBhbmQgaXMgc2FmZSB0byB1c2Ugd2l0aFxuICogYFN0cmluZy5mcm9tQ2hhckNvZGVgLiBBcyBzdWNoLCBvbmx5IGtleXMgdGhhdCBjb3JyZXNwb25kIHRvIHByaW50YWJsZVxuICogY2hhcmFjdGVycyBwcm9kdWNlIGEgdmFsaWQgYGNoYXJDb2RlYCwgdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgRW50ZXIuXG4gKiBUaGUgVGFiLWtleSBpcyBjb25zaWRlcmVkIG5vbi1wcmludGFibGUgYW5kIGRvZXMgbm90IGhhdmUgYSBgY2hhckNvZGVgLFxuICogcHJlc3VtYWJseSBiZWNhdXNlIGl0IGRvZXMgbm90IHByb2R1Y2UgYSB0YWItY2hhcmFjdGVyIGluIGJyb3dzZXJzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge251bWJlcn0gTm9ybWFsaXplZCBgY2hhckNvZGVgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBjaGFyQ29kZSA9IHZvaWQgMDtcbiAgdmFyIGtleUNvZGUgPSBuYXRpdmVFdmVudC5rZXlDb2RlO1xuXG4gIGlmICgnY2hhckNvZGUnIGluIG5hdGl2ZUV2ZW50KSB7XG4gICAgY2hhckNvZGUgPSBuYXRpdmVFdmVudC5jaGFyQ29kZTtcblxuICAgIC8vIEZGIGRvZXMgbm90IHNldCBgY2hhckNvZGVgIGZvciB0aGUgRW50ZXIta2V5LCBjaGVjayBhZ2FpbnN0IGBrZXlDb2RlYC5cbiAgICBpZiAoY2hhckNvZGUgPT09IDAgJiYga2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIGNoYXJDb2RlID0gMTM7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgYGNoYXJDb2RlYCwgYnV0IGBrZXlDb2RlYCBoYXMgdGhlIGNvcnJlY3QgdmFsdWUuXG4gICAgY2hhckNvZGUgPSBrZXlDb2RlO1xuICB9XG5cbiAgLy8gSUUgYW5kIEVkZ2UgKG9uIFdpbmRvd3MpIGFuZCBDaHJvbWUgLyBTYWZhcmkgKG9uIFdpbmRvd3MgYW5kIExpbnV4KVxuICAvLyByZXBvcnQgRW50ZXIgYXMgY2hhckNvZGUgMTAgd2hlbiBjdHJsIGlzIHByZXNzZWQuXG4gIGlmIChjaGFyQ29kZSA9PT0gMTApIHtcbiAgICBjaGFyQ29kZSA9IDEzO1xuICB9XG5cbiAgLy8gU29tZSBub24tcHJpbnRhYmxlIGtleXMgYXJlIHJlcG9ydGVkIGluIGBjaGFyQ29kZWAvYGtleUNvZGVgLCBkaXNjYXJkIHRoZW0uXG4gIC8vIE11c3Qgbm90IGRpc2NhcmQgdGhlIChub24tKXByaW50YWJsZSBFbnRlci1rZXkuXG4gIGlmIChjaGFyQ29kZSA+PSAzMiB8fCBjaGFyQ29kZSA9PT0gMTMpIHtcbiAgICByZXR1cm4gY2hhckNvZGU7XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICBFc2M6ICdFc2NhcGUnLFxuICBTcGFjZWJhcjogJyAnLFxuICBMZWZ0OiAnQXJyb3dMZWZ0JyxcbiAgVXA6ICdBcnJvd1VwJyxcbiAgUmlnaHQ6ICdBcnJvd1JpZ2h0JyxcbiAgRG93bjogJ0Fycm93RG93bicsXG4gIERlbDogJ0RlbGV0ZScsXG4gIFdpbjogJ09TJyxcbiAgTWVudTogJ0NvbnRleHRNZW51JyxcbiAgQXBwczogJ0NvbnRleHRNZW51JyxcbiAgU2Nyb2xsOiAnU2Nyb2xsTG9jaycsXG4gIE1velByaW50YWJsZUtleTogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gICc4JzogJ0JhY2tzcGFjZScsXG4gICc5JzogJ1RhYicsXG4gICcxMic6ICdDbGVhcicsXG4gICcxMyc6ICdFbnRlcicsXG4gICcxNic6ICdTaGlmdCcsXG4gICcxNyc6ICdDb250cm9sJyxcbiAgJzE4JzogJ0FsdCcsXG4gICcxOSc6ICdQYXVzZScsXG4gICcyMCc6ICdDYXBzTG9jaycsXG4gICcyNyc6ICdFc2NhcGUnLFxuICAnMzInOiAnICcsXG4gICczMyc6ICdQYWdlVXAnLFxuICAnMzQnOiAnUGFnZURvd24nLFxuICAnMzUnOiAnRW5kJyxcbiAgJzM2JzogJ0hvbWUnLFxuICAnMzcnOiAnQXJyb3dMZWZ0JyxcbiAgJzM4JzogJ0Fycm93VXAnLFxuICAnMzknOiAnQXJyb3dSaWdodCcsXG4gICc0MCc6ICdBcnJvd0Rvd24nLFxuICAnNDUnOiAnSW5zZXJ0JyxcbiAgJzQ2JzogJ0RlbGV0ZScsXG4gICcxMTInOiAnRjEnLFxuICAnMTEzJzogJ0YyJyxcbiAgJzExNCc6ICdGMycsXG4gICcxMTUnOiAnRjQnLFxuICAnMTE2JzogJ0Y1JyxcbiAgJzExNyc6ICdGNicsXG4gICcxMTgnOiAnRjcnLFxuICAnMTE5JzogJ0Y4JyxcbiAgJzEyMCc6ICdGOScsXG4gICcxMjEnOiAnRjEwJyxcbiAgJzEyMic6ICdGMTEnLFxuICAnMTIzJzogJ0YxMicsXG4gICcxNDQnOiAnTnVtTG9jaycsXG4gICcxNDUnOiAnU2Nyb2xsTG9jaycsXG4gICcyMjQnOiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IFN5bnRoZXRpY1VJRXZlbnQuZXh0ZW5kKHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIERyYWdFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmV4dGVuZCh7XG4gIGRhdGFUcmFuc2ZlcjogbnVsbFxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBUb3VjaEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL3RvdWNoLWV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSBTeW50aGV0aWNVSUV2ZW50LmV4dGVuZCh7XG4gIHRvdWNoZXM6IG51bGwsXG4gIHRhcmdldFRvdWNoZXM6IG51bGwsXG4gIGNoYW5nZWRUb3VjaGVzOiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbn0pO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwOS9XRC1jc3MzLXRyYW5zaXRpb25zLTIwMDkwMzIwLyN0cmFuc2l0aW9uLWV2ZW50cy1cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RyYW5zaXRpb25FdmVudFxuICovXG52YXIgU3ludGhldGljVHJhbnNpdGlvbkV2ZW50ID0gU3ludGhldGljRXZlbnQuZXh0ZW5kKHtcbiAgcHJvcGVydHlOYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBXaGVlbEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFN5bnRoZXRpY1doZWVsRXZlbnQgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmV4dGVuZCh7XG4gIGRlbHRhWDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVgnIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFYIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFYYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKHJpZ2h0IGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVgnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFYIDogMDtcbiAgfSxcbiAgZGVsdGFZOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWScgaW4gZXZlbnQgPyBldmVudC5kZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhYCBmb3IgSUU8OSBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YSA6IDA7XG4gIH0sXG5cbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59KTtcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFtUT1BfQUJPUlRdLFxuICogICB9LFxuICogICAuLi5cbiAqIH07XG4gKiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSBuZXcgTWFwKFtcbiAqICAgW1RPUF9BQk9SVCwgeyBzYW1lQ29uZmlnIH1dLFxuICogXSk7XG4gKi9cblxudmFyIGludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMgPSBbW1RPUF9CTFVSLCAnYmx1ciddLCBbVE9QX0NBTkNFTCwgJ2NhbmNlbCddLCBbVE9QX0NMSUNLLCAnY2xpY2snXSwgW1RPUF9DTE9TRSwgJ2Nsb3NlJ10sIFtUT1BfQ09OVEVYVF9NRU5VLCAnY29udGV4dE1lbnUnXSwgW1RPUF9DT1BZLCAnY29weSddLCBbVE9QX0NVVCwgJ2N1dCddLCBbVE9QX0FVWF9DTElDSywgJ2F1eENsaWNrJ10sIFtUT1BfRE9VQkxFX0NMSUNLLCAnZG91YmxlQ2xpY2snXSwgW1RPUF9EUkFHX0VORCwgJ2RyYWdFbmQnXSwgW1RPUF9EUkFHX1NUQVJULCAnZHJhZ1N0YXJ0J10sIFtUT1BfRFJPUCwgJ2Ryb3AnXSwgW1RPUF9GT0NVUywgJ2ZvY3VzJ10sIFtUT1BfSU5QVVQsICdpbnB1dCddLCBbVE9QX0lOVkFMSUQsICdpbnZhbGlkJ10sIFtUT1BfS0VZX0RPV04sICdrZXlEb3duJ10sIFtUT1BfS0VZX1BSRVNTLCAna2V5UHJlc3MnXSwgW1RPUF9LRVlfVVAsICdrZXlVcCddLCBbVE9QX01PVVNFX0RPV04sICdtb3VzZURvd24nXSwgW1RPUF9NT1VTRV9VUCwgJ21vdXNlVXAnXSwgW1RPUF9QQVNURSwgJ3Bhc3RlJ10sIFtUT1BfUEFVU0UsICdwYXVzZSddLCBbVE9QX1BMQVksICdwbGF5J10sIFtUT1BfUE9JTlRFUl9DQU5DRUwsICdwb2ludGVyQ2FuY2VsJ10sIFtUT1BfUE9JTlRFUl9ET1dOLCAncG9pbnRlckRvd24nXSwgW1RPUF9QT0lOVEVSX1VQLCAncG9pbnRlclVwJ10sIFtUT1BfUkFURV9DSEFOR0UsICdyYXRlQ2hhbmdlJ10sIFtUT1BfUkVTRVQsICdyZXNldCddLCBbVE9QX1NFRUtFRCwgJ3NlZWtlZCddLCBbVE9QX1NVQk1JVCwgJ3N1Ym1pdCddLCBbVE9QX1RPVUNIX0NBTkNFTCwgJ3RvdWNoQ2FuY2VsJ10sIFtUT1BfVE9VQ0hfRU5ELCAndG91Y2hFbmQnXSwgW1RPUF9UT1VDSF9TVEFSVCwgJ3RvdWNoU3RhcnQnXSwgW1RPUF9WT0xVTUVfQ0hBTkdFLCAndm9sdW1lQ2hhbmdlJ11dO1xudmFyIG5vbkludGVyYWN0aXZlRXZlbnRUeXBlTmFtZXMgPSBbW1RPUF9BQk9SVCwgJ2Fib3J0J10sIFtUT1BfQU5JTUFUSU9OX0VORCwgJ2FuaW1hdGlvbkVuZCddLCBbVE9QX0FOSU1BVElPTl9JVEVSQVRJT04sICdhbmltYXRpb25JdGVyYXRpb24nXSwgW1RPUF9BTklNQVRJT05fU1RBUlQsICdhbmltYXRpb25TdGFydCddLCBbVE9QX0NBTl9QTEFZLCAnY2FuUGxheSddLCBbVE9QX0NBTl9QTEFZX1RIUk9VR0gsICdjYW5QbGF5VGhyb3VnaCddLCBbVE9QX0RSQUcsICdkcmFnJ10sIFtUT1BfRFJBR19FTlRFUiwgJ2RyYWdFbnRlciddLCBbVE9QX0RSQUdfRVhJVCwgJ2RyYWdFeGl0J10sIFtUT1BfRFJBR19MRUFWRSwgJ2RyYWdMZWF2ZSddLCBbVE9QX0RSQUdfT1ZFUiwgJ2RyYWdPdmVyJ10sIFtUT1BfRFVSQVRJT05fQ0hBTkdFLCAnZHVyYXRpb25DaGFuZ2UnXSwgW1RPUF9FTVBUSUVELCAnZW1wdGllZCddLCBbVE9QX0VOQ1JZUFRFRCwgJ2VuY3J5cHRlZCddLCBbVE9QX0VOREVELCAnZW5kZWQnXSwgW1RPUF9FUlJPUiwgJ2Vycm9yJ10sIFtUT1BfR09UX1BPSU5URVJfQ0FQVFVSRSwgJ2dvdFBvaW50ZXJDYXB0dXJlJ10sIFtUT1BfTE9BRCwgJ2xvYWQnXSwgW1RPUF9MT0FERURfREFUQSwgJ2xvYWRlZERhdGEnXSwgW1RPUF9MT0FERURfTUVUQURBVEEsICdsb2FkZWRNZXRhZGF0YSddLCBbVE9QX0xPQURfU1RBUlQsICdsb2FkU3RhcnQnXSwgW1RPUF9MT1NUX1BPSU5URVJfQ0FQVFVSRSwgJ2xvc3RQb2ludGVyQ2FwdHVyZSddLCBbVE9QX01PVVNFX01PVkUsICdtb3VzZU1vdmUnXSwgW1RPUF9NT1VTRV9PVVQsICdtb3VzZU91dCddLCBbVE9QX01PVVNFX09WRVIsICdtb3VzZU92ZXInXSwgW1RPUF9QTEFZSU5HLCAncGxheWluZyddLCBbVE9QX1BPSU5URVJfTU9WRSwgJ3BvaW50ZXJNb3ZlJ10sIFtUT1BfUE9JTlRFUl9PVVQsICdwb2ludGVyT3V0J10sIFtUT1BfUE9JTlRFUl9PVkVSLCAncG9pbnRlck92ZXInXSwgW1RPUF9QUk9HUkVTUywgJ3Byb2dyZXNzJ10sIFtUT1BfU0NST0xMLCAnc2Nyb2xsJ10sIFtUT1BfU0VFS0lORywgJ3NlZWtpbmcnXSwgW1RPUF9TVEFMTEVELCAnc3RhbGxlZCddLCBbVE9QX1NVU1BFTkQsICdzdXNwZW5kJ10sIFtUT1BfVElNRV9VUERBVEUsICd0aW1lVXBkYXRlJ10sIFtUT1BfVE9HR0xFLCAndG9nZ2xlJ10sIFtUT1BfVE9VQ0hfTU9WRSwgJ3RvdWNoTW92ZSddLCBbVE9QX1RSQU5TSVRJT05fRU5ELCAndHJhbnNpdGlvbkVuZCddLCBbVE9QX1dBSVRJTkcsICd3YWl0aW5nJ10sIFtUT1BfV0hFRUwsICd3aGVlbCddXTtcblxudmFyIGV2ZW50VHlwZXMkNCA9IHt9O1xudmFyIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHt9O1xuXG5mdW5jdGlvbiBhZGRFdmVudFR5cGVOYW1lVG9Db25maWcoX3JlZiwgaXNJbnRlcmFjdGl2ZSkge1xuICB2YXIgdG9wRXZlbnQgPSBfcmVmWzBdLFxuICAgICAgZXZlbnQgPSBfcmVmWzFdO1xuXG4gIHZhciBjYXBpdGFsaXplZEV2ZW50ID0gZXZlbnRbMF0udG9VcHBlckNhc2UoKSArIGV2ZW50LnNsaWNlKDEpO1xuICB2YXIgb25FdmVudCA9ICdvbicgKyBjYXBpdGFsaXplZEV2ZW50O1xuXG4gIHZhciB0eXBlID0ge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBvbkV2ZW50LFxuICAgICAgY2FwdHVyZWQ6IG9uRXZlbnQgKyAnQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcEV2ZW50XSxcbiAgICBpc0ludGVyYWN0aXZlOiBpc0ludGVyYWN0aXZlXG4gIH07XG4gIGV2ZW50VHlwZXMkNFtldmVudF0gPSB0eXBlO1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wRXZlbnRdID0gdHlwZTtcbn1cblxuaW50ZXJhY3RpdmVFdmVudFR5cGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR1cGxlKSB7XG4gIGFkZEV2ZW50VHlwZU5hbWVUb0NvbmZpZyhldmVudFR1cGxlLCB0cnVlKTtcbn0pO1xubm9uSW50ZXJhY3RpdmVFdmVudFR5cGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFR1cGxlKSB7XG4gIGFkZEV2ZW50VHlwZU5hbWVUb0NvbmZpZyhldmVudFR1cGxlLCBmYWxzZSk7XG59KTtcblxuLy8gT25seSB1c2VkIGluIERFViBmb3IgZXhoYXVzdGl2ZW5lc3MgdmFsaWRhdGlvbi5cbnZhciBrbm93bkhUTUxUb3BMZXZlbFR5cGVzID0gW1RPUF9BQk9SVCwgVE9QX0NBTkNFTCwgVE9QX0NBTl9QTEFZLCBUT1BfQ0FOX1BMQVlfVEhST1VHSCwgVE9QX0NMT1NFLCBUT1BfRFVSQVRJT05fQ0hBTkdFLCBUT1BfRU1QVElFRCwgVE9QX0VOQ1JZUFRFRCwgVE9QX0VOREVELCBUT1BfRVJST1IsIFRPUF9JTlBVVCwgVE9QX0lOVkFMSUQsIFRPUF9MT0FELCBUT1BfTE9BREVEX0RBVEEsIFRPUF9MT0FERURfTUVUQURBVEEsIFRPUF9MT0FEX1NUQVJULCBUT1BfUEFVU0UsIFRPUF9QTEFZLCBUT1BfUExBWUlORywgVE9QX1BST0dSRVNTLCBUT1BfUkFURV9DSEFOR0UsIFRPUF9SRVNFVCwgVE9QX1NFRUtFRCwgVE9QX1NFRUtJTkcsIFRPUF9TVEFMTEVELCBUT1BfU1VCTUlULCBUT1BfU1VTUEVORCwgVE9QX1RJTUVfVVBEQVRFLCBUT1BfVE9HR0xFLCBUT1BfVk9MVU1FX0NIQU5HRSwgVE9QX1dBSVRJTkddO1xuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkNCxcblxuICBpc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGU6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUpIHtcbiAgICB2YXIgY29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgcmV0dXJuIGNvbmZpZyAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy5pc0ludGVyYWN0aXZlID09PSB0cnVlO1xuICB9LFxuXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlIFRPUF9LRVlfUFJFU1M6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRPUF9LRVlfRE9XTjpcbiAgICAgIGNhc2UgVE9QX0tFWV9VUDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfQkxVUjpcbiAgICAgIGNhc2UgVE9QX0ZPQ1VTOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRPUF9DTElDSzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRPUF9BVVhfQ0xJQ0s6XG4gICAgICBjYXNlIFRPUF9ET1VCTEVfQ0xJQ0s6XG4gICAgICBjYXNlIFRPUF9NT1VTRV9ET1dOOlxuICAgICAgY2FzZSBUT1BfTU9VU0VfTU9WRTpcbiAgICAgIGNhc2UgVE9QX01PVVNFX1VQOlxuICAgICAgLy8gVE9ETzogRGlzYWJsZWQgZWxlbWVudHMgc2hvdWxkIG5vdCByZXNwb25kIHRvIG1vdXNlIGV2ZW50c1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUT1BfTU9VU0VfT1VUOlxuICAgICAgY2FzZSBUT1BfTU9VU0VfT1ZFUjpcbiAgICAgIGNhc2UgVE9QX0NPTlRFWFRfTUVOVTpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfRFJBRzpcbiAgICAgIGNhc2UgVE9QX0RSQUdfRU5EOlxuICAgICAgY2FzZSBUT1BfRFJBR19FTlRFUjpcbiAgICAgIGNhc2UgVE9QX0RSQUdfRVhJVDpcbiAgICAgIGNhc2UgVE9QX0RSQUdfTEVBVkU6XG4gICAgICBjYXNlIFRPUF9EUkFHX09WRVI6XG4gICAgICBjYXNlIFRPUF9EUkFHX1NUQVJUOlxuICAgICAgY2FzZSBUT1BfRFJPUDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRPUF9UT1VDSF9DQU5DRUw6XG4gICAgICBjYXNlIFRPUF9UT1VDSF9FTkQ6XG4gICAgICBjYXNlIFRPUF9UT1VDSF9NT1ZFOlxuICAgICAgY2FzZSBUT1BfVE9VQ0hfU1RBUlQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVE9QX0FOSU1BVElPTl9FTkQ6XG4gICAgICBjYXNlIFRPUF9BTklNQVRJT05fSVRFUkFUSU9OOlxuICAgICAgY2FzZSBUT1BfQU5JTUFUSU9OX1NUQVJUOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQW5pbWF0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfVFJBTlNJVElPTl9FTkQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfU0NST0xMOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRPUF9XSEVFTDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfQ09QWTpcbiAgICAgIGNhc2UgVE9QX0NVVDpcbiAgICAgIGNhc2UgVE9QX1BBU1RFOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfR09UX1BPSU5URVJfQ0FQVFVSRTpcbiAgICAgIGNhc2UgVE9QX0xPU1RfUE9JTlRFUl9DQVBUVVJFOlxuICAgICAgY2FzZSBUT1BfUE9JTlRFUl9DQU5DRUw6XG4gICAgICBjYXNlIFRPUF9QT0lOVEVSX0RPV046XG4gICAgICBjYXNlIFRPUF9QT0lOVEVSX01PVkU6XG4gICAgICBjYXNlIFRPUF9QT0lOVEVSX09VVDpcbiAgICAgIGNhc2UgVE9QX1BPSU5URVJfT1ZFUjpcbiAgICAgIGNhc2UgVE9QX1BPSU5URVJfVVA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNQb2ludGVyRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChrbm93bkhUTUxUb3BMZXZlbFR5cGVzLmluZGV4T2YodG9wTGV2ZWxUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1NpbXBsZUV2ZW50UGx1Z2luOiBVbmhhbmRsZWQgZXZlbnQgdHlwZSwgYCVzYC4gVGhpcyB3YXJuaW5nICcgKyAnaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgdG9wTGV2ZWxUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSFRNTCBFdmVudHNcbiAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9pbmRleC5odG1sI2V2ZW50cy0wXG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxufTtcblxudmFyIGlzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZSA9IFNpbXBsZUV2ZW50UGx1Z2luLmlzSW50ZXJhY3RpdmVUb3BMZXZlbEV2ZW50VHlwZTtcblxuXG52YXIgQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFID0gMTA7XG52YXIgY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUm9vdENvbnRhaW5lck5vZGUoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdC5yZXR1cm4pIHtcbiAgICBpbnN0ID0gaW5zdC5yZXR1cm47XG4gIH1cbiAgaWYgKGluc3QudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB3ZSdyZSBpbiBhIGRldGFjaGVkIHRyZWUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGluc3Quc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpIHtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnBvcCgpO1xuICAgIGluc3RhbmNlLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGluc3RhbmNlLnRhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcExldmVsVHlwZTogdG9wTGV2ZWxUeXBlLFxuICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRJbnN0OiB0YXJnZXRJbnN0LFxuICAgIGFuY2VzdG9yczogW11cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyhpbnN0YW5jZSkge1xuICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSBudWxsO1xuICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG51bGw7XG4gIGluc3RhbmNlLnRhcmdldEluc3QgPSBudWxsO1xuICBpbnN0YW5jZS5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCA8IENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSkge1xuICAgIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nKSB7XG4gIHZhciB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcudGFyZ2V0SW5zdDtcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdGFyZ2V0SW5zdDtcbiAgZG8ge1xuICAgIGlmICghYW5jZXN0b3IpIHtcbiAgICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgcm9vdCA9IGZpbmRSb290Q29udGFpbmVyTm9kZShhbmNlc3Rvcik7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocm9vdCk7XG4gIH0gd2hpbGUgKGFuY2VzdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldEluc3QgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgcnVuRXh0cmFjdGVkRXZlbnRzSW5CYXRjaChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cbnZhciBfZW5hYmxlZCA9IHRydWU7XG5cbmZ1bmN0aW9uIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICBfZW5hYmxlZCA9ICEhZW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5cbi8qKlxuICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wTGV2ZWxUeXBlIE51bWJlciBmcm9tIGBUb3BMZXZlbEV2ZW50VHlwZXNgLlxuICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgZGlzcGF0Y2ggPSBpc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGUodG9wTGV2ZWxUeXBlKSA/IGRpc3BhdGNoSW50ZXJhY3RpdmVFdmVudCA6IGRpc3BhdGNoRXZlbnQ7XG5cbiAgYWRkRXZlbnRCdWJibGVMaXN0ZW5lcihlbGVtZW50LCBnZXRSYXdFdmVudE5hbWUodG9wTGV2ZWxUeXBlKSxcbiAgLy8gQ2hlY2sgaWYgaW50ZXJhY3RpdmUgYW5kIHdyYXAgaW4gaW50ZXJhY3RpdmVVcGRhdGVzXG4gIGRpc3BhdGNoLmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbi8qKlxuICogVHJhcHMgYSB0b3AtbGV2ZWwgZXZlbnQgYnkgdXNpbmcgZXZlbnQgY2FwdHVyaW5nLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3BMZXZlbFR5cGUgTnVtYmVyIGZyb20gYFRvcExldmVsRXZlbnRUeXBlc2AuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgZGlzcGF0Y2ggPSBpc0ludGVyYWN0aXZlVG9wTGV2ZWxFdmVudFR5cGUodG9wTGV2ZWxUeXBlKSA/IGRpc3BhdGNoSW50ZXJhY3RpdmVFdmVudCA6IGRpc3BhdGNoRXZlbnQ7XG5cbiAgYWRkRXZlbnRDYXB0dXJlTGlzdGVuZXIoZWxlbWVudCwgZ2V0UmF3RXZlbnROYW1lKHRvcExldmVsVHlwZSksXG4gIC8vIENoZWNrIGlmIGludGVyYWN0aXZlIGFuZCB3cmFwIGluIGludGVyYWN0aXZlVXBkYXRlc1xuICBkaXNwYXRjaC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEludGVyYWN0aXZlRXZlbnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBpbnRlcmFjdGl2ZVVwZGF0ZXMoZGlzcGF0Y2hFdmVudCwgdG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBpZiAoIV9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldEluc3QudGFnID09PSAnbnVtYmVyJyAmJiAhaXNGaWJlck1vdW50ZWQodGFyZ2V0SW5zdCkpIHtcbiAgICAvLyBJZiB3ZSBnZXQgYW4gZXZlbnQgKGV4OiBpbWcgb25sb2FkKSBiZWZvcmUgY29tbWl0dGluZyB0aGF0XG4gICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAvLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4gICAgLy8gZGlzcGF0Y2hpbmcgdGhlbSBhZnRlciB0aGUgbW91bnQuXG4gICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gIH1cblxuICB2YXIgYm9va0tlZXBpbmcgPSBnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICBiYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbCwgYm9va0tlZXBpbmcpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoYm9va0tlZXBpbmcpO1xuICB9XG59XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnRcbiAqICAgIHBsdWdnYWJsZSBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW5cbiAqICAgIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArICgnJyArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gKlxuICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICpcbiAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBtb3VudEF0IENvbnRhaW5lciB3aGVyZSB0byBtb3VudCB0aGUgbGlzdGVuZXJcbiAqL1xuZnVuY3Rpb24gbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgbW91bnRBdCkge1xuICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIHN3aXRjaCAoZGVwZW5kZW5jeSkge1xuICAgICAgICBjYXNlIFRPUF9TQ1JPTEw6XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoVE9QX1NDUk9MTCwgbW91bnRBdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVE9QX0ZPQ1VTOlxuICAgICAgICBjYXNlIFRPUF9CTFVSOlxuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KFRPUF9GT0NVUywgbW91bnRBdCk7XG4gICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoVE9QX0JMVVIsIG1vdW50QXQpO1xuICAgICAgICAgIC8vIFdlIHNldCB0aGUgZmxhZyBmb3IgYSBzaW5nbGUgZGVwZW5kZW5jeSBsYXRlciBpbiB0aGlzIGZ1bmN0aW9uLFxuICAgICAgICAgIC8vIGJ1dCB0aGlzIGVuc3VyZXMgd2UgbWFyayBib3RoIGFzIGF0dGFjaGVkIHJhdGhlciB0aGFuIGp1c3Qgb25lLlxuICAgICAgICAgIGlzTGlzdGVuaW5nW1RPUF9CTFVSXSA9IHRydWU7XG4gICAgICAgICAgaXNMaXN0ZW5pbmdbVE9QX0ZPQ1VTXSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgVE9QX0NBTkNFTDpcbiAgICAgICAgY2FzZSBUT1BfQ0xPU0U6XG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoZ2V0UmF3RXZlbnROYW1lKGRlcGVuZGVuY3kpKSkge1xuICAgICAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoZGVwZW5kZW5jeSwgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRPUF9JTlZBTElEOlxuICAgICAgICBjYXNlIFRPUF9TVUJNSVQ6XG4gICAgICAgIGNhc2UgVE9QX1JFU0VUOlxuICAgICAgICAgIC8vIFdlIGxpc3RlbiB0byB0aGVtIG9uIHRoZSB0YXJnZXQgRE9NIGVsZW1lbnRzLlxuICAgICAgICAgIC8vIFNvbWUgb2YgdGhlbSBidWJibGUgc28gd2UgZG9uJ3Qgd2FudCB0aGVtIHRvIGZpcmUgdHdpY2UuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gQnkgZGVmYXVsdCwgbGlzdGVuIG9uIHRoZSB0b3AgbGV2ZWwgdG8gYWxsIG5vbi1tZWRpYSBldmVudHMuXG4gICAgICAgICAgLy8gTWVkaWEgZXZlbnRzIGRvbid0IGJ1YmJsZSBzbyBhZGRpbmcgdGhlIGxpc3RlbmVyIHdvdWxkbid0IGRvIGFueXRoaW5nLlxuICAgICAgICAgIHZhciBpc01lZGlhRXZlbnQgPSBtZWRpYUV2ZW50VHlwZXMuaW5kZXhPZihkZXBlbmRlbmN5KSAhPT0gLTE7XG4gICAgICAgICAgaWYgKCFpc01lZGlhRXZlbnQpIHtcbiAgICAgICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgbW91bnRBdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKHJlZ2lzdHJhdGlvbk5hbWUsIG1vdW50QXQpIHtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIHtcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBvdXRlck5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gb3V0ZXJOb2RlLm93bmVyRG9jdW1lbnQ7XG5cbiAgdmFyIHdpbiA9IG93bmVyRG9jdW1lbnQgJiYgb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uICYmIHdpbi5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZSxcbiAgICAgIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG5cbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBhbmNob3JOb2RlLm5vZGVUeXBlO1xuICAgIGZvY3VzTm9kZS5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpO1xufVxuXG4vKipcbiAqIFJldHVybnMge3N0YXJ0LCBlbmR9IHdoZXJlIGBzdGFydGAgaXMgdGhlIGNoYXJhY3Rlci9jb2RlcG9pbnQgaW5kZXggb2ZcbiAqIChhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQpIHdpdGhpbiB0aGUgdGV4dENvbnRlbnQgb2YgYG91dGVyTm9kZWAsIGFuZFxuICogYGVuZGAgaXMgdGhlIGluZGV4IG9mIChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KS5cbiAqXG4gKiBSZXR1cm5zIG51bGwgaWYgeW91IHBhc3MgaW4gZ2FyYmFnZSBpbnB1dCBidXQgd2Ugc2hvdWxkIHByb2JhYmx5IGp1c3QgY3Jhc2guXG4gKlxuICogRXhwb3J0ZWQgb25seSBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMob3V0ZXJOb2RlLCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpIHtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBzdGFydCA9IC0xO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBpbmRleFdpdGhpbkFuY2hvciA9IDA7XG4gIHZhciBpbmRleFdpdGhpbkZvY3VzID0gMDtcbiAgdmFyIG5vZGUgPSBvdXRlck5vZGU7XG4gIHZhciBwYXJlbnROb2RlID0gbnVsbDtcblxuICBvdXRlcjogd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IGFuY2hvck5vZGUgJiYgKGFuY2hvck9mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoICsgYW5jaG9yT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGZvY3VzTm9kZSAmJiAoZm9jdXNPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBlbmQgPSBsZW5ndGggKyBmb2N1c09mZnNldDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgICBsZW5ndGggKz0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBpZiAoKG5leHQgPSBub2RlLmZpcnN0Q2hpbGQpID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBmaXJzdCBjaGlsZCBgbmV4dGAuXG4gICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gb3V0ZXJOb2RlKSB7XG4gICAgICAgIC8vIElmIGBvdXRlck5vZGVgIGhhcyBjaGlsZHJlbiwgdGhpcyBpcyBhbHdheXMgdGhlIHNlY29uZCB0aW1lIHZpc2l0aW5nXG4gICAgICAgIC8vIGl0LiBJZiBpdCBoYXMgbm8gY2hpbGRyZW4sIHRoaXMgaXMgc3RpbGwgdGhlIGZpcnN0IGxvb3AsIGFuZCB0aGUgb25seVxuICAgICAgICAvLyB2YWxpZCBzZWxlY3Rpb24gaXMgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGJvdGggZXF1YWwgdG8gdGhpcyBub2RlXG4gICAgICAgIC8vIGFuZCBib3RoIG9mZnNldHMgMCwgaW4gd2hpY2ggY2FzZSB3ZSB3aWxsIGhhdmUgaGFuZGxlZCBhYm92ZS5cbiAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gYW5jaG9yTm9kZSAmJiArK2luZGV4V2l0aGluQW5jaG9yID09PSBhbmNob3JPZmZzZXQpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PT0gZm9jdXNOb2RlICYmICsraW5kZXhXaXRoaW5Gb2N1cyA9PT0gZm9jdXNPZmZzZXQpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5uZXh0U2libGluZykgIT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBub2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gTW92aW5nIGZyb20gYG5vZGVgIHRvIGl0cyBuZXh0IHNpYmxpbmcgYG5leHRgLlxuICAgIG5vZGUgPSBuZXh0O1xuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgPT09IC0xKSB7XG4gICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLiAoV291bGQgaGFwcGVuIGlmIHRoZSBhbmNob3IvZm9jdXMgbm9kZXMgYXJlbid0XG4gICAgLy8gYWN0dWFsbHkgaW5zaWRlIHRoZSBwYXNzZWQtaW4gbm9kZS4pXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGVuZFxuICB9O1xufVxuXG4vKipcbiAqIEluIG1vZGVybiBub24tSUUgYnJvd3NlcnMsIHdlIGNhbiBzdXBwb3J0IGJvdGggZm9yd2FyZCBhbmQgYmFja3dhcmRcbiAqIHNlbGVjdGlvbnMuXG4gKlxuICogTm90ZTogSUUxMCsgc3VwcG9ydHMgdGhlIFNlbGVjdGlvbiBvYmplY3QsIGJ1dCBpdCBkb2VzIG5vdCBzdXBwb3J0XG4gKiB0aGUgYGV4dGVuZGAgbWV0aG9kLCB3aGljaCBtZWFucyB0aGF0IGV2ZW4gaW4gbW9kZXJuIElFLCBpdCdzIG5vdCBwb3NzaWJsZVxuICogdG8gcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBiYWNrd2FyZCBzZWxlY3Rpb24uIFRodXMsIGZvciBhbGwgSUVcbiAqIHZlcnNpb25zLCB3ZSB1c2UgdGhlIG9sZCBJRSBBUEkgdG8gY3JlYXRlIG91ciBzZWxlY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAqL1xuZnVuY3Rpb24gc2V0T2Zmc2V0cyhub2RlLCBvZmZzZXRzKSB7XG4gIHZhciBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gIHZhciB3aW4gPSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcblxuICAvLyBFZGdlIGZhaWxzIHdpdGggXCJPYmplY3QgZXhwZWN0ZWRcIiBpbiBzb21lIHNjZW5hcmlvcy5cbiAgLy8gKEZvciBpbnN0YW5jZTogVGlueU1DRSBlZGl0b3IgdXNlZCBpbiBhIGxpc3QgY29tcG9uZW50IHRoYXQgc3VwcG9ydHMgcGFzdGluZyB0byBhZGQgbW9yZSxcbiAgLy8gZmFpbHMgd2hlbiBwYXN0aW5nIDEwMCsgaXRlbXMpXG4gIGlmICghd2luLmdldFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gIHZhciBsZW5ndGggPSBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDEgJiYgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHN0YXJ0TWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gc3RhcnRNYXJrZXIub2Zmc2V0ICYmIHNlbGVjdGlvbi5mb2N1c05vZGUgPT09IGVuZE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gZW5kTWFya2VyLm9mZnNldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmFuZ2UgPSBkb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzSW5Eb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUub3duZXJEb2N1bWVudCAmJiBjb250YWluc05vZGUobm9kZS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yaWdpbkZyYW1lKGlmcmFtZSkge1xuICB0cnkge1xuICAgIC8vIEFjY2Vzc2luZyB0aGUgY29udGVudERvY3VtZW50IG9mIGEgSFRNTElmcmFtZUVsZW1lbnQgY2FuIGNhdXNlIHRoZSBicm93c2VyXG4gICAgLy8gdG8gdGhyb3csIGUuZy4gaWYgaXQgaGFzIGEgY3Jvc3Mtb3JpZ2luIHNyYyBhdHRyaWJ1dGUuXG4gICAgLy8gU2FmYXJpIHdpbGwgc2hvdyBhbiBlcnJvciBpbiB0aGUgY29uc29sZSB3aGVuIHRoZSBhY2Nlc3MgcmVzdWx0cyBpbiBcIkJsb2NrZWQgYSBmcmFtZSB3aXRoIG9yaWdpblwiLiBlLmc6XG4gICAgLy8gaWZyYW1lLmNvbnRlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAvLyBBIHNhZmV0eSB3YXkgaXMgdG8gYWNjZXNzIG9uZSBvZiB0aGUgY3Jvc3Mgb3JpZ2luIHByb3BlcnRpZXM6IFdpbmRvdyBvciBMb2NhdGlvblxuICAgIC8vIFdoaWNoIG1pZ2h0IHJlc3VsdCBpbiBcIlNlY3VyaXR5RXJyb3JcIiBET00gRXhjZXB0aW9uIGFuZCBpdCBpcyBjb21wYXRpYmxlIHRvIFNhZmFyaS5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9icm93c2Vycy5odG1sI2ludGVncmF0aW9uLXdpdGgtaWRsXG5cbiAgICByZXR1cm4gdHlwZW9mIGlmcmFtZS5jb250ZW50V2luZG93LmxvY2F0aW9uLmhyZWYgPT09ICdzdHJpbmcnO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudERlZXAoKSB7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBlbGVtZW50ID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICB3aGlsZSAoZWxlbWVudCBpbnN0YW5jZW9mIHdpbi5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgIGlmIChpc1NhbWVPcmlnaW5GcmFtZShlbGVtZW50KSkge1xuICAgICAgd2luID0gZWxlbWVudC5jb250ZW50V2luZG93O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgZWxlbWVudCA9IGdldEFjdGl2ZUVsZW1lbnQod2luLmRvY3VtZW50KTtcbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBAUmVhY3RJbnB1dFNlbGVjdGlvbjogUmVhY3QgaW5wdXQgc2VsZWN0aW9uIG1vZHVsZS4gQmFzZWQgb24gU2VsZWN0aW9uLmpzLFxuICogYnV0IG1vZGlmaWVkIHRvIGJlIHN1aXRhYmxlIGZvciByZWFjdCBhbmQgaGFzIGEgY291cGxlIG9mIGJ1ZyBmaXhlcyAoZG9lc24ndFxuICogYXNzdW1lIGJ1dHRvbnMgaGF2ZSByYW5nZSBzZWxlY3Rpb25zIGFsbG93ZWQpLlxuICogSW5wdXQgc2VsZWN0aW9uIG1vZHVsZSBmb3IgUmVhY3QuXG4gKi9cblxuLyoqXG4gKiBAaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiB3ZSBnZXQgdGhlIGVsZW1lbnQgdHlwZXMgdGhhdCBzdXBwb3J0IHNlbGVjdGlvblxuICogZnJvbSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNkby1ub3QtYXBwbHksIGxvb2tpbmcgYXQgYHNlbGVjdGlvblN0YXJ0YFxuICogYW5kIGBzZWxlY3Rpb25FbmRgIHJvd3MuXG4gKi9cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IGVsZW0udHlwZSA9PT0gJ3NlYXJjaCcgfHwgZWxlbS50eXBlID09PSAndGVsJyB8fCBlbGVtLnR5cGUgPT09ICd1cmwnIHx8IGVsZW0udHlwZSA9PT0gJ3Bhc3N3b3JkJykgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCkge1xuICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50RGVlcCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbiQxKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cbmZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50RGVlcCgpO1xuICB2YXIgcHJpb3JGb2N1c2VkRWxlbSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uZm9jdXNlZEVsZW07XG4gIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgaWYgKGN1ckZvY3VzZWRFbGVtICE9PSBwcmlvckZvY3VzZWRFbGVtICYmIGlzSW5Eb2N1bWVudChwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgIGlmIChwcmlvclNlbGVjdGlvblJhbmdlICE9PSBudWxsICYmIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cblxuICAgIC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwcmlvckZvY3VzZWRFbGVtLmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcmlvckZvY3VzZWRFbGVtLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uJDEoaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHZvaWQgMDtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbn1cblxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGlucHV0LCBvZmZzZXRzKSB7XG4gIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQsXG4gICAgICBlbmQgPSBvZmZzZXRzLmVuZDtcblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzdGFydDtcbiAgfVxuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gIH1cbn1cblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IGNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzJDMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtUT1BfQkxVUiwgVE9QX0NPTlRFWFRfTUVOVSwgVE9QX0RSQUdfRU5ELCBUT1BfRk9DVVMsIFRPUF9LRVlfRE9XTiwgVE9QX0tFWV9VUCwgVE9QX01PVVNFX0RPV04sIFRPUF9NT1VTRV9VUCwgVE9QX1NFTEVDVElPTl9DSEFOR0VdXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHdpbiA9IG5vZGUub3duZXJEb2N1bWVudCAmJiBub2RlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW4uZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgZG9jdW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudCB0YXJnZXQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gKiBAcmV0dXJuIHtEb2N1bWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChldmVudFRhcmdldCkge1xuICByZXR1cm4gZXZlbnRUYXJnZXQud2luZG93ID09PSBldmVudFRhcmdldCA/IGV2ZW50VGFyZ2V0LmRvY3VtZW50IDogZXZlbnRUYXJnZXQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyBldmVudFRhcmdldCA6IGV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG59XG5cbi8qKlxuICogUG9sbCBzZWxlY3Rpb24gdG8gc2VlIHdoZXRoZXIgaXQncyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50VGFyZ2V0XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICB2YXIgZG9jID0gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKG1vdXNlRG93biB8fCBhY3RpdmVFbGVtZW50JDEgPT0gbnVsbCB8fCBhY3RpdmVFbGVtZW50JDEgIT09IGdldEFjdGl2ZUVsZW1lbnQoZG9jKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50JDEpO1xuICBpZiAoIWxhc3RTZWxlY3Rpb24gfHwgIXNoYWxsb3dFcXVhbChsYXN0U2VsZWN0aW9uLCBjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgIGxhc3RTZWxlY3Rpb24gPSBjdXJyZW50U2VsZWN0aW9uO1xuXG4gICAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gU3ludGhldGljRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMy5zZWxlY3QsIGFjdGl2ZUVsZW1lbnRJbnN0JDEsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudCQxO1xuXG4gICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZG9jID0gZ2V0RXZlbnRUYXJnZXREb2N1bWVudChuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgLy8gVHJhY2sgd2hldGhlciBhbGwgbGlzdGVuZXJzIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4gICAgLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG4gICAgaWYgKCFkb2MgfHwgIWlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMoJ29uU2VsZWN0JywgZG9jKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSBUT1BfRk9DVVM6XG4gICAgICAgIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkgfHwgdGFyZ2V0Tm9kZS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJykge1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IHRhcmdldE5vZGU7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudEluc3QkMSA9IHRhcmdldEluc3Q7XG4gICAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRPUF9CTFVSOlxuICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgVE9QX01PVVNFX0RPV046XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUT1BfQ09OVEVYVF9NRU5VOlxuICAgICAgY2FzZSBUT1BfTU9VU0VfVVA6XG4gICAgICBjYXNlIFRPUF9EUkFHX0VORDpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSBUT1BfU0VMRUNUSU9OX0NIQU5HRTpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlIFRPUF9LRVlfRE9XTjpcbiAgICAgIGNhc2UgVE9QX0tFWV9VUDpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKi9cbmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERPTUV2ZW50UGx1Z2luT3JkZXIpO1xuc2V0Q29tcG9uZW50VHJlZShnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEsIGdldEluc3RhbmNlRnJvbU5vZGUkMSwgZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKTtcblxuLyoqXG4gKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAqIHRoZW0pLlxuICovXG5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgU2ltcGxlRXZlbnRQbHVnaW46IFNpbXBsZUV2ZW50UGx1Z2luLFxuICBFbnRlckxlYXZlRXZlbnRQbHVnaW46IEVudGVyTGVhdmVFdmVudFBsdWdpbixcbiAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICBTZWxlY3RFdmVudFBsdWdpbjogU2VsZWN0RXZlbnRQbHVnaW4sXG4gIEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cbn0pO1xuXG52YXIgZGlkV2FyblNlbGVjdGVkU2V0T25PcHRpb24gPSBmYWxzZTtcbnZhciBkaWRXYXJuSW52YWxpZENoaWxkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsYXR0ZW5DaGlsZHJlbihjaGlsZHJlbikge1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIC8vIEZsYXR0ZW4gY2hpbGRyZW4uIFdlJ2xsIHdhcm4gaWYgdGhleSBhcmUgaW52YWxpZFxuICAvLyBkdXJpbmcgdmFsaWRhdGVQcm9wcygpIHdoaWNoIHJ1bnMgZm9yIGh5ZHJhdGlvbiB0b28uXG4gIC8vIE5vdGUgdGhhdCB0aGlzIHdvdWxkIHRocm93IG9uIG5vbi1lbGVtZW50IG9iamVjdHMuXG4gIC8vIEVsZW1lbnRzIGFyZSBzdHJpbmdpZmllZCAod2hpY2ggaXMgbm9ybWFsbHkgaXJyZWxldmFudFxuICAvLyBidXQgbWF0dGVycyBmb3IgPGZidD4pLlxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIC8vIE5vdGU6IHdlIGRvbid0IHdhcm4gYWJvdXQgaW52YWxpZCBjaGlsZHJlbiBoZXJlLlxuICAgIC8vIEluc3RlYWQsIHRoaXMgaXMgZG9uZSBzZXBhcmF0ZWx5IGJlbG93IHNvIHRoYXRcbiAgICAvLyBpdCBoYXBwZW5zIGR1cmluZyB0aGUgaHlkcmF0aW9uIGNvZGVwYXRoIHRvby5cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICB7XG4gICAgLy8gVGhpcyBtaXJyb3JzIHRoZSBjb2RlcGF0aCBhYm92ZSwgYnV0IHJ1bnMgZm9yIGh5ZHJhdGlvbiB0b28uXG4gICAgLy8gV2FybiBhYm91dCBpbnZhbGlkIGNoaWxkcmVuIGhlcmUgc28gdGhhdCBjbGllbnQgYW5kIGh5ZHJhdGlvbiBhcmUgY29uc2lzdGVudC5cbiAgICAvLyBUT0RPOiB0aGlzIHNlZW1zIGxpa2UgaXQgY291bGQgY2F1c2UgYSBERVYtb25seSB0aHJvdyBmb3IgaHlkcmF0aW9uXG4gICAgLy8gaWYgY2hpbGRyZW4gY29udGFpbnMgYSBub24tZWxlbWVudCBvYmplY3QuIFdlIHNob3VsZCB0cnkgdG8gYXZvaWQgdGhhdC5cbiAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnb2JqZWN0JyAmJiBwcm9wcy5jaGlsZHJlbiAhPT0gbnVsbCkge1xuICAgICAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjaGlsZC50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRpZFdhcm5JbnZhbGlkQ2hpbGQpIHtcbiAgICAgICAgICBkaWRXYXJuSW52YWxpZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgaWYgKHByb3BzLnNlbGVjdGVkICE9IG51bGwgJiYgIWRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKTtcbiAgICAgIGRpZFdhcm5TZWxlY3RlZFNldE9uT3B0aW9uID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIHZhbHVlPVwiXCIgc2hvdWxkIG1ha2UgYSB2YWx1ZSBhdHRyaWJ1dGUgKCM2MjE5KVxuICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcHMudmFsdWUpKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcbiAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IHZvaWQgMDtcblxue1xuICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcbiAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobm9kZSwgbXVsdGlwbGUsIHByb3BWYWx1ZSwgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gIHZhciBvcHRpb25zID0gbm9kZS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHZhciBzZWxlY3RlZFZhbHVlcyA9IHByb3BWYWx1ZTtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9wdGlvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KCckJyArIG9wdGlvbnNbX2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW19pXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9IHRvU3RyaW5nKGdldFRvU3RyaW5nVmFsdWUocHJvcFZhbHVlKSk7XG4gICAgdmFyIGRlZmF1bHRTZWxlY3RlZCA9IG51bGw7XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgb3B0aW9ucy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICBpZiAob3B0aW9uc1tfaTJdLnZhbHVlID09PSBfc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW19pMl0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tfaTJdLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRTZWxlY3RlZCA9PT0gbnVsbCAmJiAhb3B0aW9uc1tfaTJdLmRpc2FibGVkKSB7XG4gICAgICAgIGRlZmF1bHRTZWxlY3RlZCA9IG9wdGlvbnNbX2kyXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFNlbGVjdGVkLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUubXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdFVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgd2FzTXVsdGlwbGUgPSBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSAhIXByb3BzLm11bHRpcGxlKSB7XG4gICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLm11bHRpcGxlID8gW10gOiAnJywgZmFsc2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJykgOiB2b2lkIDA7XG5cbiAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4gIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitTb3BoaWUgc2VlbWVkIHRvIGxpa2UgdGhpc1xuICAvLyBzb2x1dGlvbi4gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWRcbiAgLy8gdG8gYmUgYSBzdHJpbmcuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hpbGRyZW46IHRvU3RyaW5nKG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcyk7XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWxEZWZhdWx0VmFsKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICclcyBjb250YWlucyBhIHRleHRhcmVhIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgfVxuICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IGdldFRvU3RyaW5nVmFsdWUoaW5pdGlhbFZhbHVlKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBnZXRUb1N0cmluZ1ZhbHVlKHByb3BzLnZhbHVlKTtcbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IGdldFRvU3RyaW5nVmFsdWUocHJvcHMuZGVmYXVsdFZhbHVlKTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICB2YXIgbmV3VmFsdWUgPSB0b1N0cmluZyh2YWx1ZSk7XG4gICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsICYmIG5vZGUuZGVmYXVsdFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSB0b1N0cmluZyhkZWZhdWx0VmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gIHZhciB0ZXh0Q29udGVudCA9IG5vZGUudGV4dENvbnRlbnQ7XG5cbiAgLy8gT25seSBzZXQgbm9kZS52YWx1ZSBpZiB0ZXh0Q29udGVudCBpcyBlcXVhbCB0byB0aGUgZXhwZWN0ZWRcbiAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgLy8gd2lsbCBwb3B1bGF0ZSB0ZXh0Q29udGVudCBhcyB3ZWxsLlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDE1MjUvXG4gIGlmICh0ZXh0Q29udGVudCA9PT0gbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSkge1xuICAgIG5vZGUudmFsdWUgPSB0ZXh0Q29udGVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKTtcbn1cblxudmFyIEhUTUxfTkFNRVNQQUNFJDEgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG52YXIgTUFUSF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG52YXIgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5cbnZhciBOYW1lc3BhY2VzID0ge1xuICBodG1sOiBIVE1MX05BTUVTUEFDRSQxLFxuICBtYXRobWw6IE1BVEhfTkFNRVNQQUNFLFxuICBzdmc6IFNWR19OQU1FU1BBQ0Vcbn07XG5cbi8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcbiAgICBjYXNlICdtYXRoJzpcbiAgICAgIHJldHVybiBNQVRIX05BTUVTUEFDRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFJDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAvLyBObyAob3IgZGVmYXVsdCkgcGFyZW50IG5hbWVzcGFjZTogcG90ZW50aWFsIGVudHJ5IHBvaW50LlxuICAgIHJldHVybiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxuICAvLyBCeSBkZWZhdWx0LCBwYXNzIG5hbWVzcGFjZSBiZWxvdy5cbiAgcmV0dXJuIHBhcmVudE5hbWVzcGFjZTtcbn1cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bmN0aW9uIHdoaWNoIGhhcyAndW5zYWZlJyBwcml2aWxlZ2VzIChyZXF1aXJlZCBieSB3aW5kb3dzOCBhcHBzKVxuICovXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxufTtcblxuLy8gU1ZHIHRlbXAgY29udGFpbmVyIGZvciBJRSBsYWNraW5nIGlubmVySFRNTFxudmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gdm9pZCAwO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZVxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0SW5uZXJIVE1MID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAvLyB0aGUgdGFyZ2V0IG5vZGVcblxuICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IE5hbWVzcGFjZXMuc3ZnICYmICEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sICsgJzwvc3ZnPic7XG4gICAgdmFyIHN2Z05vZGUgPSByZXVzYWJsZVNWR0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgd2hpbGUgKHN2Z05vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLiBGb3IgdGV4dCB1cGRhdGVzLCBpdCdzIGZhc3RlclxuICogdG8gc2V0IHRoZSBgbm9kZVZhbHVlYCBvZiB0aGUgVGV4dCBub2RlIGRpcmVjdGx5IGluc3RlYWQgb2YgdXNpbmdcbiAqIGAudGV4dENvbnRlbnRgIHdoaWNoIHdpbGwgcmVtb3ZlIHRoZSBleGlzdGluZyBub2RlIGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuLy8gTGlzdCBkZXJpdmVkIGZyb20gR2Vja28gc291cmNlIGNvZGU6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9nZWNrby1kZXYvYmxvYi80ZTYzOGVmYzcxL2xheW91dC9zdHlsZS90ZXN0L3Byb3BlcnR5X2RhdGFiYXNlLmpzXG52YXIgc2hvcnRoYW5kVG9Mb25naGFuZCA9IHtcbiAgYW5pbWF0aW9uOiBbJ2FuaW1hdGlvbkRlbGF5JywgJ2FuaW1hdGlvbkRpcmVjdGlvbicsICdhbmltYXRpb25EdXJhdGlvbicsICdhbmltYXRpb25GaWxsTW9kZScsICdhbmltYXRpb25JdGVyYXRpb25Db3VudCcsICdhbmltYXRpb25OYW1lJywgJ2FuaW1hdGlvblBsYXlTdGF0ZScsICdhbmltYXRpb25UaW1pbmdGdW5jdGlvbiddLFxuICBiYWNrZ3JvdW5kOiBbJ2JhY2tncm91bmRBdHRhY2htZW50JywgJ2JhY2tncm91bmRDbGlwJywgJ2JhY2tncm91bmRDb2xvcicsICdiYWNrZ3JvdW5kSW1hZ2UnLCAnYmFja2dyb3VuZE9yaWdpbicsICdiYWNrZ3JvdW5kUG9zaXRpb25YJywgJ2JhY2tncm91bmRQb3NpdGlvblknLCAnYmFja2dyb3VuZFJlcGVhdCcsICdiYWNrZ3JvdW5kU2l6ZSddLFxuICBiYWNrZ3JvdW5kUG9zaXRpb246IFsnYmFja2dyb3VuZFBvc2l0aW9uWCcsICdiYWNrZ3JvdW5kUG9zaXRpb25ZJ10sXG4gIGJvcmRlcjogWydib3JkZXJCb3R0b21Db2xvcicsICdib3JkZXJCb3R0b21TdHlsZScsICdib3JkZXJCb3R0b21XaWR0aCcsICdib3JkZXJJbWFnZU91dHNldCcsICdib3JkZXJJbWFnZVJlcGVhdCcsICdib3JkZXJJbWFnZVNsaWNlJywgJ2JvcmRlckltYWdlU291cmNlJywgJ2JvcmRlckltYWdlV2lkdGgnLCAnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlckxlZnRTdHlsZScsICdib3JkZXJMZWZ0V2lkdGgnLCAnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJSaWdodFN0eWxlJywgJ2JvcmRlclJpZ2h0V2lkdGgnLCAnYm9yZGVyVG9wQ29sb3InLCAnYm9yZGVyVG9wU3R5bGUnLCAnYm9yZGVyVG9wV2lkdGgnXSxcbiAgYm9yZGVyQmxvY2tFbmQ6IFsnYm9yZGVyQmxvY2tFbmRDb2xvcicsICdib3JkZXJCbG9ja0VuZFN0eWxlJywgJ2JvcmRlckJsb2NrRW5kV2lkdGgnXSxcbiAgYm9yZGVyQmxvY2tTdGFydDogWydib3JkZXJCbG9ja1N0YXJ0Q29sb3InLCAnYm9yZGVyQmxvY2tTdGFydFN0eWxlJywgJ2JvcmRlckJsb2NrU3RhcnRXaWR0aCddLFxuICBib3JkZXJCb3R0b206IFsnYm9yZGVyQm90dG9tQ29sb3InLCAnYm9yZGVyQm90dG9tU3R5bGUnLCAnYm9yZGVyQm90dG9tV2lkdGgnXSxcbiAgYm9yZGVyQ29sb3I6IFsnYm9yZGVyQm90dG9tQ29sb3InLCAnYm9yZGVyTGVmdENvbG9yJywgJ2JvcmRlclJpZ2h0Q29sb3InLCAnYm9yZGVyVG9wQ29sb3InXSxcbiAgYm9yZGVySW1hZ2U6IFsnYm9yZGVySW1hZ2VPdXRzZXQnLCAnYm9yZGVySW1hZ2VSZXBlYXQnLCAnYm9yZGVySW1hZ2VTbGljZScsICdib3JkZXJJbWFnZVNvdXJjZScsICdib3JkZXJJbWFnZVdpZHRoJ10sXG4gIGJvcmRlcklubGluZUVuZDogWydib3JkZXJJbmxpbmVFbmRDb2xvcicsICdib3JkZXJJbmxpbmVFbmRTdHlsZScsICdib3JkZXJJbmxpbmVFbmRXaWR0aCddLFxuICBib3JkZXJJbmxpbmVTdGFydDogWydib3JkZXJJbmxpbmVTdGFydENvbG9yJywgJ2JvcmRlcklubGluZVN0YXJ0U3R5bGUnLCAnYm9yZGVySW5saW5lU3RhcnRXaWR0aCddLFxuICBib3JkZXJMZWZ0OiBbJ2JvcmRlckxlZnRDb2xvcicsICdib3JkZXJMZWZ0U3R5bGUnLCAnYm9yZGVyTGVmdFdpZHRoJ10sXG4gIGJvcmRlclJhZGl1czogWydib3JkZXJCb3R0b21MZWZ0UmFkaXVzJywgJ2JvcmRlckJvdHRvbVJpZ2h0UmFkaXVzJywgJ2JvcmRlclRvcExlZnRSYWRpdXMnLCAnYm9yZGVyVG9wUmlnaHRSYWRpdXMnXSxcbiAgYm9yZGVyUmlnaHQ6IFsnYm9yZGVyUmlnaHRDb2xvcicsICdib3JkZXJSaWdodFN0eWxlJywgJ2JvcmRlclJpZ2h0V2lkdGgnXSxcbiAgYm9yZGVyU3R5bGU6IFsnYm9yZGVyQm90dG9tU3R5bGUnLCAnYm9yZGVyTGVmdFN0eWxlJywgJ2JvcmRlclJpZ2h0U3R5bGUnLCAnYm9yZGVyVG9wU3R5bGUnXSxcbiAgYm9yZGVyVG9wOiBbJ2JvcmRlclRvcENvbG9yJywgJ2JvcmRlclRvcFN0eWxlJywgJ2JvcmRlclRvcFdpZHRoJ10sXG4gIGJvcmRlcldpZHRoOiBbJ2JvcmRlckJvdHRvbVdpZHRoJywgJ2JvcmRlckxlZnRXaWR0aCcsICdib3JkZXJSaWdodFdpZHRoJywgJ2JvcmRlclRvcFdpZHRoJ10sXG4gIGNvbHVtblJ1bGU6IFsnY29sdW1uUnVsZUNvbG9yJywgJ2NvbHVtblJ1bGVTdHlsZScsICdjb2x1bW5SdWxlV2lkdGgnXSxcbiAgY29sdW1uczogWydjb2x1bW5Db3VudCcsICdjb2x1bW5XaWR0aCddLFxuICBmbGV4OiBbJ2ZsZXhCYXNpcycsICdmbGV4R3JvdycsICdmbGV4U2hyaW5rJ10sXG4gIGZsZXhGbG93OiBbJ2ZsZXhEaXJlY3Rpb24nLCAnZmxleFdyYXAnXSxcbiAgZm9udDogWydmb250RmFtaWx5JywgJ2ZvbnRGZWF0dXJlU2V0dGluZ3MnLCAnZm9udEtlcm5pbmcnLCAnZm9udExhbmd1YWdlT3ZlcnJpZGUnLCAnZm9udFNpemUnLCAnZm9udFNpemVBZGp1c3QnLCAnZm9udFN0cmV0Y2gnLCAnZm9udFN0eWxlJywgJ2ZvbnRWYXJpYW50JywgJ2ZvbnRWYXJpYW50QWx0ZXJuYXRlcycsICdmb250VmFyaWFudENhcHMnLCAnZm9udFZhcmlhbnRFYXN0QXNpYW4nLCAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLCAnZm9udFZhcmlhbnROdW1lcmljJywgJ2ZvbnRWYXJpYW50UG9zaXRpb24nLCAnZm9udFdlaWdodCcsICdsaW5lSGVpZ2h0J10sXG4gIGZvbnRWYXJpYW50OiBbJ2ZvbnRWYXJpYW50QWx0ZXJuYXRlcycsICdmb250VmFyaWFudENhcHMnLCAnZm9udFZhcmlhbnRFYXN0QXNpYW4nLCAnZm9udFZhcmlhbnRMaWdhdHVyZXMnLCAnZm9udFZhcmlhbnROdW1lcmljJywgJ2ZvbnRWYXJpYW50UG9zaXRpb24nXSxcbiAgZ2FwOiBbJ2NvbHVtbkdhcCcsICdyb3dHYXAnXSxcbiAgZ3JpZDogWydncmlkQXV0b0NvbHVtbnMnLCAnZ3JpZEF1dG9GbG93JywgJ2dyaWRBdXRvUm93cycsICdncmlkVGVtcGxhdGVBcmVhcycsICdncmlkVGVtcGxhdGVDb2x1bW5zJywgJ2dyaWRUZW1wbGF0ZVJvd3MnXSxcbiAgZ3JpZEFyZWE6IFsnZ3JpZENvbHVtbkVuZCcsICdncmlkQ29sdW1uU3RhcnQnLCAnZ3JpZFJvd0VuZCcsICdncmlkUm93U3RhcnQnXSxcbiAgZ3JpZENvbHVtbjogWydncmlkQ29sdW1uRW5kJywgJ2dyaWRDb2x1bW5TdGFydCddLFxuICBncmlkQ29sdW1uR2FwOiBbJ2NvbHVtbkdhcCddLFxuICBncmlkR2FwOiBbJ2NvbHVtbkdhcCcsICdyb3dHYXAnXSxcbiAgZ3JpZFJvdzogWydncmlkUm93RW5kJywgJ2dyaWRSb3dTdGFydCddLFxuICBncmlkUm93R2FwOiBbJ3Jvd0dhcCddLFxuICBncmlkVGVtcGxhdGU6IFsnZ3JpZFRlbXBsYXRlQXJlYXMnLCAnZ3JpZFRlbXBsYXRlQ29sdW1ucycsICdncmlkVGVtcGxhdGVSb3dzJ10sXG4gIGxpc3RTdHlsZTogWydsaXN0U3R5bGVJbWFnZScsICdsaXN0U3R5bGVQb3NpdGlvbicsICdsaXN0U3R5bGVUeXBlJ10sXG4gIG1hcmdpbjogWydtYXJnaW5Cb3R0b20nLCAnbWFyZ2luTGVmdCcsICdtYXJnaW5SaWdodCcsICdtYXJnaW5Ub3AnXSxcbiAgbWFya2VyOiBbJ21hcmtlckVuZCcsICdtYXJrZXJNaWQnLCAnbWFya2VyU3RhcnQnXSxcbiAgbWFzazogWydtYXNrQ2xpcCcsICdtYXNrQ29tcG9zaXRlJywgJ21hc2tJbWFnZScsICdtYXNrTW9kZScsICdtYXNrT3JpZ2luJywgJ21hc2tQb3NpdGlvblgnLCAnbWFza1Bvc2l0aW9uWScsICdtYXNrUmVwZWF0JywgJ21hc2tTaXplJ10sXG4gIG1hc2tQb3NpdGlvbjogWydtYXNrUG9zaXRpb25YJywgJ21hc2tQb3NpdGlvblknXSxcbiAgb3V0bGluZTogWydvdXRsaW5lQ29sb3InLCAnb3V0bGluZVN0eWxlJywgJ291dGxpbmVXaWR0aCddLFxuICBvdmVyZmxvdzogWydvdmVyZmxvd1gnLCAnb3ZlcmZsb3dZJ10sXG4gIHBhZGRpbmc6IFsncGFkZGluZ0JvdHRvbScsICdwYWRkaW5nTGVmdCcsICdwYWRkaW5nUmlnaHQnLCAncGFkZGluZ1RvcCddLFxuICBwbGFjZUNvbnRlbnQ6IFsnYWxpZ25Db250ZW50JywgJ2p1c3RpZnlDb250ZW50J10sXG4gIHBsYWNlSXRlbXM6IFsnYWxpZ25JdGVtcycsICdqdXN0aWZ5SXRlbXMnXSxcbiAgcGxhY2VTZWxmOiBbJ2FsaWduU2VsZicsICdqdXN0aWZ5U2VsZiddLFxuICB0ZXh0RGVjb3JhdGlvbjogWyd0ZXh0RGVjb3JhdGlvbkNvbG9yJywgJ3RleHREZWNvcmF0aW9uTGluZScsICd0ZXh0RGVjb3JhdGlvblN0eWxlJ10sXG4gIHRleHRFbXBoYXNpczogWyd0ZXh0RW1waGFzaXNDb2xvcicsICd0ZXh0RW1waGFzaXNTdHlsZSddLFxuICB0cmFuc2l0aW9uOiBbJ3RyYW5zaXRpb25EZWxheScsICd0cmFuc2l0aW9uRHVyYXRpb24nLCAndHJhbnNpdGlvblByb3BlcnR5JywgJ3RyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiddLFxuICB3b3JkV3JhcDogWydvdmVyZmxvd1dyYXAnXVxufTtcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IHRydWUsXG4gIGJvcmRlckltYWdlU2xpY2U6IHRydWUsXG4gIGJvcmRlckltYWdlV2lkdGg6IHRydWUsXG4gIGJveEZsZXg6IHRydWUsXG4gIGJveEZsZXhHcm91cDogdHJ1ZSxcbiAgYm94T3JkaW5hbEdyb3VwOiB0cnVlLFxuICBjb2x1bW5Db3VudDogdHJ1ZSxcbiAgY29sdW1uczogdHJ1ZSxcbiAgZmxleDogdHJ1ZSxcbiAgZmxleEdyb3c6IHRydWUsXG4gIGZsZXhQb3NpdGl2ZTogdHJ1ZSxcbiAgZmxleFNocmluazogdHJ1ZSxcbiAgZmxleE5lZ2F0aXZlOiB0cnVlLFxuICBmbGV4T3JkZXI6IHRydWUsXG4gIGdyaWRBcmVhOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcblxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhKGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHZhbHVlKS50cmltKCk7XG59XG5cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKHVwcGVyY2FzZVBhdHRlcm4sICctJDEnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG4gIHZhciBtc1BhdHRlcm4kMSA9IC9eLW1zLS87XG4gIHZhciBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuICAvLyBzdHlsZSB2YWx1ZXMgc2hvdWxkbid0IGNvbnRhaW4gYSBzZW1pY29sb25cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuXG4gIHZhciB3YXJuZWRTdHlsZU5hbWVzID0ge307XG4gIHZhciB3YXJuZWRTdHlsZVZhbHVlcyA9IHt9O1xuICB2YXIgd2FybmVkRm9yTmFOVmFsdWUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSBmYWxzZTtcblxuICB2YXIgY2FtZWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGh5cGhlblBhdHRlcm4sIGZ1bmN0aW9uIChfLCBjaGFyYWN0ZXIpIHtcbiAgICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsXG4gICAgLy8gQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICAgIC8vIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAgICAvLyBpcyBjb252ZXJ0ZWQgdG8gbG93ZXJjYXNlIGBtc2AuXG4gICAgY2FtZWxpemUobmFtZS5yZXBsYWNlKG1zUGF0dGVybiQxLCAnbXMtJykpKTtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnVW5zdXBwb3J0ZWQgdmVuZG9yLXByZWZpeGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVWYWx1ZXMuaGFzT3duUHJvcGVydHkodmFsdWUpICYmIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlVmFsdWVzW3ZhbHVlXSA9IHRydWU7XG4gICAgd2FybmluZyQxKGZhbHNlLCBcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc05hTiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyQxKGZhbHNlLCAnYEluZmluaXR5YCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJywgbmFtZSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAobmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNOYU4obmFtZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIHZhciBkZWxpbWl0ZXIgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcykge1xuICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAge1xuICAgICAgaWYgKCFpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlJDEoc3R5bGVOYW1lLCBzdHlsZXNbc3R5bGVOYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBpc0N1c3RvbVByb3BlcnR5KTtcbiAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICBzdHlsZU5hbWUgPSAnY3NzRmxvYXQnO1xuICAgIH1cbiAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzVmFsdWVFbXB0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG59XG5cbi8qKlxuICogR2l2ZW4ge2NvbG9yOiAncmVkJywgb3ZlcmZsb3c6ICdoaWRkZW4nfSByZXR1cm5zIHtcbiAqICAgY29sb3I6ICdjb2xvcicsXG4gKiAgIG92ZXJmbG93WDogJ292ZXJmbG93JyxcbiAqICAgb3ZlcmZsb3dZOiAnb3ZlcmZsb3cnLFxuICogfS4gVGhpcyBjYW4gYmUgcmVhZCBhcyBcInRoZSBvdmVyZmxvd1kgcHJvcGVydHkgd2FzIHNldCBieSB0aGUgb3ZlcmZsb3dcbiAqIHNob3J0aGFuZFwiLiBUaGF0IGlzLCB0aGUgdmFsdWVzIGFyZSB0aGUgcHJvcGVydHkgdGhhdCBlYWNoIHdhcyBkZXJpdmVkIGZyb20uXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZFNob3J0aGFuZE1hcChzdHlsZXMpIHtcbiAgdmFyIGV4cGFuZGVkID0ge307XG4gIGZvciAodmFyIGtleSBpbiBzdHlsZXMpIHtcbiAgICB2YXIgbG9uZ2hhbmRzID0gc2hvcnRoYW5kVG9Mb25naGFuZFtrZXldIHx8IFtrZXldO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9uZ2hhbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBleHBhbmRlZFtsb25naGFuZHNbaV1dID0ga2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwYW5kZWQ7XG59XG5cbi8qKlxuICogV2hlbiBtaXhpbmcgc2hvcnRoYW5kIGFuZCBsb25naGFuZCBwcm9wZXJ0eSBuYW1lcywgd2Ugd2FybiBkdXJpbmcgdXBkYXRlcyBpZlxuICogd2UgZXhwZWN0IGFuIGluY29ycmVjdCByZXN1bHQgdG8gb2NjdXIuIEluIHBhcnRpY3VsYXIsIHdlIHdhcm4gZm9yOlxuICpcbiAqIFVwZGF0aW5nIGEgc2hvcnRoYW5kIHByb3BlcnR5IChsb25naGFuZCBnZXRzIG92ZXJ3cml0dGVuKTpcbiAqICAge2ZvbnQ6ICdmb28nLCBmb250VmFyaWFudDogJ2Jhcid9IC0+IHtmb250OiAnYmF6JywgZm9udFZhcmlhbnQ6ICdiYXInfVxuICogICBiZWNvbWVzIC5zdHlsZS5mb250ID0gJ2JheidcbiAqIFJlbW92aW5nIGEgc2hvcnRoYW5kIHByb3BlcnR5IChsb25naGFuZCBnZXRzIGxvc3QgdG9vKTpcbiAqICAge2ZvbnQ6ICdmb28nLCBmb250VmFyaWFudDogJ2Jhcid9IC0+IHtmb250VmFyaWFudDogJ2Jhcid9XG4gKiAgIGJlY29tZXMgLnN0eWxlLmZvbnQgPSAnJ1xuICogUmVtb3ZpbmcgYSBsb25naGFuZCBwcm9wZXJ0eSAoc2hvdWxkIHJldmVydCB0byBzaG9ydGhhbmQ7IGRvZXNuJ3QpOlxuICogICB7Zm9udDogJ2ZvbycsIGZvbnRWYXJpYW50OiAnYmFyJ30gLT4ge2ZvbnQ6ICdmb28nfVxuICogICBiZWNvbWVzIC5zdHlsZS5mb250VmFyaWFudCA9ICcnXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsIG5leHRTdHlsZXMpIHtcbiAgaWYgKCF3YXJuQWJvdXRTaG9ydGhhbmRQcm9wZXJ0eUNvbGxpc2lvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghbmV4dFN0eWxlcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBleHBhbmRlZFVwZGF0ZXMgPSBleHBhbmRTaG9ydGhhbmRNYXAoc3R5bGVVcGRhdGVzKTtcbiAgdmFyIGV4cGFuZGVkU3R5bGVzID0gZXhwYW5kU2hvcnRoYW5kTWFwKG5leHRTdHlsZXMpO1xuICB2YXIgd2FybmVkQWJvdXQgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIGV4cGFuZGVkVXBkYXRlcykge1xuICAgIHZhciBvcmlnaW5hbEtleSA9IGV4cGFuZGVkVXBkYXRlc1trZXldO1xuICAgIHZhciBjb3JyZWN0T3JpZ2luYWxLZXkgPSBleHBhbmRlZFN0eWxlc1trZXldO1xuICAgIGlmIChjb3JyZWN0T3JpZ2luYWxLZXkgJiYgb3JpZ2luYWxLZXkgIT09IGNvcnJlY3RPcmlnaW5hbEtleSkge1xuICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvcmlnaW5hbEtleSArICcsJyArIGNvcnJlY3RPcmlnaW5hbEtleTtcbiAgICAgIGlmICh3YXJuZWRBYm91dFt3YXJuaW5nS2V5XSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZEFib3V0W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIGEgc3R5bGUgcHJvcGVydHkgZHVyaW5nIHJlcmVuZGVyICglcykgd2hlbiBhICcgKyAnY29uZmxpY3RpbmcgcHJvcGVydHkgaXMgc2V0ICglcykgY2FuIGxlYWQgdG8gc3R5bGluZyBidWdzLiBUbyAnICsgXCJhdm9pZCB0aGlzLCBkb24ndCBtaXggc2hvcnRoYW5kIGFuZCBub24tc2hvcnRoYW5kIHByb3BlcnRpZXMgXCIgKyAnZm9yIHRoZSBzYW1lIHZhbHVlOyBpbnN0ZWFkLCByZXBsYWNlIHRoZSBzaG9ydGhhbmQgd2l0aCAnICsgJ3NlcGFyYXRlIHZhbHVlcy4nLCBpc1ZhbHVlRW1wdHkoc3R5bGVVcGRhdGVzW29yaWdpbmFsS2V5XSkgPyAnUmVtb3ZpbmcnIDogJ1VwZGF0aW5nJywgb3JpZ2luYWxLZXksIGNvcnJlY3RPcmlnaW5hbEtleSk7XG4gICAgfVxuICB9XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgd2hpdGVsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZVxuICAvLyBOT1RFOiBtZW51aXRlbSdzIGNsb3NlIHRhZyBzaG91bGQgYmUgb21pdHRlZCwgYnV0IHRoYXQgY2F1c2VzIHByb2JsZW1zLlxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gIG1lbnVpdGVtOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxuLy8gVE9ETzogV2UgY2FuIHJlbW92ZSB0aGlzIGlmIHdlIGFkZCBpbnZhcmlhbnRXaXRoU3RhY2soKVxuLy8gb3IgYWRkIHN0YWNrIGJ5IGRlZmF1bHQgdG8gaW52YXJpYW50cyB3aGVyZSBwb3NzaWJsZS5cbnZhciBIVE1MJDEgPSAnX19odG1sJztcblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMiA9IG51bGw7XG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG59XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gIGlmICh2b2lkRWxlbWVudFRhZ3NbdGFnXSkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJyVzIGlzIGEgdm9pZCBlbGVtZW50IHRhZyBhbmQgbXVzdCBuZWl0aGVyIGhhdmUgYGNoaWxkcmVuYCBub3IgdXNlIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJXMnLCB0YWcsIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMi5nZXRTdGFja0FkZGVuZHVtKCkpIDogdm9pZCAwO1xuICB9XG4gIGlmIChwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCAhPSBudWxsKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogdm9pZCAwO1xuICAgICEodHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09PSAnb2JqZWN0JyAmJiBIVE1MJDEgaW4gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YXJpYW50LWRhbmdlcm91c2x5LXNldC1pbm5lci1odG1sIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdm9pZCAwO1xuICB9XG4gIHtcbiAgICAhKHByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyB8fCAhcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gd2FybmluZyQxKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLicpIDogdm9pZCAwO1xuICB9XG4gICEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiB1c2luZyBKU1guJXMnLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDIuZ2V0U3RhY2tBZGRlbmR1bSgpKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnO1xuICB9XG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgd2hpdGVsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG4vLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoZSBIVE1MIG9yIFNWRyB3aGl0ZWxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjbGFzczogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgZm9yOiAnaHRtbEZvcicsXG4gIGZvcm06ICdmb3JtJyxcbiAgZm9ybW1ldGhvZDogJ2Zvcm1NZXRob2QnLFxuICBmb3JtYWN0aW9uOiAnZm9ybUFjdGlvbicsXG4gIGZvcm1lbmN0eXBlOiAnZm9ybUVuY1R5cGUnLFxuICBmb3Jtbm92YWxpZGF0ZTogJ2Zvcm1Ob1ZhbGlkYXRlJyxcbiAgZm9ybXRhcmdldDogJ2Zvcm1UYXJnZXQnLFxuICBmcmFtZWJvcmRlcjogJ2ZyYW1lQm9yZGVyJyxcbiAgaGVhZGVyczogJ2hlYWRlcnMnLFxuICBoZWlnaHQ6ICdoZWlnaHQnLFxuICBoaWRkZW46ICdoaWRkZW4nLFxuICBoaWdoOiAnaGlnaCcsXG4gIGhyZWY6ICdocmVmJyxcbiAgaHJlZmxhbmc6ICdocmVmTGFuZycsXG4gIGh0bWxmb3I6ICdodG1sRm9yJyxcbiAgaHR0cGVxdWl2OiAnaHR0cEVxdWl2JyxcbiAgJ2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2JyxcbiAgaWNvbjogJ2ljb24nLFxuICBpZDogJ2lkJyxcbiAgaW5uZXJodG1sOiAnaW5uZXJIVE1MJyxcbiAgaW5wdXRtb2RlOiAnaW5wdXRNb2RlJyxcbiAgaW50ZWdyaXR5OiAnaW50ZWdyaXR5JyxcbiAgaXM6ICdpcycsXG4gIGl0ZW1pZDogJ2l0ZW1JRCcsXG4gIGl0ZW1wcm9wOiAnaXRlbVByb3AnLFxuICBpdGVtcmVmOiAnaXRlbVJlZicsXG4gIGl0ZW1zY29wZTogJ2l0ZW1TY29wZScsXG4gIGl0ZW10eXBlOiAnaXRlbVR5cGUnLFxuICBrZXlwYXJhbXM6ICdrZXlQYXJhbXMnLFxuICBrZXl0eXBlOiAna2V5VHlwZScsXG4gIGtpbmQ6ICdraW5kJyxcbiAgbGFiZWw6ICdsYWJlbCcsXG4gIGxhbmc6ICdsYW5nJyxcbiAgbGlzdDogJ2xpc3QnLFxuICBsb29wOiAnbG9vcCcsXG4gIGxvdzogJ2xvdycsXG4gIG1hbmlmZXN0OiAnbWFuaWZlc3QnLFxuICBtYXJnaW53aWR0aDogJ21hcmdpbldpZHRoJyxcbiAgbWFyZ2luaGVpZ2h0OiAnbWFyZ2luSGVpZ2h0JyxcbiAgbWF4OiAnbWF4JyxcbiAgbWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgbWVkaWE6ICdtZWRpYScsXG4gIG1lZGlhZ3JvdXA6ICdtZWRpYUdyb3VwJyxcbiAgbWV0aG9kOiAnbWV0aG9kJyxcbiAgbWluOiAnbWluJyxcbiAgbWlubGVuZ3RoOiAnbWluTGVuZ3RoJyxcbiAgbXVsdGlwbGU6ICdtdWx0aXBsZScsXG4gIG11dGVkOiAnbXV0ZWQnLFxuICBuYW1lOiAnbmFtZScsXG4gIG5vbW9kdWxlOiAnbm9Nb2R1bGUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gIGluOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICB0eXBlb2Y6ICd0eXBlb2YnLFxuICB1MTogJ3UxJyxcbiAgdTI6ICd1MicsXG4gIHVuZGVybGluZXBvc2l0aW9uOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICAndW5kZXJsaW5lLXBvc2l0aW9uJzogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgdW5kZXJsaW5ldGhpY2tuZXNzOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ3VuZGVybGluZS10aGlja25lc3MnOiAndW5kZXJsaW5lVGhpY2tuZXNzJyxcbiAgdW5pY29kZTogJ3VuaWNvZGUnLFxuICB1bmljb2RlYmlkaTogJ3VuaWNvZGVCaWRpJyxcbiAgJ3VuaWNvZGUtYmlkaSc6ICd1bmljb2RlQmlkaScsXG4gIHVuaWNvZGVyYW5nZTogJ3VuaWNvZGVSYW5nZScsXG4gICd1bmljb2RlLXJhbmdlJzogJ3VuaWNvZGVSYW5nZScsXG4gIHVuaXRzcGVyZW06ICd1bml0c1BlckVtJyxcbiAgJ3VuaXRzLXBlci1lbSc6ICd1bml0c1BlckVtJyxcbiAgdW5zZWxlY3RhYmxlOiAndW5zZWxlY3RhYmxlJyxcbiAgdmFscGhhYmV0aWM6ICd2QWxwaGFiZXRpYycsXG4gICd2LWFscGhhYmV0aWMnOiAndkFscGhhYmV0aWMnLFxuICB2YWx1ZXM6ICd2YWx1ZXMnLFxuICB2ZWN0b3JlZmZlY3Q6ICd2ZWN0b3JFZmZlY3QnLFxuICAndmVjdG9yLWVmZmVjdCc6ICd2ZWN0b3JFZmZlY3QnLFxuICB2ZXJzaW9uOiAndmVyc2lvbicsXG4gIHZlcnRhZHZ5OiAndmVydEFkdlknLFxuICAndmVydC1hZHYteSc6ICd2ZXJ0QWR2WScsXG4gIHZlcnRvcmlnaW54OiAndmVydE9yaWdpblgnLFxuICAndmVydC1vcmlnaW4teCc6ICd2ZXJ0T3JpZ2luWCcsXG4gIHZlcnRvcmlnaW55OiAndmVydE9yaWdpblknLFxuICAndmVydC1vcmlnaW4teSc6ICd2ZXJ0T3JpZ2luWScsXG4gIHZoYW5naW5nOiAndkhhbmdpbmcnLFxuICAndi1oYW5naW5nJzogJ3ZIYW5naW5nJyxcbiAgdmlkZW9ncmFwaGljOiAndklkZW9ncmFwaGljJyxcbiAgJ3YtaWRlb2dyYXBoaWMnOiAndklkZW9ncmFwaGljJyxcbiAgdmlld2JveDogJ3ZpZXdCb3gnLFxuICB2aWV3dGFyZ2V0OiAndmlld1RhcmdldCcsXG4gIHZpc2liaWxpdHk6ICd2aXNpYmlsaXR5JyxcbiAgdm1hdGhlbWF0aWNhbDogJ3ZNYXRoZW1hdGljYWwnLFxuICAndi1tYXRoZW1hdGljYWwnOiAndk1hdGhlbWF0aWNhbCcsXG4gIHZvY2FiOiAndm9jYWInLFxuICB3aWR0aHM6ICd3aWR0aHMnLFxuICB3b3Jkc3BhY2luZzogJ3dvcmRTcGFjaW5nJyxcbiAgJ3dvcmQtc3BhY2luZyc6ICd3b3JkU3BhY2luZycsXG4gIHdyaXRpbmdtb2RlOiAnd3JpdGluZ01vZGUnLFxuICAnd3JpdGluZy1tb2RlJzogJ3dyaXRpbmdNb2RlJyxcbiAgeDE6ICd4MScsXG4gIHgyOiAneDInLFxuICB4OiAneCcsXG4gIHhjaGFubmVsc2VsZWN0b3I6ICd4Q2hhbm5lbFNlbGVjdG9yJyxcbiAgeGhlaWdodDogJ3hIZWlnaHQnLFxuICAneC1oZWlnaHQnOiAneEhlaWdodCcsXG4gIHhsaW5rYWN0dWF0ZTogJ3hsaW5rQWN0dWF0ZScsXG4gICd4bGluazphY3R1YXRlJzogJ3hsaW5rQWN0dWF0ZScsXG4gIHhsaW5rYXJjcm9sZTogJ3hsaW5rQXJjcm9sZScsXG4gICd4bGluazphcmNyb2xlJzogJ3hsaW5rQXJjcm9sZScsXG4gIHhsaW5raHJlZjogJ3hsaW5rSHJlZicsXG4gICd4bGluazpocmVmJzogJ3hsaW5rSHJlZicsXG4gIHhsaW5rcm9sZTogJ3hsaW5rUm9sZScsXG4gICd4bGluazpyb2xlJzogJ3hsaW5rUm9sZScsXG4gIHhsaW5rc2hvdzogJ3hsaW5rU2hvdycsXG4gICd4bGluazpzaG93JzogJ3hsaW5rU2hvdycsXG4gIHhsaW5rdGl0bGU6ICd4bGlua1RpdGxlJyxcbiAgJ3hsaW5rOnRpdGxlJzogJ3hsaW5rVGl0bGUnLFxuICB4bGlua3R5cGU6ICd4bGlua1R5cGUnLFxuICAneGxpbms6dHlwZSc6ICd4bGlua1R5cGUnLFxuICB4bWxiYXNlOiAneG1sQmFzZScsXG4gICd4bWw6YmFzZSc6ICd4bWxCYXNlJyxcbiAgeG1sbGFuZzogJ3htbExhbmcnLFxuICAneG1sOmxhbmcnOiAneG1sTGFuZycsXG4gIHhtbG5zOiAneG1sbnMnLFxuICAneG1sOnNwYWNlJzogJ3htbFNwYWNlJyxcbiAgeG1sbnN4bGluazogJ3htbG5zWGxpbmsnLFxuICAneG1sbnM6eGxpbmsnOiAneG1sbnNYbGluaycsXG4gIHhtbHNwYWNlOiAneG1sU3BhY2UnLFxuICB5MTogJ3kxJyxcbiAgeTI6ICd5MicsXG4gIHk6ICd5JyxcbiAgeWNoYW5uZWxzZWxlY3RvcjogJ3lDaGFubmVsU2VsZWN0b3InLFxuICB6OiAneicsXG4gIHpvb21hbmRwYW46ICd6b29tQW5kUGFuJ1xufTtcblxudmFyIGFyaWFQcm9wZXJ0aWVzID0ge1xuICAnYXJpYS1jdXJyZW50JzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtZGV0YWlscyc6IDAsXG4gICdhcmlhLWRpc2FibGVkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaGlkZGVuJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEtaW52YWxpZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWtleXNob3J0Y3V0cyc6IDAsXG4gICdhcmlhLWxhYmVsJzogMCxcbiAgJ2FyaWEtcm9sZWRlc2NyaXB0aW9uJzogMCxcbiAgLy8gV2lkZ2V0IEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXV0b2NvbXBsZXRlJzogMCxcbiAgJ2FyaWEtY2hlY2tlZCc6IDAsXG4gICdhcmlhLWV4cGFuZGVkJzogMCxcbiAgJ2FyaWEtaGFzcG9wdXAnOiAwLFxuICAnYXJpYS1sZXZlbCc6IDAsXG4gICdhcmlhLW1vZGFsJzogMCxcbiAgJ2FyaWEtbXVsdGlsaW5lJzogMCxcbiAgJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJzogMCxcbiAgJ2FyaWEtb3JpZW50YXRpb24nOiAwLFxuICAnYXJpYS1wbGFjZWhvbGRlcic6IDAsXG4gICdhcmlhLXByZXNzZWQnOiAwLFxuICAnYXJpYS1yZWFkb25seSc6IDAsXG4gICdhcmlhLXJlcXVpcmVkJzogMCxcbiAgJ2FyaWEtc2VsZWN0ZWQnOiAwLFxuICAnYXJpYS1zb3J0JzogMCxcbiAgJ2FyaWEtdmFsdWVtYXgnOiAwLFxuICAnYXJpYS12YWx1ZW1pbic6IDAsXG4gICdhcmlhLXZhbHVlbm93JzogMCxcbiAgJ2FyaWEtdmFsdWV0ZXh0JzogMCxcbiAgLy8gTGl2ZSBSZWdpb24gQXR0cmlidXRlc1xuICAnYXJpYS1hdG9taWMnOiAwLFxuICAnYXJpYS1idXN5JzogMCxcbiAgJ2FyaWEtbGl2ZSc6IDAsXG4gICdhcmlhLXJlbGV2YW50JzogMCxcbiAgLy8gRHJhZy1hbmQtRHJvcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWRyb3BlZmZlY3QnOiAwLFxuICAnYXJpYS1ncmFiYmVkJzogMCxcbiAgLy8gUmVsYXRpb25zaGlwIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCc6IDAsXG4gICdhcmlhLWNvbGNvdW50JzogMCxcbiAgJ2FyaWEtY29saW5kZXgnOiAwLFxuICAnYXJpYS1jb2xzcGFuJzogMCxcbiAgJ2FyaWEtY29udHJvbHMnOiAwLFxuICAnYXJpYS1kZXNjcmliZWRieSc6IDAsXG4gICdhcmlhLWVycm9ybWVzc2FnZSc6IDAsXG4gICdhcmlhLWZsb3d0byc6IDAsXG4gICdhcmlhLWxhYmVsbGVkYnknOiAwLFxuICAnYXJpYS1vd25zJzogMCxcbiAgJ2FyaWEtcG9zaW5zZXQnOiAwLFxuICAnYXJpYS1yb3djb3VudCc6IDAsXG4gICdhcmlhLXJvd2luZGV4JzogMCxcbiAgJ2FyaWEtcm93c3Bhbic6IDAsXG4gICdhcmlhLXNldHNpemUnOiAwXG59O1xuXG52YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xudmFyIHJBUklBID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgckFSSUFDYW1lbCA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxudmFyIGhhc093blByb3BlcnR5JDIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5JDIuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLicsIG5hbWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IGNvcnJlY3ROYW1lKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIGNvcnJlY3ROYW1lKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IGFyaWFQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogbnVsbDtcblxuICAgIC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cbiAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gc3RhbmRhcmROYW1lKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdVbmtub3duIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHN0YW5kYXJkTmFtZSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcykge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9pbnZhbGlkLWFyaWEtcHJvcCcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpO1xufVxuXG52YXIgZGlkV2FyblZhbHVlTnVsbCA9IGZhbHNlO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBhcnJheSB3aGVuIGBtdWx0aXBsZWAgaXMgc2V0IHRvIGB0cnVlYCAnICsgJ3RvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgZm9yIHVuY29udHJvbGxlZCBjb21wb25lbnRzLicsIHR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBfaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICB2YXIgRVZFTlRfTkFNRV9SRUdFWCA9IC9eb24uLztcbiAgdmFyIElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWCA9IC9eb25bXkEtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2UgY2FuJ3QgcmVseSBvbiB0aGUgZXZlbnQgc3lzdGVtIGJlaW5nIGluamVjdGVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgaWYgKGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gOiBudWxsO1xuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgLy8gSWYgbm8gZXZlbnQgcGx1Z2lucyBoYXZlIGJlZW4gaW5qZWN0ZWQsIHdlIGFyZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIFNvIHdlIGNhbid0IHRlbGwgaWYgdGhlIGV2ZW50IG5hbWUgaXMgY29ycmVjdCBmb3Igc3VyZSwgYnV0IHdlIGNhbiBmaWx0ZXJcbiAgICAgIC8vIG91dCBrbm93biBiYWQgb25lcyBsaWtlIGBvbmNsaWNrYC4gV2UgY2FuJ3Qgc3VnZ2VzdCBhIHNwZWNpZmljIHJlcGxhY2VtZW50IHRob3VnaC5cbiAgICAgIGlmIChJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLCBuYW1lKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBMZXQgdGhlIEFSSUEgYXR0cmlidXRlIGhvb2sgdmFsaWRhdGUgQVJJQSBhdHRyaWJ1dGVzXG4gICAgaWYgKHJBUklBJDEudGVzdChuYW1lKSB8fCByQVJJQUNhbWVsJDEudGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2FyaWEnKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCB0eXBlb2YgdmFsdWUpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgbmFtZSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgICB2YXIgaXNSZXNlcnZlZCA9IHByb3BlcnR5SW5mbyAhPT0gbnVsbCAmJiBwcm9wZXJ0eUluZm8udHlwZSA9PT0gUkVTRVJWRUQ7XG5cbiAgICAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZCAmJiBuYW1lICE9PSBsb3dlckNhc2VkTmFtZSkge1xuICAgICAgLy8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4gICAgICAvLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LicsIG5hbWUsIGxvd2VyQ2FzZWROYW1lKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIG5hbWUsIG5hbWUpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBXYXJuIHdoZW4gcGFzc2luZyB0aGUgc3RyaW5ncyAnZmFsc2UnIG9yICd0cnVlJyBpbnRvIGEgYm9vbGVhbiBwcm9wXG4gICAgaWYgKCh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ3RydWUnKSAmJiBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlY2VpdmVkIHRoZSBzdHJpbmcgYCVzYCBmb3IgdGhlIGJvb2xlYW4gYXR0cmlidXRlIGAlc2AuICcgKyAnJXMgJyArICdEaWQgeW91IG1lYW4gJXM9eyVzfT8nLCB2YWx1ZSwgbmFtZSwgdmFsdWUgPT09ICdmYWxzZScgPyAnVGhlIGJyb3dzZXIgd2lsbCBpbnRlcnByZXQgaXQgYXMgYSB0cnV0aHkgdmFsdWUuJyA6ICdBbHRob3VnaCB0aGlzIHdvcmtzLCBpdCB3aWxsIG5vdCB3b3JrIGFzIGV4cGVjdGVkIGlmIHlvdSBwYXNzIHRoZSBzdHJpbmcgXCJmYWxzZVwiLicsIG5hbWUsIHZhbHVlKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGNhblVzZUV2ZW50U3lzdGVtKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvcicsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvcicsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzLCBjYW5Vc2VFdmVudFN5c3RlbSk7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5TaGFkeURPTSA9IGZhbHNlO1xuXG52YXIgREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgPSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnO1xudmFyIFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyA9ICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnO1xudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgPSAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJztcbnZhciBBVVRPRk9DVVMgPSAnYXV0b0ZvY3VzJztcbnZhciBDSElMRFJFTiA9ICdjaGlsZHJlbic7XG52YXIgU1RZTEUkMSA9ICdzdHlsZSc7XG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG52YXIgSFRNTF9OQU1FU1BBQ0UgPSBOYW1lc3BhY2VzLmh0bWw7XG5cblxudmFyIHdhcm5lZFVua25vd25UYWdzID0gdm9pZCAwO1xudmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHZvaWQgMDtcblxudmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSB2b2lkIDA7XG52YXIgd2FybkZvclRleHREaWZmZXJlbmNlID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IHZvaWQgMDtcbnZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gdm9pZCAwO1xudmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IHZvaWQgMDtcbnZhciBjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nID0gdm9pZCAwO1xuXG52YXIgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlID0gdm9pZCAwO1xudmFyIG5vcm1hbGl6ZUhUTUwgPSB2b2lkIDA7XG5cbntcbiAgd2FybmVkVW5rbm93blRhZ3MgPSB7XG4gICAgLy8gQ2hyb21lIGlzIHRoZSBvbmx5IG1ham9yIGJyb3dzZXIgbm90IHNoaXBwaW5nIDx0aW1lPi4gQnV0IGFzIG9mIEp1bHlcbiAgICAvLyAyMDE3IGl0IGludGVuZHMgdG8gc2hpcCBpdCBkdWUgdG8gd2lkZXNwcmVhZCB1c2FnZS4gV2UgaW50ZW50aW9uYWxseVxuICAgIC8vICpkb24ndCogd2FybiBmb3IgPHRpbWU+IGV2ZW4gaWYgaXQncyB1bnJlY29nbml6ZWQgYnkgQ2hyb21lIGJlY2F1c2VcbiAgICAvLyBpdCBzb29uIHdpbGwgYmUsIGFuZCBtYW55IGFwcHMgaGF2ZSBiZWVuIHVzaW5nIGl0IGFueXdheS5cbiAgICB0aW1lOiB0cnVlLFxuICAgIC8vIFRoZXJlIGFyZSB3b3JraW5nIHBvbHlmaWxscyBmb3IgPGRpYWxvZz4uIExldCBwZW9wbGUgdXNlIGl0LlxuICAgIGRpYWxvZzogdHJ1ZSxcbiAgICAvLyBFbGVjdHJvbiBzaGlwcyBhIGN1c3RvbSA8d2Vidmlldz4gdGFnIHRvIGRpc3BsYXkgZXh0ZXJuYWwgd2ViIGNvbnRlbnQgaW5cbiAgICAvLyBhbiBpc29sYXRlZCBmcmFtZSBhbmQgcHJvY2Vzcy5cbiAgICAvLyBUaGlzIHRhZyBpcyBub3QgcHJlc2VudCBpbiBub24gRWxlY3Ryb24gZW52aXJvbm1lbnRzIHN1Y2ggYXMgSlNEb20gd2hpY2hcbiAgICAvLyBpcyBvZnRlbiB1c2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgIC8vIEBzZWUgaHR0cHM6Ly9lbGVjdHJvbmpzLm9yZy9kb2NzL2FwaS93ZWJ2aWV3LXRhZ1xuICAgIHdlYnZpZXc6IHRydWVcbiAgfTtcblxuICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIC8qIGNhblVzZUV2ZW50U3lzdGVtICovdHJ1ZSk7XG4gIH07XG5cbiAgLy8gSUUgMTEgcGFyc2VzICYgbm9ybWFsaXplcyB0aGUgc3R5bGUgYXR0cmlidXRlIGFzIG9wcG9zZWQgdG8gb3RoZXJcbiAgLy8gYnJvd3NlcnMuIEl0IGFkZHMgc3BhY2VzIGFuZCBzb3J0cyB0aGUgcHJvcGVydGllcyBpbiBzb21lXG4gIC8vIG5vbi1hbHBoYWJldGljYWwgb3JkZXIuIEhhbmRsaW5nIHRoYXQgd291bGQgcmVxdWlyZSBzb3J0aW5nIENTU1xuICAvLyBwcm9wZXJ0aWVzIGluIHRoZSBjbGllbnQgJiBzZXJ2ZXIgdmVyc2lvbnMgb3IgYXBwbHlpbmdcbiAgLy8gYGV4cGVjdGVkU3R5bGVgIHRvIGEgdGVtcG9yYXJ5IERPTSBub2RlIHRvIHJlYWQgaXRzIGBzdHlsZWAgYXR0cmlidXRlXG4gIC8vIG5vcm1hbGl6ZWQuIFNpbmNlIGl0IG9ubHkgYWZmZWN0cyBJRSwgd2UncmUgc2tpcHBpbmcgc3R5bGUgd2FybmluZ3NcbiAgLy8gaW4gdGhhdCBicm93c2VyIGNvbXBsZXRlbHkgaW4gZmF2b3Igb2YgZG9pbmcgYWxsIHRoYXQgd29yay5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTE4MDdcbiAgY2FuRGlmZlN0eWxlRm9ySHlkcmF0aW9uV2FybmluZyA9IGNhblVzZURPTSAmJiAhZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xuXG4gIC8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuICAvLyBJdCBhbHNvIGNhbiB0dXJuIFxcdTAwMDAgaW50byBcXHVGRkZEIGluc2lkZSBhdHRyaWJ1dGVzLlxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc2luZ2xlLXBhZ2UuaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbiAgLy8gV2Ugd2lsbCBzdGlsbCBwYXRjaCB1cCBpbiB0aGlzIGNhc2UgYnV0IG5vdCBmaXJlIHRoZSB3YXJuaW5nLlxuICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbiAgdmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIG1hcmt1cFN0cmluZyA9IHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnID8gbWFya3VwIDogJycgKyBtYXJrdXA7XG4gICAgcmV0dXJuIG1hcmt1cFN0cmluZy5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgJ1xcbicpLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCAnJyk7XG4gIH07XG5cbiAgd2FybkZvclRleHREaWZmZXJlbmNlID0gZnVuY3Rpb24gKHNlcnZlclRleHQsIGNsaWVudFRleHQpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZWRDbGllbnRUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFRleHQpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShzZXJ2ZXJUZXh0KTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclRleHQgPT09IG5vcm1hbGl6ZWRDbGllbnRUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VmFsdWUpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVmFsdWUpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVmFsdWUgPT09IG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUHJvcCBgJXNgIGRpZCBub3QgbWF0Y2guIFNlcnZlcjogJXMgQ2xpZW50OiAlcycsIHByb3BOYW1lLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkU2VydmVyVmFsdWUpLCBKU09OLnN0cmluZ2lmeShub3JtYWxpemVkQ2xpZW50VmFsdWUpKTtcbiAgfTtcblxuICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V4dHJhIGF0dHJpYnV0ZXMgZnJvbSB0aGUgc2VydmVyOiAlcycsIG5hbWVzKTtcbiAgfTtcblxuICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAocmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4nLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lLCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZSB0aGUgSFRNTCBhbmQgcmVhZCBpdCBiYWNrIHRvIG5vcm1hbGl6ZSB0aGUgSFRNTCBzdHJpbmcgc28gdGhhdCBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgY29tcGFyaXNvbi5cbiAgbm9ybWFsaXplSFRNTCA9IGZ1bmN0aW9uIChwYXJlbnQsIGh0bWwpIHtcbiAgICAvLyBXZSBjb3VsZCBoYXZlIGNyZWF0ZWQgYSBzZXBhcmF0ZSBkb2N1bWVudCBoZXJlIHRvIGF2b2lkXG4gICAgLy8gcmUtaW5pdGlhbGl6aW5nIGN1c3RvbSBlbGVtZW50cyBpZiB0aGV5IGV4aXN0LiBCdXQgdGhpcyBicmVha3NcbiAgICAvLyBob3cgPG5vc2NyaXB0PiBpcyBiZWluZyBoYW5kbGVkLiBTbyB3ZSB1c2UgdGhlIHNhbWUgZG9jdW1lbnQuXG4gICAgLy8gU2VlIHRoZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzExMTU3LlxuICAgIHZhciB0ZXN0RWxlbWVudCA9IHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFID8gcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChwYXJlbnQudGFnTmFtZSkgOiBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocGFyZW50Lm5hbWVzcGFjZVVSSSwgcGFyZW50LnRhZ05hbWUpO1xuICAgIHRlc3RFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgcmV0dXJuIHRlc3RFbGVtZW50LmlubmVySFRNTDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGlzRG9jdW1lbnRPckZyYWdtZW50ID0gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgfHwgcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG4gIHZhciBkb2MgPSBpc0RvY3VtZW50T3JGcmFnbWVudCA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgZG9jKTtcbn1cblxuZnVuY3Rpb24gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/IHJvb3RDb250YWluZXJFbGVtZW50IDogcm9vdENvbnRhaW5lckVsZW1lbnQub3duZXJEb2N1bWVudDtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KG5vZGUpIHtcbiAgLy8gTW9iaWxlIFNhZmFyaSBkb2VzIG5vdCBmaXJlIHByb3Blcmx5IGJ1YmJsZSBjbGljayBldmVudHMgb25cbiAgLy8gbm9uLWludGVyYWN0aXZlIGVsZW1lbnRzLCB3aGljaCBtZWFucyBkZWxlZ2F0ZWQgY2xpY2sgbGlzdGVuZXJzIGRvIG5vdFxuICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gIC8vIGxpc3RlbmVyIG9uIHRoZSB0YXJnZXQgbm9kZS5cbiAgLy8gaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgLy8gSnVzdCBzZXQgaXQgdXNpbmcgdGhlIG9uY2xpY2sgcHJvcGVydHkgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIG1hbmFnZSBhbnlcbiAgLy8gYm9va2tlZXBpbmcgZm9yIGl0LiBOb3Qgc3VyZSBpZiB3ZSBuZWVkIHRvIGNsZWFyIGl0IHdoZW4gdGhlIGxpc3RlbmVyIGlzXG4gIC8vIHJlbW92ZWQuXG4gIC8vIFRPRE86IE9ubHkgZG8gdGhpcyBmb3IgdGhlIHJlbGV2YW50IFNhZmFyaXMgbWF5YmU/XG4gIG5vZGUub25jbGljayA9IG5vb3A7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUkMSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgc2V0VmFsdWVGb3JTdHlsZXMoZG9tRWxlbWVudCwgbmV4dFByb3ApO1xuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgaW5pdGlhbCB0ZXh0Q29udGVudCB3aGVuIHRoZSB0ZXh0IGlzIGVtcHR5LiBJbiBJRTExIHNldHRpbmdcbiAgICAgICAgLy8gdGV4dENvbnRlbnQgb24gYSA8dGV4dGFyZWE+IHdpbGwgY2F1c2UgdGhlIHBsYWNlaG9sZGVyIHRvIG5vdFxuICAgICAgICAvLyBzaG93IHdpdGhpbiB0aGUgPHRleHRhcmVhPiB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY3MzEjaXNzdWVjb21tZW50LTI1NDg3NDU1M1xuICAgICAgICB2YXIgY2FuU2V0VGV4dENvbnRlbnQgPSB0YWcgIT09ICd0ZXh0YXJlYScgfHwgbmV4dFByb3AgIT09ICcnO1xuICAgICAgICBpZiAoY2FuU2V0VGV4dENvbnRlbnQpIHtcbiAgICAgICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCAnJyArIG5leHRQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIFdlIHBvbHlmaWxsIGl0IHNlcGFyYXRlbHkgb24gdGhlIGNsaWVudCBkdXJpbmcgY29tbWl0LlxuICAgICAgLy8gV2UgY291bGQgaGF2ZSBleGNsdWRlZCBpdCBpbiB0aGUgcHJvcGVydHkgbGlzdCBpbnN0ZWFkIG9mXG4gICAgICAvLyBhZGRpbmcgYSBzcGVjaWFsIGNhc2UgaGVyZSwgYnV0IHRoZW4gaXQgd291bGRuJ3QgYmUgZW1pdHRlZFxuICAgICAgLy8gb24gc2VydmVyIHJlbmRlcmluZyAoYnV0IHdlICpkbyogd2FudCB0byBlbWl0IGl0IGluIFNTUikuXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFJDEpIHtcbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgc2V0SW5uZXJIVE1MKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBwcm9wVmFsdWUsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQsIHBhcmVudE5hbWVzcGFjZSkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSB2b2lkIDA7XG5cbiAgLy8gV2UgY3JlYXRlIHRhZ3MgaW4gdGhlIG5hbWVzcGFjZSBvZiB0aGVpciBwYXJlbnQgY29udGFpbmVyLCBleGNlcHQgSFRNTFxuICAvLyB0YWdzIGdldCBubyBuYW1lc3BhY2UuXG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KTtcbiAgdmFyIGRvbUVsZW1lbnQgPSB2b2lkIDA7XG4gIHZhciBuYW1lc3BhY2VVUkkgPSBwYXJlbnROYW1lc3BhY2U7XG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgbmFtZXNwYWNlVVJJID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAge1xuICAgICAgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICAhKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHR5cGUgPT09IHR5cGUudG9Mb3dlckNhc2UoKSkgPyB3YXJuaW5nJDEoZmFsc2UsICc8JXMgLz4gaXMgdXNpbmcgaW5jb3JyZWN0IGNhc2luZy4gJyArICdVc2UgUGFzY2FsQ2FzZSBmb3IgUmVhY3QgY29tcG9uZW50cywgJyArICdvciBsb3dlcmNhc2UgZm9yIEhUTUwgZWxlbWVudHMuJywgdHlwZSkgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICBkb21FbGVtZW50ID0gZGl2LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUsIHsgaXM6IHByb3BzLmlzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgICAvLyBOb3JtYWxseSBhdHRyaWJ1dGVzIGFyZSBhc3NpZ25lZCBpbiBgc2V0SW5pdGlhbERPTVByb3BlcnRpZXNgLCBob3dldmVyIHRoZSBgbXVsdGlwbGVgIGFuZCBgc2l6ZWBcbiAgICAgIC8vIGF0dHJpYnV0ZXMgb24gYHNlbGVjdGBzIG5lZWRzIHRvIGJlIGFkZGVkIGJlZm9yZSBgb3B0aW9uYHMgYXJlIGluc2VydGVkLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50czpcbiAgICAgIC8vIC0gYSBidWcgd2hlcmUgdGhlIGBzZWxlY3RgIGRvZXMgbm90IHNjcm9sbCB0byB0aGUgY29ycmVjdCBvcHRpb24gYmVjYXVzZSBzaW5ndWxhclxuICAgICAgLy8gIGBzZWxlY3RgIGVsZW1lbnRzIGF1dG9tYXRpY2FsbHkgcGljayB0aGUgZmlyc3QgaXRlbSAjMTMyMjJcbiAgICAgIC8vIC0gYSBidWcgd2hlcmUgdGhlIGBzZWxlY3RgIHNldCB0aGUgZmlyc3QgaXRlbSBhcyBzZWxlY3RlZCBkZXNwaXRlIHRoZSBgc2l6ZWAgYXR0cmlidXRlICMxNDIzOVxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMyMjJcbiAgICAgIC8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0MjM5XG4gICAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBkb21FbGVtZW50O1xuICAgICAgICBpZiAocHJvcHMubXVsdGlwbGUpIHtcbiAgICAgICAgICBub2RlLm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9wcy5zaXplKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBhIHNpemUgZ3JlYXRlciB0aGFuIDEgY2F1c2VzIGEgc2VsZWN0IHRvIGJlaGF2ZSBsaWtlIGBtdWx0aXBsZT10cnVlYCwgd2hlcmVcbiAgICAgICAgICAvLyBpdCBpcyBwb3NzaWJsZSB0aGF0IG5vIG9wdGlvbiBpcyBzZWxlY3RlZC5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoaXMgaXMgb25seSBuZWNlc3Nhcnkgd2hlbiBhIHNlbGVjdCBpbiBcInNpbmdsZSBzZWxlY3Rpb24gbW9kZVwiLlxuICAgICAgICAgIG5vZGUuc2l6ZSA9IHByb3BzLnNpemU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgdHlwZSk7XG4gIH1cblxuICB7XG4gICAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgIGlmICghaXNDdXN0b21Db21wb25lbnRUYWcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRvbUVsZW1lbnQpID09PSAnW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdJyAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHdhcm5lZFVua25vd25UYWdzLCB0eXBlKSkge1xuICAgICAgICB3YXJuZWRVbmtub3duVGFnc1t0eXBlXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1RoZSB0YWcgPCVzPiBpcyB1bnJlY29nbml6ZWQgaW4gdGhpcyBicm93c2VyLiAnICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBSZWFjdCBjb21wb25lbnQsIHN0YXJ0IGl0cyBuYW1lIHdpdGggJyArICdhbiB1cHBlcmNhc2UgbGV0dGVyLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSh0ZXh0LCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KS5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbn1cblxuZnVuY3Rpb24gc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgdmFyIHByb3BzID0gdm9pZCAwO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0xPQUQsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVkaWFFdmVudFR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRyYXBCdWJibGVkRXZlbnQobWVkaWFFdmVudFR5cGVzW2ldLCBkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfRVJST1IsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfRVJST1IsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfTE9BRCwgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9SRVNFVCwgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KFRPUF9TVUJNSVQsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfVE9HR0xFLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKTtcblxuICBzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsIGRvbUVsZW1lbnQsIHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcywgZmFsc2UpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBkaWZmIGJldHdlZW4gdGhlIHR3byBvYmplY3RzLlxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCBsYXN0UmF3UHJvcHMsIG5leHRSYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCBuZXh0UmF3UHJvcHMpO1xuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuXG4gIHZhciBsYXN0UHJvcHMgPSB2b2lkIDA7XG4gIHZhciBuZXh0UHJvcHMgPSB2b2lkIDA7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxhc3RQcm9wcyA9IGxhc3RSYXdQcm9wcztcbiAgICAgIG5leHRQcm9wcyA9IG5leHRSYXdQcm9wcztcbiAgICAgIGlmICh0eXBlb2YgbGFzdFByb3BzLm9uQ2xpY2sgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG5leHRQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgbmV4dFByb3BzKTtcblxuICB2YXIgcHJvcEtleSA9IHZvaWQgMDtcbiAgdmFyIHN0eWxlTmFtZSA9IHZvaWQgMDtcbiAgdmFyIHN0eWxlVXBkYXRlcyA9IG51bGw7XG4gIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUkMSkge1xuICAgICAgdmFyIGxhc3RTdHlsZSA9IGxhc3RQcm9wc1twcm9wS2V5XTtcbiAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RTdHlsZSkge1xuICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIHx8IHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBOb29wLiBUaGlzIGlzIGhhbmRsZWQgYnkgdGhlIGNsZWFyIHRleHQgbWVjaGFuaXNtLlxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IEFVVE9GT0NVUykge1xuICAgICAgLy8gTm9vcC4gSXQgZG9lc24ndCB3b3JrIG9uIHVwZGF0ZXMgYW55d2F5LlxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBmaWJlciBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAvLyB0byB1cGRhdGUgdGhpcyBlbGVtZW50LlxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFsbCBvdGhlciBkZWxldGVkIHByb3BlcnRpZXMgd2UgYWRkIGl0IHRvIHRoZSBxdWV1ZS4gV2UgdXNlXG4gICAgICAvLyB0aGUgd2hpdGVsaXN0IGluIHRoZSBjb21taXQgcGhhc2UgaW5zdGVhZC5cbiAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCBudWxsKTtcbiAgICB9XG4gIH1cbiAgZm9yIChwcm9wS2V5IGluIG5leHRQcm9wcykge1xuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICB2YXIgbGFzdFByb3AgPSBsYXN0UHJvcHMgIT0gbnVsbCA/IGxhc3RQcm9wc1twcm9wS2V5XSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3AgfHwgbmV4dFByb3AgPT0gbnVsbCAmJiBsYXN0UHJvcCA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFJDEpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgIGlmIChsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAoIXVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZC5wdXNoKHByb3BLZXksIHN0eWxlVXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVVcGRhdGVzID0gbmV4dFByb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wID8gbGFzdFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dEh0bWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBJdCBtaWdodCBiZSB0b28gbGF0ZSB0byBjbGVhciB0aGlzIGlmIHdlIGhhdmUgY2hpbGRyZW5cbiAgICAgICAgLy8gaW5zZXJ0ZWQgYWxyZWFkeS5cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAobGFzdFByb3AgIT09IG5leHRQcm9wICYmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgLy8gV2UgZWFnZXJseSBsaXN0ZW4gdG8gdGhpcyBldmVuIHRob3VnaCB3ZSBoYXZlbid0IGNvbW1pdHRlZCB5ZXQuXG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkICYmIGxhc3RQcm9wICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBwcm9wcyBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAgIC8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFueSBvdGhlciBwcm9wZXJ0eSB3ZSBhbHdheXMgYWRkIGl0IHRvIHRoZSBxdWV1ZSBhbmQgdGhlbiB3ZVxuICAgICAgLy8gZmlsdGVyIGl0IG91dCB1c2luZyB0aGUgd2hpdGVsaXN0IGR1cmluZyB0aGUgY29tbWl0LlxuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgIHtcbiAgICAgIHZhbGlkYXRlU2hvcnRoYW5kUHJvcGVydHlDb2xsaXNpb25JbkRldihzdHlsZVVwZGF0ZXMsIG5leHRQcm9wc1tTVFlMRSQxXSk7XG4gICAgfVxuICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChTVFlMRSQxLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG4vLyBBcHBseSB0aGUgZGlmZi5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdGFnLCBsYXN0UmF3UHJvcHMsIG5leHRSYXdQcm9wcykge1xuICAvLyBVcGRhdGUgY2hlY2tlZCAqYmVmb3JlKiBuYW1lLlxuICAvLyBJbiB0aGUgbWlkZGxlIG9mIGFuIHVwZGF0ZSwgaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBtdWx0aXBsZSBjaGVja2VkLlxuICAvLyBXaGVuIGEgY2hlY2tlZCByYWRpbyB0cmllcyB0byBjaGFuZ2UgbmFtZSwgYnJvd3NlciBtYWtlcyBhbm90aGVyIHJhZGlvJ3MgY2hlY2tlZCBmYWxzZS5cbiAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBuZXh0UmF3UHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuZXh0UmF3UHJvcHMubmFtZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlQ2hlY2tlZChkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICB9XG5cbiAgdmFyIHdhc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbGFzdFJhd1Byb3BzKTtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBuZXh0UmF3UHJvcHMpO1xuICAvLyBBcHBseSB0aGUgZGlmZi5cbiAgdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB3YXNDdXN0b21Db21wb25lbnRUYWcsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICAvLyBUT0RPOiBFbnN1cmUgdGhhdCBhbiB1cGRhdGUgZ2V0cyBzY2hlZHVsZWQgaWYgYW55IG9mIHRoZSBzcGVjaWFsIHByb3BzXG4gIC8vIGNoYW5nZWQuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbiAgICAgIC8vIGhhcHBlbiBhZnRlciBgdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuICAgICAgLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxuICAgICAgdXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgdXBkYXRlV3JhcHBlciQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4gICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgcG9zdFVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvc3NpYmxlU3RhbmRhcmROYW1lKHByb3BOYW1lKSB7XG4gIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghcG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdIHx8IG51bGw7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSB2b2lkIDA7XG4gIHZhciBleHRyYUF0dHJpYnV0ZU5hbWVzID0gdm9pZCAwO1xuXG4gIHtcbiAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIGlzIHVzaW5nIHNoYWR5IERPTS4gVXNpbmcgc2hhZHkgRE9NIHdpdGggUmVhY3QgY2FuICcgKyAnY2F1c2UgdGhpbmdzIHRvIGJyZWFrIHN1YnRseS4nLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWVJbkRldk9yTnVsbCgpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgZGlkV2FyblNoYWR5RE9NID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0xPQUQsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZWRpYUV2ZW50VHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChtZWRpYUV2ZW50VHlwZXNbaV0sIGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0VSUk9SLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfRVJST1IsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfTE9BRCwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX1JFU0VULCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX1NVQk1JVCwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX1RPR0dMRSwgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudChUT1BfSU5WQUxJRCwgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoVE9QX0lOVkFMSUQsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzKTtcblxuICB7XG4gICAgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXR0cmlidXRlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tfaV0ubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIC8vIEJ1aWx0LWluIFNTUiBhdHRyaWJ1dGUgaXMgd2hpdGVsaXN0ZWRcbiAgICAgICAgY2FzZSAnZGF0YS1yZWFjdHJvb3QnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IHVzZSB0aGUgb3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMDY3Ni5cbiAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmFkZChhdHRyaWJ1dGVzW19pXS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG4gIGZvciAodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gcmF3UHJvcHNbcHJvcEtleV07XG4gICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBGb3IgdGV4dCBjb250ZW50IGNoaWxkcmVuIHdlIGNvbXBhcmUgYWdhaW5zdCB0ZXh0Q29udGVudC4gVGhpc1xuICAgICAgLy8gbWlnaHQgbWF0Y2ggYWRkaXRpb25hbCBIVE1MIHRoYXQgaXMgaGlkZGVuIHdoZW4gd2UgcmVhZCBpdCB1c2luZ1xuICAgICAgLy8gdGV4dENvbnRlbnQuIEUuZy4gXCJmb29cIiB3aWxsIG1hdGNoIFwiZjxzcGFuPm9vPC9zcGFuPlwiIGJ1dCB0aGF0IHN0aWxsXG4gICAgICAvLyBzYXRpc2ZpZXMgb3VyIHJlcXVpcmVtZW50LiBPdXIgcmVxdWlyZW1lbnQgaXMgbm90IHRvIHByb2R1Y2UgcGVyZmVjdFxuICAgICAgLy8gSFRNTCBhbmQgYXR0cmlidXRlcy4gSWRlYWxseSB3ZSBzaG91bGQgcHJlc2VydmUgc3RydWN0dXJlIGJ1dCBpdCdzXG4gICAgICAvLyBvayBub3QgdG8gaWYgdGhlIHZpc2libGUgY29udGVudCBpcyBzdGlsbCBlbm91Z2ggdG8gaW5kaWNhdGUgd2hhdFxuICAgICAgLy8gZXZlbiBsaXN0ZW5lcnMgdGhlc2Ugbm9kZXMgbWlnaHQgYmUgd2lyZWQgdXAgdG8uXG4gICAgICAvLyBUT0RPOiBXYXJuIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBhIHNpbmdsZSB0ZXh0Tm9kZSBhcyBhIGNoaWxkLlxuICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIHVzZSBkb21FbGVtZW50LmZpcnN0Q2hpbGQubm9kZVZhbHVlIHRvIGNvbXBhcmU/XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sICcnICsgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0cnVlICYmXG4gICAgLy8gQ29udmluY2UgRmxvdyB3ZSd2ZSBjYWxjdWxhdGVkIGl0IChpdCdzIERFVi1vbmx5IGluIHRoaXMgbWV0aG9kLilcbiAgICB0eXBlb2YgaXNDdXN0b21Db21wb25lbnRUYWcgPT09ICdib29sZWFuJykge1xuICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgcHJvcGVydGllcyBjb3JyZXNwb25kIHRvIHRoZWlyIGV4cGVjdGVkIHZhbHVlcy5cbiAgICAgIHZhciBzZXJ2ZXJWYWx1ZSA9IHZvaWQgMDtcbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8ocHJvcEtleSk7XG4gICAgICBpZiAoc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcuIFdlJ3JlIGlnbm9yaW5nIGFsbCB0aGVzZSB3YXJuaW5ncy5cbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgfHxcbiAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG4gICAgICBwcm9wS2V5ID09PSAndmFsdWUnIHx8IHByb3BLZXkgPT09ICdjaGVja2VkJyB8fCBwcm9wS2V5ID09PSAnc2VsZWN0ZWQnKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgbmV4dEh0bWwgIT0gbnVsbCA/IG5leHRIdG1sIDogJycpO1xuICAgICAgICBpZiAoZXhwZWN0ZWRIVE1MICE9PSBzZXJ2ZXJIVE1MKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlckhUTUwsIGV4cGVjdGVkSFRNTCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1RZTEUkMSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkpO1xuXG4gICAgICAgIGlmIChjYW5EaWZmU3R5bGVGb3JIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgdmFyIGV4cGVjdGVkU3R5bGUgPSBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMobmV4dFByb3ApO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIGV4cGVjdGVkU3R5bGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc2hvdWxkSWdub3JlQXR0cmlidXRlKHByb3BLZXksIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpICYmICFzaG91bGRSZW1vdmVBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3AsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgICAgIHZhciBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHByb3BlcnR5SW5mbyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wLCBwcm9wZXJ0eUluZm8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5kZWxldGUocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IGdldFBvc3NpYmxlU3RhbmRhcmROYW1lKHByb3BLZXkpO1xuICAgICAgICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbnVsbCAmJiBzdGFuZGFyZE5hbWUgIT09IHByb3BLZXkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYW4gU1ZHIHByb3AgaXMgc3VwcGxpZWQgd2l0aCBiYWQgY2FzaW5nLCBpdCB3aWxsXG4gICAgICAgICAgICAgIC8vIGJlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgZnJvbSBIVE1MLCBidXQgd2lsbCBwcm9kdWNlIGEgbWlzbWF0Y2hcbiAgICAgICAgICAgICAgLy8gKGFuZCB3b3VsZCBiZSBpbmNvcnJlY3RseSByZW5kZXJlZCBvbiB0aGUgY2xpZW50KS5cbiAgICAgICAgICAgICAgLy8gSG93ZXZlciwgd2UgYWxyZWFkeSB3YXJuIGFib3V0IGJhZCBjYXNpbmcgZWxzZXdoZXJlLlxuICAgICAgICAgICAgICAvLyBTbyB3ZSdsbCBza2lwIHRoZSBtaXNsZWFkaW5nIGV4dHJhIG1pc21hdGNoIHdhcm5pbmcgaW4gdGhpcyBjYXNlLlxuICAgICAgICAgICAgICBpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuZGVsZXRlKHN0YW5kYXJkTmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmRlbGV0ZShwcm9wS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlICYmICFpc01pc21hdGNoRHVlVG9CYWRDYXNpbmcpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgaWYgKGV4dHJhQXR0cmlidXRlTmFtZXMuc2l6ZSA+IDAgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgd2FybkZvckV4dHJhQXR0cmlidXRlcyhleHRyYUF0dHJpYnV0ZU5hbWVzKTtcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIC8vIEZvciBpbnB1dCBhbmQgdGV4dGFyZWEgd2UgY3VycmVudCBhbHdheXMgc2V0IHRoZSB2YWx1ZSBwcm9wZXJ0eSBhdFxuICAgICAgLy8gcG9zdCBtb3VudCB0byBmb3JjZSBpdCB0byBkaXZlcmdlIGZyb20gYXR0cmlidXRlcy4gSG93ZXZlciwgZm9yXG4gICAgICAvLyBvcHRpb24gYW5kIHNlbGVjdCB3ZSBkb24ndCBxdWl0ZSBkbyB0aGUgc2FtZSB0aGluZyBhbmQgc2VsZWN0XG4gICAgICAvLyBpcyBub3QgcmVzaWxpZW50IHRvIHRoZSBET00gc3RhdGUgY2hhbmdpbmcgc28gd2UgZG9uJ3QgZG8gdGhhdCBoZXJlLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgbm90IGRvaW5nIHRoaXMgZm9yIGlucHV0IGFuZCB0ZXh0YXJlYS5cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHJhd1Byb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRUZXh0KHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnROb2RlLCBjaGlsZCkge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnROb2RlLCBjaGlsZCkge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnROb2RlLCB0YWcsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnROb2RlLCB0ZXh0KSB7XG4gIHtcbiAgICBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAgIC8vIFdlIGV4cGVjdCB0byBpbnNlcnQgZW1wdHkgdGV4dCBub2RlcyBzaW5jZSB0aGV5J3JlIG5vdCByZXByZXNlbnRlZCBpblxuICAgICAgLy8gdGhlIEhUTUwuXG4gICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgaWYgd2UgY2FuIGp1c3QgYXZvaWQgaW5zZXJ0aW5nIGVtcHR5XG4gICAgICAvLyB0ZXh0IG5vZGVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICB9XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoKSB7fTtcbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgLy8gVGhpcyB2YWxpZGF0aW9uIGNvZGUgd2FzIHdyaXR0ZW4gYmFzZWQgb24gdGhlIEhUTUw1IHBhcnNpbmcgc3BlYzpcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgLy9cbiAgLy8gTm90ZTogdGhpcyBkb2VzIG5vdCBjYXRjaCBhbGwgaW52YWxpZCBuZXN0aW5nLCBub3IgZG9lcyBpdCB0cnkgdG8gKGFzIGl0J3NcbiAgLy8gbm90IGNsZWFyIHdoYXQgcHJhY3RpY2FsIGJlbmVmaXQgZG9pbmcgc28gcHJvdmlkZXMpOyBpbnN0ZWFkLCB3ZSB3YXJuIG9ubHlcbiAgLy8gZm9yIGNhc2VzIHdoZXJlIHRoZSBwYXJzZXIgd2lsbCBnaXZlIGEgcGFyc2UgdHJlZSBkaWZmZXJpbmcgZnJvbSB3aGF0IFJlYWN0XG4gIC8vIGludGVuZGVkLiBGb3IgZXhhbXBsZSwgPGI+PGRpdj48L2Rpdj48L2I+IGlzIGludmFsaWQgYnV0IHdlIGRvbid0IHdhcm5cbiAgLy8gYmVjYXVzZSBpdCBzdGlsbCBwYXJzZXMgY29ycmVjdGx5OyB3ZSBkbyB3YXJuIGZvciBvdGhlciBjYXNlcyBsaWtlIG5lc3RlZFxuICAvLyA8cD4gdGFncyB3aGVyZSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBpbXBsaWNpdGx5IGNsb3NlcyB0aGVcbiAgLy8gZmlyc3QsIGNhdXNpbmcgYSBjb25mdXNpbmcgbWVzcy5cblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNzcGVjaWFsXG4gIHZhciBzcGVjaWFsVGFncyA9IFsnYWRkcmVzcycsICdhcHBsZXQnLCAnYXJlYScsICdhcnRpY2xlJywgJ2FzaWRlJywgJ2Jhc2UnLCAnYmFzZWZvbnQnLCAnYmdzb3VuZCcsICdibG9ja3F1b3RlJywgJ2JvZHknLCAnYnInLCAnYnV0dG9uJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NvbCcsICdjb2xncm91cCcsICdkZCcsICdkZXRhaWxzJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZW1iZWQnLCAnZmllbGRzZXQnLCAnZmlnY2FwdGlvbicsICdmaWd1cmUnLCAnZm9vdGVyJywgJ2Zvcm0nLCAnZnJhbWUnLCAnZnJhbWVzZXQnLCAnaDEnLCAnaDInLCAnaDMnLCAnaDQnLCAnaDUnLCAnaDYnLCAnaGVhZCcsICdoZWFkZXInLCAnaGdyb3VwJywgJ2hyJywgJ2h0bWwnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpc2luZGV4JywgJ2xpJywgJ2xpbmsnLCAnbGlzdGluZycsICdtYWluJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ25hdicsICdub2VtYmVkJywgJ25vZnJhbWVzJywgJ25vc2NyaXB0JywgJ29iamVjdCcsICdvbCcsICdwJywgJ3BhcmFtJywgJ3BsYWludGV4dCcsICdwcmUnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NvdXJjZScsICdzdHlsZScsICdzdW1tYXJ5JywgJ3RhYmxlJywgJ3Rib2R5JywgJ3RkJywgJ3RlbXBsYXRlJywgJ3RleHRhcmVhJywgJ3Rmb290JywgJ3RoJywgJ3RoZWFkJywgJ3RpdGxlJywgJ3RyJywgJ3RyYWNrJywgJ3VsJywgJ3dicicsICd4bXAnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICB2YXIgaW5TY29wZVRhZ3MgPSBbJ2FwcGxldCcsICdjYXB0aW9uJywgJ2h0bWwnLCAndGFibGUnLCAndGQnLCAndGgnLCAnbWFycXVlZScsICdvYmplY3QnLCAndGVtcGxhdGUnLFxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2h0bWwtaW50ZWdyYXRpb24tcG9pbnRcbiAgLy8gVE9ETzogRGlzdGluZ3Vpc2ggYnkgbmFtZXNwYWNlIGhlcmUgLS0gZm9yIDx0aXRsZT4sIGluY2x1ZGluZyBpdCBoZXJlXG4gIC8vIGVycnMgb24gdGhlIHNpZGUgb2YgZmV3ZXIgd2FybmluZ3NcbiAgJ2ZvcmVpZ25PYmplY3QnLCAnZGVzYycsICd0aXRsZSddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLWJ1dHRvbi1zY29wZVxuICB2YXIgYnV0dG9uU2NvcGVUYWdzID0gaW5TY29wZVRhZ3MuY29uY2F0KFsnYnV0dG9uJ10pO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2dlbmVyYXRlLWltcGxpZWQtZW5kLXRhZ3NcbiAgdmFyIGltcGxpZWRFbmRUYWdzID0gWydkZCcsICdkdCcsICdsaScsICdvcHRpb24nLCAnb3B0Z3JvdXAnLCAncCcsICdycCcsICdydCddO1xuXG4gIHZhciBlbXB0eUFuY2VzdG9ySW5mbyA9IHtcbiAgICBjdXJyZW50OiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHVwZGF0ZWRBbmNlc3RvckluZm8gPSBmdW5jdGlvbiAob2xkSW5mbywgdGFnKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZyB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8uY3VycmVudCA9IGluZm87XG5cbiAgICBpZiAodGFnID09PSAnZm9ybScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5mb3JtVGFnID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2EnKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYnV0dG9uJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbm9icicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2xpJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnZGQnIHx8IHRhZyA9PT0gJ2R0Jykge1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG5cbiAgICByZXR1cm4gYW5jZXN0b3JJbmZvO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBpc1RhZ1ZhbGlkV2l0aFBhcmVudCA9IGZ1bmN0aW9uICh0YWcsIHBhcmVudFRhZykge1xuICAgIC8vIEZpcnN0LCBsZXQncyBjaGVjayBpZiB3ZSdyZSBpbiBhbiB1bnVzdWFsIHBhcnNpbmcgbW9kZS4uLlxuICAgIHN3aXRjaCAocGFyZW50VGFnKSB7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5zZWxlY3RcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJ29wdGdyb3VwJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICBjYXNlICdvcHRncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdvcHRpb24nIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIFN0cmljdGx5IHNwZWFraW5nLCBzZWVpbmcgYW4gPG9wdGlvbj4gZG9lc24ndCBtZWFuIHdlJ3JlIGluIGEgPHNlbGVjdD5cbiAgICAgIC8vIGJ1dFxuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRkXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jYXB0aW9uXG4gICAgICAvLyBObyBzcGVjaWFsIGJlaGF2aW9yIHNpbmNlIHRoZXNlIHJ1bGVzIGZhbGwgYmFjayB0byBcImluIGJvZHlcIiBtb2RlIGZvclxuICAgICAgLy8gYWxsIGV4Y2VwdCBzcGVjaWFsIHRhYmxlIG5vZGVzIHdoaWNoIGNhdXNlIGJhZCBwYXJzaW5nIGJlaGF2aW9yIGFueXdheS5cblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludHJcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RoJyB8fCB0YWcgPT09ICd0ZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5jb2xncm91cFxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY29sJyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50YWJsZVxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnY2FwdGlvbicgfHwgdGFnID09PSAnY29sZ3JvdXAnIHx8IHRhZyA9PT0gJ3Rib2R5JyB8fCB0YWcgPT09ICd0Zm9vdCcgfHwgdGFnID09PSAndGhlYWQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlbWFudGljcy5odG1sI3RoZS1odG1sLWVsZW1lbnRcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaGVhZCcgfHwgdGFnID09PSAnYm9keSc7XG4gICAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnaHRtbCc7XG4gICAgfVxuXG4gICAgLy8gUHJvYmFibHkgaW4gdGhlIFwiaW4gYm9keVwiIHBhcnNpbmcgbW9kZSwgc28gd2Ugb3V0bGF3IG9ubHkgdGFnIGNvbWJvc1xuICAgIC8vIHdoZXJlIHRoZSBwYXJzaW5nIHJ1bGVzIGNhdXNlIGltcGxpY2l0IG9wZW5zIG9yIGNsb3NlcyB0byBiZSBhZGRlZC5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyAhPT0gJ2gxJyAmJiBwYXJlbnRUYWcgIT09ICdoMicgJiYgcGFyZW50VGFnICE9PSAnaDMnICYmIHBhcmVudFRhZyAhPT0gJ2g0JyAmJiBwYXJlbnRUYWcgIT09ICdoNScgJiYgcGFyZW50VGFnICE9PSAnaDYnO1xuXG4gICAgICBjYXNlICdycCc6XG4gICAgICBjYXNlICdydCc6XG4gICAgICAgIHJldHVybiBpbXBsaWVkRW5kVGFncy5pbmRleE9mKHBhcmVudFRhZykgPT09IC0xO1xuXG4gICAgICBjYXNlICdib2R5JzpcbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0ZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICBjYXNlICd0aCc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIC8vIFRoZXNlIHRhZ3MgYXJlIG9ubHkgdmFsaWQgd2l0aCBhIGZldyBwYXJlbnRzIHRoYXQgaGF2ZSBzcGVjaWFsIGNoaWxkXG4gICAgICAgIC8vIHBhcnNpbmcgcnVsZXMgLS0gaWYgd2UncmUgZG93biBoZXJlLCB0aGVuIG5vbmUgb2YgdGhvc2UgbWF0Y2hlZCBhbmRcbiAgICAgICAgLy8gc28gd2UgYWxsb3cgaXQgb25seSBpZiB3ZSBkb24ndCBrbm93IHdoYXQgdGhlIHBhcmVudCBpcywgYXMgYWxsIG90aGVyXG4gICAgICAgIC8vIGNhc2VzIGFyZSBpbnZhbGlkLlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnID09IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICBjYXNlICdhcnRpY2xlJzpcbiAgICAgIGNhc2UgJ2FzaWRlJzpcbiAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgY2FzZSAnZGlhbG9nJzpcbiAgICAgIGNhc2UgJ2Rpcic6XG4gICAgICBjYXNlICdkaXYnOlxuICAgICAgY2FzZSAnZGwnOlxuICAgICAgY2FzZSAnZmllbGRzZXQnOlxuICAgICAgY2FzZSAnZmlnY2FwdGlvbic6XG4gICAgICBjYXNlICdmaWd1cmUnOlxuICAgICAgY2FzZSAnZm9vdGVyJzpcbiAgICAgIGNhc2UgJ2hlYWRlcic6XG4gICAgICBjYXNlICdoZ3JvdXAnOlxuICAgICAgY2FzZSAnbWFpbic6XG4gICAgICBjYXNlICdtZW51JzpcbiAgICAgIGNhc2UgJ25hdic6XG4gICAgICBjYXNlICdvbCc6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ3NlY3Rpb24nOlxuICAgICAgY2FzZSAnc3VtbWFyeSc6XG4gICAgICBjYXNlICd1bCc6XG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICBjYXNlICdocic6XG4gICAgICBjYXNlICd4bXAnOlxuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdmb3JtJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5mb3JtVGFnIHx8IGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnbGknOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2RkJzpcbiAgICAgIGNhc2UgJ2R0JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gU3BlYyBzYXlzIHNvbWV0aGluZyBhYm91dCBzdG9yaW5nIGEgbGlzdCBvZiBtYXJrZXJzLCBidXQgaXQgc291bmRzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gdGhpcyBjaGVjay5cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnbm9icic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgdmFyIGRpZFdhcm4gPSB7fTtcblxuICB2YWxpZGF0ZURPTU5lc3RpbmcgPSBmdW5jdGlvbiAoY2hpbGRUYWcsIGNoaWxkVGV4dCwgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG5cbiAgICBpZiAoY2hpbGRUZXh0ICE9IG51bGwpIHtcbiAgICAgICEoY2hpbGRUYWcgPT0gbnVsbCkgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3Rpbmc6IHdoZW4gY2hpbGRUZXh0IGlzIHBhc3NlZCwgY2hpbGRUYWcgc2hvdWxkIGJlIG51bGwnKSA6IHZvaWQgMDtcbiAgICAgIGNoaWxkVGFnID0gJyN0ZXh0JztcbiAgICB9XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW52YWxpZFBhcmVudE9yQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcbiAgICBpZiAoIWludmFsaWRQYXJlbnRPckFuY2VzdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuY2VzdG9yVGFnID0gaW52YWxpZFBhcmVudE9yQW5jZXN0b3IudGFnO1xuICAgIHZhciBhZGRlbmR1bSA9IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKTtcblxuICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIGFkZGVuZHVtO1xuICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgdmFyIHdoaXRlc3BhY2VJbmZvID0gJyc7XG4gICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1RleHQgbm9kZXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgd2hpdGVzcGFjZUluZm8gPSBcIiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIFwiICsgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgfVxuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzJXMlcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgd2hpdGVzcGFjZUluZm8sIGluZm8sIGFkZGVuZHVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBkZXNjZW5kYW50IG9mICcgKyAnPCVzPi4lcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgYWRkZW5kdW0pO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gUmVuZGVyZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBwZXJzaXN0ZW5jZVxuLy8gY2FuIHJlLWV4cG9ydCBldmVyeXRoaW5nIGZyb20gdGhpcyBtb2R1bGUuXG5cbmZ1bmN0aW9uIHNoaW0oKSB7XG4gIGludmFyaWFudChmYWxzZSwgJ1RoZSBjdXJyZW50IHJlbmRlcmVyIGRvZXMgbm90IHN1cHBvcnQgcGVyc2lzdGVuY2UuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbi8vIFBlcnNpc3RlbmNlICh3aGVuIHVuc3VwcG9ydGVkKVxudmFyIHN1cHBvcnRzUGVyc2lzdGVuY2UgPSBmYWxzZTtcbnZhciBjbG9uZUluc3RhbmNlID0gc2hpbTtcbnZhciBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHNoaW07XG52YXIgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0ID0gc2hpbTtcbnZhciBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gc2hpbTtcbnZhciByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4gPSBzaGltO1xudmFyIGNsb25lSGlkZGVuSW5zdGFuY2UgPSBzaGltO1xudmFyIGNsb25lVW5oaWRkZW5JbnN0YW5jZSA9IHNoaW07XG52YXIgY3JlYXRlSGlkZGVuVGV4dEluc3RhbmNlID0gc2hpbTtcblxudmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HID0gdm9pZCAwO1xue1xuICBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xufVxuXG52YXIgU1VTUEVOU0VfU1RBUlRfREFUQSA9ICckJztcbnZhciBTVVNQRU5TRV9FTkRfREFUQSA9ICcvJCc7XG5cbnZhciBTVFlMRSA9ICdzdHlsZSc7XG5cbnZhciBldmVudHNFbmFibGVkID0gbnVsbDtcbnZhciBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG5cbmZ1bmN0aW9uIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYnV0dG9uJzpcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXR1cm4gISFwcm9wcy5hdXRvRm9jdXM7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRSb290SG9zdENvbnRleHQocm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gIHZhciB0eXBlID0gdm9pZCAwO1xuICB2YXIgbmFtZXNwYWNlID0gdm9pZCAwO1xuICB2YXIgbm9kZVR5cGUgPSByb290Q29udGFpbmVySW5zdGFuY2Uubm9kZVR5cGU7XG4gIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICBjYXNlIERPQ1VNRU5UX05PREU6XG4gICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAge1xuICAgICAgICB0eXBlID0gbm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyAnI2RvY3VtZW50JyA6ICcjZnJhZ21lbnQnO1xuICAgICAgICB2YXIgcm9vdCA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIG5hbWVzcGFjZSA9IHJvb3QgPyByb290Lm5hbWVzcGFjZVVSSSA6IGdldENoaWxkTmFtZXNwYWNlKG51bGwsICcnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgdHlwZSA9IGNvbnRhaW5lci50YWdOYW1lO1xuICAgICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICB7XG4gICAgdmFyIHZhbGlkYXRlZFRhZyA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgX2FuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgdmFsaWRhdGVkVGFnKTtcbiAgICByZXR1cm4geyBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvIH07XG4gIH1cbiAgcmV0dXJuIG5hbWVzcGFjZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGRIb3N0Q29udGV4dChwYXJlbnRIb3N0Q29udGV4dCwgdHlwZSwgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gIHtcbiAgICB2YXIgcGFyZW50SG9zdENvbnRleHREZXYgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICB2YXIgX25hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKHBhcmVudEhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZSwgdHlwZSk7XG4gICAgdmFyIF9hbmNlc3RvckluZm8yID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRIb3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUpO1xuICAgIHJldHVybiB7IG5hbWVzcGFjZTogX25hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvMiB9O1xuICB9XG4gIHZhciBwYXJlbnROYW1lc3BhY2UgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgcmV0dXJuIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSk7XG59XG5cbmZ1bmN0aW9uIGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZUZvckNvbW1pdChjb250YWluZXJJbmZvKSB7XG4gIGV2ZW50c0VuYWJsZWQgPSBpc0VuYWJsZWQoKTtcbiAgc2VsZWN0aW9uSW5mb3JtYXRpb24gPSBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpO1xuICBzZXRFbmFibGVkKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gcmVzZXRBZnRlckNvbW1pdChjb250YWluZXJJbmZvKSB7XG4gIHJlc3RvcmVTZWxlY3Rpb24oc2VsZWN0aW9uSW5mb3JtYXRpb24pO1xuICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG4gIHNldEVuYWJsZWQoZXZlbnRzRW5hYmxlZCk7XG4gIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICB7XG4gICAgLy8gVE9ETzogdGFrZSBuYW1lc3BhY2UgaW50byBhY2NvdW50IHdoZW4gdmFsaWRhdGluZy5cbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICB2YWxpZGF0ZURPTU5lc3RpbmcodHlwZSwgbnVsbCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICBpZiAodHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cbiAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gIH1cbiAgdmFyIGRvbUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIHBhcmVudE5hbWVzcGFjZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGRvbUVsZW1lbnQpO1xuICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgcmV0dXJuIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVXBkYXRlKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICB7XG4gICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgaWYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiAhPT0gdHlwZW9mIG9sZFByb3BzLmNoaWxkcmVuICYmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpKSB7XG4gICAgICB2YXIgc3RyaW5nID0gJycgKyBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSk7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmcobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcm9wcykge1xuICByZXR1cm4gdHlwZSA9PT0gJ3RleHRhcmVhJyB8fCB0eXBlID09PSAnb3B0aW9uJyB8fCB0eXBlID09PSAnbm9zY3JpcHQnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCAhPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlKHR5cGUsIHByb3BzKSB7XG4gIHJldHVybiAhIXByb3BzLmhpZGRlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dEluc3RhbmNlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAge1xuICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgIHZhbGlkYXRlRE9NTmVzdGluZyhudWxsLCB0ZXh0LCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICB9XG4gIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHROb2RlKTtcbiAgcmV0dXJuIHRleHROb2RlO1xufVxuXG52YXIgaXNQcmltYXJ5UmVuZGVyZXIgPSB0cnVlO1xuLy8gVGhpcyBpbml0aWFsaXphdGlvbiBjb2RlIG1heSBydW4gZXZlbiBvbiBzZXJ2ZXIgZW52aXJvbm1lbnRzXG4vLyBpZiBhIGNvbXBvbmVudCBqdXN0IGltcG9ydHMgUmVhY3RET00gKGUuZy4gZm9yIGZpbmRET01Ob2RlKS5cbi8vIFNvbWUgZW52aXJvbm1lbnRzIG1pZ2h0IG5vdCBoYXZlIHNldFRpbWVvdXQgb3IgY2xlYXJUaW1lb3V0LlxudmFyIHNjaGVkdWxlVGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZDtcbnZhciBjYW5jZWxUaW1lb3V0ID0gdHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJyA/IGNsZWFyVGltZW91dCA6IHVuZGVmaW5lZDtcbnZhciBub1RpbWVvdXQgPSAtMTtcbnZhciBzY2hlZHVsZVBhc3NpdmVFZmZlY3RzID0gc2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG52YXIgY2FuY2VsUGFzc2l2ZUVmZmVjdHMgPSBzY2hlZHVsZXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICBNdXRhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNNdXRhdGlvbiA9IHRydWU7XG5cbmZ1bmN0aW9uIGNvbW1pdE1vdW50KGRvbUVsZW1lbnQsIHR5cGUsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIC8vIERlc3BpdGUgdGhlIG5hbWluZyB0aGF0IG1pZ2h0IGltcGx5IG90aGVyd2lzZSwgdGhpcyBtZXRob2Qgb25seVxuICAvLyBmaXJlcyBpZiB0aGVyZSBpcyBhbiBgVXBkYXRlYCBlZmZlY3Qgc2NoZWR1bGVkIGR1cmluZyBtb3VudGluZy5cbiAgLy8gVGhpcyBoYXBwZW5zIGlmIGBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbmAgcmV0dXJucyBgdHJ1ZWAgKHdoaWNoIGl0XG4gIC8vIGRvZXMgdG8gaW1wbGVtZW50IHRoZSBgYXV0b0ZvY3VzYCBhdHRyaWJ1dGUgb24gdGhlIGNsaWVudCkuIEJ1dFxuICAvLyB0aGVyZSBhcmUgYWxzbyBvdGhlciBjYXNlcyB3aGVuIHRoaXMgbWlnaHQgaGFwcGVuIChzdWNoIGFzIHBhdGNoaW5nXG4gIC8vIHVwIHRleHQgY29udGVudCBkdXJpbmcgaHlkcmF0aW9uIG1pc21hdGNoKS4gU28gd2UnbGwgY2hlY2sgdGhpcyBhZ2Fpbi5cbiAgaWYgKHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgbmV3UHJvcHMpKSB7XG4gICAgZG9tRWxlbWVudC5mb2N1cygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgLy8gVXBkYXRlIHRoZSBwcm9wcyBoYW5kbGUgc28gdGhhdCB3ZSBrbm93IHdoaWNoIHByb3BzIGFyZSB0aGUgb25lcyB3aXRoXG4gIC8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbiAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBuZXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBET00gbm9kZS5cbiAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xufVxuXG5mdW5jdGlvbiByZXNldFRleHRDb250ZW50KGRvbUVsZW1lbnQpIHtcbiAgc2V0VGV4dENvbnRlbnQoZG9tRWxlbWVudCwgJycpO1xufVxuXG5mdW5jdGlvbiBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCkge1xuICB0ZXh0SW5zdGFuY2Uubm9kZVZhbHVlID0gbmV3VGV4dDtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGQocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihjb250YWluZXIsIGNoaWxkKSB7XG4gIHZhciBwYXJlbnROb2RlID0gdm9pZCAwO1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBwYXJlbnROb2RlID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGNvbnRhaW5lcik7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50Tm9kZSA9IGNvbnRhaW5lcjtcbiAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxuICAvLyBUaGlzIGNvbnRhaW5lciBtaWdodCBiZSB1c2VkIGZvciBhIHBvcnRhbC5cbiAgLy8gSWYgc29tZXRoaW5nIGluc2lkZSBhIHBvcnRhbCBpcyBjbGlja2VkLCB0aGF0IGNsaWNrIHNob3VsZCBidWJibGVcbiAgLy8gdGhyb3VnaCB0aGUgUmVhY3QgdHJlZS4gSG93ZXZlciwgb24gTW9iaWxlIFNhZmFyaSB0aGUgY2xpY2sgd291bGRcbiAgLy8gbmV2ZXIgYnViYmxlIHRocm91Z2ggdGhlICpET00qIHRyZWUgdW5sZXNzIGFuIGFuY2VzdG9yIHdpdGggb25jbGlja1xuICAvLyBldmVudCBleGlzdHMuIFNvIHdlIHdvdWxkbid0IHNlZSBpdCBhbmQgZGlzcGF0Y2ggaXQuXG4gIC8vIFRoaXMgaXMgd2h5IHdlIGVuc3VyZSB0aGF0IG5vbiBSZWFjdCByb290IGNvbnRhaW5lcnMgaGF2ZSBpbmxpbmUgb25jbGlja1xuICAvLyBkZWZpbmVkLlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzExOTE4XG4gIHZhciByZWFjdFJvb3RDb250YWluZXIgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgaWYgKChyZWFjdFJvb3RDb250YWluZXIgPT09IG51bGwgfHwgcmVhY3RSb290Q29udGFpbmVyID09PSB1bmRlZmluZWQpICYmIHBhcmVudE5vZGUub25jbGljayA9PT0gbnVsbCkge1xuICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQocGFyZW50Tm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGluc2VydEluQ29udGFpbmVyQmVmb3JlKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY29udGFpbmVyLCBjaGlsZCkge1xuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhclN1c3BlbnNlQm91bmRhcnkocGFyZW50SW5zdGFuY2UsIHN1c3BlbnNlSW5zdGFuY2UpIHtcbiAgdmFyIG5vZGUgPSBzdXNwZW5zZUluc3RhbmNlO1xuICAvLyBEZWxldGUgYWxsIG5vZGVzIHdpdGhpbiB0aGlzIHN1c3BlbnNlIGJvdW5kYXJ5LlxuICAvLyBUaGVyZSBtaWdodCBiZSBuZXN0ZWQgbm9kZXMgc28gd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGhvd1xuICAvLyBkZWVwIHdlIGFyZSBhbmQgb25seSBicmVhayBvdXQgd2hlbiB3ZSdyZSBiYWNrIG9uIHRvcC5cbiAgdmFyIGRlcHRoID0gMDtcbiAgZG8ge1xuICAgIHZhciBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgaWYgKG5leHROb2RlICYmIG5leHROb2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBkYXRhID0gbmV4dE5vZGUuZGF0YTtcbiAgICAgIGlmIChkYXRhID09PSBTVVNQRU5TRV9FTkRfREFUQSkge1xuICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICBwYXJlbnRJbnN0YW5jZS5yZW1vdmVDaGlsZChuZXh0Tm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSA9PT0gU1VTUEVOU0VfU1RBUlRfREFUQSkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlID0gbmV4dE5vZGU7XG4gIH0gd2hpbGUgKG5vZGUpO1xuICAvLyBUT0RPOiBXYXJuLCB3ZSBkaWRuJ3QgZmluZCB0aGUgZW5kIGNvbW1lbnQgYm91bmRhcnkuXG59XG5cbmZ1bmN0aW9uIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIoY29udGFpbmVyLCBzdXNwZW5zZUluc3RhbmNlKSB7XG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeShjb250YWluZXIucGFyZW50Tm9kZSwgc3VzcGVuc2VJbnN0YW5jZSk7XG4gIH0gZWxzZSBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICBjbGVhclN1c3BlbnNlQm91bmRhcnkoY29udGFpbmVyLCBzdXNwZW5zZUluc3RhbmNlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEb2N1bWVudCBub2RlcyBzaG91bGQgbmV2ZXIgY29udGFpbiBzdXNwZW5zZSBib3VuZGFyaWVzLlxuICB9XG59XG5cbmZ1bmN0aW9uIGhpZGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICAvLyBUT0RPOiBEb2VzIHRoaXMgd29yayBmb3IgYWxsIGVsZW1lbnQgdHlwZXM/IFdoYXQgYWJvdXQgTWF0aE1MPyBTaG91bGQgd2VcbiAgLy8gcGFzcyBob3N0IGNvbnRleHQgdG8gdGhpcyBtZXRob2Q/XG4gIGluc3RhbmNlID0gaW5zdGFuY2U7XG4gIGluc3RhbmNlLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG59XG5cbmZ1bmN0aW9uIGhpZGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlKSB7XG4gIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSAnJztcbn1cblxuZnVuY3Rpb24gdW5oaWRlSW5zdGFuY2UoaW5zdGFuY2UsIHByb3BzKSB7XG4gIGluc3RhbmNlID0gaW5zdGFuY2U7XG4gIHZhciBzdHlsZVByb3AgPSBwcm9wc1tTVFlMRV07XG4gIHZhciBkaXNwbGF5ID0gc3R5bGVQcm9wICE9PSB1bmRlZmluZWQgJiYgc3R5bGVQcm9wICE9PSBudWxsICYmIHN0eWxlUHJvcC5oYXNPd25Qcm9wZXJ0eSgnZGlzcGxheScpID8gc3R5bGVQcm9wLmRpc3BsYXkgOiBudWxsO1xuICBpbnN0YW5jZS5zdHlsZS5kaXNwbGF5ID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZSgnZGlzcGxheScsIGRpc3BsYXkpO1xufVxuXG5mdW5jdGlvbiB1bmhpZGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSB0ZXh0O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgSHlkcmF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBzdXBwb3J0c0h5ZHJhdGlvbiA9IHRydWU7XG5cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgaWYgKGluc3RhbmNlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSBpbnN0YW5jZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhbiBlbGVtZW50IG5vZGUuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShpbnN0YW5jZSwgdGV4dCkge1xuICBpZiAodGV4dCA9PT0gJycgfHwgaW5zdGFuY2Uubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgIC8vIEVtcHR5IHN0cmluZ3MgYXJlIG5vdCBwYXJzZWQgYnkgSFRNTCBzbyB0aGVyZSB3b24ndCBiZSBhIGNvcnJlY3QgbWF0Y2ggaGVyZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGEgdGV4dCBub2RlLlxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gIGlmIChpbnN0YW5jZS5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFRoaXMgaGFzIG5vdyBiZWVuIHJlZmluZWQgdG8gYSBzdXNwZW5zZSBub2RlLlxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlU2libGluZyhpbnN0YW5jZSkge1xuICB2YXIgbm9kZSA9IGluc3RhbmNlLm5leHRTaWJsaW5nO1xuICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFICYmICghZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlciB8fCBub2RlLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUgfHwgbm9kZS5kYXRhICE9PSBTVVNQRU5TRV9TVEFSVF9EQVRBKSkge1xuICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSkge1xuICB2YXIgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gIHdoaWxlIChuZXh0ICYmIG5leHQubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSAmJiBuZXh0Lm5vZGVUeXBlICE9PSBURVhUX05PREUgJiYgKCFlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyIHx8IG5leHQubm9kZVR5cGUgIT09IENPTU1FTlRfTk9ERSB8fCBuZXh0LmRhdGEgIT09IFNVU1BFTlNFX1NUQVJUX0RBVEEpKSB7XG4gICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIG5leHQ7XG59XG5cbmZ1bmN0aW9uIGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgaW5zdGFuY2UpO1xuICAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgLy8gZ2V0IGF0dGFjaGVkLlxuICB1cGRhdGVGaWJlclByb3BzKGluc3RhbmNlLCBwcm9wcyk7XG4gIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gIHtcbiAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gIH1cbiAgcmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHRJbnN0YW5jZSk7XG4gIHJldHVybiBkaWZmSHlkcmF0ZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG59XG5cbmZ1bmN0aW9uIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSkge1xuICB2YXIgbm9kZSA9IHN1c3BlbnNlSW5zdGFuY2UubmV4dFNpYmxpbmc7XG4gIC8vIFNraXAgcGFzdCBhbGwgbm9kZXMgd2l0aGluIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkuXG4gIC8vIFRoZXJlIG1pZ2h0IGJlIG5lc3RlZCBub2RlcyBzbyB3ZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgaG93XG4gIC8vIGRlZXAgd2UgYXJlIGFuZCBvbmx5IGJyZWFrIG91dCB3aGVuIHdlJ3JlIGJhY2sgb24gdG9wLlxuICB2YXIgZGVwdGggPSAwO1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgaWYgKGRhdGEgPT09IFNVU1BFTlNFX0VORF9EQVRBKSB7XG4gICAgICAgIGlmIChkZXB0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBTVVNQRU5TRV9TVEFSVF9EQVRBKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICB9XG4gIC8vIFRPRE86IFdhcm4sIHdlIGRpZG4ndCBmaW5kIHRoZSBlbmQgY29tbWVudCBib3VuZGFyeS5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKSB7XG4gIHtcbiAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgIC8vIFRPRE86IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVN1c3BlbnNlQm91bmRhcnlcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90SHlkcmF0ZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICB9IGVsc2UgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgIC8vIFRPRE86IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVN1c3BlbnNlQm91bmRhcnlcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICB9XG59XG5cblxuXG5mdW5jdGlvbiBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0KSB7XG4gIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlkTm90RmluZEh5ZHJhdGFibGVTdXNwZW5zZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSkge1xuICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAvLyBUT0RPOiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFN1c3BlbnNlKHBhcmVudEluc3RhbmNlKTtcbiAgfVxufVxuXG4vLyBQcmVmaXggbWVhc3VyZW1lbnRzIHNvIHRoYXQgaXQncyBwb3NzaWJsZSB0byBmaWx0ZXIgdGhlbS5cbi8vIExvbmdlciBwcmVmaXhlcyBhcmUgaGFyZCB0byByZWFkIGluIERldlRvb2xzLlxudmFyIHJlYWN0RW1vamkgPSAnXFx1MjY5Qic7XG52YXIgd2FybmluZ0Vtb2ppID0gJ1xcdTI2RDQnO1xudmFyIHN1cHBvcnRzVXNlclRpbWluZyA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMgPT09ICdmdW5jdGlvbic7XG5cbi8vIEtlZXAgdHJhY2sgb2YgY3VycmVudCBmaWJlciBzbyB0aGF0IHdlIGtub3cgdGhlIHBhdGggdG8gdW53aW5kIG9uIHBhdXNlLlxuLy8gVE9ETzogdGhpcyBsb29rcyB0aGUgc2FtZSBhcyBuZXh0VW5pdE9mV29yayBpbiBzY2hlZHVsZXIuIENhbiB3ZSB1bmlmeSB0aGVtP1xudmFyIGN1cnJlbnRGaWJlciA9IG51bGw7XG4vLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHVzZXIgY29kZSwgd2hpY2ggZmliZXIgYW5kIG1ldGhvZCBpcyBpdD9cbi8vIFJldXNpbmcgYGN1cnJlbnRGaWJlcmAgd291bGQgYmUgY29uZnVzaW5nIGZvciB0aGlzIGJlY2F1c2UgdXNlciBjb2RlIGZpYmVyXG4vLyBjYW4gY2hhbmdlIGR1cmluZyBjb21taXQgcGhhc2UgdG9vLCBidXQgd2UgZG9uJ3QgbmVlZCB0byB1bndpbmQgaXQgKHNpbmNlXG4vLyBsaWZlY3ljbGVzIGluIHRoZSBjb21taXQgcGhhc2UgZG9uJ3QgcmVzZW1ibGUgYSB0cmVlKS5cbnZhciBjdXJyZW50UGhhc2UgPSBudWxsO1xudmFyIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbi8vIERpZCBsaWZlY3ljbGUgaG9vayBzY2hlZHVsZSBhbiB1cGRhdGU/IFRoaXMgaXMgb2Z0ZW4gYSBwZXJmb3JtYW5jZSBwcm9ibGVtLFxuLy8gc28gd2Ugd2lsbCBrZWVwIHRyYWNrIG9mIGl0LCBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVwb3J0LlxuLy8gVHJhY2sgY29tbWl0cyBjYXVzZWQgYnkgY2FzY2FkaW5nIHVwZGF0ZXMuXG52YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbnZhciBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbnZhciBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG52YXIgaXNXYWl0aW5nRm9yQ2FsbGJhY2sgPSBmYWxzZTtcbi8vIER1cmluZyBjb21taXRzLCB3ZSBvbmx5IHNob3cgYSBtZWFzdXJlbWVudCBvbmNlIHBlciBtZXRob2QgbmFtZVxuLy8gdG8gYXZvaWQgc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIHdpdGggbWVhc3VyZW1lbnQgb3ZlcmhlYWQuXG52YXIgbGFiZWxzSW5DdXJyZW50Q29tbWl0ID0gbmV3IFNldCgpO1xuXG52YXIgZm9ybWF0TWFya05hbWUgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcmV0dXJuIHJlYWN0RW1vamkgKyAnICcgKyBtYXJrTmFtZTtcbn07XG5cbnZhciBmb3JtYXRMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCwgd2FybmluZykge1xuICB2YXIgcHJlZml4ID0gd2FybmluZyA/IHdhcm5pbmdFbW9qaSArICcgJyA6IHJlYWN0RW1vamkgKyAnICc7XG4gIHZhciBzdWZmaXggPSB3YXJuaW5nID8gJyBXYXJuaW5nOiAnICsgd2FybmluZyA6ICcnO1xuICByZXR1cm4gJycgKyBwcmVmaXggKyBsYWJlbCArIHN1ZmZpeDtcbn07XG5cbnZhciBiZWdpbk1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UubWFyayhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGNsZWFyTWFyayA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKSk7XG59O1xuXG52YXIgZW5kTWFyayA9IGZ1bmN0aW9uIChsYWJlbCwgbWFya05hbWUsIHdhcm5pbmcpIHtcbiAgdmFyIGZvcm1hdHRlZE1hcmtOYW1lID0gZm9ybWF0TWFya05hbWUobWFya05hbWUpO1xuICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCwgd2FybmluZyk7XG4gIHRyeSB7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShmb3JtYXR0ZWRMYWJlbCwgZm9ybWF0dGVkTWFya05hbWUpO1xuICB9IGNhdGNoIChlcnIpIHt9XG4gIC8vIElmIHByZXZpb3VzIG1hcmsgd2FzIG1pc3NpbmcgZm9yIHNvbWUgcmVhc29uLCB0aGlzIHdpbGwgdGhyb3cuXG4gIC8vIFRoaXMgY291bGQgb25seSBoYXBwZW4gaWYgUmVhY3QgY3Jhc2hlZCBpbiBhbiB1bmV4cGVjdGVkIHBsYWNlIGVhcmxpZXIuXG4gIC8vIERvbid0IHBpbGUgb24gd2l0aCBtb3JlIGVycm9ycy5cblxuICAvLyBDbGVhciBtYXJrcyBpbW1lZGlhdGVseSB0byBhdm9pZCBncm93aW5nIGJ1ZmZlci5cbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXR0ZWRNYXJrTmFtZSk7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMoZm9ybWF0dGVkTGFiZWwpO1xufTtcblxudmFyIGdldEZpYmVyTWFya05hbWUgPSBmdW5jdGlvbiAobGFiZWwsIGRlYnVnSUQpIHtcbiAgcmV0dXJuIGxhYmVsICsgJyAoIycgKyBkZWJ1Z0lEICsgJyknO1xufTtcblxudmFyIGdldEZpYmVyTGFiZWwgPSBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSkge1xuICBpZiAocGhhc2UgPT09IG51bGwpIHtcbiAgICAvLyBUaGVzZSBhcmUgY29tcG9zaXRlIGNvbXBvbmVudCB0b3RhbCB0aW1lIG1lYXN1cmVtZW50cy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArICcgWycgKyAoaXNNb3VudGVkID8gJ3VwZGF0ZScgOiAnbW91bnQnKSArICddJztcbiAgfSBlbHNlIHtcbiAgICAvLyBDb21wb3NpdGUgY29tcG9uZW50IG1ldGhvZHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnLicgKyBwaGFzZTtcbiAgfVxufTtcblxudmFyIGJlZ2luRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuXG4gIGlmIChpc0NvbW1pdHRpbmcgJiYgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmhhcyhsYWJlbCkpIHtcbiAgICAvLyBEdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSwgd2UgZG9uJ3Qgc2hvdyBkdXBsaWNhdGUgbGFiZWxzIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBhIGZpeGVkIG92ZXJoZWFkIGZvciBldmVyeSBtZWFzdXJlbWVudCwgYW5kIHdlIGRvbid0XG4gICAgLy8gd2FudCB0byBzdHJldGNoIHRoZSBjb21taXQgcGhhc2UgYmV5b25kIG5lY2Vzc2FyeS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmFkZChsYWJlbCk7XG5cbiAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gIGJlZ2luTWFyayhtYXJrTmFtZSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGNsZWFyRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgY2xlYXJNYXJrKG1hcmtOYW1lKTtcbn07XG5cbnZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlLCB3YXJuaW5nKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBlbmRNYXJrKGxhYmVsLCBtYXJrTmFtZSwgd2FybmluZyk7XG59O1xuXG52YXIgc2hvdWxkSWdub3JlRmliZXIgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgLy8gSG9zdCBjb21wb25lbnRzIHNob3VsZCBiZSBza2lwcGVkIGluIHRoZSB0aW1lbGluZS5cbiAgLy8gV2UgY291bGQgY2hlY2sgdHlwZW9mIGZpYmVyLnR5cGUsIGJ1dCBkb2VzIHRoaXMgd29yayB3aXRoIFJOP1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICBjbGVhckZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlKTtcbiAgfVxuICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG59O1xuXG52YXIgcGF1c2VUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFN0b3BzIGFsbCBjdXJyZW50bHkgYWN0aXZlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlc3VtZWRcbiAgLy8gaWYgd2UgY29udGludWUgaW4gYSBsYXRlciBkZWZlcnJlZCBsb29wIGZyb20gdGhlIHNhbWUgdW5pdCBvZiB3b3JrLlxuICB2YXIgZmliZXIgPSBjdXJyZW50RmliZXI7XG4gIHdoaWxlIChmaWJlcikge1xuICAgIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnNSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICBpZiAoZmliZXIucmV0dXJuICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoZmliZXIucmV0dXJuKTtcbiAgfVxuICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICBiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlc3VtZXMgYWxsIG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgYWN0aXZlIGR1cmluZyB0aGUgbGFzdCBkZWZlcnJlZCBsb29wLlxuICBpZiAoY3VycmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoY3VycmVudEZpYmVyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0KCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkU2NoZWR1bGVVcGRhdGUoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsTW91bnQnICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UmVxdWVzdENhbGxiYWNrVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKHN1cHBvcnRzVXNlclRpbWluZyAmJiAhaXNXYWl0aW5nRm9yQ2FsbGJhY2spIHtcbiAgICAgIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIGJlZ2luTWFyaygnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUmVxdWVzdENhbGxiYWNrVGltZXIoZGlkRXhwaXJlLCBleHBpcmF0aW9uVGltZSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4gICAgICB2YXIgd2FybmluZyA9IGRpZEV4cGlyZSA/ICdSZWFjdCB3YXMgYmxvY2tlZCBieSBtYWluIHRocmVhZCcgOiBudWxsO1xuICAgICAgZW5kTWFyaygnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uIHdpbGwgZm9yY2UgZmx1c2ggaW4gJyArIGV4cGlyYXRpb25UaW1lICsgJyBtcyknLCAnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScsIHdhcm5pbmcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgdGhpcyBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXI7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBSZW1lbWJlciB3ZSBzaG91bGRuJ3QgY29tcGxldGUgbWVhc3VyZW1lbnQgZm9yIHRoaXMgZmliZXIuXG4gICAgLy8gT3RoZXJ3aXNlIGZsYW1lY2hhcnQgd2lsbCBiZSBkZWVwIGV2ZW4gZm9yIHNtYWxsIHVwZGF0ZXMuXG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBjbGVhckZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BGYWlsZWRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgdmFyIHdhcm5pbmcgPSBmaWJlci50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50ID8gJ1JlbmRlcmluZyB3YXMgc3VzcGVuZGVkJyA6ICdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSB0aGlzIGVycm9yIGJvdW5kYXJ5JztcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIHdhcm5pbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgcGhhc2UpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50KCk7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgcGhhc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gZmliZXI7XG4gICAgY3VycmVudFBoYXNlID0gcGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFBoYXNlVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5pbmcgPSBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA/ICdTY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJyA6IG51bGw7XG4gICAgICBlbmRGaWJlck1hcmsoY3VycmVudFBoYXNlRmliZXIsIGN1cnJlbnRQaGFzZSwgd2FybmluZyk7XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yaykge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGN1cnJlbnRGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgIC8vIFRoaXMgaXMgdG9wIGxldmVsIGNhbGwuXG4gICAgLy8gQW55IG90aGVyIG1lYXN1cmVtZW50cyBhcmUgcGVyZm9ybWVkIHdpdGhpbi5cbiAgICBiZWdpbk1hcmsoJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScpO1xuICAgIC8vIFJlc3VtZSBhbnkgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBpbiBwcm9ncmVzcyBkdXJpbmcgdGhlIGxhc3QgbG9vcC5cbiAgICByZXN1bWVUaW1lcnMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5LCBkaWRDb21wbGV0ZVJvb3QpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeS50eXBlKSB8fCAnVW5rbm93bic7XG4gICAgICAgIHdhcm5pbmcgPSAnQW4gdXBkYXRlIHRvICcgKyBjb21wb25lbnROYW1lICsgJyBpbnRlcnJ1cHRlZCB0aGUgcHJldmlvdXMgcmVuZGVyJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAxKSB7XG4gICAgICB3YXJuaW5nID0gJ1RoZXJlIHdlcmUgY2FzY2FkaW5nIHVwZGF0ZXMnO1xuICAgIH1cbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbiAgICB2YXIgbGFiZWwgPSBkaWRDb21wbGV0ZVJvb3QgPyAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb246IENvbXBsZXRlZCBSb290KScgOiAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb246IFlpZWxkZWQpJztcbiAgICAvLyBQYXVzZSBhbnkgbWVhc3VyZW1lbnRzIHVudGlsIHRoZSBuZXh0IGxvb3AuXG4gICAgcGF1c2VUaW1lcnMoKTtcbiAgICBlbmRNYXJrKGxhYmVsLCAnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgd2FybmluZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpc0NvbW1pdHRpbmcgPSB0cnVlO1xuICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgd2FybmluZyA9IG51bGw7XG4gICAgaWYgKGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCkge1xuICAgICAgd2FybmluZyA9ICdMaWZlY3ljbGUgaG9vayBzY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJztcbiAgICB9IGVsc2UgaWYgKGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPiAwKSB7XG4gICAgICB3YXJuaW5nID0gJ0NhdXNlZCBieSBhIGNhc2NhZGluZyB1cGRhdGUgaW4gZWFybGllciBjb21taXQnO1xuICAgIH1cbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wKys7XG4gICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmNsZWFyKCk7XG5cbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBDaGFuZ2VzKScsICcoQ29tbWl0dGluZyBDaGFuZ2VzKScsIHdhcm5pbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgU25hcHNob3QgRWZmZWN0cyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNvdW50ID0gZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQ7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIFNuYXBzaG90IEVmZmVjdHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDb21taXR0aW5nIFNuYXBzaG90IEVmZmVjdHMpJywgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY291bnQgPSBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdDtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJywgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY291bnQgPSBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdDtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgZW5kTWFyaygnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScsIG51bGwpO1xuICB9XG59XG5cbnZhciB2YWx1ZVN0YWNrID0gW107XG5cbnZhciBmaWJlclN0YWNrID0gdm9pZCAwO1xuXG57XG4gIGZpYmVyU3RhY2sgPSBbXTtcbn1cblxudmFyIGluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBkZWZhdWx0VmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gcG9wKGN1cnNvciwgZmliZXIpIHtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgfVxuXG4gIGluZGV4LS07XG59XG5cbmZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSwgZmliZXIpIHtcbiAgaW5kZXgrKztcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tUaGF0U3RhY2tJc0VtcHR5KCkge1xuICB7XG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnRXhwZWN0ZWQgYW4gZW1wdHkgc3RhY2suIFNvbWV0aGluZyB3YXMgbm90IHJlc2V0IHByb3Blcmx5LicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldFN0YWNrQWZ0ZXJGYXRhbEVycm9ySW5EZXYoKSB7XG4gIHtcbiAgICBpbmRleCA9IC0xO1xuICAgIHZhbHVlU3RhY2subGVuZ3RoID0gMDtcbiAgICBmaWJlclN0YWNrLmxlbmd0aCA9IDA7XG4gIH1cbn1cblxudmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHZvaWQgMDtcblxue1xuICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQgPSB7fTtcbn1cblxudmFyIGVtcHR5Q29udGV4dE9iamVjdCA9IHt9O1xue1xuICBPYmplY3QuZnJlZXplKGVtcHR5Q29udGV4dE9iamVjdCk7XG59XG5cbi8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5Q29udGV4dE9iamVjdCk7XG4vLyBBIGN1cnNvciB0byBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkLlxudmFyIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZmFsc2UpO1xuLy8gS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBvYmplY3QgdGhhdCB3YXMgb24gdGhlIHN0YWNrLlxuLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4vLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxudmFyIHByZXZpb3VzQ29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcblxuZnVuY3Rpb24gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGRpZFB1c2hPd25Db250ZXh0SWZQcm92aWRlcikge1xuICBpZiAoZGlkUHVzaE93bkNvbnRleHRJZlByb3ZpZGVyICYmIGlzQ29udGV4dFByb3ZpZGVyKENvbXBvbmVudCkpIHtcbiAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4gICAgLy8gd2UgbWF5IGhhdmUgYWxyZWFkeSBwdXNoZWQgaXRzIG93biBjaGlsZCBjb250ZXh0IG9uIHRoZSBzdGFjay4gQSBjb250ZXh0XG4gICAgLy8gcHJvdmlkZXIgc2hvdWxkIG5vdCBcInNlZVwiIGl0cyBvd24gY2hpbGQgY29udGV4dC4gVGhlcmVmb3JlIHdlIHJlYWQgdGhlXG4gICAgLy8gcHJldmlvdXMgKHBhcmVudCkgY29udGV4dCBpbnN0ZWFkIGZvciBhIGNvbnRleHQgcHJvdmlkZXIuXG4gICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgfVxuICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBtYXNrZWRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQgPSBtYXNrZWRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG4gIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfVxuXG4gIC8vIEF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIHVubWFza2VkIGNvbnRleHQgaGFzIGNoYW5nZWQuXG4gIC8vIEZhaWxpbmcgdG8gZG8gdGhpcyB3aWxsIHJlc3VsdCBpbiB1bm5lY2Vzc2FyeSBjYWxscyB0byBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLlxuICAvLyBUaGlzIG1heSB0cmlnZ2VyIGluZmluaXRlIGxvb3BzIGlmIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgY2FsbHMgc2V0U3RhdGUuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaWYgKGluc3RhbmNlICYmIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQgPT09IHVubWFza2VkQ29udGV4dCkge1xuICAgIHJldHVybiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0ge307XG4gIGZvciAodmFyIGtleSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICBjb250ZXh0W2tleV0gPSB1bm1hc2tlZENvbnRleHRba2V5XTtcbiAgfVxuXG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNvbnRleHRUeXBlcywgY29udGV4dCwgJ2NvbnRleHQnLCBuYW1lLCBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KTtcbiAgfVxuXG4gIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGJlZm9yZSB0aGUgY2xhc3MgY29tcG9uZW50IGlzIGluc3RhbnRpYXRlZCBzbyBjaGVjayBmb3IgaW5zdGFuY2UuXG4gIGlmIChpbnN0YW5jZSkge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAgcmV0dXJuIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIodHlwZSkge1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuICByZXR1cm4gY2hpbGRDb250ZXh0VHlwZXMgIT09IG51bGwgJiYgY2hpbGRDb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dChmaWJlcikge1xuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlcikge1xuICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIsIGNvbnRleHQsIGRpZENoYW5nZSkge1xuICAhKGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID09PSBlbXB0eUNvbnRleHRPYmplY3QpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHR5cGUsIHBhcmVudENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSB0eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIXdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICB3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgdmFyIGNoaWxkQ29udGV4dCA9IHZvaWQgMDtcbiAge1xuICAgIHNldEN1cnJlbnRQaGFzZSgnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIH1cbiAgc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCAnZ2V0Q2hpbGRDb250ZXh0Jyk7XG4gIGNoaWxkQ29udGV4dCA9IGluc3RhbmNlLmdldENoaWxkQ29udGV4dCgpO1xuICBzdG9wUGhhc2VUaW1lcigpO1xuICB7XG4gICAgc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ1Vua25vd24nLCBjb250ZXh0S2V5KSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdVbmtub3duJztcbiAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUsXG4gICAgLy8gSW4gcHJhY3RpY2UsIHRoZXJlIGlzIG9uZSBjYXNlIGluIHdoaWNoIHdlIHdvbid0IGdldCBhIHN0YWNrLiBJdCdzIHdoZW5cbiAgICAvLyBzb21lYm9keSBjYWxscyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcigpIGFuZCB3ZSBwcm9jZXNzXG4gICAgLy8gY29udGV4dCBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50IGluc3RhbmNlLiBUaGUgc3RhY2sgd2lsbCBiZSBtaXNzaW5nXG4gICAgLy8gYmVjYXVzZSBpdCdzIG91dHNpZGUgb2YgdGhlIHJlY29uY2lsaWF0aW9uLCBhbmQgc28gdGhlIHBvaW50ZXIgaGFzIG5vdFxuICAgIC8vIGJlZW4gc2V0LiBUaGlzIGlzIHJhcmUgYW5kIGRvZXNuJ3QgbWF0dGVyLiBXZSdsbCBhbHNvIHJlbW92ZSB0aGF0IEFQSS5cbiAgICBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KTtcbiAgfVxuXG4gIHJldHVybiBfYXNzaWduKHt9LCBwYXJlbnRDb250ZXh0LCBjaGlsZENvbnRleHQpO1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgLy8gUmVtZW1iZXIgdGhlIHBhcmVudCBjb250ZXh0IHNvIHdlIGNhbiBtZXJnZSB3aXRoIGl0IGxhdGVyLlxuICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkaWQtcGVyZm9ybS13b3JrIHZhbHVlIHRvIGF2b2lkIGluYWR2ZXJ0ZW50bHkgYmxvY2tpbmcgdXBkYXRlcy5cbiAgcHJldmlvdXNDb250ZXh0ID0gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB0eXBlLCBkaWRDaGFuZ2UpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAhaW5zdGFuY2UgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBoYXZlIGFuIGluc3RhbmNlIGJ5IHRoaXMgcG9pbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGRpZENoYW5nZSkge1xuICAgIC8vIE1lcmdlIHBhcmVudCBhbmQgb3duIGNvbnRleHQuXG4gICAgLy8gU2tpcCB0aGlzIGlmIHdlJ3JlIG5vdCB1cGRhdGluZyBkdWUgdG8gc0NVLlxuICAgIC8vIFRoaXMgYXZvaWRzIHVubmVjZXNzYXJpbHkgcmVjb21wdXRpbmcgbWVtb2l6ZWQgdmFsdWVzLlxuICAgIHZhciBtZXJnZWRDb250ZXh0ID0gcHJvY2Vzc0NoaWxkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdHlwZSwgcHJldmlvdXNDb250ZXh0KTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IG1lcmdlZENvbnRleHQ7XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBvbGQgKG9yIGVtcHR5KSBjb250ZXh0IHdpdGggdGhlIG5ldyBvbmUuXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVyZ2VkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgIShpc0ZpYmVyTW91bnRlZChmaWJlcikgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIGRvIHtcbiAgICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuY29udGV4dDtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gbm9kZS50eXBlO1xuICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfSB3aGlsZSAobm9kZSAhPT0gbnVsbCk7XG4gIGludmFyaWFudChmYWxzZSwgJ0ZvdW5kIHVuZXhwZWN0ZWQgZGV0YWNoZWQgc3VidHJlZSBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbnZhciBvbkNvbW1pdEZpYmVyUm9vdCA9IG51bGw7XG52YXIgb25Db21taXRGaWJlclVubW91bnQgPSBudWxsO1xudmFyIGhhc0xvZ2dlZEVycm9yID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNhdGNoRXJyb3JzKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhcmcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHRydWUgJiYgIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUmVhY3QgRGV2VG9vbHMgZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciBpc0RldlRvb2xzUHJlc2VudCA9IHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnO1xuXG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBob29rID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XG4gICAgLy8gVGhpcyBpc24ndCBhIHJlYWwgcHJvcGVydHkgb24gdGhlIGhvb2ssIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIG9wdCBvdXRcbiAgICAvLyBvZiBEZXZUb29scyBpbnRlZ3JhdGlvbiBhbmQgYXNzb2NpYXRlZCB3YXJuaW5ncyBhbmQgbG9ncy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzM4NzdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9XG4gICAgLy8gRGV2VG9vbHMgZXhpc3RzLCBldmVuIHRob3VnaCBpdCBkb2Vzbid0IHN1cHBvcnQgRmliZXIuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHJ5IHtcbiAgICB2YXIgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7XG4gICAgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cbiAgICBvbkNvbW1pdEZpYmVyUm9vdCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChyb290KSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9KTtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudCA9IGNhdGNoRXJyb3JzKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgLy8gRGV2VG9vbHMgZXhpc3RzXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclJvb3Qocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudChmaWJlcik7XG4gIH1cbn1cblxuLy8gTWF4IDMxIGJpdCBpbnRlZ2VyLiBUaGUgbWF4IGludGVnZXIgc2l6ZSBpbiBWOCBmb3IgMzItYml0IHN5c3RlbXMuXG4vLyBNYXRoLnBvdygyLCAzMCkgLSAxXG4vLyAwYjExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVxudmFyIG1heFNpZ25lZDMxQml0SW50ID0gMTA3Mzc0MTgyMztcblxudmFyIE5vV29yayA9IDA7XG52YXIgTmV2ZXIgPSAxO1xudmFyIFN5bmMgPSBtYXhTaWduZWQzMUJpdEludDtcblxudmFyIFVOSVRfU0laRSA9IDEwO1xudmFyIE1BR0lDX05VTUJFUl9PRkZTRVQgPSBtYXhTaWduZWQzMUJpdEludCAtIDE7XG5cbi8vIDEgdW5pdCBvZiBleHBpcmF0aW9uIHRpbWUgcmVwcmVzZW50cyAxMG1zLlxuZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zKSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiBNQUdJQ19OVU1CRVJfT0ZGU0VUIC0gKG1zIC8gVU5JVF9TSVpFIHwgMCk7XG59XG5cbmZ1bmN0aW9uIGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSkge1xuICByZXR1cm4gKE1BR0lDX05VTUJFUl9PRkZTRVQgLSBleHBpcmF0aW9uVGltZSkgKiBVTklUX1NJWkU7XG59XG5cbmZ1bmN0aW9uIGNlaWxpbmcobnVtLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuICgobnVtIC8gcHJlY2lzaW9uIHwgMCkgKyAxKSAqIHByZWNpc2lvbjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25Jbk1zLCBidWNrZXRTaXplTXMpIHtcbiAgcmV0dXJuIE1BR0lDX05VTUJFUl9PRkZTRVQgLSBjZWlsaW5nKE1BR0lDX05VTUJFUl9PRkZTRVQgLSBjdXJyZW50VGltZSArIGV4cGlyYXRpb25Jbk1zIC8gVU5JVF9TSVpFLCBidWNrZXRTaXplTXMgLyBVTklUX1NJWkUpO1xufVxuXG52YXIgTE9XX1BSSU9SSVRZX0VYUElSQVRJT04gPSA1MDAwO1xudmFyIExPV19QUklPUklUWV9CQVRDSF9TSVpFID0gMjUwO1xuXG5mdW5jdGlvbiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKSB7XG4gIHJldHVybiBjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldChjdXJyZW50VGltZSwgTE9XX1BSSU9SSVRZX0VYUElSQVRJT04sIExPV19QUklPUklUWV9CQVRDSF9TSVpFKTtcbn1cblxuLy8gV2UgaW50ZW50aW9uYWxseSBzZXQgYSBoaWdoZXIgZXhwaXJhdGlvbiB0aW1lIGZvciBpbnRlcmFjdGl2ZSB1cGRhdGVzIGluXG4vLyBkZXYgdGhhbiBpbiBwcm9kdWN0aW9uLlxuLy9cbi8vIElmIHRoZSBtYWluIHRocmVhZCBpcyBiZWluZyBibG9ja2VkIHNvIGxvbmcgdGhhdCB5b3UgaGl0IHRoZSBleHBpcmF0aW9uLFxuLy8gaXQncyBhIHByb2JsZW0gdGhhdCBjb3VsZCBiZSBzb2x2ZWQgd2l0aCBiZXR0ZXIgc2NoZWR1bGluZy5cbi8vXG4vLyBQZW9wbGUgd2lsbCBiZSBtb3JlIGxpa2VseSB0byBub3RpY2UgdGhpcyBhbmQgZml4IGl0IHdpdGggdGhlIGxvbmdcbi8vIGV4cGlyYXRpb24gdGltZSBpbiBkZXZlbG9wbWVudC5cbi8vXG4vLyBJbiBwcm9kdWN0aW9uIHdlIG9wdCBmb3IgYmV0dGVyIFVYIGF0IHRoZSByaXNrIG9mIG1hc2tpbmcgc2NoZWR1bGluZ1xuLy8gcHJvYmxlbXMsIGJ5IGV4cGlyaW5nIGZhc3QuXG52YXIgSElHSF9QUklPUklUWV9FWFBJUkFUSU9OID0gNTAwO1xudmFyIEhJR0hfUFJJT1JJVFlfQkFUQ0hfU0laRSA9IDEwMDtcblxuZnVuY3Rpb24gY29tcHV0ZUludGVyYWN0aXZlRXhwaXJhdGlvbihjdXJyZW50VGltZSkge1xuICByZXR1cm4gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIEhJR0hfUFJJT1JJVFlfRVhQSVJBVElPTiwgSElHSF9QUklPUklUWV9CQVRDSF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQ29uY3VycmVudE1vZGUgPSAxO1xudmFyIFN0cmljdE1vZGUgPSAyO1xudmFyIFByb2ZpbGVNb2RlID0gNDtcblxudmFyIGhhc0JhZE1hcFBvbHlmaWxsID0gdm9pZCAwO1xuXG57XG4gIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIHZhciB0ZXN0TWFwID0gbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgdmFyIHRlc3RTZXQgPSBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgLy8gVGhpcyBpcyBuZWNlc3NhcnkgZm9yIFJvbGx1cCB0byBub3QgY29uc2lkZXIgdGhlc2UgdW51c2VkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yb2xsdXAvcm9sbHVwL2lzc3Vlcy8xNzcxXG4gICAgLy8gVE9ETzogd2UgY2FuIHJlbW92ZSB0aGVzZSBpZiBSb2xsdXAgZml4ZXMgdGhlIGJ1Zy5cbiAgICB0ZXN0TWFwLnNldCgwLCAwKTtcbiAgICB0ZXN0U2V0LmFkZCgwKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyBBIEZpYmVyIGlzIHdvcmsgb24gYSBDb21wb25lbnQgdGhhdCBuZWVkcyB0byBiZSBkb25lIG9yIHdhcyBkb25lLiBUaGVyZSBjYW5cbi8vIGJlIG1vcmUgdGhhbiBvbmUgcGVyIGNvbXBvbmVudC5cblxuXG52YXIgZGVidWdDb3VudGVyID0gdm9pZCAwO1xuXG57XG4gIGRlYnVnQ291bnRlciA9IDE7XG59XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5lbGVtZW50VHlwZSA9IG51bGw7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDtcblxuICAvLyBGaWJlclxuICB0aGlzLnJldHVybiA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcblxuICB0aGlzLnJlZiA9IG51bGw7XG5cbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB0aGlzLmNvbnRleHREZXBlbmRlbmNpZXMgPSBudWxsO1xuXG4gIHRoaXMubW9kZSA9IG1vZGU7XG5cbiAgLy8gRWZmZWN0c1xuICB0aGlzLmVmZmVjdFRhZyA9IE5vRWZmZWN0O1xuICB0aGlzLm5leHRFZmZlY3QgPSBudWxsO1xuXG4gIHRoaXMuZmlyc3RFZmZlY3QgPSBudWxsO1xuICB0aGlzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHRoaXMuY2hpbGRFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAvLyBOb3RlOiBUaGUgZm9sbG93aW5nIGlzIGRvbmUgdG8gYXZvaWQgYSB2OCBwZXJmb3JtYW5jZSBjbGlmZi5cbiAgICAvL1xuICAgIC8vIEluaXRpYWxpemluZyB0aGUgZmllbGRzIGJlbG93IHRvIHNtaXMgYW5kIGxhdGVyIHVwZGF0aW5nIHRoZW0gd2l0aFxuICAgIC8vIGRvdWJsZSB2YWx1ZXMgd2lsbCBjYXVzZSBGaWJlcnMgdG8gZW5kIHVwIGhhdmluZyBzZXBhcmF0ZSBzaGFwZXMuXG4gICAgLy8gVGhpcyBiZWhhdmlvci9idWcgaGFzIHNvbWV0aGluZyB0byBkbyB3aXRoIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9uKCkuXG4gICAgLy8gRm9ydHVuYXRlbHkgdGhpcyBvbmx5IGltcGFjdHMgREVWIGJ1aWxkcy5cbiAgICAvLyBVbmZvcnR1bmF0ZWx5IGl0IG1ha2VzIFJlYWN0IHVudXNhYmx5IHNsb3cgZm9yIHNvbWUgYXBwbGljYXRpb25zLlxuICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIGluaXRpYWxpemUgdGhlIGZpZWxkcyBiZWxvdyB3aXRoIGRvdWJsZXMuXG4gICAgLy9cbiAgICAvLyBMZWFybiBtb3JlIGFib3V0IHRoaXMgaGVyZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0MzY1XG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9ODUzOFxuICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IE51bWJlci5OYU47XG5cbiAgICAvLyBJdCdzIG9rYXkgdG8gcmVwbGFjZSB0aGUgaW5pdGlhbCBkb3VibGVzIHdpdGggc21pcyBhZnRlciBpbml0aWFsaXphdGlvbi5cbiAgICAvLyBUaGlzIHdvbid0IHRyaWdnZXIgdGhlIHBlcmZvcm1hbmNlIGNsaWZmIG1lbnRpb25lZCBhYm92ZSxcbiAgICAvLyBhbmQgaXQgc2ltcGxpZmllcyBvdGhlciBwcm9maWxlciBjb2RlIChpbmNsdWRpbmcgRGV2VG9vbHMpLlxuICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICB9XG5cbiAge1xuICAgIHRoaXMuX2RlYnVnSUQgPSBkZWJ1Z0NvdW50ZXIrKztcbiAgICB0aGlzLl9kZWJ1Z1NvdXJjZSA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2RlYnVnSG9va1R5cGVzID0gbnVsbDtcbiAgICBpZiAoIWhhc0JhZE1hcFBvbHlmaWxsICYmIHR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIFBPSk8gY29uc3RydWN0b3IsIHN0aWxsXG4vLyBwbGVhc2UgZW5zdXJlIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG4vLyAxKSBOb2JvZHkgc2hvdWxkIGFkZCBhbnkgaW5zdGFuY2UgbWV0aG9kcyBvbiB0aGlzLiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZVxuLy8gICAgbW9yZSBkaWZmaWN1bHQgdG8gcHJlZGljdCB3aGVuIHRoZXkgZ2V0IG9wdGltaXplZCBhbmQgdGhleSBhcmUgYWxtb3N0XG4vLyAgICBuZXZlciBpbmxpbmVkIHByb3Blcmx5IGluIHN0YXRpYyBjb21waWxlcnMuXG4vLyAyKSBOb2JvZHkgc2hvdWxkIHJlbHkgb24gYGluc3RhbmNlb2YgRmliZXJgIGZvciB0eXBlIHRlc3RpbmcuIFdlIHNob3VsZFxuLy8gICAgYWx3YXlzIGtub3cgd2hlbiBpdCBpcyBhIGZpYmVyLlxuLy8gMykgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuLy8gICAgdG8gb3B0aW1pemUgaW4gYSBub24tSklUIGVudmlyb25tZW50LlxuLy8gNCkgV2UgY2FuIGVhc2lseSBnbyBmcm9tIGEgY29uc3RydWN0b3IgdG8gYSBjcmVhdGVGaWJlciBvYmplY3QgbGl0ZXJhbCBpZiB0aGF0XG4vLyAgICBpcyBmYXN0ZXIuXG4vLyA1KSBJdCBzaG91bGQgYmUgZWFzeSB0byBwb3J0IHRoaXMgdG8gYSBDIHN0cnVjdCBhbmQga2VlcCBhIEMgaW1wbGVtZW50YXRpb25cbi8vICAgIGNvbXBhdGlibGUuXG52YXIgY3JlYXRlRmliZXIgPSBmdW5jdGlvbiAodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAvLyAkRmxvd0ZpeE1lOiB0aGUgc2hhcGVzIGFyZSBleGFjdCBoZXJlIGJ1dCBGbG93IGRvZXNuJ3QgbGlrZSBjb25zdHJ1Y3RvcnNcbiAgcmV0dXJuIG5ldyBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhc2hvdWxkQ29uc3RydWN0KHR5cGUpICYmIHR5cGUuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCkge1xuICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSA/IENsYXNzQ29tcG9uZW50IDogRnVuY3Rpb25Db21wb25lbnQ7XG4gIH0gZWxzZSBpZiAoQ29tcG9uZW50ICE9PSB1bmRlZmluZWQgJiYgQ29tcG9uZW50ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gQ29tcG9uZW50LiQkdHlwZW9mO1xuICAgIGlmICgkJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSkge1xuICAgICAgcmV0dXJuIEZvcndhcmRSZWY7XG4gICAgfVxuICAgIGlmICgkJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICByZXR1cm4gTWVtb0NvbXBvbmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ7XG59XG5cbi8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4gICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4gICAgLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuICAgIC8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4gICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnQua2V5LCBjdXJyZW50Lm1vZGUpO1xuICAgIHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG5cbiAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IE5vRWZmZWN0O1xuXG4gICAgLy8gVGhlIGVmZmVjdCBsaXN0IGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgLy8gV2UgaW50ZW50aW9uYWxseSByZXNldCwgcmF0aGVyIHRoYW4gY29weSwgYWN0dWFsRHVyYXRpb24gJiBhY3R1YWxTdGFydFRpbWUuXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHRpbWUgZnJvbSBlbmRsZXNzbHkgYWNjdW11bGF0aW5nIGluIG5ldyBjb21taXRzLlxuICAgICAgLy8gVGhpcyBoYXMgdGhlIGRvd25zaWRlIG9mIHJlc2V0dGluZyB2YWx1ZXMgZm9yIGRpZmZlcmVudCBwcmlvcml0eSByZW5kZXJzLFxuICAgICAgLy8gQnV0IHdvcmtzIGZvciB5aWVsZGluZyAodGhlIGNvbW1vbiBjYXNlKSBhbmQgc2hvdWxkIHN1cHBvcnQgcmVzdW1pbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxEdXJhdGlvbiA9IDA7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hY3R1YWxTdGFydFRpbWUgPSAtMTtcbiAgICB9XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZEV4cGlyYXRpb25UaW1lID0gY3VycmVudC5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IGN1cnJlbnQuZXhwaXJhdGlvblRpbWU7XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gIHdvcmtJblByb2dyZXNzLmNvbnRleHREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmNvbnRleHREZXBlbmRlbmNpZXM7XG5cbiAgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9zdFJvb3RGaWJlcihpc0NvbmN1cnJlbnQpIHtcbiAgdmFyIG1vZGUgPSBpc0NvbmN1cnJlbnQgPyBDb25jdXJyZW50TW9kZSB8IFN0cmljdE1vZGUgOiBOb0NvbnRleHQ7XG5cbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAvLyBBbHdheXMgY29sbGVjdCBwcm9maWxlIHRpbWluZ3Mgd2hlbiBEZXZUb29scyBhcmUgcHJlc2VudC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcbiAgICAvLyBXaXRob3V0IHNvbWUgbm9kZXMgaW4gdGhlIHRyZWUgaGF2aW5nIGVtcHR5IGJhc2UgdGltZXMuXG4gICAgbW9kZSB8PSBQcm9maWxlTW9kZTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCAvLyBSZWFjdCRFbGVtZW50VHlwZVxua2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSB2b2lkIDA7XG5cbiAgdmFyIGZpYmVyVGFnID0gSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDtcbiAgLy8gVGhlIHJlc29sdmVkIHR5cGUgaXMgc2V0IGlmIHdlIGtub3cgd2hhdCB0aGUgZmluYWwgdHlwZSB3aWxsIGJlLiBJLmUuIGl0J3Mgbm90IGxhenkuXG4gIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoc2hvdWxkQ29uc3RydWN0KHR5cGUpKSB7XG4gICAgICBmaWJlclRhZyA9IENsYXNzQ29tcG9uZW50O1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBmaWJlclRhZyA9IEhvc3RDb21wb25lbnQ7XG4gIH0gZWxzZSB7XG4gICAgZ2V0VGFnOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbiwgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tTW9kZShwZW5kaW5nUHJvcHMsIG1vZGUgfCBDb25jdXJyZW50TW9kZSB8IFN0cmljdE1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tTW9kZShwZW5kaW5nUHJvcHMsIG1vZGUgfCBTdHJpY3RNb2RlLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsIG1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRQcm92aWRlcjtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBjb25zdW1lclxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dENvbnN1bWVyO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gRm9yd2FyZFJlZjtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTWVtb0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTGF6eUNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBcIiArICduYW1lZCBpbXBvcnRzLic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZpYmVyID0gY3JlYXRlRmliZXIoZmliZXJUYWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSB0eXBlO1xuICBmaWJlci50eXBlID0gcmVzb2x2ZWRUeXBlO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCBtb2RlLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgb3duZXIgPSBudWxsO1xuICB7XG4gICAgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHR5cGUsIGtleSwgcGVuZGluZ1Byb3BzLCBvd25lciwgbW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwgZWxlbWVudHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBleHBpcmF0aW9uVGltZSwga2V5KSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIHBlbmRpbmdQcm9wcy5pZCAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHBlbmRpbmdQcm9wcy5vblJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUHJvZmlsZXIgbXVzdCBzcGVjaWZ5IGFuIFwiaWRcIiBzdHJpbmcgYW5kIFwib25SZW5kZXJcIiBmdW5jdGlvbiBhcyBwcm9wcycpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFByb2ZpbGVyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSB8IFByb2ZpbGVNb2RlKTtcbiAgLy8gVE9ETzogVGhlIFByb2ZpbGVyIGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gIGZpYmVyLnR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tTW9kZShwZW5kaW5nUHJvcHMsIG1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoTW9kZSwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuXG4gIC8vIFRPRE86IFRoZSBNb2RlIGZpYmVyIHNob3VsZG4ndCBoYXZlIGEgdHlwZS4gSXQgaGFzIGEgdGFnLlxuICB2YXIgdHlwZSA9IChtb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb0NvbnRleHQgPyBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIDogUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgZmliZXIudHlwZSA9IHR5cGU7XG5cbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsIG1vZGUsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoU3VzcGVuc2VDb21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcblxuICAvLyBUT0RPOiBUaGUgU3VzcGVuc2VDb21wb25lbnQgZmliZXIgc2hvdWxkbid0IGhhdmUgYSB0eXBlLiBJdCBoYXMgYSB0YWcuXG4gIHZhciB0eXBlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSB0eXBlO1xuICBmaWJlci50eXBlID0gdHlwZTtcblxuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIGNvbnRlbnQsIG51bGwsIG1vZGUpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBudWxsLCBudWxsLCBOb0NvbnRleHQpO1xuICAvLyBUT0RPOiBUaGVzZSBzaG91bGQgbm90IG5lZWQgYSB0eXBlLlxuICBmaWJlci5lbGVtZW50VHlwZSA9ICdERUxFVEVEJztcbiAgZmliZXIudHlwZSA9ICdERUxFVEVEJztcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsIC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gZmliZXI7XG59XG5cbi8vIFVzZWQgZm9yIHN0YXNoaW5nIFdJUCBwcm9wZXJ0aWVzIHRvIHJlcGxheSBmYWlsZWQgd29yayBpbiBERVYuXG5mdW5jdGlvbiBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVih0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBGaWJlcidzIGluaXRpYWwgcHJvcGVydGllcyB3aWxsIGFsd2F5cyBiZSBvdmVyd3JpdHRlbi5cbiAgICAvLyBXZSBvbmx5IHVzZSBhIEZpYmVyIHRvIGVuc3VyZSB0aGUgc2FtZSBoaWRkZW4gY2xhc3Mgc28gREVWIGlzbid0IHNsb3cuXG4gICAgdGFyZ2V0ID0gY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwgbnVsbCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgfVxuXG4gIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSB3cml0dGVuIGFzIGEgbGlzdCBvZiBhbGwgcHJvcGVydGllcy5cbiAgLy8gV2UgdHJpZWQgdG8gdXNlIE9iamVjdC5hc3NpZ24oKSBpbnN0ZWFkIGJ1dCB0aGlzIGlzIGNhbGxlZCBpblxuICAvLyB0aGUgaG90dGVzdCBwYXRoLCBhbmQgT2JqZWN0LmFzc2lnbigpIHdhcyB0b28gc2xvdzpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMjUwMlxuICAvLyBUaGlzIGNvZGUgaXMgREVWLW9ubHkgc28gc2l6ZSBpcyBub3QgYSBjb25jZXJuLlxuXG4gIHRhcmdldC50YWcgPSBzb3VyY2UudGFnO1xuICB0YXJnZXQua2V5ID0gc291cmNlLmtleTtcbiAgdGFyZ2V0LmVsZW1lbnRUeXBlID0gc291cmNlLmVsZW1lbnRUeXBlO1xuICB0YXJnZXQudHlwZSA9IHNvdXJjZS50eXBlO1xuICB0YXJnZXQuc3RhdGVOb2RlID0gc291cmNlLnN0YXRlTm9kZTtcbiAgdGFyZ2V0LnJldHVybiA9IHNvdXJjZS5yZXR1cm47XG4gIHRhcmdldC5jaGlsZCA9IHNvdXJjZS5jaGlsZDtcbiAgdGFyZ2V0LnNpYmxpbmcgPSBzb3VyY2Uuc2libGluZztcbiAgdGFyZ2V0LmluZGV4ID0gc291cmNlLmluZGV4O1xuICB0YXJnZXQucmVmID0gc291cmNlLnJlZjtcbiAgdGFyZ2V0LnBlbmRpbmdQcm9wcyA9IHNvdXJjZS5wZW5kaW5nUHJvcHM7XG4gIHRhcmdldC5tZW1vaXplZFByb3BzID0gc291cmNlLm1lbW9pemVkUHJvcHM7XG4gIHRhcmdldC51cGRhdGVRdWV1ZSA9IHNvdXJjZS51cGRhdGVRdWV1ZTtcbiAgdGFyZ2V0Lm1lbW9pemVkU3RhdGUgPSBzb3VyY2UubWVtb2l6ZWRTdGF0ZTtcbiAgdGFyZ2V0LmNvbnRleHREZXBlbmRlbmNpZXMgPSBzb3VyY2UuY29udGV4dERlcGVuZGVuY2llcztcbiAgdGFyZ2V0Lm1vZGUgPSBzb3VyY2UubW9kZTtcbiAgdGFyZ2V0LmVmZmVjdFRhZyA9IHNvdXJjZS5lZmZlY3RUYWc7XG4gIHRhcmdldC5uZXh0RWZmZWN0ID0gc291cmNlLm5leHRFZmZlY3Q7XG4gIHRhcmdldC5maXJzdEVmZmVjdCA9IHNvdXJjZS5maXJzdEVmZmVjdDtcbiAgdGFyZ2V0Lmxhc3RFZmZlY3QgPSBzb3VyY2UubGFzdEVmZmVjdDtcbiAgdGFyZ2V0LmV4cGlyYXRpb25UaW1lID0gc291cmNlLmV4cGlyYXRpb25UaW1lO1xuICB0YXJnZXQuY2hpbGRFeHBpcmF0aW9uVGltZSA9IHNvdXJjZS5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICB0YXJnZXQuYWx0ZXJuYXRlID0gc291cmNlLmFsdGVybmF0ZTtcbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICB0YXJnZXQuYWN0dWFsRHVyYXRpb24gPSBzb3VyY2UuYWN0dWFsRHVyYXRpb247XG4gICAgdGFyZ2V0LmFjdHVhbFN0YXJ0VGltZSA9IHNvdXJjZS5hY3R1YWxTdGFydFRpbWU7XG4gICAgdGFyZ2V0LnNlbGZCYXNlRHVyYXRpb24gPSBzb3VyY2Uuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICB0YXJnZXQudHJlZUJhc2VEdXJhdGlvbiA9IHNvdXJjZS50cmVlQmFzZUR1cmF0aW9uO1xuICB9XG4gIHRhcmdldC5fZGVidWdJRCA9IHNvdXJjZS5fZGVidWdJRDtcbiAgdGFyZ2V0Ll9kZWJ1Z1NvdXJjZSA9IHNvdXJjZS5fZGVidWdTb3VyY2U7XG4gIHRhcmdldC5fZGVidWdPd25lciA9IHNvdXJjZS5fZGVidWdPd25lcjtcbiAgdGFyZ2V0Ll9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gc291cmNlLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nO1xuICB0YXJnZXQuX2RlYnVnSG9va1R5cGVzID0gc291cmNlLl9kZWJ1Z0hvb2tUeXBlcztcbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgbGlmdGVkIGludG8gdGhlIHJlbmRlcmVyLlxuXG5cbi8vIFRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcyBhcmUgb25seSB1c2VkIGJ5IGludGVyYWN0aW9uIHRyYWNpbmcgYnVpbGRzLlxuLy8gVGhleSBlbmFibGUgaW50ZXJhY3Rpb25zIHRvIGJlIGFzc29jaWF0ZWQgd2l0aCB0aGVpciBhc3luYyB3b3JrLFxuLy8gQW5kIGV4cG9zZSBpbnRlcmFjdGlvbiBtZXRhZGF0YSB0byB0aGUgUmVhY3QgRGV2VG9vbHMgUHJvZmlsZXIgcGx1Z2luLlxuLy8gTm90ZSB0aGF0IHRoZXNlIGF0dHJpYnV0ZXMgYXJlIG9ubHkgZGVmaW5lZCB3aGVuIHRoZSBlbmFibGVTY2hlZHVsZXJUcmFjaW5nIGZsYWcgaXMgZW5hYmxlZC5cblxuXG4vLyBFeHBvcnRlZCBGaWJlclJvb3QgdHlwZSBpbmNsdWRlcyBhbGwgcHJvcGVydGllcyxcbi8vIFRvIGF2b2lkIHJlcXVpcmluZyBwb3RlbnRpYWxseSBlcnJvci1wcm9uZSA6YW55IGNhc3RzIHRocm91Z2hvdXQgdGhlIHByb2plY3QuXG4vLyBQcm9maWxpbmcgcHJvcGVydGllcyBhcmUgb25seSBzYWZlIHRvIGFjY2VzcyBpbiBwcm9maWxpbmcgYnVpbGRzICh3aGVuIGVuYWJsZVNjaGVkdWxlclRyYWNpbmcgaXMgdHJ1ZSkuXG4vLyBUaGUgdHlwZXMgYXJlIGRlZmluZWQgc2VwYXJhdGVseSB3aXRoaW4gdGhpcyBmaWxlIHRvIGVuc3VyZSB0aGV5IHN0YXkgaW4gc3luYy5cbi8vIChXZSBkb24ndCBoYXZlIHRvIHVzZSBhbiBpbmxpbmUgOmFueSBjYXN0IHdoZW4gZW5hYmxlU2NoZWR1bGVyVHJhY2luZyBpcyBkaXNhYmxlZC4pXG5cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGlzQ29uY3VycmVudCwgaHlkcmF0ZSkge1xuICAvLyBDeWNsaWMgY29uc3RydWN0aW9uLiBUaGlzIGNoZWF0cyB0aGUgdHlwZSBzeXN0ZW0gcmlnaHQgbm93IGJlY2F1c2VcbiAgLy8gc3RhdGVOb2RlIGlzIGFueS5cbiAgdmFyIHVuaW5pdGlhbGl6ZWRGaWJlciA9IGNyZWF0ZUhvc3RSb290RmliZXIoaXNDb25jdXJyZW50KTtcblxuICB2YXIgcm9vdCA9IHZvaWQgMDtcbiAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICByb290ID0ge1xuICAgICAgY3VycmVudDogdW5pbml0aWFsaXplZEZpYmVyLFxuICAgICAgY29udGFpbmVySW5mbzogY29udGFpbmVySW5mbyxcbiAgICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcblxuICAgICAgZWFybGllc3RQZW5kaW5nVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0UGVuZGluZ1RpbWU6IE5vV29yayxcbiAgICAgIGVhcmxpZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0UGluZ2VkVGltZTogTm9Xb3JrLFxuXG4gICAgICBwaW5nQ2FjaGU6IG51bGwsXG5cbiAgICAgIGRpZEVycm9yOiBmYWxzZSxcblxuICAgICAgcGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgICBmaW5pc2hlZFdvcms6IG51bGwsXG4gICAgICB0aW1lb3V0SGFuZGxlOiBub1RpbWVvdXQsXG4gICAgICBjb250ZXh0OiBudWxsLFxuICAgICAgcGVuZGluZ0NvbnRleHQ6IG51bGwsXG4gICAgICBoeWRyYXRlOiBoeWRyYXRlLFxuICAgICAgbmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT246IE5vV29yayxcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgICBmaXJzdEJhdGNoOiBudWxsLFxuICAgICAgbmV4dFNjaGVkdWxlZFJvb3Q6IG51bGwsXG5cbiAgICAgIGludGVyYWN0aW9uVGhyZWFkSUQ6IHRyYWNpbmcudW5zdGFibGVfZ2V0VGhyZWFkSUQoKSxcbiAgICAgIG1lbW9pemVkSW50ZXJhY3Rpb25zOiBuZXcgU2V0KCksXG4gICAgICBwZW5kaW5nSW50ZXJhY3Rpb25NYXA6IG5ldyBNYXAoKVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcm9vdCA9IHtcbiAgICAgIGN1cnJlbnQ6IHVuaW5pdGlhbGl6ZWRGaWJlcixcbiAgICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG5cbiAgICAgIHBpbmdDYWNoZTogbnVsbCxcblxuICAgICAgZWFybGllc3RQZW5kaW5nVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0UGVuZGluZ1RpbWU6IE5vV29yayxcbiAgICAgIGVhcmxpZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0U3VzcGVuZGVkVGltZTogTm9Xb3JrLFxuICAgICAgbGF0ZXN0UGluZ2VkVGltZTogTm9Xb3JrLFxuXG4gICAgICBkaWRFcnJvcjogZmFsc2UsXG5cbiAgICAgIHBlbmRpbmdDb21taXRFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgICAgZmluaXNoZWRXb3JrOiBudWxsLFxuICAgICAgdGltZW91dEhhbmRsZTogbm9UaW1lb3V0LFxuICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgIHBlbmRpbmdDb250ZXh0OiBudWxsLFxuICAgICAgaHlkcmF0ZTogaHlkcmF0ZSxcbiAgICAgIG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uOiBOb1dvcmssXG4gICAgICBleHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgICAgZmlyc3RCYXRjaDogbnVsbCxcbiAgICAgIG5leHRTY2hlZHVsZWRSb290OiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuXG4gIC8vIFRoZSByZWFzb24gZm9yIHRoZSB3YXkgdGhlIEZsb3cgdHlwZXMgYXJlIHN0cnVjdHVyZWQgaW4gdGhpcyBmaWxlLFxuICAvLyBJcyB0byBhdm9pZCBuZWVkaW5nIDphbnkgY2FzdHMgZXZlcnl3aGVyZSBpbnRlcmFjdGlvbiB0cmFjaW5nIGZpZWxkcyBhcmUgdXNlZC5cbiAgLy8gVW5mb3J0dW5hdGVseSB0aGF0IHJlcXVpcmVzIGFuIDphbnkgY2FzdCBmb3Igbm9uLWludGVyYWN0aW9uIHRyYWNpbmcgY2FwYWJsZSBidWlsZHMuXG4gIC8vICRGbG93Rml4TWUgUmVtb3ZlIHRoaXMgOmFueSBjYXN0IGFuZCByZXBsYWNlIGl0IHdpdGggc29tZXRoaW5nIGJldHRlci5cbiAgcmV0dXJuIHJvb3Q7XG59XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYGxvd1ByaW9yaXR5V2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICBkaXNjYXJkUGVuZGluZ1dhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgZmx1c2hQZW5kaW5nRGVwcmVjYXRpb25XYXJuaW5nczogZnVuY3Rpb24gKCkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkRGVwcmVjYXRpb25XYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIHJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fVxufTtcblxue1xuICB2YXIgTElGRUNZQ0xFX1NVR0dFU1RJT05TID0ge1xuICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQ6ICdjb21wb25lbnREaWRNb3VudCcsXG4gICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6ICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzJyxcbiAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZTogJ2NvbXBvbmVudERpZFVwZGF0ZSdcbiAgfTtcblxuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBuZXcgTWFwKCk7XG4gIHZhciBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cbiAgdmFyIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzID0gbmV3IFNldCgpO1xuICB2YXIgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcbiAgdmFyIGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQgPSBuZXcgU2V0KCk7XG5cbiAgdmFyIHNldFRvU29ydGVkU3RyaW5nID0gZnVuY3Rpb24gKHNldCkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycmF5LnNvcnQoKS5qb2luKCcsICcpO1xuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBuZXcgTWFwKCk7XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChsaWZlY3ljbGVXYXJuaW5nc01hcCwgc3RyaWN0Um9vdCkge1xuICAgICAgdmFyIGxpZmVjeWNsZXNXYXJuaW5nTWVzc2FnZXMgPSBbXTtcblxuICAgICAgT2JqZWN0LmtleXMobGlmZWN5Y2xlV2FybmluZ3NNYXApLmZvckVhY2goZnVuY3Rpb24gKGxpZmVjeWNsZSkge1xuICAgICAgICB2YXIgbGlmZWN5Y2xlV2FybmluZ3MgPSBsaWZlY3ljbGVXYXJuaW5nc01hcFtsaWZlY3ljbGVdO1xuICAgICAgICBpZiAobGlmZWN5Y2xlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBjb21wb25lbnROYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICBsaWZlY3ljbGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgICAgY29tcG9uZW50TmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgZm9ybWF0dGVkID0gbGlmZWN5Y2xlLnJlcGxhY2UoJ1VOU0FGRV8nLCAnJyk7XG4gICAgICAgICAgdmFyIHN1Z2dlc3Rpb24gPSBMSUZFQ1lDTEVfU1VHR0VTVElPTlNbbGlmZWN5Y2xlXTtcbiAgICAgICAgICB2YXIgc29ydGVkQ29tcG9uZW50TmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnROYW1lcyk7XG5cbiAgICAgICAgICBsaWZlY3ljbGVzV2FybmluZ01lc3NhZ2VzLnB1c2goZm9ybWF0dGVkICsgJzogUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHMgdG8gdXNlICcgKyAoc3VnZ2VzdGlvbiArICcgaW5zdGVhZDogJyArIHNvcnRlZENvbXBvbmVudE5hbWVzKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAobGlmZWN5Y2xlc1dhcm5pbmdNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBzdHJpY3RSb290Q29tcG9uZW50U3RhY2sgPSBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc3RyaWN0Um9vdCk7XG5cbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnVW5zYWZlIGxpZmVjeWNsZSBtZXRob2RzIHdlcmUgZm91bmQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZTolcycgKyAnXFxuXFxuJXMnICsgJ1xcblxcbkxlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6JyArICdcXG5odHRwczovL2ZiLm1lL3JlYWN0LXN0cmljdC1tb2RlLXdhcm5pbmdzJywgc3RyaWN0Um9vdENvbXBvbmVudFN0YWNrLCBsaWZlY3ljbGVzV2FybmluZ01lc3NhZ2VzLmpvaW4oJ1xcblxcbicpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IG5ldyBNYXAoKTtcbiAgfTtcblxuICB2YXIgZmluZFN0cmljdFJvb3QgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgbWF5YmVTdHJpY3RSb290ID0gbnVsbDtcblxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIG1heWJlU3RyaWN0Um9vdCA9IG5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdEZXByZWNhdGlvbldhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKHVuaXF1ZU5hbWVzKTtcblxuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdjb21wb25lbnRXaWxsTW91bnQgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnVXNlIGNvbXBvbmVudERpZE1vdW50IGluc3RlYWQuIEFzIGEgdGVtcG9yYXJ5IHdvcmthcm91bmQsICcgKyAneW91IGNhbiByZW5hbWUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudC4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTonICsgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsIHNvcnRlZE5hbWVzKTtcblxuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIF91bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgX3VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhfdW5pcXVlTmFtZXMpO1xuXG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnVXNlIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgaW5zdGVhZC4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTonICsgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsIF9zb3J0ZWROYW1lcyk7XG5cbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgX3VuaXF1ZU5hbWVzMiA9IG5ldyBTZXQoKTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgX3VuaXF1ZU5hbWVzMi5hZGQoZ2V0Q29tcG9uZW50TmFtZShmaWJlci50eXBlKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX3NvcnRlZE5hbWVzMiA9IHNldFRvU29ydGVkU3RyaW5nKF91bmlxdWVOYW1lczIpO1xuXG4gICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ2NvbXBvbmVudFdpbGxVcGRhdGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uICcgKyAnVXNlIGNvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLiBBcyBhIHRlbXBvcmFyeSB3b3JrYXJvdW5kLCAnICsgJ3lvdSBjYW4gcmVuYW1lIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlLicgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1hc3luYy1jb21wb25lbnQtbGlmZWN5Y2xlLWhvb2tzJywgX3NvcnRlZE5hbWVzMik7XG5cbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG4gICAgaWYgKGRpZFdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge1xuICAgIHZhciBzdHJpY3RSb290ID0gZmluZFN0cmljdFJvb3QoZmliZXIpO1xuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRGVkdXAgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIC8vIFRoaXMgaXMgZGlmZmljdWx0IHRvIHRyYWNrIGFueSBvdGhlciB3YXkgc2luY2UgY29tcG9uZW50IG5hbWVzXG4gICAgLy8gYXJlIG9mdGVuIHZhZ3VlIGFuZCBhcmUgbGlrZWx5IHRvIGNvbGxpZGUgYmV0d2VlbiAzcmQgcGFydHkgbGlicmFyaWVzLlxuICAgIC8vIEFuIGV4cGFuZCBwcm9wZXJ0eSBpcyBwcm9iYWJseSBva2F5IHRvIHVzZSBoZXJlIHNpbmNlIGl0J3MgREVWLW9ubHksXG4gICAgLy8gYW5kIHdpbGwgb25seSBiZSBzZXQgaW4gdGhlIGV2ZW50IG9mIHNlcmlvdXMgd2FybmluZ3MuXG4gICAgaWYgKGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmdzRm9yUm9vdCA9IHZvaWQgMDtcbiAgICBpZiAoIXBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncy5oYXMoc3RyaWN0Um9vdCkpIHtcbiAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudDogW10sXG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzOiBbXSxcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGU6IFtdXG4gICAgICB9O1xuXG4gICAgICBwZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Muc2V0KHN0cmljdFJvb3QsIHdhcm5pbmdzRm9yUm9vdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IHBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncy5nZXQoc3RyaWN0Um9vdCk7XG4gICAgfVxuXG4gICAgdmFyIHVuc2FmZUxpZmVjeWNsZXMgPSBbXTtcbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSB8fCB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5wdXNoKCdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUgfHwgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1bnNhZmVMaWZlY3ljbGVzLnB1c2goJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUgfHwgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB1bnNhZmVMaWZlY3ljbGVzLnB1c2goJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgfVxuXG4gICAgaWYgKHVuc2FmZUxpZmVjeWNsZXMubGVuZ3RoID4gMCkge1xuICAgICAgdW5zYWZlTGlmZWN5Y2xlcy5mb3JFYWNoKGZ1bmN0aW9uIChsaWZlY3ljbGUpIHtcbiAgICAgICAgd2FybmluZ3NGb3JSb290W2xpZmVjeWNsZV0ucHVzaChmaWJlcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgdmFyIHN0cmljdFJvb3QgPSBmaW5kU3RyaWN0Um9vdChmaWJlcik7XG4gICAgaWYgKHN0cmljdFJvb3QgPT09IG51bGwpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBTdHJpY3RNb2RlIGNvbXBvbmVudCBpbiBhIHN0cmljdCBtb2RlIHRyZWUuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG4gICAgaWYgKGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmdzRm9yUm9vdCA9IHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCk7XG5cbiAgICBpZiAoZmliZXIudHlwZS5jb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzICE9IG51bGwgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHdhcm5pbmdzRm9yUm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IFtdO1xuICAgICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIHdhcm5pbmdzRm9yUm9vdCk7XG4gICAgICB9XG4gICAgICB3YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyQXJyYXksIHN0cmljdFJvb3QpIHtcbiAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZpYmVyQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyh1bmlxdWVOYW1lcyk7XG4gICAgICB2YXIgc3RyaWN0Um9vdENvbXBvbmVudFN0YWNrID0gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHN0cmljdFJvb3QpO1xuXG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdMZWdhY3kgY29udGV4dCBBUEkgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZTogJXMnICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTonICsgJ1xcbmh0dHBzOi8vZmIubWUvcmVhY3Qtc3RyaWN0LW1vZGUtd2FybmluZ3MnLCBzdHJpY3RSb290Q29tcG9uZW50U3RhY2ssIHNvcnRlZE5hbWVzKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLy8gVGhpcyBsZXRzIHVzIGhvb2sgaW50byBGaWJlciB0byBkZWJ1ZyB3aGF0IGl0J3MgZG9pbmcuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvODAzMy5cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIG5vdCBldmVuIGZvciBSZWFjdCBEZXZUb29scy5cbi8vIFlvdSBtYXkgb25seSBpbmplY3QgYSBkZWJ1Z1Rvb2wgaWYgeW91IHdvcmsgb24gUmVhY3QgRmliZXIgaXRzZWxmLlxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24gPSB7XG4gIGRlYnVnVG9vbDogbnVsbFxufTtcblxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSA9IFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb247XG5cbi8vIFRPRE86IE9mZnNjcmVlbiB1cGRhdGVzIHNob3VsZCBuZXZlciBzdXNwZW5kLiBIb3dldmVyLCBhIHByb21pc2UgdGhhdFxuLy8gc3VzcGVuZGVkIGluc2lkZSBhbiBvZmZzY3JlZW4gc3VidHJlZSBzaG91bGQgYmUgYWJsZSB0byBwaW5nIGF0IHRoZSBwcmlvcml0eVxuLy8gb2YgdGhlIG91dGVyIHJlbmRlci5cblxuZnVuY3Rpb24gbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIElmIHRoZXJlJ3MgYSBnYXAgYmV0d2VlbiBjb21wbGV0aW5nIGEgZmFpbGVkIHJvb3QgYW5kIHJldHJ5aW5nIGl0LFxuICAvLyBhZGRpdGlvbmFsIHVwZGF0ZXMgbWF5IGJlIHNjaGVkdWxlZC4gQ2xlYXIgYGRpZEVycm9yYCwgaW4gY2FzZSB0aGUgdXBkYXRlXG4gIC8vIGlzIHN1ZmZpY2llbnQgdG8gZml4IHRoZSBlcnJvci5cbiAgcm9vdC5kaWRFcnJvciA9IGZhbHNlO1xuXG4gIC8vIFVwZGF0ZSB0aGUgbGF0ZXN0IGFuZCBlYXJsaWVzdCBwZW5kaW5nIHRpbWVzXG4gIHZhciBlYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lO1xuICBpZiAoZWFybGllc3RQZW5kaW5nVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgLy8gTm8gb3RoZXIgcGVuZGluZyB1cGRhdGVzLlxuICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZWFybGllc3RQZW5kaW5nVGltZSA8IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBlYXJsaWVzdCBwZW5kaW5nIHVwZGF0ZS5cbiAgICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGF0ZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lO1xuICAgICAgaWYgKGxhdGVzdFBlbmRpbmdUaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGF0ZXN0IHBlbmRpbmcgdXBkYXRlXG4gICAgICAgIHJvb3QubGF0ZXN0UGVuZGluZ1RpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKGV4cGlyYXRpb25UaW1lLCByb290KTtcbn1cblxuZnVuY3Rpb24gbWFya0NvbW1pdHRlZFByaW9yaXR5TGV2ZWxzKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZSkge1xuICByb290LmRpZEVycm9yID0gZmFsc2U7XG5cbiAgaWYgKGVhcmxpZXN0UmVtYWluaW5nVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgLy8gRmFzdCBwYXRoLiBUaGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLiBDbGVhciBldmVyeXRoaW5nLlxuICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IE5vV29yaztcbiAgICByb290LmxhdGVzdFBlbmRpbmdUaW1lID0gTm9Xb3JrO1xuICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgIHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZSA9IE5vV29yaztcbiAgICByb290LmxhdGVzdFBpbmdlZFRpbWUgPSBOb1dvcms7XG4gICAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKE5vV29yaywgcm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVhcmxpZXN0UmVtYWluaW5nVGltZSA8IHJvb3QubGF0ZXN0UGluZ2VkVGltZSkge1xuICAgIHJvb3QubGF0ZXN0UGluZ2VkVGltZSA9IE5vV29yaztcbiAgfVxuXG4gIC8vIExldCdzIHNlZSBpZiB0aGUgcHJldmlvdXMgbGF0ZXN0IGtub3duIHBlbmRpbmcgbGV2ZWwgd2FzIGp1c3QgZmx1c2hlZC5cbiAgdmFyIGxhdGVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZTtcbiAgaWYgKGxhdGVzdFBlbmRpbmdUaW1lICE9PSBOb1dvcmspIHtcbiAgICBpZiAobGF0ZXN0UGVuZGluZ1RpbWUgPiBlYXJsaWVzdFJlbWFpbmluZ1RpbWUpIHtcbiAgICAgIC8vIFdlJ3ZlIGZsdXNoZWQgYWxsIHRoZSBrbm93biBwZW5kaW5nIGxldmVscy5cbiAgICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWUgPSBOb1dvcms7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lO1xuICAgICAgaWYgKGVhcmxpZXN0UGVuZGluZ1RpbWUgPiBlYXJsaWVzdFJlbWFpbmluZ1RpbWUpIHtcbiAgICAgICAgLy8gV2UndmUgZmx1c2hlZCB0aGUgZWFybGllc3Qga25vd24gcGVuZGluZyBsZXZlbC4gU2V0IHRoaXMgdG8gdGhlXG4gICAgICAgIC8vIGxhdGVzdCBwZW5kaW5nIHRpbWUuXG4gICAgICAgIHJvb3QuZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IGxldCdzIGhhbmRsZSB0aGUgZWFybGllc3QgcmVtYWluaW5nIGxldmVsIGluIHRoZSB3aG9sZSB0cmVlLiBXZSBuZWVkIHRvXG4gIC8vIGRlY2lkZSB3aGV0aGVyIHRvIHRyZWF0IGl0IGFzIGEgcGVuZGluZyBsZXZlbCBvciBhcyBzdXNwZW5kZWQuIENoZWNrXG4gIC8vIGl0IGZhbGxzIHdpdGhpbiB0aGUgcmFuZ2Ugb2Yga25vd24gc3VzcGVuZGVkIGxldmVscy5cblxuICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIGlmIChlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPT09IE5vV29yaykge1xuICAgIC8vIFRoZXJlJ3Mgbm8gc3VzcGVuZGVkIHdvcmsuIFRyZWF0IHRoZSBlYXJsaWVzdCByZW1haW5pbmcgbGV2ZWwgYXMgYVxuICAgIC8vIHBlbmRpbmcgbGV2ZWwuXG4gICAgbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZSk7XG4gICAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKE5vV29yaywgcm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhdGVzdFN1c3BlbmRlZFRpbWUgPSByb290LmxhdGVzdFN1c3BlbmRlZFRpbWU7XG4gIGlmIChlYXJsaWVzdFJlbWFpbmluZ1RpbWUgPCBsYXRlc3RTdXNwZW5kZWRUaW1lKSB7XG4gICAgLy8gVGhlIGVhcmxpZXN0IHJlbWFpbmluZyBsZXZlbCBpcyBsYXRlciB0aGFuIGFsbCB0aGUgc3VzcGVuZGVkIHdvcmsuIFRoYXRcbiAgICAvLyBtZWFucyB3ZSd2ZSBmbHVzaGVkIGFsbCB0aGUgc3VzcGVuZGVkIHdvcmsuXG4gICAgcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWUgPSBOb1dvcms7XG4gICAgcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lID0gTm9Xb3JrO1xuICAgIHJvb3QubGF0ZXN0UGluZ2VkVGltZSA9IE5vV29yaztcblxuICAgIC8vIFRoZXJlJ3Mgbm8gc3VzcGVuZGVkIHdvcmsuIFRyZWF0IHRoZSBlYXJsaWVzdCByZW1haW5pbmcgbGV2ZWwgYXMgYVxuICAgIC8vIHBlbmRpbmcgbGV2ZWwuXG4gICAgbWFya1BlbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZSk7XG4gICAgZmluZE5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uKE5vV29yaywgcm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVhcmxpZXN0UmVtYWluaW5nVGltZSA+IGVhcmxpZXN0U3VzcGVuZGVkVGltZSkge1xuICAgIC8vIFRoZSBlYXJsaWVzdCByZW1haW5pbmcgdGltZSBpcyBlYXJsaWVyIHRoYW4gYWxsIHRoZSBzdXNwZW5kZWQgd29yay5cbiAgICAvLyBUcmVhdCBpdCBhcyBhIHBlbmRpbmcgdXBkYXRlLlxuICAgIG1hcmtQZW5kaW5nUHJpb3JpdHlMZXZlbChyb290LCBlYXJsaWVzdFJlbWFpbmluZ1RpbWUpO1xuICAgIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihOb1dvcmssIHJvb3QpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRoZSBlYXJsaWVzdCByZW1haW5pbmcgdGltZSBmYWxscyB3aXRoaW4gdGhlIHJhbmdlIG9mIGtub3duIHN1c3BlbmRlZFxuICAvLyBsZXZlbHMuIFdlIHNob3VsZCB0cmVhdCB0aGlzIGFzIHN1c3BlbmRlZCB3b3JrLlxuICBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24oTm9Xb3JrLCByb290KTtcbn1cblxuZnVuY3Rpb24gaGFzTG93ZXJQcmlvcml0eVdvcmsocm9vdCwgZXJyb3JlZEV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBsYXRlc3RQZW5kaW5nVGltZSA9IHJvb3QubGF0ZXN0UGVuZGluZ1RpbWU7XG4gIHZhciBsYXRlc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lO1xuICB2YXIgbGF0ZXN0UGluZ2VkVGltZSA9IHJvb3QubGF0ZXN0UGluZ2VkVGltZTtcbiAgcmV0dXJuIGxhdGVzdFBlbmRpbmdUaW1lICE9PSBOb1dvcmsgJiYgbGF0ZXN0UGVuZGluZ1RpbWUgPCBlcnJvcmVkRXhwaXJhdGlvblRpbWUgfHwgbGF0ZXN0U3VzcGVuZGVkVGltZSAhPT0gTm9Xb3JrICYmIGxhdGVzdFN1c3BlbmRlZFRpbWUgPCBlcnJvcmVkRXhwaXJhdGlvblRpbWUgfHwgbGF0ZXN0UGluZ2VkVGltZSAhPT0gTm9Xb3JrICYmIGxhdGVzdFBpbmdlZFRpbWUgPCBlcnJvcmVkRXhwaXJhdGlvblRpbWU7XG59XG5cbmZ1bmN0aW9uIGlzUHJpb3JpdHlMZXZlbFN1c3BlbmRlZChyb290LCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIHZhciBsYXRlc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5sYXRlc3RTdXNwZW5kZWRUaW1lO1xuICByZXR1cm4gZWFybGllc3RTdXNwZW5kZWRUaW1lICE9PSBOb1dvcmsgJiYgZXhwaXJhdGlvblRpbWUgPD0gZWFybGllc3RTdXNwZW5kZWRUaW1lICYmIGV4cGlyYXRpb25UaW1lID49IGxhdGVzdFN1c3BlbmRlZFRpbWU7XG59XG5cbmZ1bmN0aW9uIG1hcmtTdXNwZW5kZWRQcmlvcml0eUxldmVsKHJvb3QsIHN1c3BlbmRlZFRpbWUpIHtcbiAgcm9vdC5kaWRFcnJvciA9IGZhbHNlO1xuICBjbGVhclBpbmcocm9vdCwgc3VzcGVuZGVkVGltZSk7XG5cbiAgLy8gRmlyc3QsIGNoZWNrIHRoZSBrbm93biBwZW5kaW5nIGxldmVscyBhbmQgdXBkYXRlIHRoZW0gaWYgbmVlZGVkLlxuICB2YXIgZWFybGllc3RQZW5kaW5nVGltZSA9IHJvb3QuZWFybGllc3RQZW5kaW5nVGltZTtcbiAgdmFyIGxhdGVzdFBlbmRpbmdUaW1lID0gcm9vdC5sYXRlc3RQZW5kaW5nVGltZTtcbiAgaWYgKGVhcmxpZXN0UGVuZGluZ1RpbWUgPT09IHN1c3BlbmRlZFRpbWUpIHtcbiAgICBpZiAobGF0ZXN0UGVuZGluZ1RpbWUgPT09IHN1c3BlbmRlZFRpbWUpIHtcbiAgICAgIC8vIEJvdGgga25vd24gcGVuZGluZyBsZXZlbHMgd2VyZSBzdXNwZW5kZWQuIENsZWFyIHRoZW0uXG4gICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmxhdGVzdFBlbmRpbmdUaW1lID0gTm9Xb3JrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgZWFybGllc3QgcGVuZGluZyBsZXZlbCB3YXMgc3VzcGVuZGVkLiBDbGVhciBieSBzZXR0aW5nIGl0IHRvIHRoZVxuICAgICAgLy8gbGF0ZXN0IHBlbmRpbmcgbGV2ZWwuXG4gICAgICByb290LmVhcmxpZXN0UGVuZGluZ1RpbWUgPSBsYXRlc3RQZW5kaW5nVGltZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobGF0ZXN0UGVuZGluZ1RpbWUgPT09IHN1c3BlbmRlZFRpbWUpIHtcbiAgICAvLyBUaGUgbGF0ZXN0IHBlbmRpbmcgbGV2ZWwgd2FzIHN1c3BlbmRlZC4gQ2xlYXIgYnkgc2V0dGluZyBpdCB0byB0aGVcbiAgICAvLyBsYXRlc3QgcGVuZGluZyBsZXZlbC5cbiAgICByb290LmxhdGVzdFBlbmRpbmdUaW1lID0gZWFybGllc3RQZW5kaW5nVGltZTtcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHVwZGF0ZSB0aGUga25vd24gc3VzcGVuZGVkIGxldmVscy5cbiAgdmFyIGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lO1xuICB2YXIgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgaWYgKGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgLy8gTm8gb3RoZXIgc3VzcGVuZGVkIGxldmVscy5cbiAgICByb290LmVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZSA9IHN1c3BlbmRlZFRpbWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVhcmxpZXN0U3VzcGVuZGVkVGltZSA8IHN1c3BlbmRlZFRpbWUpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGVhcmxpZXN0IHN1c3BlbmRlZCBsZXZlbC5cbiAgICAgIHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lID0gc3VzcGVuZGVkVGltZTtcbiAgICB9IGVsc2UgaWYgKGxhdGVzdFN1c3BlbmRlZFRpbWUgPiBzdXNwZW5kZWRUaW1lKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBsYXRlc3Qgc3VzcGVuZGVkIGxldmVsXG4gICAgICByb290LmxhdGVzdFN1c3BlbmRlZFRpbWUgPSBzdXNwZW5kZWRUaW1lO1xuICAgIH1cbiAgfVxuXG4gIGZpbmROZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbihzdXNwZW5kZWRUaW1lLCByb290KTtcbn1cblxuZnVuY3Rpb24gbWFya1BpbmdlZFByaW9yaXR5TGV2ZWwocm9vdCwgcGluZ2VkVGltZSkge1xuICByb290LmRpZEVycm9yID0gZmFsc2U7XG5cbiAgLy8gVE9ETzogV2hlbiB3ZSBhZGQgYmFjayByZXN1bWluZywgd2UgbmVlZCB0byBlbnN1cmUgdGhlIHByb2dyZXNzZWQgd29ya1xuICAvLyBpcyB0aHJvd24gb3V0IGFuZCBub3QgcmV1c2VkIGR1cmluZyB0aGUgcmVzdGFydGVkIHJlbmRlci4gT25lIHdheSB0b1xuICAvLyBpbnZhbGlkYXRlIHRoZSBwcm9ncmVzc2VkIHdvcmsgaXMgdG8gcmVzdGFydCBhdCBleHBpcmF0aW9uVGltZSArIDEuXG4gIHZhciBsYXRlc3RQaW5nZWRUaW1lID0gcm9vdC5sYXRlc3RQaW5nZWRUaW1lO1xuICBpZiAobGF0ZXN0UGluZ2VkVGltZSA9PT0gTm9Xb3JrIHx8IGxhdGVzdFBpbmdlZFRpbWUgPiBwaW5nZWRUaW1lKSB7XG4gICAgcm9vdC5sYXRlc3RQaW5nZWRUaW1lID0gcGluZ2VkVGltZTtcbiAgfVxuICBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24ocGluZ2VkVGltZSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIGNsZWFyUGluZyhyb290LCBjb21wbGV0ZWRUaW1lKSB7XG4gIHZhciBsYXRlc3RQaW5nZWRUaW1lID0gcm9vdC5sYXRlc3RQaW5nZWRUaW1lO1xuICBpZiAobGF0ZXN0UGluZ2VkVGltZSA+PSBjb21wbGV0ZWRUaW1lKSB7XG4gICAgcm9vdC5sYXRlc3RQaW5nZWRUaW1lID0gTm9Xb3JrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRFYXJsaWVzdE91dHN0YW5kaW5nUHJpb3JpdHlMZXZlbChyb290LCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgZWFybGllc3RFeHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuXG4gIHZhciBlYXJsaWVzdFBlbmRpbmdUaW1lID0gcm9vdC5lYXJsaWVzdFBlbmRpbmdUaW1lO1xuICB2YXIgZWFybGllc3RTdXNwZW5kZWRUaW1lID0gcm9vdC5lYXJsaWVzdFN1c3BlbmRlZFRpbWU7XG4gIGlmIChlYXJsaWVzdFBlbmRpbmdUaW1lID4gZWFybGllc3RFeHBpcmF0aW9uVGltZSkge1xuICAgIGVhcmxpZXN0RXhwaXJhdGlvblRpbWUgPSBlYXJsaWVzdFBlbmRpbmdUaW1lO1xuICB9XG4gIGlmIChlYXJsaWVzdFN1c3BlbmRlZFRpbWUgPiBlYXJsaWVzdEV4cGlyYXRpb25UaW1lKSB7XG4gICAgZWFybGllc3RFeHBpcmF0aW9uVGltZSA9IGVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgfVxuICByZXR1cm4gZWFybGllc3RFeHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gZGlkRXhwaXJlQXRFeHBpcmF0aW9uVGltZShyb290LCBjdXJyZW50VGltZSkge1xuICB2YXIgZXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICBpZiAoZXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiBjdXJyZW50VGltZSA8PSBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZSByb290IGhhcyBleHBpcmVkLiBGbHVzaCBhbGwgd29yayB1cCB0byB0aGUgY3VycmVudCB0aW1lLlxuICAgIHJvb3QubmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24gPSBjdXJyZW50VGltZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kTmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24oY29tcGxldGVkRXhwaXJhdGlvblRpbWUsIHJvb3QpIHtcbiAgdmFyIGVhcmxpZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QuZWFybGllc3RTdXNwZW5kZWRUaW1lO1xuICB2YXIgbGF0ZXN0U3VzcGVuZGVkVGltZSA9IHJvb3QubGF0ZXN0U3VzcGVuZGVkVGltZTtcbiAgdmFyIGVhcmxpZXN0UGVuZGluZ1RpbWUgPSByb290LmVhcmxpZXN0UGVuZGluZ1RpbWU7XG4gIHZhciBsYXRlc3RQaW5nZWRUaW1lID0gcm9vdC5sYXRlc3RQaW5nZWRUaW1lO1xuXG4gIC8vIFdvcmsgb24gdGhlIGVhcmxpZXN0IHBlbmRpbmcgdGltZS4gRmFpbGluZyB0aGF0LCB3b3JrIG9uIHRoZSBsYXRlc3RcbiAgLy8gcGluZ2VkIHRpbWUuXG4gIHZhciBuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiA9IGVhcmxpZXN0UGVuZGluZ1RpbWUgIT09IE5vV29yayA/IGVhcmxpZXN0UGVuZGluZ1RpbWUgOiBsYXRlc3RQaW5nZWRUaW1lO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vIHBlbmRpbmcgb3IgcGluZ2VkIHdvcmssIGNoZWNrIGlmIHRoZXJlJ3Mgc3VzcGVuZGVkIHdvcmtcbiAgLy8gdGhhdCdzIGxvd2VyIHByaW9yaXR5IHRoYW4gd2hhdCB3ZSBqdXN0IGNvbXBsZXRlZC5cbiAgaWYgKG5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uID09PSBOb1dvcmsgJiYgKGNvbXBsZXRlZEV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbGF0ZXN0U3VzcGVuZGVkVGltZSA8IGNvbXBsZXRlZEV4cGlyYXRpb25UaW1lKSkge1xuICAgIC8vIFRoZSBsb3dlc3QgcHJpb3JpdHkgc3VzcGVuZGVkIHdvcmsgaXMgdGhlIHdvcmsgbW9zdCBsaWtlbHkgdG8gYmVcbiAgICAvLyBjb21taXR0ZWQgbmV4dC4gTGV0J3Mgc3RhcnQgcmVuZGVyaW5nIGl0IGFnYWluLCBzbyB0aGF0IGlmIGl0IHRpbWVzIG91dCxcbiAgICAvLyBpdCdzIHJlYWR5IHRvIGNvbW1pdC5cbiAgICBuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbiA9IGxhdGVzdFN1c3BlbmRlZFRpbWU7XG4gIH1cblxuICB2YXIgZXhwaXJhdGlvblRpbWUgPSBuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbjtcbiAgaWYgKGV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgZWFybGllc3RTdXNwZW5kZWRUaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBFeHBpcmUgdXNpbmcgdGhlIGVhcmxpZXN0IGtub3duIGV4cGlyYXRpb24gdGltZS5cbiAgICBleHBpcmF0aW9uVGltZSA9IGVhcmxpZXN0U3VzcGVuZGVkVGltZTtcbiAgfVxuXG4gIHJvb3QubmV4dEV4cGlyYXRpb25UaW1lVG9Xb3JrT24gPSBuZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbjtcbiAgcm9vdC5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzKSB7XG4gIGlmIChDb21wb25lbnQgJiYgQ29tcG9uZW50LmRlZmF1bHRQcm9wcykge1xuICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wcy4gVGFrZW4gZnJvbSBSZWFjdEVsZW1lbnRcbiAgICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBiYXNlUHJvcHMpO1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSBDb21wb25lbnQuZGVmYXVsdFByb3BzO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbiAgfVxuICByZXR1cm4gYmFzZVByb3BzO1xufVxuXG5mdW5jdGlvbiByZWFkTGF6eUNvbXBvbmVudFR5cGUobGF6eUNvbXBvbmVudCkge1xuICB2YXIgc3RhdHVzID0gbGF6eUNvbXBvbmVudC5fc3RhdHVzO1xuICB2YXIgcmVzdWx0ID0gbGF6eUNvbXBvbmVudC5fcmVzdWx0O1xuICBzd2l0Y2ggKHN0YXR1cykge1xuICAgIGNhc2UgUmVzb2x2ZWQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSByZXN1bHQ7XG4gICAgICAgIHJldHVybiBDb21wb25lbnQ7XG4gICAgICB9XG4gICAgY2FzZSBSZWplY3RlZDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGVycm9yID0gcmVzdWx0O1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICBjYXNlIFBlbmRpbmc6XG4gICAgICB7XG4gICAgICAgIHZhciB0aGVuYWJsZSA9IHJlc3VsdDtcbiAgICAgICAgdGhyb3cgdGhlbmFibGU7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgbGF6eUNvbXBvbmVudC5fc3RhdHVzID0gUGVuZGluZztcbiAgICAgICAgdmFyIGN0b3IgPSBsYXp5Q29tcG9uZW50Ll9jdG9yO1xuICAgICAgICB2YXIgX3RoZW5hYmxlID0gY3RvcigpO1xuICAgICAgICBfdGhlbmFibGUudGhlbihmdW5jdGlvbiAobW9kdWxlT2JqZWN0KSB7XG4gICAgICAgICAgaWYgKGxhenlDb21wb25lbnQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRFeHBvcnQgPSBtb2R1bGVPYmplY3QuZGVmYXVsdDtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ2xhenk6IEV4cGVjdGVkIHRoZSByZXN1bHQgb2YgYSBkeW5hbWljIGltcG9ydCgpIGNhbGwuICcgKyAnSW5zdGVhZCByZWNlaXZlZDogJXNcXG5cXG5Zb3VyIGNvZGUgc2hvdWxkIGxvb2sgbGlrZTogXFxuICAnICsgXCJjb25zdCBNeUNvbXBvbmVudCA9IGxhenkoKCkgPT4gaW1wb3J0KCcuL015Q29tcG9uZW50JykpXCIsIG1vZHVsZU9iamVjdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhenlDb21wb25lbnQuX3N0YXR1cyA9IFJlc29sdmVkO1xuICAgICAgICAgICAgbGF6eUNvbXBvbmVudC5fcmVzdWx0ID0gZGVmYXVsdEV4cG9ydDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgIGlmIChsYXp5Q29tcG9uZW50Ll9zdGF0dXMgPT09IFBlbmRpbmcpIHtcbiAgICAgICAgICAgIGxhenlDb21wb25lbnQuX3N0YXR1cyA9IFJlamVjdGVkO1xuICAgICAgICAgICAgbGF6eUNvbXBvbmVudC5fcmVzdWx0ID0gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSGFuZGxlIHN5bmNocm9ub3VzIHRoZW5hYmxlcy5cbiAgICAgICAgc3dpdGNoIChsYXp5Q29tcG9uZW50Ll9zdGF0dXMpIHtcbiAgICAgICAgICBjYXNlIFJlc29sdmVkOlxuICAgICAgICAgICAgcmV0dXJuIGxhenlDb21wb25lbnQuX3Jlc3VsdDtcbiAgICAgICAgICBjYXNlIFJlamVjdGVkOlxuICAgICAgICAgICAgdGhyb3cgbGF6eUNvbXBvbmVudC5fcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGxhenlDb21wb25lbnQuX3Jlc3VsdCA9IF90aGVuYWJsZTtcbiAgICAgICAgdGhyb3cgX3RoZW5hYmxlO1xuICAgICAgfVxuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGlzQXJyYXkkMSA9IEFycmF5LmlzQXJyYXk7XG5cbi8vIFJlYWN0LkNvbXBvbmVudCB1c2VzIGEgc2hhcmVkIGZyb3plbiBvYmplY3QgYnkgZGVmYXVsdC5cbi8vIFdlJ2xsIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSBuZWVkIHRvIGluaXRpYWxpemUgbGVnYWN5IHJlZnMuXG52YXIgZW1wdHlSZWZzT2JqZWN0ID0gbmV3IFJlYWN0LkNvbXBvbmVudCgpLnJlZnM7XG5cbnZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IHZvaWQgMDtcbnZhciB3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUgPSB2b2lkIDA7XG52YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gdm9pZCAwO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUgPSBuZXcgU2V0KCk7XG5cbiAgdmFyIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjayA9IG5ldyBTZXQoKTtcblxuICB3YXJuT25JbnZhbGlkQ2FsbGJhY2skMSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGtleSA9IGNhbGxlck5hbWUgKyAnXycgKyBjYWxsYmFjaztcbiAgICBpZiAoIWRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSkge1xuICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpO1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxlck5hbWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlID0gZnVuY3Rpb24gKHR5cGUsIHBhcnRpYWxTdGF0ZSkge1xuICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpIHx8ICdDb21wb25lbnQnO1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmYWtlSW50ZXJuYWxJbnN0YW5jZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0IGEgUmVhY3QgMTUgdHJlZSBpbnNpZGUgYSBSZWFjdCAxNiB0cmVlIHVzaW5nIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLCB3aGljaCBpc25cXCd0IHN1cHBvcnRlZC4gVHJ5IHRvIG1ha2Ugc3VyZSB5b3UgaGF2ZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0IChhbmQgaWRlYWxseSwgc3dpdGNoIHRvIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCkuJyk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5leHRQcm9wcykge1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICB7XG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAvLyBJbnZva2UgdGhlIGZ1bmN0aW9uIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgICAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGFydGlhbFN0YXRlID0gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5leHRQcm9wcywgcHJldlN0YXRlKTtcblxuICB7XG4gICAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKGN0b3IsIHBhcnRpYWxTdGF0ZSk7XG4gIH1cbiAgLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAgdmFyIG1lbW9pemVkU3RhdGUgPSBwYXJ0aWFsU3RhdGUgPT09IG51bGwgfHwgcGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQgPyBwcmV2U3RhdGUgOiBfYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuXG4gIC8vIE9uY2UgdGhlIHVwZGF0ZSBxdWV1ZSBpcyBlbXB0eSwgcGVyc2lzdCB0aGUgZGVyaXZlZCBzdGF0ZSBvbnRvIHRoZVxuICAvLyBiYXNlIHN0YXRlLlxuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuICB9XG59XG5cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogaXNNb3VudGVkLFxuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcik7XG5cbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcik7XG5cbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgICB1cGRhdGUudGFnID0gUmVwbGFjZVN0YXRlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayQxKGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgICB9XG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgfSxcbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoaW5zdCk7XG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVxdWVzdEN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgZmliZXIpO1xuXG4gICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrJDEoY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgIGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSk7XG4gICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpZiAodHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIHtcbiAgICAgICEoc2hvdWxkVXBkYXRlICE9PSB1bmRlZmluZWQpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKG9sZFByb3BzLCBuZXdQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgdHlwZW9mIGN0b3IucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yPycsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vR2V0SW5pdGlhbFN0YXRlT25FUzYgPSAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fCBpbnN0YW5jZS5zdGF0ZTtcbiAgICAhbm9HZXRJbml0aWFsU3RhdGVPbkVTNiA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9HZXREZWZhdWx0UHJvcHNPbkVTNiA9ICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMgfHwgaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkO1xuICAgICFub0dldERlZmF1bHRQcm9wc09uRVM2ID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vSW5zdGFuY2VQcm9wVHlwZXMgPSAhaW5zdGFuY2UucHJvcFR5cGVzO1xuICAgICFub0luc3RhbmNlUHJvcFR5cGVzID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vSW5zdGFuY2VDb250ZXh0VHlwZSA9ICFpbnN0YW5jZS5jb250ZXh0VHlwZTtcbiAgICAhbm9JbnN0YW5jZUNvbnRleHRUeXBlID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBub0luc3RhbmNlQ29udGV4dFR5cGVzID0gIWluc3RhbmNlLmNvbnRleHRUeXBlcztcbiAgICAhbm9JbnN0YW5jZUNvbnRleHRUeXBlcyA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2NvbnRleHRUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIGNvbnRleHRUeXBlcyBpbnN0ZWFkLicsIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgaWYgKGN0b3IuY29udGV4dFR5cGUgJiYgY3Rvci5jb250ZXh0VHlwZXMgJiYgIWRpZFdhcm5BYm91dENvbnRleHRUeXBlQW5kQ29udGV4dFR5cGVzLmhhcyhjdG9yKSkge1xuICAgICAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVBbmRDb250ZXh0VHlwZXMuYWRkKGN0b3IpO1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgZGVjbGFyZXMgYm90aCBjb250ZXh0VHlwZXMgYW5kIGNvbnRleHRUeXBlIHN0YXRpYyBwcm9wZXJ0aWVzLiAnICsgJ1RoZSBsZWdhY3kgY29udGV4dFR5cGVzIHByb3BlcnR5IHdpbGwgYmUgaWdub3JlZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgbm9Db21wb25lbnRTaG91bGRVcGRhdGUgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nO1xuICAgICFub0NvbXBvbmVudFNob3VsZFVwZGF0ZSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgIH1cbiAgICB2YXIgbm9Db21wb25lbnREaWRVbm1vdW50ID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbic7XG4gICAgIW5vQ29tcG9uZW50RGlkVW5tb3VudCA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgIW5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSkgOiB2b2lkIDA7XG4gICAgdmFyIG5vVW5zYWZlQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAhbm9VbnNhZmVDb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gbmV3UHJvcHM7XG4gICAgIShpbnN0YW5jZS5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFoYXNNdXRhdGVkUHJvcHMpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMoLi4uKTogV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUsIG5hbWUpIDogdm9pZCAwO1xuICAgIHZhciBub0luc3RhbmNlRGVmYXVsdFByb3BzID0gIWluc3RhbmNlLmRlZmF1bHRQcm9wcztcbiAgICAhbm9JbnN0YW5jZURlZmF1bHRQcm9wcyA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpIDogdm9pZCAwO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICFkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuaGFzKGN0b3IpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUuYWRkKGN0b3IpO1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgc2hvdWxkIGJlIHVzZWQgd2l0aCBjb21wb25lbnREaWRVcGRhdGUoKS4gJyArICdUaGlzIGNvbXBvbmVudCBkZWZpbmVzIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgb25seS4nLCBnZXRDb21wb25lbnROYW1lKGN0b3IpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9JbnN0YW5jZUdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbic7XG4gICAgIW5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9JbnN0YW5jZUdldERlcml2ZWRTdGF0ZUZyb21DYXRjaCA9IHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbic7XG4gICAgIW5vSW5zdGFuY2VHZXREZXJpdmVkU3RhdGVGcm9tQ2F0Y2ggPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclczogZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgbm9TdGF0aWNHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHR5cGVvZiBjdG9yLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nO1xuICAgICFub1N0YXRpY0dldFNuYXBzaG90QmVmb3JlVXBkYXRlID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC4nLCBuYW1lKSA6IHZvaWQgMDtcbiAgICB2YXIgX3N0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaWYgKF9zdGF0ZSAmJiAodHlwZW9mIF9zdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheSQxKF9zdGF0ZSkpKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCBuYW1lKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICEodHlwZW9mIGN0b3IuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgbmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudXBkYXRlciA9IGNsYXNzQ29tcG9uZW50VXBkYXRlcjtcbiAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gIC8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcbiAgc2V0KGluc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHtcbiAgICBpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gZmFrZUludGVybmFsSW5zdGFuY2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgcHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGZhbHNlO1xuICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB2YXIgY29udGV4dCA9IG51bGw7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAge1xuICAgIGlmICgnY29udGV4dFR5cGUnIGluIGN0b3IpIHtcbiAgICAgIHZhciBpc1ZhbGlkID1cbiAgICAgIC8vIEFsbG93IG51bGwgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9uXG4gICAgICBjb250ZXh0VHlwZSA9PT0gbnVsbCB8fCBjb250ZXh0VHlwZSAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgJiYgY29udGV4dFR5cGUuX2NvbnRleHQgPT09IHVuZGVmaW5lZDsgLy8gTm90IGEgPENvbnRleHQuQ29uc3VtZXI+XG5cbiAgICAgIGlmICghaXNWYWxpZCAmJiAhZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmhhcyhjdG9yKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKGN0b3IpO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAgICBpZiAoY29udGV4dFR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiAnICsgJ1RoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuICcgKyAnVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gJyArICd0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuJztcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29udGV4dFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byBhICcgKyB0eXBlb2YgY29udGV4dFR5cGUgKyAnLic7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyB0aGUgQ29udGV4dC5Qcm92aWRlciBpbnN0ZWFkPyc7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuX2NvbnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIDxDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbignLCAnKSArICd9Lic7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiAnICsgJ2NvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzJywgZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JywgYWRkZW5kdW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIGN0b3IsIHRydWUpO1xuICAgIHZhciBjb250ZXh0VHlwZXMgPSBjdG9yLmNvbnRleHRUeXBlcztcbiAgICBpc0xlZ2FjeUNvbnRleHRDb25zdW1lciA9IGNvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjb250ZXh0VHlwZXMgIT09IHVuZGVmaW5lZDtcbiAgICBjb250ZXh0ID0gaXNMZWdhY3lDb250ZXh0Q29uc3VtZXIgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgLy8gSW5zdGFudGlhdGUgdHdpY2UgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICB7XG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgfVxuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgIT09IG51bGwgJiYgaW5zdGFuY2Uuc3RhdGUgIT09IHVuZGVmaW5lZCA/IGluc3RhbmNlLnN0YXRlIDogbnVsbDtcbiAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICAgIGlmICghZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICcgKyAnJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgJyArICdhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gJyArICdUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuJywgY29tcG9uZW50TmFtZSwgaW5zdGFuY2Uuc3RhdGUgPT09IG51bGwgPyAnbnVsbCcgOiAndW5kZWZpbmVkJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbmV3IGNvbXBvbmVudCBBUElzIGFyZSBkZWZpbmVkLCBcInVuc2FmZVwiIGxpZmVjeWNsZXMgd29uJ3QgYmUgY2FsbGVkLlxuICAgIC8vIFdhcm4gYWJvdXQgdGhlc2UgbGlmZWN5Y2xlcyBpZiB0aGV5IGFyZSBwcmVzZW50LlxuICAgIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBtZXRob2RzIHRob3VnaC5cbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIHZhciBuZXdBcGlOYW1lID0gdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nID8gJ2dldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpJyA6ICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpJztcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmhhcyhfY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlLmFkZChfY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnVW5zYWZlIGxlZ2FjeSBsaWZlY3ljbGVzIHdpbGwgbm90IGJlIGNhbGxlZCBmb3IgY29tcG9uZW50cyB1c2luZyBuZXcgY29tcG9uZW50IEFQSXMuXFxuXFxuJyArICclcyB1c2VzICVzIGJ1dCBhbHNvIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgbGVnYWN5IGxpZmVjeWNsZXM6JXMlcyVzXFxuXFxuJyArICdUaGUgYWJvdmUgbGlmZWN5Y2xlcyBzaG91bGQgYmUgcmVtb3ZlZC4gTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTpcXG4nICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtYXN5bmMtY29tcG9uZW50LWxpZmVjeWNsZS1ob29rcycsIF9jb21wb25lbnROYW1lLCBuZXdBcGlOYW1lLCBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyAnXFxuICAnICsgZm91bmRXaWxsTW91bnROYW1lIDogJycsIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgPyAnXFxuICAnICsgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA6ICcnLCBmb3VuZFdpbGxVcGRhdGVOYW1lICE9PSBudWxsID8gJ1xcbiAgJyArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIFJlYWN0RmliZXJDb250ZXh0IHVzdWFsbHkgdXBkYXRlcyB0aGlzIGNhY2hlIGJ1dCBjYW4ndCBmb3IgbmV3bHktY3JlYXRlZCBpbnN0YW5jZXMuXG4gIGlmIChpc0xlZ2FjeUNvbnRleHRDb25zdW1lcikge1xuICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICB9XG5cbiAgc3RvcFBoYXNlVGltZXIoKTtcblxuICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgJ0NvbXBvbmVudCcpO1xuICAgIH1cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcbiAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gJyArIFwidGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufVxuXG4vLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG5mdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB7XG4gICAgY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgaW5zdGFuY2UucmVmcyA9IGVtcHR5UmVmc09iamVjdDtcblxuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG4gIH1cblxuICB7XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSBuZXdQcm9wcykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclczogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRvIGFzc2lnbiBwcm9wcyBkaXJlY3RseSB0byBzdGF0ZSAnICsgXCJiZWNhdXNlIHVwZGF0ZXMgdG8gcHJvcHMgd29uJ3QgYmUgcmVmbGVjdGVkIGluIHN0YXRlLiBcIiArICdJbiBtb3N0IGNhc2VzLCBpdCBpcyBiZXR0ZXIgdG8gdXNlIHByb3BzIGRpcmVjdGx5LicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmcod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBpZiAod2FybkFib3V0RGVwcmVjYXRlZExpZmVjeWNsZXMpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZERlcHJlY2F0aW9uV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgIC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuICAgIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcblxuICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG4gIHZhciBuZXh0Q29udGV4dCA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dExlZ2FjeVVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgY3RvciwgdHJ1ZSk7XG4gICAgbmV4dENvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXh0TGVnYWN5VW5tYXNrZWRDb250ZXh0KTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJztcblxuICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO1xuXG4gIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBuZXdTdGF0ZSA9IGluc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cbiAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSkge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXdQcm9wcyk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB8fCBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY3Rvciwgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgIH1cbiAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbi8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPyBvbGRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMod29ya0luUHJvZ3Jlc3MudHlwZSwgb2xkUHJvcHMpO1xuXG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIG5leHRDb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBuZXh0VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBjdG9yLCB0cnVlKTtcbiAgICBuZXh0Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICB9XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nO1xuXG4gIC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cblxuICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCk7XG5cbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICFjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTbmFwc2hvdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgaW5zdGFuY2UuY29udGV4dCA9IG5leHRDb250ZXh0O1xuXG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmSW5TdHJpY3RNb2RlID0gdm9pZCAwO1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHZvaWQgMDtcbnZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB2b2lkIDA7XG52YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHt9O1xuXG57XG4gIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZJblN0cmljdE1vZGUgPSB7fTtcblxuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG4gIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hpbGQuX3N0b3JlIHx8IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgfHwgY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgISh0eXBlb2YgY2hpbGQuX3N0b3JlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYoKTtcbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgICB3YXJuaW5nJDEoZmFsc2UsICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyk7XG4gIH07XG59XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50JCQxLCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAobWl4ZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAocmV0dXJuRmliZXIubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHJldHVybkZpYmVyLnR5cGUpIHx8ICdDb21wb25lbnQnO1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZkluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0Egc3RyaW5nIHJlZiwgXCIlc1wiLCBoYXMgYmVlbiBmb3VuZCB3aXRoaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1N0cmluZyByZWZzIGFyZSBhIHNvdXJjZSBvZiBwb3RlbnRpYWwgYnVncyBhbmQgc2hvdWxkIGJlIGF2b2lkZWQuICcgKyAnV2UgcmVjb21tZW5kIHVzaW5nIGNyZWF0ZVJlZigpIGluc3RlYWQuJyArICdcXG4lcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOicgKyAnXFxuaHR0cHM6Ly9mYi5tZS9yZWFjdC1zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgbWl4ZWRSZWYsIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChyZXR1cm5GaWJlcikpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZkluU3RyaWN0TW9kZVtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5fb3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIGluc3QgPSB2b2lkIDA7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgICAgIShvd25lckZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnRnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLiBEaWQgeW91IG1lYW4gdG8gdXNlIFJlYWN0LmZvcndhcmRSZWYoKT8nKSA6IHZvaWQgMDtcbiAgICAgICAgaW5zdCA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgICAgIWluc3QgPyBpbnZhcmlhbnQoZmFsc2UsICdNaXNzaW5nIG93bmVyIGZvciBzdHJpbmcgcmVmICVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICAgIHZhciBzdHJpbmdSZWYgPSAnJyArIG1peGVkUmVmO1xuICAgICAgLy8gQ2hlY2sgaWYgcHJldmlvdXMgc3RyaW5nIHJlZiBtYXRjaGVzIG5ldyBzdHJpbmcgcmVmXG4gICAgICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCAmJiBjdXJyZW50JCQxLnJlZiAhPT0gbnVsbCAmJiB0eXBlb2YgY3VycmVudCQkMS5yZWYgPT09ICdmdW5jdGlvbicgJiYgY3VycmVudCQkMS5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50JCQxLnJlZjtcbiAgICAgIH1cbiAgICAgIHZhciByZWYgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlZnMgPSBpbnN0LnJlZnM7XG4gICAgICAgIGlmIChyZWZzID09PSBlbXB0eVJlZnNPYmplY3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgbGF6eSBwb29sZWQgZnJvemVuIG9iamVjdCwgc28gd2UgbmVlZCB0byBpbml0aWFsaXplLlxuICAgICAgICAgIHJlZnMgPSBpbnN0LnJlZnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICAhKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24sIGEgc3RyaW5nLCBhbiBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlUmVmKCksIG9yIG51bGwuJykgOiB2b2lkIDA7XG4gICAgICAhZWxlbWVudC5fb3duZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICglcykgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtYXkgYmUgYWRkaW5nIGEgcmVmIHRvIGEgZnVuY3Rpb24gY29tcG9uZW50XFxuMi4gWW91IG1heSBiZSBhZGRpbmcgYSByZWYgdG8gYSBjb21wb25lbnQgdGhhdCB3YXMgbm90IGNyZWF0ZWQgaW5zaWRlIGEgY29tcG9uZW50XFwncyByZW5kZXIgbWV0aG9kXFxuMy4gWW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGxvYWRlZFxcblNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIG1peGVkUmVmKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1peGVkUmVmO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gIGlmIChyZXR1cm5GaWJlci50eXBlICE9PSAndGV4dGFyZWEnKSB7XG4gICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAge1xuICAgICAgYWRkZW5kdW0gPSAnIElmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicgKyBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCk7XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQsIGFkZGVuZHVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUoKSB7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicgKyBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCk7XG5cbiAgaWYgKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIHdhcm5pbmckMShmYWxzZSwgJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicpO1xufVxuXG4vLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuZnVuY3Rpb24gQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlbGV0aW9ucyBhcmUgYWRkZWQgaW4gcmV2ZXJzZWQgb3JkZXIgc28gd2UgYWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmV0dXJuIGZpYmVyJ3MgZWZmZWN0IGxpc3QgaXMgZW1wdHkgZXhjZXB0IGZvclxuICAgIC8vIGRlbGV0aW9ucywgc28gd2UgY2FuIGp1c3QgYXBwZW5kIHRoZSBkZWxldGlvbiB0byB0aGUgbGlzdC4gVGhlIHJlbWFpbmluZ1xuICAgIC8vIGVmZmVjdHMgYXJlbid0IGFkZGVkIHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZS4gT25jZSB3ZSBpbXBsZW1lbnRcbiAgICAvLyByZXN1bWluZywgdGhpcyBtYXkgbm90IGJlIHRydWUuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbiAgICAvLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGRUb0RlbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY2xvbmUuaW5kZXggPSAwO1xuICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICAgIHZhciBjdXJyZW50JCQxID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChjdXJyZW50JCQxICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50JCQxLmluZGV4O1xuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50JCQxLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCB8fCBjdXJyZW50JCQxLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCQkMSwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQkJDEsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQkJDEgIT09IG51bGwgJiYgY3VycmVudCQkMS5lbGVtZW50VHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50JCQxLCBlbGVtZW50LnByb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQkJDEsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQkJDEsIGVsZW1lbnQpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCQkMSwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50JCQxID09PSBudWxsIHx8IGN1cnJlbnQkJDEudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQkJDEuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQkJDEuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCQkMSwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCQkMSwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCB8fCBjdXJyZW50JCQxLnRhZyAhPT0gRnJhZ21lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmcmFnbWVudCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCQkMSwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihyZXR1cm5GaWJlciwgbnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgX2NyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDIgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkMi5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkMyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICAgIF9jcmVhdGVkMy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVkMztcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG5cbiAgICB2YXIga2V5ID0gb2xkRmliZXIgIT09IG51bGwgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3JcbiAgICAgIC8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSB0ZXh0IG5vZGVzLCB0aGV5IG1hdGNoLlxuICAgICAgdmFyIG1hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgbWF0Y2hlZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwgbmV3Q2hpbGQua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjMgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjMsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkKTtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrbm93bktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJywga2V5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RoIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG5cbiAgICB7XG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmICghX25ld0ZpYmVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXIyKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cblxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICB7XG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJlbmRlcmluZyBHZW5lcmF0b3JzIGJlY2F1c2UgaXQncyBhIG11dGF0aW9uLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI5OTVcbiAgICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAvLyAkRmxvd0ZpeE1lIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IHRvU3RyaW5nVGFnXG4gICAgICBuZXdDaGlsZHJlbkl0ZXJhYmxlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdHZW5lcmF0b3InKSB7XG4gICAgICAgICFkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID8gd2FybmluZyQxKGZhbHNlLCAnVXNpbmcgR2VuZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gS2VlcCBpbiBtaW5kICcgKyAneW91IG1pZ2h0IG5lZWQgdG8gcG9seWZpbGwgdGhlc2UgZmVhdHVyZXMgZm9yIG9sZGVyIGJyb3dzZXJzLicpIDogdm9pZCAwO1xuICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICBpZiAobmV3Q2hpbGRyZW5JdGVyYWJsZS5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgICFkaWRXYXJuQWJvdXRNYXBzID8gd2FybmluZyQxKGZhbHNlLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuICAgICAgdmFyIF9uZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgIGZvciAoOyAhX3N0ZXAuZG9uZTsgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKG5ld0NoaWxkcmVuICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAoIW9sZEZpYmVyKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9uZXdGaWJlcjMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIHZhciBfbmV3RmliZXI0ID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI0O1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG4gICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50ID8gZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIDogY2hpbGQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFID8gZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA6IGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGNoaWxkLCBlbGVtZW50KTtcbiAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lLCBlbGVtZW50LmtleSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIF9jcmVhdGVkNC5yZWYgPSBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50KTtcbiAgICAgIF9jcmVhdGVkNC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBwb3J0YWwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLm1vZGUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgdmFyIGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsICYmIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiYgbmV3Q2hpbGQua2V5ID09PSBudWxsO1xuICAgIGlmIChpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50KSB7XG4gICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBvYmplY3QgdHlwZXNcbiAgICB2YXIgaXNPYmplY3QgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsO1xuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAndW5kZWZpbmVkJyAmJiAhaXNVbmtleWVkVG9wTGV2ZWxGcmFnbWVudCkge1xuICAgICAgLy8gSWYgdGhlIG5ldyBjaGlsZCBpcyB1bmRlZmluZWQsIGFuZCB0aGUgcmV0dXJuIGZpYmVyIGlzIGEgY29tcG9zaXRlXG4gICAgICAvLyBjb21wb25lbnQsIHRocm93IGFuIGVycm9yLiBJZiBGaWJlciByZXR1cm4gdHlwZXMgYXJlIGRpc2FibGVkLFxuICAgICAgLy8gd2UgYWxyZWFkeSB0aHJldyBhYm92ZS5cbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHRvIHRoZSBuZXh0IGNhc2UsIHdoaWNoIGhhbmRsZXMgYm90aFxuICAgICAgICAvLyBmdW5jdGlvbnMgYW5kIGNsYXNzZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lZCBuby1mYWxsdGhyb3VnaFxuICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSk7XG52YXIgbW91bnRDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcihmYWxzZSk7XG5cbmZ1bmN0aW9uIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgIShjdXJyZW50JCQxID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBjdXJyZW50JCQxLmNoaWxkKSA/IGludmFyaWFudChmYWxzZSwgJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcblxuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLCBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUpO1xuICAgIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG4gIG5ld0NoaWxkLnNpYmxpbmcgPSBudWxsO1xufVxuXG52YXIgTk9fQ09OVEVYVCA9IHt9O1xuXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yJDEgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG52YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG5cbmZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gICEoYyAhPT0gTk9fQ09OVEVYVCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgcmV0dXJuIHJvb3RJbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgLy8gUHVzaCBjdXJyZW50IHJvb3QgaW5zdGFuY2Ugb250byB0aGUgc3RhY2s7XG4gIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcbiAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG5cbiAgLy8gRmluYWxseSwgd2UgbmVlZCB0byBwdXNoIHRoZSBob3N0IGNvbnRleHQgdG8gdGhlIHN0YWNrLlxuICAvLyBIb3dldmVyLCB3ZSBjYW4ndCBqdXN0IGNhbGwgZ2V0Um9vdEhvc3RDb250ZXh0KCkgYW5kIHB1c2ggaXQgYmVjYXVzZVxuICAvLyB3ZSdkIGhhdmUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVudHJpZXMgb24gdGhlIHN0YWNrIGRlcGVuZGluZyBvblxuICAvLyB3aGV0aGVyIGdldFJvb3RIb3N0Q29udGV4dCgpIHRocm93cyBzb21ld2hlcmUgaW4gcmVuZGVyZXIgY29kZSBvciBub3QuXG4gIC8vIFNvIHdlIHB1c2ggYW4gZW1wdHkgdmFsdWUgZmlyc3QuIFRoaXMgbGV0cyB1cyBzYWZlbHkgdW53aW5kIG9uIGVycm9ycy5cbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgTk9fQ09OVEVYVCwgZmliZXIpO1xuICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuICAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoaXMgZnVuY3Rpb24gZG9lc24ndCB0aHJvdywgcmVwbGFjZSBpdC5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yJDEsIG5leHRSb290Q29udGV4dCwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IkMSwgZmliZXIpO1xuICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RDb250ZXh0KCkge1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcikge1xuICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IkMS5jdXJyZW50KTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gIC8vIERvbid0IHB1c2ggdGhpcyBGaWJlcidzIGNvbnRleHQgdW5sZXNzIGl0J3MgdW5pcXVlLlxuICBpZiAoY29udGV4dCA9PT0gbmV4dENvbnRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IkMSwgbmV4dENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciQxLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG52YXIgTm9FZmZlY3QkMSA9IC8qICAgICAgICAgICAgICovMDtcbnZhciBVbm1vdW50U25hcHNob3QgPSAvKiAgICAgICovMjtcbnZhciBVbm1vdW50TXV0YXRpb24gPSAvKiAgICAgICovNDtcbnZhciBNb3VudE11dGF0aW9uID0gLyogICAgICAgICovODtcbnZhciBVbm1vdW50TGF5b3V0ID0gLyogICAgICAgICovMTY7XG52YXIgTW91bnRMYXlvdXQgPSAvKiAgICAgICAgICAqLzMyO1xudmFyIE1vdW50UGFzc2l2ZSA9IC8qICAgICAgICAgKi82NDtcbnZhciBVbm1vdW50UGFzc2l2ZSA9IC8qICAgICAgICovMTI4O1xuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcblxuXG52YXIgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50ID0gdm9pZCAwO1xue1xuICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQgPSBuZXcgU2V0KCk7XG59XG5cbi8vIFRoZXNlIGFyZSBzZXQgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbXBvbmVudC5cbnZhciByZW5kZXJFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbi8vIFRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBJJ3ZlIG5hbWVkIGl0IGRpZmZlcmVudGx5IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG52YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG5cbi8vIEhvb2tzIGFyZSBzdG9yZWQgYXMgYSBsaW5rZWQgbGlzdCBvbiB0aGUgZmliZXIncyBtZW1vaXplZFN0YXRlIGZpZWxkLiBUaGVcbi8vIGN1cnJlbnQgaG9vayBsaXN0IGlzIHRoZSBsaXN0IHRoYXQgYmVsb25ncyB0byB0aGUgY3VycmVudCBmaWJlci4gVGhlXG4vLyB3b3JrLWluLXByb2dyZXNzIGhvb2sgbGlzdCBpcyBhIG5ldyBsaXN0IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG52YXIgY3VycmVudEhvb2sgPSBudWxsO1xudmFyIG5leHRDdXJyZW50SG9vayA9IG51bGw7XG52YXIgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xudmFyIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG52YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbnZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbnZhciBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IG51bGw7XG52YXIgc2lkZUVmZmVjdFRhZyA9IDA7XG5cbi8vIFVwZGF0ZXMgc2NoZWR1bGVkIGR1cmluZyByZW5kZXIgd2lsbCB0cmlnZ2VyIGFuIGltbWVkaWF0ZSByZS1yZW5kZXIgYXQgdGhlXG4vLyBlbmQgb2YgdGhlIGN1cnJlbnQgcGFzcy4gV2UgY2FuJ3Qgc3RvcmUgdGhlc2UgdXBkYXRlcyBvbiB0aGUgbm9ybWFsIHF1ZXVlLFxuLy8gYmVjYXVzZSBpZiB0aGUgd29yayBpcyBhYm9ydGVkLCB0aGV5IHNob3VsZCBiZSBkaXNjYXJkZWQuIEJlY2F1c2UgdGhpcyBpc1xuLy8gYSByZWxhdGl2ZWx5IHJhcmUgY2FzZSwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGFkZCBhbiBhZGRpdGlvbmFsIGZpZWxkIHRvXG4vLyBlaXRoZXIgdGhlIGhvb2sgb3IgcXVldWUgb2JqZWN0IHR5cGVzLiBTbyB3ZSBzdG9yZSB0aGVtIGluIGEgbGF6aWx5IGNyZWF0ZVxuLy8gbWFwIG9mIHF1ZXVlIC0+IHJlbmRlci1waGFzZSB1cGRhdGVzLCB3aGljaCBhcmUgZGlzY2FyZGVkIG9uY2UgdGhlIGNvbXBvbmVudFxuLy8gY29tcGxldGVzIHdpdGhvdXQgcmUtcmVuZGVyaW5nLlxuXG4vLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGR1cmluZyB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyByZW5kZXIgcGFzcy5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4vLyBMYXppbHkgY3JlYXRlZCBtYXAgb2YgcmVuZGVyLXBoYXNlIHVwZGF0ZXNcbnZhciByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuLy8gQ291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxudmFyIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbnZhciBSRV9SRU5ERVJfTElNSVQgPSAyNTtcblxuLy8gSW4gREVWLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByaW1pdGl2ZSBob29rXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuXG4vLyBJbiBERVYsIHRoaXMgbGlzdCBlbnN1cmVzIHRoYXQgaG9va3MgYXJlIGNhbGxlZCBpbiB0aGUgc2FtZSBvcmRlciBiZXR3ZWVuIHJlbmRlcnMuXG4vLyBUaGUgbGlzdCBzdG9yZXMgdGhlIG9yZGVyIG9mIGhvb2tzIHVzZWQgZHVyaW5nIHRoZSBpbml0aWFsIHJlbmRlciAobW91bnQpLlxuLy8gU3Vic2VxdWVudCByZW5kZXJzICh1cGRhdGVzKSByZWZlcmVuY2UgdGhpcyBsaXN0LlxudmFyIGhvb2tUeXBlc0RldiA9IG51bGw7XG52YXIgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcblxuZnVuY3Rpb24gbW91bnRIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgPT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc0RldiA9IFtob29rTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tUeXBlc0Rldi5wdXNoKGhvb2tOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9va1R5cGVzRGV2KCkge1xuICB7XG4gICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbiAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldisrO1xuICAgICAgaWYgKGhvb2tUeXBlc0Rldltob29rVHlwZXNVcGRhdGVJbmRleERldl0gIT09IGhvb2tOYW1lKSB7XG4gICAgICAgIHdhcm5Pbkhvb2tNaXNtYXRjaEluRGV2KGhvb2tOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uSG9va01pc21hdGNoSW5EZXYoY3VycmVudEhvb2tOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS50eXBlKTtcbiAgICBpZiAoIWRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gJyc7XG5cbiAgICAgICAgdmFyIHNlY29uZENvbHVtblN0YXJ0ID0gMzA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXY7IGkrKykge1xuICAgICAgICAgIHZhciBvbGRIb29rTmFtZSA9IGhvb2tUeXBlc0RldltpXTtcbiAgICAgICAgICB2YXIgbmV3SG9va05hbWUgPSBpID09PSBob29rVHlwZXNVcGRhdGVJbmRleERldiA/IGN1cnJlbnRIb29rTmFtZSA6IG9sZEhvb2tOYW1lO1xuXG4gICAgICAgICAgdmFyIHJvdyA9IGkgKyAxICsgJy4gJyArIG9sZEhvb2tOYW1lO1xuXG4gICAgICAgICAgLy8gRXh0cmEgc3BhY2Ugc28gc2Vjb25kIGNvbHVtbiBsaW5lcyB1cFxuICAgICAgICAgIC8vIGxvbCBAIElFIG5vdCBzdXBwb3J0aW5nIFN0cmluZyNyZXBlYXRcbiAgICAgICAgICB3aGlsZSAocm93Lmxlbmd0aCA8IHNlY29uZENvbHVtblN0YXJ0KSB7XG4gICAgICAgICAgICByb3cgKz0gJyAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdyArPSBuZXdIb29rTmFtZSArICdcXG4nO1xuXG4gICAgICAgICAgdGFibGUgKz0gcm93O1xuICAgICAgICB9XG5cbiAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnUmVhY3QgaGFzIGRldGVjdGVkIGEgY2hhbmdlIGluIHRoZSBvcmRlciBvZiBIb29rcyBjYWxsZWQgYnkgJXMuICcgKyAnVGhpcyB3aWxsIGxlYWQgdG8gYnVncyBhbmQgZXJyb3JzIGlmIG5vdCBmaXhlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgUnVsZXMgb2YgSG9va3M6IGh0dHBzOi8vZmIubWUvcnVsZXMtb2YtaG9va3NcXG5cXG4nICsgJyAgIFByZXZpb3VzIHJlbmRlciAgICAgICAgICAgIE5leHQgcmVuZGVyXFxuJyArICcgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4nICsgJyVzJyArICcgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cXG4nLCBjb21wb25lbnROYW1lLCB0YWJsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93SW52YWxpZEhvb2tFcnJvcigpIHtcbiAgaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvciBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbjEuIFlvdSBtaWdodCBoYXZlIG1pc21hdGNoaW5nIHZlcnNpb25zIG9mIFJlYWN0IGFuZCB0aGUgcmVuZGVyZXIgKHN1Y2ggYXMgUmVhY3QgRE9NKVxcbjIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4zLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtaW52YWxpZC1ob29rLWNhbGwgZm9yIHRpcHMgYWJvdXQgaG93IHRvIGRlYnVnIGFuZCBmaXggdGhpcyBwcm9ibGVtLicpO1xufVxuXG5mdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gIGlmIChwcmV2RGVwcyA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHdhcm5pbmckMShmYWxzZSwgJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nIGxlbmd0aHMgaW4gcHJvZCBiZWNhdXNlIHRoZXNlIGFycmF5cyBzaG91bGQgYmVcbiAgICAvLyBwYXNzZWQgaW5saW5lLlxuICAgIGlmIChuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCkge1xuICAgICAgd2FybmluZyQxKGZhbHNlLCAnVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgJ1snICsgbmV4dERlcHMuam9pbignLCAnKSArICddJywgJ1snICsgcHJldkRlcHMuam9pbignLCAnKSArICddJyk7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHJlZk9yQ29udGV4dCwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHJlbmRlckV4cGlyYXRpb25UaW1lID0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG4gIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsO1xuXG4gIHtcbiAgICBob29rVHlwZXNEZXYgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5fZGVidWdIb29rVHlwZXMgOiBudWxsO1xuICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7XG4gIH1cblxuICAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBjdXJyZW50SG9vayA9IG51bGw7XG4gIC8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbiAgLy8gcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIC8vIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIHJlbmRlclBoYXNlVXBkYXRlcyA9IG51bGw7XG4gIC8vIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgLy8gc2lkZUVmZmVjdFRhZyA9IDA7XG5cbiAgLy8gVE9ETyBXYXJuIGlmIG5vIGhvb2tzIGFyZSB1c2VkIGF0IGFsbCBkdXJpbmcgbW91bnQsIHRoZW4gc29tZSBhcmUgdXNlZCBkdXJpbmcgdXBkYXRlLlxuICAvLyBDdXJyZW50bHkgd2Ugd2lsbCBpZGVudGlmeSB0aGUgdXBkYXRlIHJlbmRlciBhcyBhIG1vdW50IGJlY2F1c2UgbmV4dEN1cnJlbnRIb29rID09PSBudWxsLlxuICAvLyBUaGlzIGlzIHRyaWNreSBiZWNhdXNlIGl0J3MgdmFsaWQgZm9yIGNlcnRhaW4gdHlwZXMgb2YgY29tcG9uZW50cyAoZS5nLiBSZWFjdC5sYXp5KVxuXG4gIC8vIFVzaW5nIG5leHRDdXJyZW50SG9vayB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbW91bnQvdXBkYXRlIG9ubHkgd29ya3MgaWYgYXQgbGVhc3Qgb25lIHN0YXRlZnVsIGhvb2sgaXMgdXNlZC5cbiAgLy8gTm9uLXN0YXRlZnVsIGhvb2tzIChlLmcuIGNvbnRleHQpIGRvbid0IGdldCBhZGRlZCB0byBtZW1vaXplZFN0YXRlLFxuICAvLyBzbyBuZXh0Q3VycmVudEhvb2sgd291bGQgYmUgbnVsbCBkdXJpbmcgdXBkYXRlcyBhbmQgbW91bnRzLlxuICB7XG4gICAgaWYgKG5leHRDdXJyZW50SG9vayAhPT0gbnVsbCkge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgIH0gZWxzZSBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgaGFuZGxlcyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjb21wb25lbnQgaXMgdXBkYXRpbmcsXG4gICAgICAvLyBidXQgbm8gc3RhdGVmdWwgaG9va3MgaGF2ZSBiZWVuIHVzZWQuXG4gICAgICAvLyBXZSB3YW50IHRvIG1hdGNoIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmVoYXZpb3IgKHdoaWNoIHdpbGwgdXNlIEhvb2tzRGlzcGF0Y2hlck9uTW91bnQpLFxuICAgICAgLy8gYnV0IHdpdGggdGhlIGV4dHJhIERFViB2YWxpZGF0aW9uIHRvIGVuc3VyZSBob29rcyBvcmRlcmluZyBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBkb2VzIHRoYXQuXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVY7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgcmVmT3JDb250ZXh0KTtcblxuICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgIGRvIHtcbiAgICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7XG5cbiAgICAgIC8vIFN0YXJ0IG92ZXIgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG4gICAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcbiAgICAgIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vaztcblxuICAgICAgY3VycmVudEhvb2sgPSBudWxsO1xuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgICAge1xuICAgICAgICAvLyBBbHNvIHZhbGlkYXRlIGhvb2sgb3JkZXIgZm9yIGNhc2NhZGluZyB1cGRhdGVzLlxuICAgICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgICAgfVxuXG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCByZWZPckNvbnRleHQpO1xuICAgIH0gd2hpbGUgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUpO1xuXG4gICAgcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgICBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIH1cblxuICAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jeS5cbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgdmFyIHJlbmRlcmVkV29yayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG5cbiAgcmVuZGVyZWRXb3JrLm1lbW9pemVkU3RhdGUgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vaztcbiAgcmVuZGVyZWRXb3JrLmV4cGlyYXRpb25UaW1lID0gcmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gIHJlbmRlcmVkV29yay51cGRhdGVRdWV1ZSA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuICByZW5kZXJlZFdvcmsuZWZmZWN0VGFnIHw9IHNpZGVFZmZlY3RUYWc7XG5cbiAge1xuICAgIHJlbmRlcmVkV29yay5fZGVidWdIb29rVHlwZXMgPSBob29rVHlwZXNEZXY7XG4gIH1cblxuICAvLyBUaGlzIGNoZWNrIHVzZXMgY3VycmVudEhvb2sgc28gdGhhdCBpdCB3b3JrcyB0aGUgc2FtZSBpbiBERVYgYW5kIHByb2QgYnVuZGxlcy5cbiAgLy8gaG9va1R5cGVzRGV2IGNvdWxkIGNhdGNoIG1vcmUgY2FzZXMgKGUuZy4gY29udGV4dCkgYnV0IG9ubHkgaW4gREVWIGJ1bmRsZXMuXG4gIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9IGN1cnJlbnRIb29rICE9PSBudWxsICYmIGN1cnJlbnRIb29rLm5leHQgIT09IG51bGw7XG5cbiAgcmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuXG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgbmV4dEN1cnJlbnRIb29rID0gbnVsbDtcbiAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgfVxuXG4gIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IG51bGw7XG4gIHNpZGVFZmZlY3RUYWcgPSAwO1xuXG4gIC8vIFRoZXNlIHdlcmUgcmVzZXQgYWJvdmVcbiAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAvLyByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICAvLyBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG5cbiAgISFkaWRSZW5kZXJUb29GZXdIb29rcyA/IGludmFyaWFudChmYWxzZSwgJ1JlbmRlcmVkIGZld2VyIGhvb2tzIHRoYW4gZXhwZWN0ZWQuIFRoaXMgbWF5IGJlIGNhdXNlZCBieSBhbiBhY2NpZGVudGFsIGVhcmx5IHJldHVybiBzdGF0ZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5mdW5jdGlvbiBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICY9IH4oUGFzc2l2ZSB8IFVwZGF0ZSk7XG4gIGlmIChjdXJyZW50LmV4cGlyYXRpb25UaW1lIDw9IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgY3VycmVudC5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEhvb2tzKCkge1xuICAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jeS5cbiAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgLy8gVGhpcyBpcyB1c2VkIHRvIHJlc2V0IHRoZSBzdGF0ZSBvZiB0aGlzIG1vZHVsZSB3aGVuIGEgY29tcG9uZW50IHRocm93cy5cbiAgLy8gSXQncyBhbHNvIGNhbGxlZCBpbnNpZGUgbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50IGlmIHdlIGRldGVybWluZSB0aGVcbiAgLy8gY29tcG9uZW50IGlzIGEgbW9kdWxlLXN0eWxlIGNvbXBvbmVudC5cbiAgcmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuXG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgbmV4dEN1cnJlbnRIb29rID0gbnVsbDtcbiAgZmlyc3RXb3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuXG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICB9XG5cbiAgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgc2lkZUVmZmVjdFRhZyA9IDA7XG5cbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG59XG5cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICB2YXIgaG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuXG4gICAgYmFzZVN0YXRlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIGJhc2VVcGRhdGU6IG51bGwsXG5cbiAgICBuZXh0OiBudWxsXG4gIH07XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3RcbiAgICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vayA9IGhvb2s7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGhvb2s7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn1cblxuZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYm90aCBmb3IgdXBkYXRlcyBhbmQgZm9yIHJlLXJlbmRlcnMgdHJpZ2dlcmVkIGJ5IGFcbiAgLy8gcmVuZGVyIHBoYXNlIHVwZGF0ZS4gSXQgYXNzdW1lcyB0aGVyZSBpcyBlaXRoZXIgYSBjdXJyZW50IGhvb2sgd2UgY2FuXG4gIC8vIGNsb25lLCBvciBhIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBmcm9tIGEgcHJldmlvdXMgcmVuZGVyIHBhc3MgdGhhdCB3ZSBjYW5cbiAgLy8gdXNlIGFzIGEgYmFzZS4gV2hlbiB3ZSByZWFjaCB0aGUgZW5kIG9mIHRoZSBiYXNlIGxpc3QsIHdlIG11c3Qgc3dpdGNoIHRvXG4gIC8vIHRoZSBkaXNwYXRjaGVyIHVzZWQgZm9yIG1vdW50cy5cbiAgaWYgKG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgIT09IG51bGwpIHtcbiAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcblxuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rICE9PSBudWxsID8gY3VycmVudEhvb2submV4dCA6IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2xvbmUgZnJvbSB0aGUgY3VycmVudCBob29rLlxuICAgICEobmV4dEN1cnJlbnRIb29rICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4nKSA6IHZvaWQgMDtcbiAgICBjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vaztcblxuICAgIHZhciBuZXdIb29rID0ge1xuICAgICAgbWVtb2l6ZWRTdGF0ZTogY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSxcblxuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50SG9vay5iYXNlU3RhdGUsXG4gICAgICBxdWV1ZTogY3VycmVudEhvb2sucXVldWUsXG4gICAgICBiYXNlVXBkYXRlOiBjdXJyZW50SG9vay5iYXNlVXBkYXRlLFxuXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGhvb2sgaW4gdGhlIGxpc3QuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG5ld0hvb2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBuZXdIb29rO1xuICAgIH1cbiAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50SG9vay5uZXh0O1xuICB9XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKSB7XG4gIHJldHVybiB7XG4gICAgbGFzdEVmZmVjdDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgaW5pdGlhbFN0YXRlID0gdm9pZCAwO1xuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdChpbml0aWFsQXJnKTtcbiAgfSBlbHNlIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsQXJnO1xuICB9XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlID0ge1xuICAgIGxhc3Q6IG51bGwsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogcmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gIH07XG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb24uYmluZChudWxsLFxuICAvLyBGbG93IGRvZXNuJ3Qga25vdyB0aGlzIGlzIG5vbi1udWxsLCBidXQgd2UgZG8uXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG4gICEocXVldWUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgYSBxdWV1ZS4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyO1xuXG4gIGlmIChudW1iZXJPZlJlUmVuZGVycyA+IDApIHtcbiAgICAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAgIHZhciBfZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzICE9PSBudWxsKSB7XG4gICAgICAvLyBSZW5kZXIgcGhhc2UgdXBkYXRlcyBhcmUgc3RvcmVkIGluIGEgbWFwIG9mIHF1ZXVlIC0+IGxpbmtlZCBsaXN0XG4gICAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuICAgICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZW5kZXJQaGFzZVVwZGF0ZXMuZGVsZXRlKHF1ZXVlKTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgdXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFByb2Nlc3MgdGhpcyByZW5kZXIgcGhhc2UgdXBkYXRlLiBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIHRoZVxuICAgICAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgICAgICAvLyByZW5kZXIncy5cbiAgICAgICAgICB2YXIgX2FjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBfYWN0aW9uKTtcbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsKTtcblxuICAgICAgICAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4gICAgICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAgICBpZiAoIWlzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAvLyBEb24ndCBwZXJzaXN0IHRoZSBzdGF0ZSBhY2N1bWxhdGVkIGZyb20gdGhlIHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvXG4gICAgICAgIC8vIHRoZSBiYXNlIHN0YXRlIHVubGVzcyB0aGUgcXVldWUgaXMgZW1wdHkuXG4gICAgICAgIC8vIFRPRE86IE5vdCBzdXJlIGlmIHRoaXMgaXMgdGhlIGRlc2lyZWQgc2VtYW50aWNzLCBidXQgaXQncyB3aGF0IHdlXG4gICAgICAgIC8vIGRvIGZvciBnRFNGUC4gSSBjYW4ndCByZW1lbWJlciB3aHkuXG4gICAgICAgIGlmIChob29rLmJhc2VVcGRhdGUgPT09IHF1ZXVlLmxhc3QpIHtcbiAgICAgICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBuZXdTdGF0ZTtcblxuICAgICAgICByZXR1cm4gW25ld1N0YXRlLCBfZGlzcGF0Y2hdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgX2Rpc3BhdGNoXTtcbiAgfVxuXG4gIC8vIFRoZSBsYXN0IHVwZGF0ZSBpbiB0aGUgZW50aXJlIHF1ZXVlXG4gIHZhciBsYXN0ID0gcXVldWUubGFzdDtcbiAgLy8gVGhlIGxhc3QgdXBkYXRlIHRoYXQgaXMgcGFydCBvZiB0aGUgYmFzZSBzdGF0ZS5cbiAgdmFyIGJhc2VVcGRhdGUgPSBob29rLmJhc2VVcGRhdGU7XG4gIHZhciBiYXNlU3RhdGUgPSBob29rLmJhc2VTdGF0ZTtcblxuICAvLyBGaW5kIHRoZSBmaXJzdCB1bnByb2Nlc3NlZCB1cGRhdGUuXG4gIHZhciBmaXJzdCA9IHZvaWQgMDtcbiAgaWYgKGJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgLy8gRm9yIHRoZSBmaXJzdCB1cGRhdGUsIHRoZSBxdWV1ZSBpcyBhIGNpcmN1bGFyIGxpbmtlZCBsaXN0IHdoZXJlXG4gICAgICAvLyBgcXVldWUubGFzdC5uZXh0ID0gcXVldWUuZmlyc3RgLiBPbmNlIHRoZSBmaXJzdCB1cGRhdGUgY29tbWl0cywgYW5kXG4gICAgICAvLyB0aGUgYGJhc2VVcGRhdGVgIGlzIG5vIGxvbmdlciBlbXB0eSwgd2UgY2FuIHVucmF2ZWwgdGhlIGxpc3QuXG4gICAgICBsYXN0Lm5leHQgPSBudWxsO1xuICAgIH1cbiAgICBmaXJzdCA9IGJhc2VVcGRhdGUubmV4dDtcbiAgfSBlbHNlIHtcbiAgICBmaXJzdCA9IGxhc3QgIT09IG51bGwgPyBsYXN0Lm5leHQgOiBudWxsO1xuICB9XG4gIGlmIChmaXJzdCAhPT0gbnVsbCkge1xuICAgIHZhciBfbmV3U3RhdGUgPSBiYXNlU3RhdGU7XG4gICAgdmFyIG5ld0Jhc2VTdGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0Jhc2VVcGRhdGUgPSBudWxsO1xuICAgIHZhciBwcmV2VXBkYXRlID0gYmFzZVVwZGF0ZTtcbiAgICB2YXIgX3VwZGF0ZSA9IGZpcnN0O1xuICAgIHZhciBkaWRTa2lwID0gZmFsc2U7XG4gICAgZG8ge1xuICAgICAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lID0gX3VwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICAgIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFByaW9yaXR5IGlzIGluc3VmZmljaWVudC4gU2tpcCB0aGlzIHVwZGF0ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3RcbiAgICAgICAgLy8gc2tpcHBlZCB1cGRhdGUsIHRoZSBwcmV2aW91cyB1cGRhdGUvc3RhdGUgaXMgdGhlIG5ldyBiYXNlXG4gICAgICAgIC8vIHVwZGF0ZS9zdGF0ZS5cbiAgICAgICAgaWYgKCFkaWRTa2lwKSB7XG4gICAgICAgICAgZGlkU2tpcCA9IHRydWU7XG4gICAgICAgICAgbmV3QmFzZVVwZGF0ZSA9IHByZXZVcGRhdGU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gX25ld1N0YXRlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cbiAgICAgICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lID4gcmVtYWluaW5nRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZUV4cGlyYXRpb25UaW1lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuICAgICAgICBpZiAoX3VwZGF0ZS5lYWdlclJlZHVjZXIgPT09IHJlZHVjZXIpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHVwZGF0ZSB3YXMgcHJvY2Vzc2VkIGVhZ2VybHksIGFuZCBpdHMgcmVkdWNlciBtYXRjaGVzIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVkdWNlciwgd2UgY2FuIHVzZSB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZS5cbiAgICAgICAgICBfbmV3U3RhdGUgPSBfdXBkYXRlLmVhZ2VyU3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9hY3Rpb24yID0gX3VwZGF0ZS5hY3Rpb247XG4gICAgICAgICAgX25ld1N0YXRlID0gcmVkdWNlcihfbmV3U3RhdGUsIF9hY3Rpb24yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJldlVwZGF0ZSA9IF91cGRhdGU7XG4gICAgICBfdXBkYXRlID0gX3VwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKF91cGRhdGUgIT09IG51bGwgJiYgX3VwZGF0ZSAhPT0gZmlyc3QpO1xuXG4gICAgaWYgKCFkaWRTa2lwKSB7XG4gICAgICBuZXdCYXNlVXBkYXRlID0gcHJldlVwZGF0ZTtcbiAgICAgIG5ld0Jhc2VTdGF0ZSA9IF9uZXdTdGF0ZTtcbiAgICB9XG5cbiAgICAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4gICAgLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgaWYgKCFpcyhfbmV3U3RhdGUsIGhvb2subWVtb2l6ZWRTdGF0ZSkpIHtcbiAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gX25ld1N0YXRlO1xuICAgIGhvb2suYmFzZVVwZGF0ZSA9IG5ld0Jhc2VVcGRhdGU7XG4gICAgaG9vay5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG5cbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IF9uZXdTdGF0ZTtcbiAgfVxuXG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlKCk7XG4gIH1cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWUgPSB7XG4gICAgbGFzdDogbnVsbCxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gIH07XG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb24uYmluZChudWxsLFxuICAvLyBGbG93IGRvZXNuJ3Qga25vdyB0aGlzIGlzIG5vbi1udWxsLCBidXQgd2UgZG8uXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiB1cGRhdGVSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyLCBpbml0aWFsU3RhdGUpO1xufVxuXG5mdW5jdGlvbiBwdXNoRWZmZWN0KHRhZywgY3JlYXRlLCBkZXN0cm95LCBkZXBzKSB7XG4gIHZhciBlZmZlY3QgPSB7XG4gICAgdGFnOiB0YWcsXG4gICAgY3JlYXRlOiBjcmVhdGUsXG4gICAgZGVzdHJveTogZGVzdHJveSxcbiAgICBkZXBzOiBkZXBzLFxuICAgIC8vIENpcmN1bGFyXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICBpZiAoY29tcG9uZW50VXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9sYXN0RWZmZWN0ID0gY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdDtcbiAgICBpZiAoX2xhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gX2xhc3RFZmZlY3QubmV4dDtcbiAgICAgIF9sYXN0RWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgICBlZmZlY3QubmV4dCA9IGZpcnN0RWZmZWN0O1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVmZmVjdDtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHJlZiA9IHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH07XG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWYpO1xuICB9XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHJlZjtcbiAgcmV0dXJuIHJlZjtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gaG9vay5tZW1vaXplZFN0YXRlO1xufVxuXG5mdW5jdGlvbiBtb3VudEVmZmVjdEltcGwoZmliZXJFZmZlY3RUYWcsIGhvb2tFZmZlY3RUYWcsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICBzaWRlRWZmZWN0VGFnIHw9IGZpYmVyRWZmZWN0VGFnO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KGhvb2tFZmZlY3RUYWcsIGNyZWF0ZSwgdW5kZWZpbmVkLCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdEltcGwoZmliZXJFZmZlY3RUYWcsIGhvb2tFZmZlY3RUYWcsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIGRlc3Ryb3kgPSB1bmRlZmluZWQ7XG5cbiAgaWYgKGN1cnJlbnRIb29rICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZFZmZlY3QgPSBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO1xuICAgIGRlc3Ryb3kgPSBwcmV2RWZmZWN0LmRlc3Ryb3k7XG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2RWZmZWN0LmRlcHM7XG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcHVzaEVmZmVjdChOb0VmZmVjdCQxLCBjcmVhdGUsIGRlc3Ryb3ksIG5leHREZXBzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNpZGVFZmZlY3RUYWcgfD0gZmliZXJFZmZlY3RUYWc7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoaG9va0VmZmVjdFRhZywgY3JlYXRlLCBkZXN0cm95LCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSB8IFBhc3NpdmUsIFVubW91bnRQYXNzaXZlIHwgTW91bnRQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSB8IFBhc3NpdmUsIFVubW91bnRQYXNzaXZlIHwgTW91bnRQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIG1vdW50RWZmZWN0SW1wbChVcGRhdGUsIFVubW91bnRNdXRhdGlvbiB8IE1vdW50TGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgVW5tb3VudE11dGF0aW9uIHwgTW91bnRMYXlvdXQsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QoY3JlYXRlLCByZWYpIHtcbiAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgcmVmQ2FsbGJhY2sgPSByZWY7XG4gICAgdmFyIF9pbnN0ID0gY3JlYXRlKCk7XG4gICAgcmVmQ2FsbGJhY2soX2luc3QpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZWZDYWxsYmFjayhudWxsKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHJlZiAhPT0gbnVsbCAmJiByZWYgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZWZPYmplY3QgPSByZWY7XG4gICAge1xuICAgICAgIXJlZk9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpID8gd2FybmluZyQxKGZhbHNlLCAnRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIGZpcnN0IGFyZ3VtZW50IHRvIGVpdGhlciBiZSBhICcgKyAncmVmIGNhbGxiYWNrIG9yIFJlYWN0LmNyZWF0ZVJlZigpIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgJ2FuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhyZWZPYmplY3QpLmpvaW4oJywgJykgKyAnfScpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgX2luc3QyID0gY3JlYXRlKCk7XG4gICAgcmVmT2JqZWN0LmN1cnJlbnQgPSBfaW5zdDI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlZk9iamVjdC5jdXJyZW50ID0gbnVsbDtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgISh0eXBlb2YgY3JlYXRlID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmckMShmYWxzZSwgJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJykgOiB2b2lkIDA7XG4gIH1cblxuICAvLyBUT0RPOiBJZiBkZXBzIGFyZSBwcm92aWRlZCwgc2hvdWxkIHdlIHNraXAgY29tcGFyaW5nIHRoZSByZWYgaXRzZWxmP1xuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcblxuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSwgVW5tb3VudE11dGF0aW9uIHwgTW91bnRMYXlvdXQsIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksIGVmZmVjdERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICAhKHR5cGVvZiBjcmVhdGUgPT09ICdmdW5jdGlvbicpID8gd2FybmluZyQxKGZhbHNlLCAnRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKSA6IHZvaWQgMDtcbiAgfVxuXG4gIC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG4gIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuXG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgVW5tb3VudE11dGF0aW9uIHwgTW91bnRMYXlvdXQsIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksIGVmZmVjdERlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudERlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gIC8vIFRoaXMgaG9vayBpcyBub3JtYWxseSBhIG5vLW9wLlxuICAvLyBUaGUgcmVhY3QtZGVidWctaG9va3MgcGFja2FnZSBpbmplY3RzIGl0cyBvd24gaW1wbGVtZW50YXRpb25cbiAgLy8gc28gdGhhdCBlLmcuIERldlRvb2xzIGNhbiBkaXNwbGF5IGN1c3RvbSBob29rIHZhbHVlcy5cbn1cblxudmFyIHVwZGF0ZURlYnVnVmFsdWUgPSBtb3VudERlYnVnVmFsdWU7XG5cbmZ1bmN0aW9uIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBuZXh0RGVwc107XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcbiAgICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIG5leHREZXBzXTtcbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBtb3VudE1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIEFzc3VtZSB0aGVzZSBhcmUgZGVmaW5lZC4gSWYgdGhleSdyZSBub3QsIGFyZUhvb2tJbnB1dHNFcXVhbCB3aWxsIHdhcm4uXG4gICAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG4vLyBpbiBhIHRlc3QtbGlrZSBlbnZpcm9ubWVudCwgd2Ugd2FudCB0byB3YXJuIGlmIGRpc3BhdGNoQWN0aW9uKClcbi8vIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgYmF0Y2hlZFVwZGF0ZXMvVGVzdFV0aWxzLmFjdCguLi4pIGNhbGwuXG52YXIgc2hvdWxkV2FybkZvclVuYmF0Y2hlZFNldFN0YXRlID0gZmFsc2U7XG5cbntcbiAgLy8gamVzdCBpc24ndCBhICdnbG9iYWwnLCBpdCdzIGp1c3QgZXhwb3NlZCB0byB0ZXN0cyB2aWEgYSB3cmFwcGVkIGZ1bmN0aW9uXG4gIC8vIGZ1cnRoZXIsIHRoaXMgaXNuJ3QgYSB0ZXN0IGZpbGUsIHNvIGZsb3cgZG9lc24ndCByZWNvZ25pemUgdGhlIHN5bWJvbC4gU28uLi5cbiAgLy8gJEZsb3dFeHBlY3RlZEVycm9yIC0gYmVjYXVzZSByZXF1aXJlbWVudHMgZG9uJ3QgZ2l2ZSBhIGRhbW4gYWJvdXQgeW91ciB0eXBlIHNpZ3MuXG4gIGlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGplc3QpIHtcbiAgICBzaG91bGRXYXJuRm9yVW5iYXRjaGVkU2V0U3RhdGUgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoQWN0aW9uKGZpYmVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gICEobnVtYmVyT2ZSZVJlbmRlcnMgPCBSRV9SRU5ERVJfTElNSVQpID8gaW52YXJpYW50KGZhbHNlLCAnVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AuJykgOiB2b2lkIDA7XG5cbiAge1xuICAgICEoYXJndW1lbnRzLmxlbmd0aCA8PSAzKSA/IHdhcm5pbmckMShmYWxzZSwgXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBcIiArICdzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciAnICsgJ3JlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKSA6IHZvaWQgMDtcbiAgfVxuXG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmIChmaWJlciA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSB8fCBhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gICAgLy8gcXVldWUgLT4gbGlua2VkIGxpc3Qgb2YgdXBkYXRlcy4gQWZ0ZXIgdGhpcyByZW5kZXIgcGFzcywgd2UnbGwgcmVzdGFydFxuICAgIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICBleHBpcmF0aW9uVGltZTogcmVuZGVyRXhwaXJhdGlvblRpbWUsXG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGVhZ2VyUmVkdWNlcjogbnVsbCxcbiAgICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAocmVuZGVyUGhhc2VVcGRhdGVzID09PSBudWxsKSB7XG4gICAgICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG4gICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgdXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuICAgICAgd2hpbGUgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgICAgfVxuICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblxuICAgIHZhciBjdXJyZW50VGltZSA9IHJlcXVlc3RDdXJyZW50VGltZSgpO1xuICAgIHZhciBfZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcik7XG5cbiAgICB2YXIgX3VwZGF0ZTIgPSB7XG4gICAgICBleHBpcmF0aW9uVGltZTogX2V4cGlyYXRpb25UaW1lLFxuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBlYWdlclJlZHVjZXI6IG51bGwsXG4gICAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgIHZhciBfbGFzdCA9IHF1ZXVlLmxhc3Q7XG4gICAgaWYgKF9sYXN0ID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICBfdXBkYXRlMi5uZXh0ID0gX3VwZGF0ZTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdCA9IF9sYXN0Lm5leHQ7XG4gICAgICBpZiAoZmlyc3QgIT09IG51bGwpIHtcbiAgICAgICAgLy8gU3RpbGwgY2lyY3VsYXIuXG4gICAgICAgIF91cGRhdGUyLm5leHQgPSBmaXJzdDtcbiAgICAgIH1cbiAgICAgIF9sYXN0Lm5leHQgPSBfdXBkYXRlMjtcbiAgICB9XG4gICAgcXVldWUubGFzdCA9IF91cGRhdGUyO1xuXG4gICAgaWYgKGZpYmVyLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgJiYgKGFsdGVybmF0ZSA9PT0gbnVsbCB8fCBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yaykpIHtcbiAgICAgIC8vIFRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgZW1wdHksIHdoaWNoIG1lYW5zIHdlIGNhbiBlYWdlcmx5IGNvbXB1dGUgdGhlXG4gICAgICAvLyBuZXh0IHN0YXRlIGJlZm9yZSBlbnRlcmluZyB0aGUgcmVuZGVyIHBoYXNlLiBJZiB0aGUgbmV3IHN0YXRlIGlzIHRoZVxuICAgICAgLy8gc2FtZSBhcyB0aGUgY3VycmVudCBzdGF0ZSwgd2UgbWF5IGJlIGFibGUgdG8gYmFpbCBvdXQgZW50aXJlbHkuXG4gICAgICB2YXIgX2xhc3RSZW5kZXJlZFJlZHVjZXIgPSBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyO1xuICAgICAgaWYgKF9sYXN0UmVuZGVyZWRSZWR1Y2VyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IHZvaWQgMDtcbiAgICAgICAge1xuICAgICAgICAgIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgX2VhZ2VyU3RhdGUgPSBfbGFzdFJlbmRlcmVkUmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7XG4gICAgICAgICAgLy8gU3Rhc2ggdGhlIGVhZ2VybHkgY29tcHV0ZWQgc3RhdGUsIGFuZCB0aGUgcmVkdWNlciB1c2VkIHRvIGNvbXB1dGVcbiAgICAgICAgICAvLyBpdCwgb24gdGhlIHVwZGF0ZSBvYmplY3QuIElmIHRoZSByZWR1Y2VyIGhhc24ndCBjaGFuZ2VkIGJ5IHRoZVxuICAgICAgICAgIC8vIHRpbWUgd2UgZW50ZXIgdGhlIHJlbmRlciBwaGFzZSwgdGhlbiB0aGUgZWFnZXIgc3RhdGUgY2FuIGJlIHVzZWRcbiAgICAgICAgICAvLyB3aXRob3V0IGNhbGxpbmcgdGhlIHJlZHVjZXIgYWdhaW4uXG4gICAgICAgICAgX3VwZGF0ZTIuZWFnZXJSZWR1Y2VyID0gX2xhc3RSZW5kZXJlZFJlZHVjZXI7XG4gICAgICAgICAgX3VwZGF0ZTIuZWFnZXJTdGF0ZSA9IF9lYWdlclN0YXRlO1xuICAgICAgICAgIGlmIChpcyhfZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSkge1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoLiBXZSBjYW4gYmFpbCBvdXQgd2l0aG91dCBzY2hlZHVsaW5nIFJlYWN0IHRvIHJlLXJlbmRlci5cbiAgICAgICAgICAgIC8vIEl0J3Mgc3RpbGwgcG9zc2libGUgdGhhdCB3ZSdsbCBuZWVkIHRvIHJlYmFzZSB0aGlzIHVwZGF0ZSBsYXRlcixcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wb25lbnQgcmUtcmVuZGVycyBmb3IgYSBkaWZmZXJlbnQgcmVhc29uIGFuZCBieSB0aGF0XG4gICAgICAgICAgICAvLyB0aW1lIHRoZSByZWR1Y2VyIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBTdXBwcmVzcyB0aGUgZXJyb3IuIEl0IHdpbGwgdGhyb3cgYWdhaW4gaW4gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBpZiAoc2hvdWxkV2FybkZvclVuYmF0Y2hlZFNldFN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgIHdhcm5JZk5vdEN1cnJlbnRseUJhdGNoaW5nSW5EZXYoZmliZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBzY2hlZHVsZVdvcmsoZmliZXIsIF9leHBpcmF0aW9uVGltZSk7XG4gIH1cbn1cblxudmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuXG4gIHVzZUNhbGxiYWNrOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUNvbnRleHQ6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTGF5b3V0RWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZU1lbW86IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVkdWNlcjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VSZWY6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlU3RhdGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRGVidWdWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yXG59O1xuXG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0gbnVsbDtcbnZhciBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG5cbntcbiAgdmFyIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgfTtcblxuICB2YXIgd2FybkludmFsaWRIb29rQWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcnVsZXMtb2YtaG9va3MnKTtcbiAgfTtcblxuICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICAgIH1cbiAgfTtcblxuICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gICAgfVxuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgICB9XG4gIH07XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudDtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pO1xuICAgIH1cbiAgfTtcblxuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQsIG9ic2VydmVkQml0cykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQsIG9ic2VydmVkQml0cyk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQ7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBjb21taXRUaW1lID0gMDtcbnZhciBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xuXG5mdW5jdGlvbiBnZXRDb21taXRUaW1lKCkge1xuICByZXR1cm4gY29tbWl0VGltZTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpIHtcbiAgaWYgKCFlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbW1pdFRpbWUgPSBzY2hlZHVsZXIudW5zdGFibGVfbm93KCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UHJvZmlsZXJUaW1lcihmaWJlcikge1xuICBpZiAoIWVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9maWxlclN0YXJ0VGltZSA9IHNjaGVkdWxlci51bnN0YWJsZV9ub3coKTtcblxuICBpZiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lIDwgMCkge1xuICAgIGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IHNjaGVkdWxlci51bnN0YWJsZV9ub3coKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyhmaWJlcikge1xuICBpZiAoIWVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbn1cblxuZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShmaWJlciwgb3ZlcnJpZGVCYXNlVGltZSkge1xuICBpZiAoIWVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocHJvZmlsZXJTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IHNjaGVkdWxlci51bnN0YWJsZV9ub3coKSAtIHByb2ZpbGVyU3RhcnRUaW1lO1xuICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgIGlmIChvdmVycmlkZUJhc2VUaW1lKSB7XG4gICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgfVxuICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gIH1cbn1cblxuLy8gVGhlIGRlZXBlc3QgRmliZXIgb24gdGhlIHN0YWNrIGludm9sdmVkIGluIGEgaHlkcmF0aW9uIGNvbnRleHQuXG4vLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxudmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbnZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhzdXNwZW5zZUluc3RhbmNlKTtcbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShyZXR1cm5GaWJlciwgaW5zdGFuY2UpIHtcbiAge1xuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UocmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sIGluc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkVG9EZWxldGUgPSBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpO1xuICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICBjaGlsZFRvRGVsZXRlLnJldHVybiA9IHJldHVybkZpYmVyO1xuICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uO1xuXG4gIC8vIFRoaXMgbWlnaHQgc2VlbSBsaWtlIGl0IGJlbG9uZ3Mgb24gcHJvZ3Jlc3NlZEZpcnN0RGVsZXRpb24uIEhvd2V2ZXIsXG4gIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgLy8gRXZlbiBpZiB3ZSBhYm9ydCBhbmQgcmVyZWNvbmNpbGUgdGhlIGNoaWxkcmVuLCB0aGF0IHdpbGwgdHJ5IHRvIGh5ZHJhdGVcbiAgLy8gYWdhaW4gYW5kIHRoZSBub2RlcyBhcmUgc3RpbGwgaW4gdGhlIGhvc3QgdHJlZSBzbyB0aGVzZSB3aWxsIGJlXG4gIC8vIHJlY3JlYXRlZC5cbiAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAge1xuICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3R5cGUsIF9wcm9wcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcikge1xuICAgICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UobmV4dEluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRG93bmdyYWRlIHRoZSB0YWcgdG8gYSBkZWh5ZHJhdGVkIGNvbXBvbmVudCB1bnRpbCB3ZSd2ZSBoeWRyYXRlZCBpdC5cbiAgICAgICAgICAgIGZpYmVyLnRhZyA9IERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDtcbiAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IHN1c3BlbnNlSW5zdGFuY2U7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgaWYgKCFuZXh0SW5zdGFuY2UpIHtcbiAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBmaXJzdEF0dGVtcHRlZEluc3RhbmNlID0gbmV4dEluc3RhbmNlO1xuICBpZiAoIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAvLyBJZiB3ZSBjYW4ndCBoeWRyYXRlIHRoaXMgaW5zdGFuY2UgbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgLy8gbWlnaHQgYmUgZmxhd2VkIG9yIHVubmVjZXNzYXJ5LlxuICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaXJzdEF0dGVtcHRlZEluc3RhbmNlKTtcbiAgICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBXZSBtYXRjaGVkIHRoZSBuZXh0IG9uZSwgd2UnbGwgbm93IGFzc3VtZSB0aGF0IHRoZSBmaXJzdCBvbmUgd2FzXG4gICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAvLyB3ZSdsbCBoYXZlIHRvIHNjaGVkdWxlIGEgZGVsZXRpb24uIFRvIGRvIHRoYXQsIHRoaXMgbm9kZSBuZWVkcyBhIGR1bW15XG4gICAgLy8gZmliZXIgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmlyc3RBdHRlbXB0ZWRJbnN0YW5jZSk7XG4gIH1cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7XG4gIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICBmaWJlci51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7XG4gIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciB0ZXh0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciB0ZXh0Q29udGVudCA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcbiAge1xuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG4gICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cbiAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICFzdXNwZW5zZUluc3RhbmNlID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICB2YXIgcGFyZW50ID0gZmliZXIucmV0dXJuO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QgJiYgcGFyZW50LnRhZyAhPT0gRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHBhcmVudDtcbn1cblxuZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgIC8vIHRyZWUuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgLy8gc2libGluZ3MuXG4gICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICAvLyBJZiB3ZSBoYXZlIGFueSByZW1haW5pbmcgaHlkcmF0YWJsZSBub2Rlcywgd2UgbmVlZCB0byBkZWxldGUgdGhlbSBub3cuXG4gIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgLy8gc2lkZSBvZiB0aGVtLlxuICAvLyBUT0RPOiBCZXR0ZXIgaGV1cmlzdGljLlxuICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMyA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xuXG52YXIgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuXG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQgPSB2b2lkIDA7XG52YXIgZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSB2b2lkIDA7XG5cbntcbiAgZGlkV2FybkFib3V0QmFkQ2xhc3MgPSB7fTtcbiAgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0RnVuY3Rpb25SZWZzID0ge307XG4gIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAvLyB3b24ndCB1cGRhdGUgaXRzIGNoaWxkIHNldCBieSBhcHBseWluZyBtaW5pbWFsIHNpZGUtZWZmZWN0cy4gSW5zdGVhZCxcbiAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgIC8vIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYW55IHdvcmsgb24gdGhlc2UgY2hpbGRyZW4uIFRoZXJlZm9yZSwgd2UgdXNlXG4gICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cblxuICAgIC8vIElmIHdlIGhhZCBhbnkgcHJvZ3Jlc3NlZCB3b3JrIGFscmVhZHksIHRoYXQgaXMgaW52YWxpZCBhdCB0aGlzIHBvaW50IHNvXG4gICAgLy8gbGV0J3MgdGhyb3cgaXQgb3V0LlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQkJDEuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBmb3JrIG9mIHJlY29uY2lsZUNoaWxkcmVuLiBJdCdzIHVzZWQgaW4gY2FzZXMgd2hlcmUgd2VcbiAgLy8gd2FudCB0byByZWNvbmNpbGUgd2l0aG91dCBtYXRjaGluZyBhZ2FpbnN0IHRoZSBleGlzdGluZyBzZXQuIFRoaXMgaGFzIHRoZVxuICAvLyBlZmZlY3Qgb2YgYWxsIGN1cnJlbnQgY2hpbGRyZW4gYmVpbmcgdW5tb3VudGVkOyBldmVuIGlmIHRoZSB0eXBlIGFuZCBrZXlcbiAgLy8gYXJlIHRoZSBzYW1lLCB0aGUgb2xkIGNoaWxkIGlzIHVubW91bnRlZCBhbmQgYSBuZXcgY2hpbGQgaXMgY3JlYXRlZC5cbiAgLy9cbiAgLy8gVG8gZG8gdGhpcywgd2UncmUgZ29pbmcgdG8gZ28gdGhyb3VnaCB0aGUgcmVjb25jaWxlIGFsZ29yaXRobSB0d2ljZS4gSW5cbiAgLy8gdGhlIGZpcnN0IHBhc3MsIHdlIHNjaGVkdWxlIGEgZGVsZXRpb24gZm9yIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbiBieVxuICAvLyBwYXNzaW5nIG51bGwuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQkJDEuY2hpbGQsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgLy8gSW4gdGhlIHNlY29uZCBwYXNzLCB3ZSBtb3VudCB0aGUgbmV3IGNoaWxkcmVuLiBUaGUgdHJpY2sgaGVyZSBpcyB0aGF0IHdlXG4gIC8vIHBhc3MgbnVsbCBpbiBwbGFjZSBvZiB3aGVyZSB3ZSB1c3VhbGx5IHBhc3MgdGhlIGN1cnJlbnQgY2hpbGQgc2V0LiBUaGlzIGhhc1xuICAvLyB0aGUgZWZmZWN0IG9mIHJlbW91bnRpbmcgYWxsIGNoaWxkcmVuIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGVpciB0aGVpclxuICAvLyBpZGVudGl0eSBtYXRjaGVzLlxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4gIC8vIGhhc24ndCB5ZXQgbW91bnRlZC4gVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBmaXJzdCByZW5kZXIgc3VzcGVuZHMuXG4gIC8vIFdlJ2xsIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGlzIGlzIGZpbmUgb3IgY2FuIGNhdXNlIGlzc3Vlcy5cblxuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAvLyBMYXp5IGNvbXBvbmVudCBwcm9wcyBjYW4ndCBiZSB2YWxpZGF0ZWQgaW4gY3JlYXRlRWxlbWVudFxuICAgICAgLy8gYmVjYXVzZSB0aGV5J3JlIG9ubHkgZ3VhcmFudGVlZCB0byBiZSByZXNvbHZlZCBoZXJlLlxuICAgICAgdmFyIGlubmVyUHJvcFR5cGVzID0gQ29tcG9uZW50LnByb3BUeXBlcztcbiAgICAgIGlmIChpbm5lclByb3BUeXBlcykge1xuICAgICAgICBjaGVja1Byb3BUeXBlcyhpbm5lclByb3BUeXBlcywgbmV4dFByb3BzLCAvLyBSZXNvbHZlZCBwcm9wc1xuICAgICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlbmRlciA9IENvbXBvbmVudC5yZW5kZXI7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG5cbiAgLy8gVGhlIHJlc3QgaXMgYSBmb3JrIG9mIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIHtcbiAgICBSZWFjdEN1cnJlbnRPd25lciQzLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICBzZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgIG5leHRDaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rcyhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyLCBuZXh0UHJvcHMsIHJlZiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgfHwgZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzRm9yU3RyaWN0TW9kZSAmJiB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TW9kZSkge1xuICAgICAgLy8gT25seSBkb3VibGUtcmVuZGVyIGNvbXBvbmVudHMgd2l0aCBIb29rc1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXIsIG5leHRQcm9wcywgcmVmLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50JCQxICE9PSBudWxsICYmICFkaWRSZWNlaXZlVXBkYXRlKSB7XG4gICAgYmFpbG91dEhvb2tzKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgdXBkYXRlRXhwaXJhdGlvblRpbWUsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChjdXJyZW50JCQxID09PSBudWxsKSB7XG4gICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcbiAgICBpZiAoaXNTaW1wbGVGdW5jdGlvbkNvbXBvbmVudCh0eXBlKSAmJiBDb21wb25lbnQuY29tcGFyZSA9PT0gbnVsbCAmJlxuICAgIC8vIFNpbXBsZU1lbW9Db21wb25lbnQgY29kZXBhdGggZG9lc24ndCByZXNvbHZlIG91dGVyIHByb3BzIGVpdGhlci5cbiAgICBDb21wb25lbnQuZGVmYXVsdFByb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBwbGFpbiBmdW5jdGlvbiBjb21wb25lbnQgd2l0aG91dCBkZWZhdWx0IHByb3BzLFxuICAgICAgLy8gYW5kIHdpdGggb25seSB0aGUgZGVmYXVsdCBzaGFsbG93IGNvbXBhcmlzb24sIHdlIHVwZ3JhZGUgaXRcbiAgICAgIC8vIHRvIGEgU2ltcGxlTWVtb0NvbXBvbmVudCB0byBhbGxvdyBmYXN0IHBhdGggdXBkYXRlcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFNpbXBsZU1lbW9Db21wb25lbnQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gdHlwZTtcbiAgICAgIHtcbiAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB0eXBlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXh0UHJvcHMsIHVwZGF0ZUV4cGlyYXRpb25UaW1lLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICAgIHtcbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIC8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG4gICAgICAgIC8vIFdlIGNvdWxkIG1vdmUgaXQgdGhlcmUsIGJ1dCB3ZSdkIHN0aWxsIG5lZWQgdGhpcyBmb3IgbGF6eSBjb2RlIHBhdGguXG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBjaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhDb21wb25lbnQudHlwZSwgbnVsbCwgbmV4dFByb3BzLCBudWxsLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGNoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG4gIHtcbiAgICB2YXIgX3R5cGUgPSBDb21wb25lbnQudHlwZTtcbiAgICB2YXIgX2lubmVyUHJvcFR5cGVzID0gX3R5cGUucHJvcFR5cGVzO1xuICAgIGlmIChfaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgIC8vIElubmVyIG1lbW8gY29tcG9uZW50IHByb3BzIGFyZW4ndCBjdXJyZW50bHkgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnQuXG4gICAgICAvLyBXZSBjb3VsZCBtb3ZlIGl0IHRoZXJlLCBidXQgd2UnZCBzdGlsbCBuZWVkIHRoaXMgZm9yIGxhenkgY29kZSBwYXRoLlxuICAgICAgY2hlY2tQcm9wVHlwZXMoX2lubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAncHJvcCcsIGdldENvbXBvbmVudE5hbWUoX3R5cGUpLCBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KTtcbiAgICB9XG4gIH1cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQkJDEuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG4gIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyB3aWxsIGJlIHRoZSBwcm9wcyB3aXRoIHJlc29sdmVkIGRlZmF1bHRQcm9wcyxcbiAgICAvLyB1bmxpa2UgY3VycmVudC5tZW1vaXplZFByb3BzIHdoaWNoIHdpbGwgYmUgdGhlIHVucmVzb2x2ZWQgb25lcy5cbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudENoaWxkLm1lbW9pemVkUHJvcHM7XG4gICAgLy8gRGVmYXVsdCB0byBzaGFsbG93IGNvbXBhcmlzb25cbiAgICB2YXIgY29tcGFyZSA9IENvbXBvbmVudC5jb21wYXJlO1xuICAgIGNvbXBhcmUgPSBjb21wYXJlICE9PSBudWxsID8gY29tcGFyZSA6IHNoYWxsb3dFcXVhbDtcbiAgICBpZiAoY29tcGFyZShwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudCQkMS5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cbiAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBuZXh0UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgbmV3Q2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcbiAgcmV0dXJuIG5ld0NoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgdXBkYXRlRXhwaXJhdGlvblRpbWUsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4gIC8vIGhhc24ndCB5ZXQgbW91bnRlZC4gVGhpcyBoYXBwZW5zIHdoZW4gdGhlIGlubmVyIHJlbmRlciBzdXNwZW5kcy5cbiAgLy8gV2UnbGwgbmVlZCB0byBmaWd1cmUgb3V0IGlmIHRoaXMgaXMgZmluZSBvciBjYW4gY2F1c2UgaXNzdWVzLlxuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgb3V0ZXJNZW1vVHlwZSA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlO1xuICAgICAgaWYgKG91dGVyTWVtb1R5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAvLyBXZSB3YXJuIHdoZW4geW91IGRlZmluZSBwcm9wVHlwZXMgb24gbGF6eSgpXG4gICAgICAgIC8vIHNvIGxldCdzIGp1c3Qgc2tpcCBvdmVyIGl0IHRvIGZpbmQgbWVtbygpIG91dGVyIHdyYXBwZXIuXG4gICAgICAgIC8vIElubmVyIHByb3BzIGZvciBtZW1vIGFyZSB2YWxpZGF0ZWQgbGF0ZXIuXG4gICAgICAgIG91dGVyTWVtb1R5cGUgPSByZWZpbmVSZXNvbHZlZExhenlDb21wb25lbnQob3V0ZXJNZW1vVHlwZSk7XG4gICAgICB9XG4gICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBvdXRlck1lbW9UeXBlICYmIG91dGVyTWVtb1R5cGUucHJvcFR5cGVzO1xuICAgICAgaWYgKG91dGVyUHJvcFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIChTaW1wbGVNZW1vQ29tcG9uZW50IGhhcyBubyBkZWZhdWx0UHJvcHMpXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZShvdXRlck1lbW9UeXBlKSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldik7XG4gICAgICB9XG4gICAgICAvLyBJbm5lciBwcm9wVHlwZXMgd2lsbCBiZSB2YWxpZGF0ZWQgaW4gdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCBwYXRoLlxuICAgIH1cbiAgfVxuICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50JCQxLm1lbW9pemVkUHJvcHM7XG4gICAgaWYgKHNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudCQkMS5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lIDwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vZGUoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQcm9maWxlcihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICB9XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIGlmIChjdXJyZW50JCQxID09PSBudWxsICYmIHJlZiAhPT0gbnVsbCB8fCBjdXJyZW50JCQxICE9PSBudWxsICYmIGN1cnJlbnQkJDEucmVmICE9PSByZWYpIHtcbiAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSkge1xuICAgICAgLy8gTGF6eSBjb21wb25lbnQgcHJvcHMgY2FuJ3QgYmUgdmFsaWRhdGVkIGluIGNyZWF0ZUVsZW1lbnRcbiAgICAgIC8vIGJlY2F1c2UgdGhleSdyZSBvbmx5IGd1YXJhbnRlZWQgdG8gYmUgcmVzb2x2ZWQgaGVyZS5cbiAgICAgIHZhciBpbm5lclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG4gICAgICBpZiAoaW5uZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgY2hlY2tQcm9wVHlwZXMoaW5uZXJQcm9wVHlwZXMsIG5leHRQcm9wcywgLy8gUmVzb2x2ZWQgcHJvcHNcbiAgICAgICAgJ3Byb3AnLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCksIGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSk7XG4gIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAvLyBPbmx5IGRvdWJsZS1yZW5kZXIgY29tcG9uZW50cyB3aXRoIEhvb2tzXG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50JCQxICE9PSBudWxsICYmICFkaWRSZWNlaXZlVXBkYXRlKSB7XG4gICAgYmFpbG91dEhvb2tzKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgIC8vIExhenkgY29tcG9uZW50IHByb3BzIGNhbid0IGJlIHZhbGlkYXRlZCBpbiBjcmVhdGVFbGVtZW50XG4gICAgICAvLyBiZWNhdXNlIHRoZXkncmUgb25seSBndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkIGhlcmUuXG4gICAgICB2YXIgaW5uZXJQcm9wVHlwZXMgPSBDb21wb25lbnQucHJvcFR5cGVzO1xuICAgICAgaWYgKGlubmVyUHJvcFR5cGVzKSB7XG4gICAgICAgIGNoZWNrUHJvcFR5cGVzKGlubmVyUHJvcFR5cGVzLCBuZXh0UHJvcHMsIC8vIFJlc29sdmVkIHByb3BzXG4gICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpLCBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgdmFyIGhhc0NvbnRleHQgPSB2b2lkIDA7XG4gIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCkge1xuICAgICAgLy8gQW4gY2xhc3MgY29tcG9uZW50IHdpdGhvdXQgYW4gaW5zdGFuY2Ugb25seSBtb3VudHMgaWYgaXQgc3VzcGVuZGVkXG4gICAgICAvLyBpbnNpZGUgYSBub24tIGNvbmN1cnJlbnQgdHJlZSwgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSB3YW50IHRvXG4gICAgICAvLyB0cmVlIGl0IGxpa2UgYSBuZXcgbW91bnQsIGV2ZW4gdGhvdWdoIGFuIGVtcHR5IHZlcnNpb24gb2YgaXQgYWxyZWFkeVxuICAgICAgLy8gY29tbWl0dGVkLiBEaXNjb25uZWN0IHRoZSBhbHRlcm5hdGUgcG9pbnRlcnMuXG4gICAgICBjdXJyZW50JCQxLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgICB9XG4gICAgLy8gSW4gdGhlIGluaXRpYWwgcGFzcyB3ZSBtaWdodCBuZWVkIHRvIGNvbnN0cnVjdCB0aGUgaW5zdGFuY2UuXG4gICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChjdXJyZW50JCQxID09PSBudWxsKSB7XG4gICAgLy8gSW4gYSByZXN1bWUsIHdlJ2xsIGFscmVhZHkgaGF2ZSBhbiBpbnN0YW5jZSB3ZSBjYW4gcmV1c2UuXG4gICAgc2hvdWxkVXBkYXRlID0gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9IGVsc2Uge1xuICAgIHNob3VsZFVwZGF0ZSA9IHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH1cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIHtcbiAgICB2YXIgaW5zdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpZiAoaW5zdC5wcm9wcyAhPT0gbmV4dFByb3BzKSB7XG4gICAgICAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcyA/IHdhcm5pbmckMShmYWxzZSwgJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlKSB8fCAnYSBjb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV4dFVuaXRPZldvcms7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgbWFya1JlZihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgdmFyIGRpZENhcHR1cmVFcnJvciA9ICh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSAhPT0gTm9FZmZlY3Q7XG5cbiAgaWYgKCFzaG91bGRVcGRhdGUgJiYgIWRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIENvbnRleHQgcHJvdmlkZXJzIHNob3VsZCBkZWZlciB0byBzQ1UgZm9yIHJlbmRlcmluZ1xuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIC8vIFJlcmVuZGVyXG4gIFJlYWN0Q3VycmVudE93bmVyJDMuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICBpZiAoZGlkQ2FwdHVyZUVycm9yICYmIHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gSWYgd2UgY2FwdHVyZWQgYW4gZXJyb3IsIGJ1dCBnZXREZXJpdmVkU3RhdGVGcm9tIGNhdGNoIGlzIG5vdCBkZWZpbmVkLFxuICAgIC8vIHVubW91bnQgYWxsIHRoZSBjaGlsZHJlbi4gY29tcG9uZW50RGlkQ2F0Y2ggd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgdG9cbiAgICAvLyByZS1yZW5kZXIgYSBmYWxsYmFjay4gVGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgd2UgbWlncmF0ZSBldmVyeW9uZSB0b1xuICAgIC8vIHRoZSBuZXcgQVBJLlxuICAgIC8vIFRPRE86IFdhcm4gaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuXG4gICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIpIHtcbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgfVxuICAgICAgc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG4gIGlmIChjdXJyZW50JCQxICE9PSBudWxsICYmIGRpZENhcHR1cmVFcnJvcikge1xuICAgIC8vIElmIHdlJ3JlIHJlY292ZXJpbmcgZnJvbSBhbiBlcnJvciwgcmVjb25jaWxlIHdpdGhvdXQgcmV1c2luZyBhbnkgb2ZcbiAgICAvLyB0aGUgZXhpc3RpbmcgY2hpbGRyZW4uIENvbmNlcHR1YWxseSwgdGhlIG5vcm1hbCBjaGlsZHJlbiBhbmQgdGhlIGNoaWxkcmVuXG4gICAgLy8gdGhhdCBhcmUgc2hvd24gb24gZXJyb3IgYXJlIHR3byBkaWZmZXJlbnQgc2V0cywgc28gd2Ugc2hvdWxkbid0IHJldXNlXG4gICAgLy8gbm9ybWFsIGNoaWxkcmVuIGV2ZW4gaWYgdGhlaXIgaWRlbnRpdGllcyBtYXRjaC5cbiAgICBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICAvLyBNZW1vaXplIHN0YXRlIHVzaW5nIHRoZSB2YWx1ZXMgd2UganVzdCB1c2VkIHRvIHJlbmRlci5cbiAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbiAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHRydWUpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpZiAocm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QucGVuZGluZ0NvbnRleHQsIHJvb3QucGVuZGluZ0NvbnRleHQgIT09IHJvb3QuY29udGV4dCk7XG4gIH0gZWxzZSBpZiAocm9vdC5jb250ZXh0KSB7XG4gICAgLy8gU2hvdWxkIGFsd2F5cyBiZSBzZXRcbiAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LmNvbnRleHQsIGZhbHNlKTtcbiAgfVxuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250YWluZXJJbmZvKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgISh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdJZiB0aGUgcm9vdCBkb2VzIG5vdCBoYXZlIGFuIHVwZGF0ZVF1ZXVlLCB3ZSBzaG91bGQgaGF2ZSBhbHJlYWR5IGJhaWxlZCBvdXQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgcHJldkNoaWxkcmVuID0gcHJldlN0YXRlICE9PSBudWxsID8gcHJldlN0YXRlLmVsZW1lbnQgOiBudWxsO1xuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFN0YXRlLmVsZW1lbnQ7XG4gIGlmIChuZXh0Q2hpbGRyZW4gPT09IHByZXZDaGlsZHJlbikge1xuICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAvLyBubyB3b3JrIHRoYXQgZXhwaXJlcyBhdCB0aGlzIHRpbWUuXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH1cbiAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmICgoY3VycmVudCQkMSA9PT0gbnVsbCB8fCBjdXJyZW50JCQxLmNoaWxkID09PSBudWxsKSAmJiByb290Lmh5ZHJhdGUgJiYgZW50ZXJIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAvLyBiZSBhbnkgY2hpbGRyZW4gdG8gaHlkcmF0ZSB3aGljaCBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZyBhc1xuICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgdHJhY2sgdGhlIGhvc3Qgcm9vdCBhcyBhIHBsYWNlbWVudCB0b1xuICAgIC8vIGtub3cgdGhhdCB3ZSdyZSBjdXJyZW50bHkgaW4gYSBtb3VudGluZyBzdGF0ZS4gVGhhdCB3YXkgaXNNb3VudGVkXG4gICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG5cbiAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgLy8gc2lkZS1lZmZlY3RzLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBzdG9yZSBQbGFjZW1lbnQgZWZmZWN0cyBvblxuICAgIC8vIG5vZGVzIHRoYXQgd2lsbCBiZSBoeWRyYXRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVyd2lzZSByZXNldCBoeWRyYXRpb24gc3RhdGUgaW4gY2FzZSB3ZSBhYm9ydGVkIGFuZCByZXN1bWVkIGFub3RoZXJcbiAgICAvLyByb290LlxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50JCQxID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlByb3BzID0gY3VycmVudCQkMSAhPT0gbnVsbCA/IGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXZlIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAvLyBhdm9pZHMgYWxsb2NhdGluZyBhbm90aGVyIEhvc3RUZXh0IGZpYmVyIGFuZCB0cmF2ZXJzaW5nIGl0LlxuICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gIH0gZWxzZSBpZiAocHJldlByb3BzICE9PSBudWxsICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBhIGRpcmVjdCB0ZXh0IGNoaWxkIHRvIGEgbm9ybWFsIGNoaWxkLCBvciB0b1xuICAgIC8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENvbnRlbnRSZXNldDtcbiAgfVxuXG4gIG1hcmtSZWYoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIC8vIENoZWNrIHRoZSBob3N0IGNvbmZpZyB0byBzZWUgaWYgdGhlIGNoaWxkcmVuIGFyZSBvZmZzY3JlZW4vaGlkZGVuLlxuICBpZiAocmVuZGVyRXhwaXJhdGlvblRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSAmJiBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlKHR5cGUsIG5leHRQcm9wcykpIHtcbiAgICAvLyBTY2hlZHVsZSB0aGlzIGZpYmVyIHRvIHJlLXJlbmRlciBhdCBvZmZzY3JlZW4gcHJpb3JpdHkuIFRoZW4gYmFpbG91dC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBOZXZlcjtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuICAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuIFRoaXMgaXMgdGVybWluYWwuIFdlJ2xsIGRvIHRoZSBjb21wbGV0aW9uIHN0ZXBcbiAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtb3VudExhenlDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgdXBkYXRlRXhwaXJhdGlvblRpbWUsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEFuIGxhenkgY29tcG9uZW50IG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZCBpbnNpZGUgYSBub24tXG4gICAgLy8gY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG8gdHJlYXQgaXQgbGlrZVxuICAgIC8vIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHkgY29tbWl0dGVkLlxuICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbiAgICBfY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIC8vIFdlIGNhbid0IHN0YXJ0IGEgVXNlciBUaW1pbmcgbWVhc3VyZW1lbnQgd2l0aCBjb3JyZWN0IGxhYmVsIHlldC5cbiAgLy8gQ2FuY2VsIGFuZCByZXN1bWUgcmlnaHQgYWZ0ZXIgd2Uga25vdyB0aGUgdGFnLlxuICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgQ29tcG9uZW50ID0gcmVhZExhenlDb21wb25lbnRUeXBlKGVsZW1lbnRUeXBlKTtcbiAgLy8gU3RvcmUgdGhlIHVud3JhcHBlZCBjb21wb25lbnQgaW4gdGhlIHR5cGUuXG4gIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQ7XG4gIHZhciByZXNvbHZlZFRhZyA9IHdvcmtJblByb2dyZXNzLnRhZyA9IHJlc29sdmVMYXp5Q29tcG9uZW50VGFnKENvbXBvbmVudCk7XG4gIHN0YXJ0V29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlRGVmYXVsdFByb3BzKENvbXBvbmVudCwgcHJvcHMpO1xuICB2YXIgY2hpbGQgPSB2b2lkIDA7XG4gIHN3aXRjaCAocmVzb2x2ZWRUYWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjaGlsZCA9IHVwZGF0ZUNsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICBjaGlsZCA9IHVwZGF0ZUZvcndhcmRSZWYobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcmVzb2x2ZWRQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvdXRlclByb3BUeXBlcyA9IENvbXBvbmVudC5wcm9wVHlwZXM7XG4gICAgICAgICAgICBpZiAob3V0ZXJQcm9wVHlwZXMpIHtcbiAgICAgICAgICAgICAgY2hlY2tQcm9wVHlwZXMob3V0ZXJQcm9wVHlwZXMsIHJlc29sdmVkUHJvcHMsIC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4gICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpLCBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSB1cGRhdGVNZW1vQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVEZWZhdWx0UHJvcHMoQ29tcG9uZW50LnR5cGUsIHJlc29sdmVkUHJvcHMpLCAvLyBUaGUgaW5uZXIgdHlwZSBjYW4gaGF2ZSBkZWZhdWx0cyB0b29cbiAgICAgICAgdXBkYXRlRXhwaXJhdGlvblRpbWUsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGhpbnQgPSAnJztcbiAgICAgICAge1xuICAgICAgICAgIGlmIChDb21wb25lbnQgIT09IG51bGwgJiYgdHlwZW9mIENvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgQ29tcG9uZW50LiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgICAgIGhpbnQgPSAnIERpZCB5b3Ugd3JhcCBhIGNvbXBvbmVudCBpbiBSZWFjdC5sYXp5KCkgbW9yZSB0aGFuIG9uY2U/JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBtZXNzYWdlIGludGVudGlvbmFsbHkgZG9lc24ndCBtZW50aW9uIEZvcndhcmRSZWYgb3IgTWVtb0NvbXBvbmVudFxuICAgICAgICAvLyBiZWNhdXNlIHRoZSBmYWN0IHRoYXQgaXQncyBhIHNlcGFyYXRlIHR5cGUgb2Ygd29yayBpcyBhblxuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogJXMuIExhenkgZWxlbWVudCB0eXBlIG11c3QgcmVzb2x2ZSB0byBhIGNsYXNzIG9yIGZ1bmN0aW9uLiVzJywgQ29tcG9uZW50LCBoaW50KTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50KF9jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEFuIGluY29tcGxldGUgY29tcG9uZW50IG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZCBpbnNpZGUgYSBub24tXG4gICAgLy8gY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG8gdHJlYXQgaXQgbGlrZVxuICAgIC8vIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHkgY29tbWl0dGVkLlxuICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbiAgICBfY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICAvLyBQcm9tb3RlIHRoZSBmaWJlciB0byBhIGNsYXNzIGFuZCB0cnkgcmVuZGVyaW5nIGFnYWluLlxuICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAvLyBUaGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uIGlzIGEgZm9yayBvZiBgdXBkYXRlQ2xhc3NDb21wb25lbnRgXG5cbiAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gIHZhciBoYXNDb250ZXh0ID0gdm9pZCAwO1xuICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgIGhhc0NvbnRleHQgPSB0cnVlO1xuICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICB9IGVsc2Uge1xuICAgIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgfVxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgdHJ1ZSwgaGFzQ29udGV4dCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xufVxuXG5mdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIEFuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IG9ubHkgbW91bnRzIGlmIGl0IHN1c3BlbmRlZCBpbnNpZGUgYSBub24tXG4gICAgLy8gY29uY3VycmVudCB0cmVlLCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIHdhbnQgdG8gdHJlYXQgaXQgbGlrZVxuICAgIC8vIGEgbmV3IG1vdW50LCBldmVuIHRob3VnaCBhbiBlbXB0eSB2ZXJzaW9uIG9mIGl0IGFscmVhZHkgY29tbWl0dGVkLlxuICAgIC8vIERpc2Nvbm5lY3QgdGhlIGFsdGVybmF0ZSBwb2ludGVycy5cbiAgICBfY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgLy8gU2luY2UgdGhpcyBpcyBjb25jZXB0dWFsbHkgYSBuZXcgZmliZXIsIHNjaGVkdWxlIGEgUGxhY2VtZW50IGVmZmVjdFxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgZmFsc2UpO1xuICB2YXIgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICB2YXIgdmFsdWUgPSB2b2lkIDA7XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQucHJvdG90eXBlICYmIHR5cGVvZiBDb21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lciQzLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB2YWx1ZSA9IHJlbmRlcldpdGhIb29rcyhudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgY29udGV4dCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICB9XG4gIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZS4kJHR5cGVvZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBjbGFzcyBpbnN0YW5jZVxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG4gICAgLy8gVGhyb3cgb3V0IGFueSBob29rcyB0aGF0IHdlcmUgdXNlZC5cbiAgICByZXNldEhvb2tzKCk7XG5cbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG4gICAgdmFyIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoQ29tcG9uZW50KSkge1xuICAgICAgaGFzQ29udGV4dCA9IHRydWU7XG4gICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB2YWx1ZS5zdGF0ZSAhPT0gbnVsbCAmJiB2YWx1ZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUuc3RhdGUgOiBudWxsO1xuXG4gICAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgcHJvcHMpO1xuICAgIH1cblxuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgdmFsdWUpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHJldHVybiBmaW5pc2hDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCB0cnVlLCBoYXNDb250ZXh0LCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBGdW5jdGlvbkNvbXBvbmVudDtcbiAgICB7XG4gICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgLy8gT25seSBkb3VibGUtcmVuZGVyIGNvbXBvbmVudHMgd2l0aCBIb29rc1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlID0gcmVuZGVyV2l0aEhvb2tzKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBjb250ZXh0LCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4obnVsbCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAgaWYgKENvbXBvbmVudCkge1xuICAgICEhQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbiBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lSW5EZXZPck51bGwoKTtcbiAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmdLZXkgPSBvd25lck5hbWUgfHwgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgfHwgJyc7XG4gICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgd2FybmluZ0tleSA9IGRlYnVnU291cmNlLmZpbGVOYW1lICsgJzonICsgZGVidWdTb3VyY2UubGluZU51bWJlcjtcbiAgICB9XG4gICAgaWYgKCFkaWRXYXJuQWJvdXRGdW5jdGlvblJlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgIGRpZFdhcm5BYm91dEZ1bmN0aW9uUmVmc1t3YXJuaW5nS2V5XSA9IHRydWU7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdGdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBiZSBnaXZlbiByZWZzLiAnICsgJ0F0dGVtcHRzIHRvIGFjY2VzcyB0aGlzIHJlZiB3aWxsIGZhaWwuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHVzZSBSZWFjdC5mb3J3YXJkUmVmKCk/JXMnLCBpbmZvKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICBpZiAoIWRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgQ29tcG9uZW50LmNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgaWYgKCFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBjb250ZXh0VHlwZS4nLCBfY29tcG9uZW50TmFtZSk7XG4gICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAvLyBXZSBzaG91bGQgYXR0ZW1wdCB0byByZW5kZXIgdGhlIHByaW1hcnkgY2hpbGRyZW4gdW5sZXNzIHRoaXMgYm91bmRhcnlcbiAgLy8gYWxyZWFkeSBzdXNwZW5kZWQgZHVyaW5nIHRoaXMgcmVuZGVyIChgYWxyZWFkeUNhcHR1cmVkYCBpcyB0cnVlKS5cbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgdmFyIG5leHREaWRUaW1lb3V0ID0gdm9pZCAwO1xuICBpZiAoKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGF0dGVtcHQuXG4gICAgbmV4dFN0YXRlID0gbnVsbDtcbiAgICBuZXh0RGlkVGltZW91dCA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIFNvbWV0aGluZyBpbiB0aGlzIGJvdW5kYXJ5J3Mgc3VidHJlZSBhbHJlYWR5IHN1c3BlbmRlZC4gU3dpdGNoIHRvXG4gICAgLy8gcmVuZGVyaW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICBuZXh0U3RhdGUgPSB7XG4gICAgICB0aW1lZE91dEF0OiBuZXh0U3RhdGUgIT09IG51bGwgPyBuZXh0U3RhdGUudGltZWRPdXRBdCA6IE5vV29ya1xuICAgIH07XG4gICAgbmV4dERpZFRpbWVvdXQgPSB0cnVlO1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmPSB+RGlkQ2FwdHVyZTtcbiAgfVxuXG4gIC8vIFRoaXMgbmV4dCBwYXJ0IGlzIGEgYml0IGNvbmZ1c2luZy4gSWYgdGhlIGNoaWxkcmVuIHRpbWVvdXQsIHdlIHN3aXRjaCB0b1xuICAvLyBzaG93aW5nIHRoZSBmYWxsYmFjayBjaGlsZHJlbiBpbiBwbGFjZSBvZiB0aGUgXCJwcmltYXJ5XCIgY2hpbGRyZW4uXG4gIC8vIEhvd2V2ZXIsIHdlIGRvbid0IHdhbnQgdG8gZGVsZXRlIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGJlY2F1c2UgdGhlbiB0aGVpclxuICAvLyBzdGF0ZSB3aWxsIGJlIGxvc3QgKGJvdGggdGhlIFJlYWN0IHN0YXRlIGFuZCB0aGUgaG9zdCBzdGF0ZSwgZS5nLlxuICAvLyB1bmNvbnRyb2xsZWQgZm9ybSBpbnB1dHMpLiBJbnN0ZWFkIHdlIGtlZXAgdGhlbSBtb3VudGVkIGFuZCBoaWRlIHRoZW0uXG4gIC8vIEJvdGggdGhlIGZhbGxiYWNrIGNoaWxkcmVuIEFORCB0aGUgcHJpbWFyeSBjaGlsZHJlbiBhcmUgcmVuZGVyZWQgYXQgdGhlXG4gIC8vIHNhbWUgdGltZS4gT25jZSB0aGUgcHJpbWFyeSBjaGlsZHJlbiBhcmUgdW4tc3VzcGVuZGVkLCB3ZSBjYW4gZGVsZXRlXG4gIC8vIHRoZSBmYWxsYmFjayBjaGlsZHJlbiDigJQgZG9uJ3QgbmVlZCB0byBwcmVzZXJ2ZSB0aGVpciBzdGF0ZS5cbiAgLy9cbiAgLy8gVGhlIHR3byBzZXRzIG9mIGNoaWxkcmVuIGFyZSBzaWJsaW5ncyBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudCwgYnV0XG4gIC8vIHNlbWFudGljYWxseSwgZm9yIHB1cnBvc2VzIG9mIHJlY29uY2lsaWF0aW9uLCB0aGV5IGFyZSB0d28gc2VwYXJhdGUgc2V0cy5cbiAgLy8gU28gd2Ugc3RvcmUgdGhlbSB1c2luZyB0d28gZnJhZ21lbnQgZmliZXJzLlxuICAvL1xuICAvLyBIb3dldmVyLCB3ZSB3YW50IHRvIGF2b2lkIGFsbG9jYXRpbmcgZXh0cmEgZmliZXJzIGZvciBldmVyeSBwbGFjZWhvbGRlci5cbiAgLy8gVGhleSdyZSBvbmx5IG5lY2Vzc2FyeSB3aGVuIHRoZSBjaGlsZHJlbiB0aW1lIG91dCwgYmVjYXVzZSB0aGF0J3MgdGhlXG4gIC8vIG9ubHkgdGltZSB3aGVuIGJvdGggc2V0cyBhcmUgbW91bnRlZC5cbiAgLy9cbiAgLy8gU28sIHRoZSBleHRyYSBmcmFnbWVudCBmaWJlcnMgYXJlIG9ubHkgdXNlZCBpZiB0aGUgY2hpbGRyZW4gdGltZSBvdXQuXG4gIC8vIE90aGVyd2lzZSwgd2UgcmVuZGVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGRpcmVjdGx5LiBUaGlzIHJlcXVpcmVzIHNvbWVcbiAgLy8gY3VzdG9tIHJlY29uY2lsaWF0aW9uIGxvZ2ljIHRvIHByZXNlcnZlIHRoZSBzdGF0ZSBvZiB0aGUgcHJpbWFyeVxuICAvLyBjaGlsZHJlbi4gSXQncyBlc3NlbnRpYWxseSBhIHZlcnkgYmFzaWMgZm9ybSBvZiByZS1wYXJlbnRpbmcuXG5cbiAgLy8gYGNoaWxkYCBwb2ludHMgdG8gdGhlIGNoaWxkIGZpYmVyLiBJbiB0aGUgbm9ybWFsIGNhc2UsIHRoaXMgaXMgdGhlIGZpcnN0XG4gIC8vIGZpYmVyIG9mIHRoZSBwcmltYXJ5IGNoaWxkcmVuIHNldC4gSW4gdGhlIHRpbWVkLW91dCBjYXNlLCBpdCdzIGFcbiAgLy8gYSBmcmFnbWVudCBmaWJlciBjb250YWluaW5nIHRoZSBwcmltYXJ5IGNoaWxkcmVuLlxuICB2YXIgY2hpbGQgPSB2b2lkIDA7XG4gIC8vIGBuZXh0YCBwb2ludHMgdG8gdGhlIG5leHQgZmliZXIgUmVhY3Qgc2hvdWxkIHJlbmRlci4gSW4gdGhlIG5vcm1hbCBjYXNlLFxuICAvLyBpdCdzIHRoZSBzYW1lIGFzIGBjaGlsZGA6IHRoZSBmaXJzdCBmaWJlciBvZiB0aGUgcHJpbWFyeSBjaGlsZHJlbiBzZXQuXG4gIC8vIEluIHRoZSB0aW1lZC1vdXQgY2FzZSwgaXQncyBhIGZyYWdtZW50IGZpYmVyIGNvbnRhaW5pbmcgdGhlICpmYWxsYmFjaypcbiAgLy8gY2hpbGRyZW4gLS0gd2Ugc2tpcCBvdmVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGVudGlyZWx5LlxuICB2YXIgbmV4dCA9IHZvaWQgMDtcbiAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwpIHtcbiAgICBpZiAoZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcikge1xuICAgICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGh5ZHJhdGluZywgdHJ5IHRvIGh5ZHJhdGUgdGhpcyBib3VuZGFyeS5cbiAgICAgIC8vIEJ1dCBvbmx5IGlmIHRoaXMgaGFzIGEgZmFsbGJhY2suXG4gICAgICBpZiAobmV4dFByb3BzLmZhbGxiYWNrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAvLyBUaGlzIGNvdWxkJ3ZlIGNoYW5nZWQgdGhlIHRhZyBpZiB0aGlzIHdhcyBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50LlxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MudGFnID09PSBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBpbml0aWFsIG1vdW50LiBUaGlzIGJyYW5jaCBpcyBwcmV0dHkgc2ltcGxlIGJlY2F1c2UgdGhlcmUnc1xuICAgIC8vIG5vIHByZXZpb3VzIHN0YXRlIHRoYXQgbmVlZHMgdG8gYmUgcHJlc2VydmVkLlxuICAgIGlmIChuZXh0RGlkVGltZW91dCkge1xuICAgICAgLy8gTW91bnQgc2VwYXJhdGUgZnJhZ21lbnRzIGZvciBwcmltYXJ5IGFuZCBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICAgIHZhciBuZXh0RmFsbGJhY2tDaGlsZHJlbiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG51bGwsIG1vZGUsIE5vV29yaywgbnVsbCk7XG5cbiAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgIC8vIE91dHNpZGUgb2YgY29uY3VycmVudCBtb2RlLCB3ZSBjb21taXQgdGhlIGVmZmVjdHMgZnJvbSB0aGVcbiAgICAgICAgdmFyIHByb2dyZXNzZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciBwcm9ncmVzc2VkUHJpbWFyeUNoaWxkID0gcHJvZ3Jlc3NlZFN0YXRlICE9PSBudWxsID8gd29ya0luUHJvZ3Jlc3MuY2hpbGQuY2hpbGQgOiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGQgPSBwcm9ncmVzc2VkUHJpbWFyeUNoaWxkO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV4dEZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gICAgICBjaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICAgICAgLy8gU2tpcCB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgYW5kIGNvbnRpbnVlIHdvcmtpbmcgb24gdGhlXG4gICAgICAvLyBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICAgIG5leHQgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gICAgICBjaGlsZC5yZXR1cm4gPSBuZXh0LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3VudCB0aGUgcHJpbWFyeSBjaGlsZHJlbiB3aXRob3V0IGFuIGludGVybWVkaWF0ZSBmcmFnbWVudCBmaWJlci5cbiAgICAgIHZhciBuZXh0UHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgY2hpbGQgPSBuZXh0ID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dFByaW1hcnlDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGFuIHVwZGF0ZS4gVGhpcyBicmFuY2ggaXMgbW9yZSBjb21wbGljYXRlZCBiZWNhdXNlIHdlIG5lZWQgdG9cbiAgICAvLyBlbnN1cmUgdGhlIHN0YXRlIG9mIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGlzIHByZXNlcnZlZC5cbiAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudCQkMS5tZW1vaXplZFN0YXRlO1xuICAgIHZhciBwcmV2RGlkVGltZW91dCA9IHByZXZTdGF0ZSAhPT0gbnVsbDtcbiAgICBpZiAocHJldkRpZFRpbWVvdXQpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRyZWUgYWxyZWFkeSB0aW1lZCBvdXQuIFRoYXQgbWVhbnMgZWFjaCBjaGlsZCBzZXQgaXNcbiAgICAgIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50JCQxLmNoaWxkO1xuICAgICAgdmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZztcbiAgICAgIGlmIChuZXh0RGlkVGltZW91dCkge1xuICAgICAgICAvLyBTdGlsbCB0aW1lZCBvdXQuIFJldXNlIHRoZSBjdXJyZW50IHByaW1hcnkgY2hpbGRyZW4gYnkgY2xvbmluZ1xuICAgICAgICAvLyBpdHMgZnJhZ21lbnQuIFdlJ3JlIGdvaW5nIHRvIHNraXAgb3ZlciB0aGVzZSBlbnRpcmVseS5cbiAgICAgICAgdmFyIF9uZXh0RmFsbGJhY2tDaGlsZHJlbiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnBlbmRpbmdQcm9wcywgTm9Xb3JrKTtcblxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vQ29udGV4dCkge1xuICAgICAgICAgIC8vIE91dHNpZGUgb2YgY29uY3VycmVudCBtb2RlLCB3ZSBjb21taXQgdGhlIGVmZmVjdHMgZnJvbSB0aGVcbiAgICAgICAgICB2YXIgX3Byb2dyZXNzZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgdmFyIF9wcm9ncmVzc2VkUHJpbWFyeUNoaWxkID0gX3Byb2dyZXNzZWRTdGF0ZSAhPT0gbnVsbCA/IHdvcmtJblByb2dyZXNzLmNoaWxkLmNoaWxkIDogd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgaWYgKF9wcm9ncmVzc2VkUHJpbWFyeUNoaWxkICE9PSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGQpIHtcbiAgICAgICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZCA9IF9wcm9ncmVzc2VkUHJpbWFyeUNoaWxkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJlY2F1c2UgcHJpbWFyeUNoaWxkRnJhZ21lbnQgaXMgYSBuZXcgZmliZXIgdGhhdCB3ZSdyZSBpbnNlcnRpbmcgYXMgdGhlXG4gICAgICAgIC8vIHBhcmVudCBvZiBhIG5ldyB0cmVlLCB3ZSBuZWVkIHRvIHNldCBpdHMgdHJlZUJhc2VEdXJhdGlvbi5cbiAgICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgLy8gdHJlZUJhc2VEdXJhdGlvbiBpcyB0aGUgc3VtIG9mIGFsbCB0aGUgY2hpbGQgdHJlZSBiYXNlIGR1cmF0aW9ucy5cbiAgICAgICAgICB2YXIgdHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgdmFyIGhpZGRlbkNoaWxkID0gX3ByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkO1xuICAgICAgICAgIHdoaWxlIChoaWRkZW5DaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJlZUJhc2VEdXJhdGlvbiArPSBoaWRkZW5DaGlsZC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICAgICAgaGlkZGVuQ2hpbGQgPSBoaWRkZW5DaGlsZC5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbG9uZSB0aGUgZmFsbGJhY2sgY2hpbGQgZnJhZ21lbnQsIHRvby4gVGhlc2Ugd2UnbGwgY29udGludWVcbiAgICAgICAgLy8gd29ya2luZyBvbi5cbiAgICAgICAgdmFyIF9mYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBfcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQsIF9uZXh0RmFsbGJhY2tDaGlsZHJlbiwgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudC5leHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGNoaWxkID0gX3ByaW1hcnlDaGlsZEZyYWdtZW50O1xuICAgICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICAgICAgLy8gU2tpcCB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgYW5kIGNvbnRpbnVlIHdvcmtpbmcgb24gdGhlXG4gICAgICAgIC8vIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgICAgICBuZXh0ID0gX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgICAgICAgY2hpbGQucmV0dXJuID0gbmV4dC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIGxvbmdlciBzdXNwZW5kZWQuIFN3aXRjaCBiYWNrIHRvIHNob3dpbmcgdGhlIHByaW1hcnkgY2hpbGRyZW4sXG4gICAgICAgIC8vIGFuZCByZW1vdmUgdGhlIGludGVybWVkaWF0ZSBmcmFnbWVudCBmaWJlci5cbiAgICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgICB2YXIgY3VycmVudFByaW1hcnlDaGlsZCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZDtcbiAgICAgICAgdmFyIHByaW1hcnlDaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50UHJpbWFyeUNoaWxkLCBfbmV4dFByaW1hcnlDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gICAgICAgIC8vIElmIHRoaXMgcmVuZGVyIGRvZXNuJ3Qgc3VzcGVuZCwgd2UgbmVlZCB0byBkZWxldGUgdGhlIGZhbGxiYWNrXG4gICAgICAgIC8vIGNoaWxkcmVuLiBXYWl0IHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZSwgYWZ0ZXIgd2UndmUgY29uZmlybWVkIHRoZVxuICAgICAgICAvLyBmYWxsYmFjayBpcyBubyBsb25nZXIgbmVlZGVkLlxuICAgICAgICAvLyBUT0RPOiBXb3VsZCBpdCBiZSBiZXR0ZXIgdG8gc3RvcmUgdGhlIGZhbGxiYWNrIGZyYWdtZW50IG9uXG4gICAgICAgIC8vIHRoZSBzdGF0ZU5vZGU/XG5cbiAgICAgICAgLy8gQ29udGludWUgcmVuZGVyaW5nIHRoZSBjaGlsZHJlbiwgbGlrZSB3ZSBub3JtYWxseSBkby5cbiAgICAgICAgY2hpbGQgPSBuZXh0ID0gcHJpbWFyeUNoaWxkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgY3VycmVudCB0cmVlIGhhcyBub3QgYWxyZWFkeSB0aW1lZCBvdXQuIFRoYXQgbWVhbnMgdGhlIHByaW1hcnlcbiAgICAgIC8vIGNoaWxkcmVuIGFyZSBub3Qgd3JhcHBlZCBpbiBhIGZyYWdtZW50IGZpYmVyLlxuICAgICAgdmFyIF9jdXJyZW50UHJpbWFyeUNoaWxkID0gY3VycmVudCQkMS5jaGlsZDtcbiAgICAgIGlmIChuZXh0RGlkVGltZW91dCkge1xuICAgICAgICAvLyBUaW1lZCBvdXQuIFdyYXAgdGhlIGNoaWxkcmVuIGluIGEgZnJhZ21lbnQgZmliZXIgdG8ga2VlcCB0aGVtXG4gICAgICAgIC8vIHNlcGFyYXRlIGZyb20gdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgICAgICB2YXIgX25leHRGYWxsYmFja0NoaWxkcmVuMiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChcbiAgICAgICAgLy8gSXQgc2hvdWxkbid0IG1hdHRlciB3aGF0IHRoZSBwZW5kaW5nIHByb3BzIGFyZSBiZWNhdXNlIHdlIGFyZW4ndFxuICAgICAgICAvLyBnb2luZyB0byByZW5kZXIgdGhpcyBmcmFnbWVudC5cbiAgICAgICAgbnVsbCwgbW9kZSwgTm9Xb3JrLCBudWxsKTtcbiAgICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi5jaGlsZCA9IF9jdXJyZW50UHJpbWFyeUNoaWxkO1xuXG4gICAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlJ3JlIGNyZWF0aW5nIGEgbmV3IGZpYmVyLCB0aGVyZSBhcmUgbm8gbmV3IGNoaWxkcmVuLFxuICAgICAgICAvLyBiZWNhdXNlIHdlJ3JlIHJldXNpbmcgYW4gYWxyZWFkeSBtb3VudGVkIHRyZWUuIFNvIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgLy8gc2NoZWR1bGUgYSBwbGFjZW1lbnQuXG4gICAgICAgIC8vIHByaW1hcnlDaGlsZEZyYWdtZW50LmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG5cbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgICAvLyBPdXRzaWRlIG9mIGNvbmN1cnJlbnQgbW9kZSwgd2UgY29tbWl0IHRoZSBlZmZlY3RzIGZyb20gdGhlXG4gICAgICAgICAgdmFyIF9wcm9ncmVzc2VkU3RhdGUyID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgX3Byb2dyZXNzZWRQcmltYXJ5Q2hpbGQyID0gX3Byb2dyZXNzZWRTdGF0ZTIgIT09IG51bGwgPyB3b3JrSW5Qcm9ncmVzcy5jaGlsZC5jaGlsZCA6IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIuY2hpbGQgPSBfcHJvZ3Jlc3NlZFByaW1hcnlDaGlsZDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZWNhdXNlIHByaW1hcnlDaGlsZEZyYWdtZW50IGlzIGEgbmV3IGZpYmVyIHRoYXQgd2UncmUgaW5zZXJ0aW5nIGFzIHRoZVxuICAgICAgICAvLyBwYXJlbnQgb2YgYSBuZXcgdHJlZSwgd2UgbmVlZCB0byBzZXQgaXRzIHRyZWVCYXNlRHVyYXRpb24uXG4gICAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIC8vIHRyZWVCYXNlRHVyYXRpb24gaXMgdGhlIHN1bSBvZiBhbGwgdGhlIGNoaWxkIHRyZWUgYmFzZSBkdXJhdGlvbnMuXG4gICAgICAgICAgdmFyIF90cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgICAgICAgICB2YXIgX2hpZGRlbkNoaWxkID0gX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi5jaGlsZDtcbiAgICAgICAgICB3aGlsZSAoX2hpZGRlbkNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbiArPSBfaGlkZGVuQ2hpbGQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgIF9oaWRkZW5DaGlsZCA9IF9oaWRkZW5DaGlsZC5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyLnRyZWVCYXNlRHVyYXRpb24gPSBfdHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhIGZyYWdtZW50IGZyb20gdGhlIGZhbGxiYWNrIGNoaWxkcmVuLCB0b28uXG4gICAgICAgIHZhciBfZmFsbGJhY2tDaGlsZEZyYWdtZW50MiA9IF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIuc2libGluZyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KF9uZXh0RmFsbGJhY2tDaGlsZHJlbjIsIG1vZGUsIHJlbmRlckV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2ZhbGxiYWNrQ2hpbGRGcmFnbWVudDIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgICAgICAgY2hpbGQgPSBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyO1xuICAgICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgICAgIC8vIFNraXAgdGhlIHByaW1hcnkgY2hpbGRyZW4sIGFuZCBjb250aW51ZSB3b3JraW5nIG9uIHRoZVxuICAgICAgICAvLyBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICAgICAgbmV4dCA9IF9mYWxsYmFja0NoaWxkRnJhZ21lbnQyO1xuICAgICAgICBjaGlsZC5yZXR1cm4gPSBuZXh0LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU3RpbGwgaGF2ZW4ndCB0aW1lZCBvdXQuICBDb250aW51ZSByZW5kZXJpbmcgdGhlIGNoaWxkcmVuLCBsaWtlIHdlXG4gICAgICAgIC8vIG5vcm1hbGx5IGRvLlxuICAgICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4yID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgICBuZXh0ID0gY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgX2N1cnJlbnRQcmltYXJ5Q2hpbGQsIF9uZXh0UHJpbWFyeUNoaWxkcmVuMiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50JCQxLnN0YXRlTm9kZTtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChjdXJyZW50JCQxID09PSBudWxsKSB7XG4gICAgLy8gRHVyaW5nIHRoZSBmaXJzdCBwYXNzLCB3ZSdsbCBiYWlsIG91dCBhbmQgbm90IGRyaWxsIGludG8gdGhlIGNoaWxkcmVuLlxuICAgIC8vIEluc3RlYWQsIHdlJ2xsIGxlYXZlIHRoZSBjb250ZW50IGluIHBsYWNlIGFuZCB0cnkgdG8gaHlkcmF0ZSBpdCBsYXRlci5cbiAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IE5ldmVyO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFdlIHVzZSBjaGlsZEV4cGlyYXRpb25UaW1lIHRvIGluZGljYXRlIHRoYXQgYSBjaGlsZCBtaWdodCBkZXBlbmQgb24gY29udGV4dCwgc28gaWZcbiAgLy8gYW55IGNvbnRleHQgaGFzIGNoYW5nZWQsIHdlIG5lZWQgdG8gdHJlYXQgaXMgYXMgaWYgdGhlIGlucHV0IG1pZ2h0IGhhdmUgY2hhbmdlZC5cbiAgdmFyIGhhc0NvbnRleHRDaGFuZ2VkJCQxID0gY3VycmVudCQkMS5jaGlsZEV4cGlyYXRpb25UaW1lID49IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICBpZiAoZGlkUmVjZWl2ZVVwZGF0ZSB8fCBoYXNDb250ZXh0Q2hhbmdlZCQkMSkge1xuICAgIC8vIFRoaXMgYm91bmRhcnkgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGZpcnN0IHJlbmRlci4gVGhpcyBtZWFucyB0aGF0IHdlIGFyZSBub3cgdW5hYmxlIHRvXG4gICAgLy8gaHlkcmF0ZSBpdC4gV2UgbWlnaHQgc3RpbGwgYmUgYWJsZSB0byBoeWRyYXRlIGl0IHVzaW5nIGFuIGVhcmxpZXIgZXhwaXJhdGlvbiB0aW1lIGJ1dFxuICAgIC8vIGR1cmluZyB0aGlzIHJlbmRlciB3ZSBjYW4ndC4gSW5zdGVhZCwgd2UncmUgZ29pbmcgdG8gZGVsZXRlIHRoZSB3aG9sZSBzdWJ0cmVlIGFuZFxuICAgIC8vIGluc3RlYWQgaW5qZWN0IGEgbmV3IHJlYWwgU3VzcGVuc2UgYm91bmRhcnkgdG8gdGFrZSBpdHMgcGxhY2UsIHdoaWNoIG1heSByZW5kZXIgY29udGVudFxuICAgIC8vIG9yIGZhbGxiYWNrLiBUaGUgcmVhbCBTdXNwZW5zZSBib3VuZGFyeSB3aWxsIHN1c3BlbmQgZm9yIGEgd2hpbGUgc28gd2UgaGF2ZSBzb21lIHRpbWVcbiAgICAvLyB0byBlbnN1cmUgaXQgY2FuIHByb2R1Y2UgcmVhbCBjb250ZW50LCBidXQgYWxsIHN0YXRlIGFuZCBwZW5kaW5nIGV2ZW50cyB3aWxsIGJlIGxvc3QuXG5cbiAgICAvLyBEZXRhY2ggZnJvbSB0aGUgY3VycmVudCBkZWh5ZHJhdGVkIGJvdW5kYXJ5LlxuICAgIGN1cnJlbnQkJDEuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gICAgLy8gSW5zZXJ0IGEgZGVsZXRpb24gaW4gdGhlIGVmZmVjdCBsaXN0LlxuICAgIHZhciByZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICAhKHJldHVybkZpYmVyICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1N1c3BlbnNlIGJvdW5kYXJpZXMgYXJlIG5ldmVyIG9uIHRoZSByb290LiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpIDogdm9pZCAwO1xuICAgIHZhciBsYXN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdDtcbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY3VycmVudCQkMTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjdXJyZW50JCQxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjdXJyZW50JCQxO1xuICAgIH1cbiAgICBjdXJyZW50JCQxLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIGN1cnJlbnQkJDEuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgICAvLyBVcGdyYWRlIHRoaXMgd29yayBpbiBwcm9ncmVzcyB0byBhIHJlYWwgU3VzcGVuc2UgY29tcG9uZW50LlxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFN1c3BlbnNlQ29tcG9uZW50O1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgLy8gVGhpcyBpcyBub3cgYW4gaW5zZXJ0aW9uLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG4gICAgLy8gUmV0cnkgYXMgYSByZWFsIFN1c3BlbnNlIGNvbXBvbmVudC5cbiAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfVxuICBpZiAoKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGF0dGVtcHQuXG4gICAgcmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZC4gTGVhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIGluIHBsYWNlLlxuICAgIC8vIFRPRE86IEluIG5vbi1jb25jdXJyZW50IG1vZGUsIHNob3VsZCB3ZSBjb21taXQgdGhlIG5vZGVzIHdlIGhhdmUgaHlkcmF0ZWQgc28gZmFyP1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIGlmIChjdXJyZW50JCQxID09PSBudWxsKSB7XG4gICAgLy8gUG9ydGFscyBhcmUgc3BlY2lhbCBiZWNhdXNlIHdlIGRvbid0IGFwcGVuZCB0aGUgY2hpbGRyZW4gZHVyaW5nIG1vdW50XG4gICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgLy8gZmxvdyBkb2Vzbid0IGRvIGR1cmluZyBtb3VudC4gVGhpcyBkb2Vzbid0IGhhcHBlbiBhdCB0aGUgcm9vdCBiZWNhdXNlXG4gICAgLy8gdGhlIHJvb3QgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgXCJjdXJyZW50XCIgd2l0aCBhIG51bGwgY2hpbGQuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgfSBlbHNlIHtcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIH1cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBwcm92aWRlclR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgY29udGV4dCA9IHByb3ZpZGVyVHlwZS5fY29udGV4dDtcblxuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG5cbiAgdmFyIG5ld1ZhbHVlID0gbmV3UHJvcHMudmFsdWU7XG5cbiAge1xuICAgIHZhciBwcm92aWRlclByb3BUeXBlcyA9IHdvcmtJblByb2dyZXNzLnR5cGUucHJvcFR5cGVzO1xuXG4gICAgaWYgKHByb3ZpZGVyUHJvcFR5cGVzKSB7XG4gICAgICBjaGVja1Byb3BUeXBlcyhwcm92aWRlclByb3BUeXBlcywgbmV3UHJvcHMsICdwcm9wJywgJ0NvbnRleHQuUHJvdmlkZXInLCBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KTtcbiAgICB9XG4gIH1cblxuICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIG5ld1ZhbHVlKTtcblxuICBpZiAob2xkUHJvcHMgIT09IG51bGwpIHtcbiAgICB2YXIgb2xkVmFsdWUgPSBvbGRQcm9wcy52YWx1ZTtcbiAgICB2YXIgY2hhbmdlZEJpdHMgPSBjYWxjdWxhdGVDaGFuZ2VkQml0cyhjb250ZXh0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgIGlmIChjaGFuZ2VkQml0cyA9PT0gMCkge1xuICAgICAgLy8gTm8gY2hhbmdlLiBCYWlsb3V0IGVhcmx5IGlmIGNoaWxkcmVuIGFyZSB0aGUgc2FtZS5cbiAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4gJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGNvbnRleHQgdmFsdWUgY2hhbmdlZC4gU2VhcmNoIGZvciBtYXRjaGluZyBjb25zdW1lcnMgYW5kIHNjaGVkdWxlXG4gICAgICAvLyB0aGVtIHRvIHVwZGF0ZS5cbiAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIGNoYW5nZWRCaXRzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG5ld0NoaWxkcmVuID0gbmV3UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbnZhciBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIC8vIFRoZSBsb2dpYyBiZWxvdyBmb3IgQ29udGV4dCBkaWZmZXJzIGRlcGVuZGluZyBvbiBQUk9EIG9yIERFViBtb2RlLiBJblxuICAvLyBERVYgbW9kZSwgd2UgY3JlYXRlIGEgc2VwYXJhdGUgb2JqZWN0IGZvciBDb250ZXh0LkNvbnN1bWVyIHRoYXQgYWN0c1xuICAvLyBsaWtlIGEgcHJveHkgdG8gQ29udGV4dC4gVGhpcyBwcm94eSBvYmplY3QgYWRkcyB1bm5lY2Vzc2FyeSBjb2RlIGluIFBST0RcbiAgLy8gc28gd2UgdXNlIHRoZSBvbGQgYmVoYXZpb3VyIChDb250ZXh0LkNvbnN1bWVyIHJlZmVyZW5jZXMgQ29udGV4dCkgdG9cbiAgLy8gcmVkdWNlIHNpemUgYW5kIG92ZXJoZWFkLiBUaGUgc2VwYXJhdGUgb2JqZWN0IHJlZmVyZW5jZXMgY29udGV4dCB2aWFcbiAgLy8gYSBwcm9wZXJ0eSBjYWxsZWQgXCJfY29udGV4dFwiLCB3aGljaCBhbHNvIGdpdmVzIHVzIHRoZSBhYmlsaXR5IHRvIGNoZWNrXG4gIC8vIGluIERFViBtb2RlIGlmIHRoaXMgcHJvcGVydHkgZXhpc3RzIG9yIG5vdCBhbmQgd2FybiBpZiBpdCBkb2VzIG5vdC5cbiAge1xuICAgIGlmIChjb250ZXh0Ll9jb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRoaXMgbWF5IGJlIGJlY2F1c2UgaXQncyBhIENvbnRleHQgKHJhdGhlciB0aGFuIGEgQ29uc3VtZXIpLlxuICAgICAgLy8gT3IgaXQgbWF5IGJlIGJlY2F1c2UgaXQncyBvbGRlciBSZWFjdCB3aGVyZSB0aGV5J3JlIHRoZSBzYW1lIHRoaW5nLlxuICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHdhcm4gaWYgd2UncmUgc3VyZSBpdCdzIGEgbmV3IFJlYWN0LlxuICAgICAgaWYgKGNvbnRleHQgIT09IGNvbnRleHQuQ29uc3VtZXIpIHtcbiAgICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIpIHtcbiAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nQ29udGV4dEFzQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlbmRlcmluZyA8Q29udGV4dD4gZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0ID0gY29udGV4dC5fY29udGV4dDtcbiAgICB9XG4gIH1cbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgICEodHlwZW9mIHJlbmRlciA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdBIGNvbnRleHQgY29uc3VtZXIgd2FzIHJlbmRlcmVkIHdpdGggbXVsdGlwbGUgY2hpbGRyZW4sIG9yIGEgY2hpbGQgJyArIFwidGhhdCBpc24ndCBhIGZ1bmN0aW9uLiBBIGNvbnRleHQgY29uc3VtZXIgZXhwZWN0cyBhIHNpbmdsZSBjaGlsZCBcIiArICd0aGF0IGlzIGEgZnVuY3Rpb24uIElmIHlvdSBkaWQgcGFzcyBhIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdGhlcmUgJyArICdpcyBubyB0cmFpbGluZyBvciBsZWFkaW5nIHdoaXRlc3BhY2UgYXJvdW5kIGl0LicpIDogdm9pZCAwO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgdmFyIG5ld1ZhbHVlID0gcmVhZENvbnRleHQoY29udGV4dCwgbmV3UHJvcHMudW5zdGFibGVfb2JzZXJ2ZWRCaXRzKTtcbiAgdmFyIG5ld0NoaWxkcmVuID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3RDdXJyZW50T3duZXIkMy5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICBuZXdDaGlsZHJlbiA9IHJlbmRlcihuZXdWYWx1ZSk7XG4gICAgc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG5cbiAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKSB7XG4gIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50JCQxICE9PSBudWxsKSB7XG4gICAgLy8gUmV1c2UgcHJldmlvdXMgY29udGV4dCBsaXN0XG4gICAgd29ya0luUHJvZ3Jlc3MuY29udGV4dERlcGVuZGVuY2llcyA9IGN1cnJlbnQkJDEuY29udGV4dERlcGVuZGVuY2llcztcbiAgfVxuXG4gIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgLy8gRG9uJ3QgdXBkYXRlIFwiYmFzZVwiIHJlbmRlciB0aW1lcyBmb3IgYmFpbG91dHMuXG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cbiAgdmFyIGNoaWxkRXhwaXJhdGlvblRpbWUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZEV4cGlyYXRpb25UaW1lO1xuICBpZiAoY2hpbGRFeHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4gICAgLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGZpYmVyIGRvZXNuJ3QgaGF2ZSB3b3JrLCBidXQgaXRzIHN1YnRyZWUgZG9lcy4gQ2xvbmUgdGhlIGNoaWxkXG4gICAgLy8gZmliZXJzIGFuZCBjb250aW51ZS5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICB2YXIgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZTtcblxuICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCkge1xuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIElmIHByb3BzIG9yIGNvbnRleHQgY2hhbmdlZCwgbWFyayB0aGUgZmliZXIgYXMgaGF2aW5nIHBlcmZvcm1lZCB3b3JrLlxuICAgICAgLy8gVGhpcyBtYXkgYmUgdW5zZXQgaWYgdGhlIHByb3BzIGFyZSBkZXRlcm1pbmVkIHRvIGJlIGVxdWFsIGxhdGVyIChtZW1vKS5cbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodXBkYXRlRXhwaXJhdGlvblRpbWUgPCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgLy8gVGhpcyBmaWJlciBkb2VzIG5vdCBoYXZlIGFueSBwZW5kaW5nIHdvcmsuIEJhaWxvdXQgd2l0aG91dCBlbnRlcmluZ1xuICAgICAgLy8gdGhlIGJlZ2luIHBoYXNlLiBUaGVyZSdzIHN0aWxsIHNvbWUgYm9va2tlZXBpbmcgd2UgdGhhdCBuZWVkcyB0byBiZSBkb25lXG4gICAgICAvLyBpbiB0aGlzIG9wdGltaXplZCBwYXRoLCBtb3N0bHkgcHVzaGluZyBzdHVmZiBvbnRvIHRoZSBzdGFjay5cbiAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZTtcbiAgICAgICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgbmV3VmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgdmFyIGRpZFRpbWVvdXQgPSBzdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgICAgIGlmIChkaWRUaW1lb3V0KSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgYm91bmRhcnkgaXMgY3VycmVudGx5IHRpbWVkIG91dCwgd2UgbmVlZCB0byBkZWNpZGVcbiAgICAgICAgICAgICAgLy8gd2hldGhlciB0byByZXRyeSB0aGUgcHJpbWFyeSBjaGlsZHJlbiwgb3IgdG8gc2tpcCBvdmVyIGl0IGFuZFxuICAgICAgICAgICAgICAvLyBnbyBzdHJhaWdodCB0byB0aGUgZmFsbGJhY2suIENoZWNrIHRoZSBwcmlvcml0eSBvZiB0aGUgcHJpbWFyeVxuICAgICAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEV4cGlyYXRpb25UaW1lID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgICAgaWYgKHByaW1hcnlDaGlsZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgcHJpbWFyeUNoaWxkRXhwaXJhdGlvblRpbWUgPj0gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZHJlbiBoYXZlIHBlbmRpbmcgd29yay4gVXNlIHRoZSBub3JtYWwgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHRvIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGFnYWluLlxuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGRvIG5vdCBoYXZlIHBlbmRpbmcgd29yayB3aXRoIHN1ZmZpY2llbnRcbiAgICAgICAgICAgICAgICAvLyBwcmlvcml0eS4gQmFpbG91dC5cbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgZmFsbGJhY2sgY2hpbGRyZW4gaGF2ZSBwZW5kaW5nIHdvcmsuIFNraXAgb3ZlciB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIHByaW1hcnkgY2hpbGRyZW4gYW5kIHdvcmsgb24gdGhlIGZhbGxiYWNrLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcikge1xuICAgICAgICAgICAgICAvLyBXZSBrbm93IHRoYXQgdGhpcyBjb21wb25lbnQgd2lsbCBzdXNwZW5kIGFnYWluIGJlY2F1c2UgaWYgaXQgaGFzXG4gICAgICAgICAgICAgIC8vIGJlZW4gdW5zdXNwZW5kZWQgaXQgaGFzIGNvbW1pdHRlZCBhcyBhIHJlZ3VsYXIgU3VzcGVuc2UgY29tcG9uZW50LlxuICAgICAgICAgICAgICAvLyBJZiBpdCBuZWVkcyB0byBiZSByZXRyaWVkLCBpdCBzaG91bGQgaGF2ZSB3b3JrIHNjaGVkdWxlZCBvbiBpdC5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEJlZm9yZSBlbnRlcmluZyB0aGUgYmVnaW4gcGhhc2UsIGNsZWFyIHRoZSBleHBpcmF0aW9uIHRpbWUuXG4gIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfZWxlbWVudFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgX2VsZW1lbnRUeXBlLCB1cGRhdGVFeHBpcmF0aW9uVGltZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIHVucmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gX0NvbXBvbmVudCA/IHVucmVzb2x2ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoX0NvbXBvbmVudCwgdW5yZXNvbHZlZFByb3BzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID09PSBfQ29tcG9uZW50MiA/IF91bnJlc29sdmVkUHJvcHMgOiByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQyLCBfdW5yZXNvbHZlZFByb3BzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBfQ29tcG9uZW50MiwgX3Jlc29sdmVkUHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzKTtcbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHtcbiAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczIgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZSA9PT0gdHlwZSA/IF91bnJlc29sdmVkUHJvcHMyIDogcmVzb2x2ZURlZmF1bHRQcm9wcyh0eXBlLCBfdW5yZXNvbHZlZFByb3BzMik7XG4gICAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBfcmVzb2x2ZWRQcm9wczIsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX3R5cGUyID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICAvLyBSZXNvbHZlIG91dGVyIHByb3BzIGZpcnN0LCB0aGVuIHJlc29sdmUgaW5uZXIgcHJvcHMuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczMgPSByZXNvbHZlRGVmYXVsdFByb3BzKF90eXBlMiwgX3VucmVzb2x2ZWRQcm9wczMpO1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnR5cGUgIT09IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgb3V0ZXJQcm9wVHlwZXMgPSBfdHlwZTIucHJvcFR5cGVzO1xuICAgICAgICAgICAgaWYgKG91dGVyUHJvcFR5cGVzKSB7XG4gICAgICAgICAgICAgIGNoZWNrUHJvcFR5cGVzKG91dGVyUHJvcFR5cGVzLCBfcmVzb2x2ZWRQcm9wczMsIC8vIFJlc29sdmVkIGZvciBvdXRlciBvbmx5XG4gICAgICAgICAgICAgICdwcm9wJywgZ2V0Q29tcG9uZW50TmFtZShfdHlwZTIpLCBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3Jlc29sdmVkUHJvcHMzID0gcmVzb2x2ZURlZmF1bHRQcm9wcyhfdHlwZTIudHlwZSwgX3Jlc29sdmVkUHJvcHMzKTtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIF90eXBlMiwgX3Jlc29sdmVkUHJvcHMzLCB1cGRhdGVFeHBpcmF0aW9uVGltZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgdXBkYXRlRXhwaXJhdGlvblRpbWUsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9Db21wb25lbnQzID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHM0ID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHM0ID0gd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPT09IF9Db21wb25lbnQzID8gX3VucmVzb2x2ZWRQcm9wczQgOiByZXNvbHZlRGVmYXVsdFByb3BzKF9Db21wb25lbnQzLCBfdW5yZXNvbHZlZFByb3BzNCk7XG4gICAgICAgIHJldHVybiBtb3VudEluY29tcGxldGVDbGFzc0NvbXBvbmVudChjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudDMsIF9yZXNvbHZlZFByb3BzNCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIGNhc2UgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcikge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbnZhciB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcblxudmFyIHJlbmRlcmVyU2lnaWwgPSB2b2lkIDA7XG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG52YXIgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbnZhciBsYXN0Q29udGV4dFdpdGhBbGxCaXRzT2JzZXJ2ZWQgPSBudWxsO1xuXG52YXIgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuXG5mdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNlcygpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG4gIC8vIGNhbm5vdCBiZSBjYWxsZWQgb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IG51bGw7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpIHtcbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpIHtcbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgbmV4dFZhbHVlKSB7XG4gIHZhciBjb250ZXh0ID0gcHJvdmlkZXJGaWJlci50eXBlLl9jb250ZXh0O1xuXG4gIGlmIChpc1ByaW1hcnlSZW5kZXJlcikge1xuICAgIHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSwgcHJvdmlkZXJGaWJlcik7XG5cbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0VmFsdWU7XG4gICAge1xuICAgICAgIShjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPT09IHVuZGVmaW5lZCB8fCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPT09IG51bGwgfHwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID09PSByZW5kZXJlclNpZ2lsKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwdXNoKHZhbHVlQ3Vyc29yLCBjb250ZXh0Ll9jdXJyZW50VmFsdWUyLCBwcm92aWRlckZpYmVyKTtcblxuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBuZXh0VmFsdWU7XG4gICAge1xuICAgICAgIShjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID09PSB1bmRlZmluZWQgfHwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9PT0gbnVsbCB8fCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID09PSByZW5kZXJlclNpZ2lsKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wUHJvdmlkZXIocHJvdmlkZXJGaWJlcikge1xuICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcblxuICBwb3AodmFsdWVDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xuXG4gIHZhciBjb250ZXh0ID0gcHJvdmlkZXJGaWJlci50eXBlLl9jb250ZXh0O1xuICBpZiAoaXNQcmltYXJ5UmVuZGVyZXIpIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBjdXJyZW50VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IGN1cnJlbnRWYWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVDaGFuZ2VkQml0cyhjb250ZXh0LCBuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgaWYgKGlzKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAvLyBObyBjaGFuZ2VcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY2hhbmdlZEJpdHMgPSB0eXBlb2YgY29udGV4dC5fY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicgPyBjb250ZXh0Ll9jYWxjdWxhdGVDaGFuZ2VkQml0cyhvbGRWYWx1ZSwgbmV3VmFsdWUpIDogbWF4U2lnbmVkMzFCaXRJbnQ7XG5cbiAgICB7XG4gICAgICAhKChjaGFuZ2VkQml0cyAmIG1heFNpZ25lZDMxQml0SW50KSA9PT0gY2hhbmdlZEJpdHMpID8gd2FybmluZyQxKGZhbHNlLCAnY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IEV4cGVjdGVkIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgYSAnICsgJzMxLWJpdCBpbnRlZ2VyLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNoYW5nZWRCaXRzKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWRCaXRzIHwgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVdvcmtPblBhcmVudFBhdGgocGFyZW50LCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAvLyBVcGRhdGUgdGhlIGNoaWxkIGV4cGlyYXRpb24gdGltZSBvZiBhbGwgdGhlIGFuY2VzdG9ycywgaW5jbHVkaW5nXG4gIC8vIHRoZSBhbHRlcm5hdGVzLlxuICB2YXIgbm9kZSA9IHBhcmVudDtcbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICB2YXIgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGU7XG4gICAgaWYgKG5vZGUuY2hpbGRFeHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBub2RlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICBhbHRlcm5hdGUuY2hpbGRFeHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lIDwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgYWx0ZXJuYXRlIHdhcyB1cGRhdGVkLCB3aGljaCBtZWFucyB0aGUgcmVzdCBvZiB0aGVcbiAgICAgIC8vIGFuY2VzdG9yIHBhdGggYWxyZWFkeSBoYXMgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgY2hhbmdlZEJpdHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICBpZiAoZmliZXIgIT09IG51bGwpIHtcbiAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICBmaWJlci5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dEZpYmVyID0gdm9pZCAwO1xuXG4gICAgLy8gVmlzaXQgdGhpcyBmaWJlci5cbiAgICB2YXIgbGlzdCA9IGZpYmVyLmNvbnRleHREZXBlbmRlbmNpZXM7XG4gICAgaWYgKGxpc3QgIT09IG51bGwpIHtcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGxpc3QuZmlyc3Q7XG4gICAgICB3aGlsZSAoZGVwZW5kZW5jeSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGV4dCBtYXRjaGVzLlxuICAgICAgICBpZiAoZGVwZW5kZW5jeS5jb250ZXh0ID09PSBjb250ZXh0ICYmIChkZXBlbmRlbmN5Lm9ic2VydmVkQml0cyAmIGNoYW5nZWRCaXRzKSAhPT0gMCkge1xuICAgICAgICAgIC8vIE1hdGNoISBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhpcyBmaWJlci5cblxuICAgICAgICAgIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIGZvcmNlIHVwZGF0ZSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcy5cbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUocmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgICAgLy8gVE9ETzogQmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgd29yay1pbi1wcm9ncmVzcywgdGhpcyB3aWxsIGFkZCB0aGVcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0aGUgY3VycmVudCBmaWJlciwgdG9vLCB3aGljaCBtZWFucyBpdCB3aWxsIHBlcnNpc3QgZXZlbiBpZlxuICAgICAgICAgICAgLy8gdGhpcyByZW5kZXIgaXMgdGhyb3duIGF3YXkuIFNpbmNlIGl0J3MgYSByYWNlIGNvbmRpdGlvbiwgbm90IHN1cmUgaXQnc1xuICAgICAgICAgICAgLy8gd29ydGggZml4aW5nLlxuICAgICAgICAgICAgZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmliZXIuZXhwaXJhdGlvblRpbWUgPCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgICAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgICBhbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY2hlZHVsZVdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgICAgICAvLyBNYXJrIHRoZSBleHBpcmF0aW9uIHRpbWUgb24gdGhlIGxpc3QsIHRvby5cbiAgICAgICAgICBpZiAobGlzdC5leHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgICBsaXN0LmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2luY2Ugd2UgYWxyZWFkeSBmb3VuZCBhIG1hdGNoLCB3ZSBjYW4gc3RvcCB0cmF2ZXJzaW5nIHRoZVxuICAgICAgICAgIC8vIGRlcGVuZGVuY3kgbGlzdC5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jeS5uZXh0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBDb250ZXh0UHJvdmlkZXIpIHtcbiAgICAgIC8vIERvbid0IHNjYW4gZGVlcGVyIGlmIHRoaXMgaXMgYSBtYXRjaGluZyBwcm92aWRlclxuICAgICAgbmV4dEZpYmVyID0gZmliZXIudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MudHlwZSA/IG51bGwgOiBmaWJlci5jaGlsZDtcbiAgICB9IGVsc2UgaWYgKGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIgJiYgZmliZXIudGFnID09PSBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgIC8vIElmIGEgZGVoeWRyYXRlZCBzdXNwZW5zZSBjb21wb25lbnQgaXMgaW4gdGhpcyBzdWJ0cmVlLCB3ZSBkb24ndCBrbm93XG4gICAgICAvLyBpZiBpdCB3aWxsIGhhdmUgYW55IGNvbnRleHQgY29uc3VtZXJzIGluIGl0LiBUaGUgYmVzdCB3ZSBjYW4gZG8gaXNcbiAgICAgIC8vIG1hcmsgaXQgYXMgaGF2aW5nIHVwZGF0ZXMgb24gaXRzIGNoaWxkcmVuLlxuICAgICAgaWYgKGZpYmVyLmV4cGlyYXRpb25UaW1lIDwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIHZhciBfYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwgJiYgX2FsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA8IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIF9hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBwYXNzaW5nIHRoaXMgZmliZXIgYXMgdGhlIHBhcmVudFxuICAgICAgLy8gYmVjYXVzZSB3ZSB3YW50IHRvIHNjaGVkdWxlIHRoaXMgZmliZXIgYXMgaGF2aW5nIHdvcmtcbiAgICAgIC8vIG9uIGl0cyBjaGlsZHJlbi4gV2UnbGwgdXNlIHRoZSBjaGlsZEV4cGlyYXRpb25UaW1lIG9uXG4gICAgICAvLyB0aGlzIGZpYmVyIHRvIGluZGljYXRlIHRoYXQgYSBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAgICAgc2NoZWR1bGVXb3JrT25QYXJlbnRQYXRoKGZpYmVyLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5zaWJsaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUcmF2ZXJzZSBkb3duLlxuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG5leHRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgY2hpbGQgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgICBuZXh0RmliZXIucmV0dXJuID0gZmliZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNoaWxkLiBUcmF2ZXJzZSB0byBuZXh0IHNpYmxpbmcuXG4gICAgICBuZXh0RmliZXIgPSBmaWJlcjtcbiAgICAgIHdoaWxlIChuZXh0RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHRGaWJlciA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAvLyBXZSdyZSBiYWNrIHRvIHRoZSByb290IG9mIHRoaXMgc3VidHJlZS4gRXhpdC5cbiAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV4dEZpYmVyLnNpYmxpbmc7XG4gICAgICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgc2libGluZyB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgICAgICBzaWJsaW5nLnJldHVybiA9IG5leHRGaWJlci5yZXR1cm47XG4gICAgICAgICAgbmV4dEZpYmVyID0gc2libGluZztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBObyBtb3JlIHNpYmxpbmdzLiBUcmF2ZXJzZSB1cC5cbiAgICAgICAgbmV4dEZpYmVyID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgZmliZXIgPSBuZXh0RmliZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RDb250ZXh0V2l0aEFsbEJpdHNPYnNlcnZlZCA9IG51bGw7XG5cbiAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSB3b3JrSW5Qcm9ncmVzcy5jb250ZXh0RGVwZW5kZW5jaWVzO1xuICBpZiAoY3VycmVudERlcGVuZGVuY2llcyAhPT0gbnVsbCAmJiBjdXJyZW50RGVwZW5kZW5jaWVzLmV4cGlyYXRpb25UaW1lID49IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gQ29udGV4dCBsaXN0IGhhcyBhIHBlbmRpbmcgdXBkYXRlLiBNYXJrIHRoYXQgdGhpcyBmaWJlciBwZXJmb3JtZWQgd29yay5cbiAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgbGlzdFxuICB3b3JrSW5Qcm9ncmVzcy5jb250ZXh0RGVwZW5kZW5jaWVzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCwgb2JzZXJ2ZWRCaXRzKSB7XG4gIHtcbiAgICAvLyBUaGlzIHdhcm5pbmcgd291bGQgZmlyZSBpZiB5b3UgcmVhZCBjb250ZXh0IGluc2lkZSBhIEhvb2sgbGlrZSB1c2VNZW1vLlxuICAgIC8vIFVubGlrZSB0aGUgY2xhc3MgY2hlY2sgYmVsb3csIGl0J3Mgbm90IGVuZm9yY2VkIGluIHByb2R1Y3Rpb24gZm9yIHBlcmYuXG4gICAgISFpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID8gd2FybmluZyQxKGZhbHNlLCAnQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJykgOiB2b2lkIDA7XG4gIH1cblxuICBpZiAobGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID09PSBjb250ZXh0KSB7XG4gICAgLy8gTm90aGluZyB0byBkby4gV2UgYWxyZWFkeSBvYnNlcnZlIGV2ZXJ5dGhpbmcgaW4gdGhpcyBjb250ZXh0LlxuICB9IGVsc2UgaWYgKG9ic2VydmVkQml0cyA9PT0gZmFsc2UgfHwgb2JzZXJ2ZWRCaXRzID09PSAwKSB7XG4gICAgLy8gRG8gbm90IG9ic2VydmUgYW55IHVwZGF0ZXMuXG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc29sdmVkT2JzZXJ2ZWRCaXRzID0gdm9pZCAwOyAvLyBBdm9pZCBkZW9wdGluZyBvbiBvYnNlcnZhYmxlIGFyZ3VtZW50cyBvciBoZXRlcm9nZW5lb3VzIHR5cGVzLlxuICAgIGlmICh0eXBlb2Ygb2JzZXJ2ZWRCaXRzICE9PSAnbnVtYmVyJyB8fCBvYnNlcnZlZEJpdHMgPT09IG1heFNpZ25lZDMxQml0SW50KSB7XG4gICAgICAvLyBPYnNlcnZlIGFsbCB1cGRhdGVzLlxuICAgICAgbGFzdENvbnRleHRXaXRoQWxsQml0c09ic2VydmVkID0gY29udGV4dDtcbiAgICAgIHJlc29sdmVkT2JzZXJ2ZWRCaXRzID0gbWF4U2lnbmVkMzFCaXRJbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVkT2JzZXJ2ZWRCaXRzID0gb2JzZXJ2ZWRCaXRzO1xuICAgIH1cblxuICAgIHZhciBjb250ZXh0SXRlbSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBvYnNlcnZlZEJpdHM6IHJlc29sdmVkT2JzZXJ2ZWRCaXRzLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdENvbnRleHREZXBlbmRlbmN5ID09PSBudWxsKSB7XG4gICAgICAhKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuIEluIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIEluIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCBpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpIDogdm9pZCAwO1xuXG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBkZXBlbmRlbmN5IGZvciB0aGlzIGNvbXBvbmVudC4gQ3JlYXRlIGEgbmV3IGxpc3QuXG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjb250ZXh0SXRlbTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyLmNvbnRleHREZXBlbmRlbmNpZXMgPSB7XG4gICAgICAgIGZpcnN0OiBjb250ZXh0SXRlbSxcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IE5vV29ya1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIGEgbmV3IGNvbnRleHQgaXRlbS5cbiAgICAgIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IGxhc3RDb250ZXh0RGVwZW5kZW5jeS5uZXh0ID0gY29udGV4dEl0ZW07XG4gICAgfVxuICB9XG4gIHJldHVybiBpc1ByaW1hcnlSZW5kZXJlciA/IGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG59XG5cbi8vIFVwZGF0ZVF1ZXVlIGlzIGEgbGlua2VkIGxpc3Qgb2YgcHJpb3JpdGl6ZWQgdXBkYXRlcy5cbi8vXG4vLyBMaWtlIGZpYmVycywgdXBkYXRlIHF1ZXVlcyBjb21lIGluIHBhaXJzOiBhIGN1cnJlbnQgcXVldWUsIHdoaWNoIHJlcHJlc2VudHNcbi8vIHRoZSB2aXNpYmxlIHN0YXRlIG9mIHRoZSBzY3JlZW4sIGFuZCBhIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIHdoaWNoIGNhbiBiZVxuLy8gbXV0YXRlZCBhbmQgcHJvY2Vzc2VkIGFzeW5jaHJvbm91c2x5IGJlZm9yZSBpdCBpcyBjb21taXR0ZWQg4oCUIGEgZm9ybSBvZlxuLy8gZG91YmxlIGJ1ZmZlcmluZy4gSWYgYSB3b3JrLWluLXByb2dyZXNzIHJlbmRlciBpcyBkaXNjYXJkZWQgYmVmb3JlIGZpbmlzaGluZyxcbi8vIHdlIGNyZWF0ZSBhIG5ldyB3b3JrLWluLXByb2dyZXNzIGJ5IGNsb25pbmcgdGhlIGN1cnJlbnQgcXVldWUuXG4vL1xuLy8gQm90aCBxdWV1ZXMgc2hhcmUgYSBwZXJzaXN0ZW50LCBzaW5nbHktbGlua2VkIGxpc3Qgc3RydWN0dXJlLiBUbyBzY2hlZHVsZSBhblxuLy8gdXBkYXRlLCB3ZSBhcHBlbmQgaXQgdG8gdGhlIGVuZCBvZiBib3RoIHF1ZXVlcy4gRWFjaCBxdWV1ZSBtYWludGFpbnMgYVxuLy8gcG9pbnRlciB0byBmaXJzdCB1cGRhdGUgaW4gdGhlIHBlcnNpc3RlbnQgbGlzdCB0aGF0IGhhc24ndCBiZWVuIHByb2Nlc3NlZC5cbi8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHBvaW50ZXIgYWx3YXlzIGhhcyBhIHBvc2l0aW9uIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhblxuLy8gdGhlIGN1cnJlbnQgcXVldWUsIHNpbmNlIHdlIGFsd2F5cyB3b3JrIG9uIHRoYXQgb25lLiBUaGUgY3VycmVudCBxdWV1ZSdzXG4vLyBwb2ludGVyIGlzIG9ubHkgdXBkYXRlZCBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSwgd2hlbiB3ZSBzd2FwIGluIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcy5cbi8vXG4vLyBGb3IgZXhhbXBsZTpcbi8vXG4vLyAgIEN1cnJlbnQgcG9pbnRlcjogICAgICAgICAgIEEgLSBCIC0gQyAtIEQgLSBFIC0gRlxuLy8gICBXb3JrLWluLXByb2dyZXNzIHBvaW50ZXI6ICAgICAgICAgICAgICBEIC0gRSAtIEZcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXlxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBoYXNcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkIG1vcmUgdXBkYXRlcyB0aGFuIGN1cnJlbnQuXG4vL1xuLy8gVGhlIHJlYXNvbiB3ZSBhcHBlbmQgdG8gYm90aCBxdWV1ZXMgaXMgYmVjYXVzZSBvdGhlcndpc2Ugd2UgbWlnaHQgZHJvcFxuLy8gdXBkYXRlcyB3aXRob3V0IGV2ZXIgcHJvY2Vzc2luZyB0aGVtLiBGb3IgZXhhbXBsZSwgaWYgd2Ugb25seSBhZGQgdXBkYXRlcyB0b1xuLy8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIHNvbWUgdXBkYXRlcyBjb3VsZCBiZSBsb3N0IHdoZW5ldmVyIGEgd29yay1pblxuLy8gLXByb2dyZXNzIHJlbmRlciByZXN0YXJ0cyBieSBjbG9uaW5nIGZyb20gY3VycmVudC4gU2ltaWxhcmx5LCBpZiB3ZSBvbmx5IGFkZFxuLy8gdXBkYXRlcyB0byB0aGUgY3VycmVudCBxdWV1ZSwgdGhlIHVwZGF0ZXMgd2lsbCBiZSBsb3N0IHdoZW5ldmVyIGFuIGFscmVhZHlcbi8vIGluLXByb2dyZXNzIHF1ZXVlIGNvbW1pdHMgYW5kIHN3YXBzIHdpdGggdGhlIGN1cnJlbnQgcXVldWUuIEhvd2V2ZXIsIGJ5XG4vLyBhZGRpbmcgdG8gYm90aCBxdWV1ZXMsIHdlIGd1YXJhbnRlZSB0aGF0IHRoZSB1cGRhdGUgd2lsbCBiZSBwYXJ0IG9mIHRoZSBuZXh0XG4vLyB3b3JrLWluLXByb2dyZXNzLiAoQW5kIGJlY2F1c2UgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgYmVjb21lcyB0aGVcbi8vIGN1cnJlbnQgcXVldWUgb25jZSBpdCBjb21taXRzLCB0aGVyZSdzIG5vIGRhbmdlciBvZiBhcHBseWluZyB0aGUgc2FtZVxuLy8gdXBkYXRlIHR3aWNlLilcbi8vXG4vLyBQcmlvcml0aXphdGlvblxuLy8gLS0tLS0tLS0tLS0tLS1cbi8vXG4vLyBVcGRhdGVzIGFyZSBub3Qgc29ydGVkIGJ5IHByaW9yaXR5LCBidXQgYnkgaW5zZXJ0aW9uOyBuZXcgdXBkYXRlcyBhcmUgYWx3YXlzXG4vLyBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuLy9cbi8vIFRoZSBwcmlvcml0eSBpcyBzdGlsbCBpbXBvcnRhbnQsIHRob3VnaC4gV2hlbiBwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWVcbi8vIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBvbmx5IHRoZSB1cGRhdGVzIHdpdGggc3VmZmljaWVudCBwcmlvcml0eSBhcmVcbi8vIGluY2x1ZGVkIGluIHRoZSByZXN1bHQuIElmIHdlIHNraXAgYW4gdXBkYXRlIGJlY2F1c2UgaXQgaGFzIGluc3VmZmljaWVudFxuLy8gcHJpb3JpdHksIGl0IHJlbWFpbnMgaW4gdGhlIHF1ZXVlIHRvIGJlIHByb2Nlc3NlZCBsYXRlciwgZHVyaW5nIGEgbG93ZXJcbi8vIHByaW9yaXR5IHJlbmRlci4gQ3J1Y2lhbGx5LCBhbGwgdXBkYXRlcyBzdWJzZXF1ZW50IHRvIGEgc2tpcHBlZCB1cGRhdGUgYWxzb1xuLy8gcmVtYWluIGluIHRoZSBxdWV1ZSAqcmVnYXJkbGVzcyBvZiB0aGVpciBwcmlvcml0eSouIFRoYXQgbWVhbnMgaGlnaCBwcmlvcml0eVxuLy8gdXBkYXRlcyBhcmUgc29tZXRpbWVzIHByb2Nlc3NlZCB0d2ljZSwgYXQgdHdvIHNlcGFyYXRlIHByaW9yaXRpZXMuIFdlIGFsc29cbi8vIGtlZXAgdHJhY2sgb2YgYSBiYXNlIHN0YXRlLCB0aGF0IHJlcHJlc2VudHMgdGhlIHN0YXRlIGJlZm9yZSB0aGUgZmlyc3Rcbi8vIHVwZGF0ZSBpbiB0aGUgcXVldWUgaXMgYXBwbGllZC5cbi8vXG4vLyBGb3IgZXhhbXBsZTpcbi8vXG4vLyAgIEdpdmVuIGEgYmFzZSBzdGF0ZSBvZiAnJywgYW5kIHRoZSBmb2xsb3dpbmcgcXVldWUgb2YgdXBkYXRlc1xuLy9cbi8vICAgICBBMSAtIEIyIC0gQzEgLSBEMlxuLy9cbi8vICAgd2hlcmUgdGhlIG51bWJlciBpbmRpY2F0ZXMgdGhlIHByaW9yaXR5LCBhbmQgdGhlIHVwZGF0ZSBpcyBhcHBsaWVkIHRvIHRoZVxuLy8gICBwcmV2aW91cyBzdGF0ZSBieSBhcHBlbmRpbmcgYSBsZXR0ZXIsIFJlYWN0IHdpbGwgcHJvY2VzcyB0aGVzZSB1cGRhdGVzIGFzXG4vLyAgIHR3byBzZXBhcmF0ZSByZW5kZXJzLCBvbmUgcGVyIGRpc3RpbmN0IHByaW9yaXR5IGxldmVsOlxuLy9cbi8vICAgRmlyc3QgcmVuZGVyLCBhdCBwcmlvcml0eSAxOlxuLy8gICAgIEJhc2Ugc3RhdGU6ICcnXG4vLyAgICAgVXBkYXRlczogW0ExLCBDMV1cbi8vICAgICBSZXN1bHQgc3RhdGU6ICdBQydcbi8vXG4vLyAgIFNlY29uZCByZW5kZXIsIGF0IHByaW9yaXR5IDI6XG4vLyAgICAgQmFzZSBzdGF0ZTogJ0EnICAgICAgICAgICAgPC0gIFRoZSBiYXNlIHN0YXRlIGRvZXMgbm90IGluY2x1ZGUgQzEsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlY2F1c2UgQjIgd2FzIHNraXBwZWQuXG4vLyAgICAgVXBkYXRlczogW0IyLCBDMSwgRDJdICAgICAgPC0gIEMxIHdhcyByZWJhc2VkIG9uIHRvcCBvZiBCMlxuLy8gICAgIFJlc3VsdCBzdGF0ZTogJ0FCQ0QnXG4vL1xuLy8gQmVjYXVzZSB3ZSBwcm9jZXNzIHVwZGF0ZXMgaW4gaW5zZXJ0aW9uIG9yZGVyLCBhbmQgcmViYXNlIGhpZ2ggcHJpb3JpdHlcbi8vIHVwZGF0ZXMgd2hlbiBwcmVjZWRpbmcgdXBkYXRlcyBhcmUgc2tpcHBlZCwgdGhlIGZpbmFsIHJlc3VsdCBpcyBkZXRlcm1pbmlzdGljXG4vLyByZWdhcmRsZXNzIG9mIHByaW9yaXR5LiBJbnRlcm1lZGlhdGUgc3RhdGUgbWF5IHZhcnkgYWNjb3JkaW5nIHRvIHN5c3RlbVxuLy8gcmVzb3VyY2VzLCBidXQgdGhlIGZpbmFsIHN0YXRlIGlzIGFsd2F5cyB0aGUgc2FtZS5cblxudmFyIFVwZGF0ZVN0YXRlID0gMDtcbnZhciBSZXBsYWNlU3RhdGUgPSAxO1xudmFyIEZvcmNlVXBkYXRlID0gMjtcbnZhciBDYXB0dXJlVXBkYXRlID0gMztcblxuLy8gR2xvYmFsIHN0YXRlIHRoYXQgaXMgcmVzZXQgYXQgdGhlIGJlZ2lubmluZyBvZiBjYWxsaW5nIGBwcm9jZXNzVXBkYXRlUXVldWVgLlxuLy8gSXQgc2hvdWxkIG9ubHkgYmUgcmVhZCByaWdodCBhZnRlciBjYWxsaW5nIGBwcm9jZXNzVXBkYXRlUXVldWVgLCB2aWFcbi8vIGBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nYC5cbnZhciBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG52YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHZvaWQgMDtcbnZhciBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSB2b2lkIDA7XG52YXIgcmVzZXRDdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSB2b2lkIDA7XG57XG4gIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbiAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgcmVzZXRDdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlUXVldWUoYmFzZVN0YXRlKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGJhc2VTdGF0ZSxcbiAgICBmaXJzdFVwZGF0ZTogbnVsbCxcbiAgICBsYXN0VXBkYXRlOiBudWxsLFxuICAgIGZpcnN0Q2FwdHVyZWRVcGRhdGU6IG51bGwsXG4gICAgbGFzdENhcHR1cmVkVXBkYXRlOiBudWxsLFxuICAgIGZpcnN0RWZmZWN0OiBudWxsLFxuICAgIGxhc3RFZmZlY3Q6IG51bGwsXG4gICAgZmlyc3RDYXB0dXJlZEVmZmVjdDogbnVsbCxcbiAgICBsYXN0Q2FwdHVyZWRFZmZlY3Q6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnRRdWV1ZSkge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgIGZpcnN0VXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RVcGRhdGUsXG4gICAgbGFzdFVwZGF0ZTogY3VycmVudFF1ZXVlLmxhc3RVcGRhdGUsXG5cbiAgICAvLyBUT0RPOiBXaXRoIHJlc3VtaW5nLCBpZiB3ZSBiYWlsIG91dCBhbmQgcmVzdXNlIHRoZSBjaGlsZCB0cmVlLCB3ZSBzaG91bGRcbiAgICAvLyBrZWVwIHRoZXNlIGVmZmVjdHMuXG4gICAgZmlyc3RDYXB0dXJlZFVwZGF0ZTogbnVsbCxcbiAgICBsYXN0Q2FwdHVyZWRVcGRhdGU6IG51bGwsXG5cbiAgICBmaXJzdEVmZmVjdDogbnVsbCxcbiAgICBsYXN0RWZmZWN0OiBudWxsLFxuXG4gICAgZmlyc3RDYXB0dXJlZEVmZmVjdDogbnVsbCxcbiAgICBsYXN0Q2FwdHVyZWRFZmZlY3Q6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG5cbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG5cbiAgICBuZXh0OiBudWxsLFxuICAgIG5leHRFZmZlY3Q6IG51bGxcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kVXBkYXRlVG9RdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gIGlmIChxdWV1ZS5sYXN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgLy8gUXVldWUgaXMgZW1wdHlcbiAgICBxdWV1ZS5maXJzdFVwZGF0ZSA9IHF1ZXVlLmxhc3RVcGRhdGUgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgcXVldWUubGFzdFVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIHF1ZXVlLmxhc3RVcGRhdGUgPSB1cGRhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlKSB7XG4gIC8vIFVwZGF0ZSBxdWV1ZXMgYXJlIGNyZWF0ZWQgbGF6aWx5LlxuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICB2YXIgcXVldWUxID0gdm9pZCAwO1xuICB2YXIgcXVldWUyID0gdm9pZCAwO1xuICBpZiAoYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBvbmx5IG9uZSBmaWJlci5cbiAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgICBxdWV1ZTIgPSBudWxsO1xuICAgIGlmIChxdWV1ZTEgPT09IG51bGwpIHtcbiAgICAgIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUoZmliZXIubWVtb2l6ZWRTdGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIGFyZSB0d28gb3duZXJzLlxuICAgIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuICAgIHF1ZXVlMiA9IGFsdGVybmF0ZS51cGRhdGVRdWV1ZTtcbiAgICBpZiAocXVldWUxID09PSBudWxsKSB7XG4gICAgICBpZiAocXVldWUyID09PSBudWxsKSB7XG4gICAgICAgIC8vIE5laXRoZXIgZmliZXIgaGFzIGFuIHVwZGF0ZSBxdWV1ZS4gQ3JlYXRlIG5ldyBvbmVzLlxuICAgICAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKGZpYmVyLm1lbW9pemVkU3RhdGUpO1xuICAgICAgICBxdWV1ZTIgPSBhbHRlcm5hdGUudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbmx5IG9uZSBmaWJlciBoYXMgYW4gdXBkYXRlIHF1ZXVlLiBDbG9uZSB0byBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNsb25lVXBkYXRlUXVldWUocXVldWUyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBPbmx5IG9uZSBmaWJlciBoYXMgYW4gdXBkYXRlIHF1ZXVlLiBDbG9uZSB0byBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgICBxdWV1ZTIgPSBhbHRlcm5hdGUudXBkYXRlUXVldWUgPSBjbG9uZVVwZGF0ZVF1ZXVlKHF1ZXVlMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCb3RoIG93bmVycyBoYXZlIGFuIHVwZGF0ZSBxdWV1ZS5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHF1ZXVlMiA9PT0gbnVsbCB8fCBxdWV1ZTEgPT09IHF1ZXVlMikge1xuICAgIC8vIFRoZXJlJ3Mgb25seSBhIHNpbmdsZSBxdWV1ZS5cbiAgICBhcHBlbmRVcGRhdGVUb1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSBhcmUgdHdvIHF1ZXVlcy4gV2UgbmVlZCB0byBhcHBlbmQgdGhlIHVwZGF0ZSB0byBib3RoIHF1ZXVlcyxcbiAgICAvLyB3aGlsZSBhY2NvdW50aW5nIGZvciB0aGUgcGVyc2lzdGVudCBzdHJ1Y3R1cmUgb2YgdGhlIGxpc3Qg4oCUIHdlIGRvbid0XG4gICAgLy8gd2FudCB0aGUgc2FtZSB1cGRhdGUgdG8gYmUgYWRkZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgaWYgKHF1ZXVlMS5sYXN0VXBkYXRlID09PSBudWxsIHx8IHF1ZXVlMi5sYXN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgICAvLyBPbmUgb2YgdGhlIHF1ZXVlcyBpcyBub3QgZW1wdHkuIFdlIG11c3QgYWRkIHRoZSB1cGRhdGUgdG8gYm90aCBxdWV1ZXMuXG4gICAgICBhcHBlbmRVcGRhdGVUb1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgICAgIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUyLCB1cGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBCb3RoIHF1ZXVlcyBhcmUgbm9uLWVtcHR5LiBUaGUgbGFzdCB1cGRhdGUgaXMgdGhlIHNhbWUgaW4gYm90aCBsaXN0cyxcbiAgICAgIC8vIGJlY2F1c2Ugb2Ygc3RydWN0dXJhbCBzaGFyaW5nLiBTbywgb25seSBhcHBlbmQgdG8gb25lIG9mIHRoZSBsaXN0cy5cbiAgICAgIGFwcGVuZFVwZGF0ZVRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgICAgLy8gQnV0IHdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIHRoZSBgbGFzdFVwZGF0ZWAgcG9pbnRlciBvZiBxdWV1ZTIuXG4gICAgICBxdWV1ZTIubGFzdFVwZGF0ZSA9IHVwZGF0ZTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgJiYgKGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gcXVldWUxIHx8IHF1ZXVlMiAhPT0gbnVsbCAmJiBjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHF1ZXVlMikgJiYgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0FuIHVwZGF0ZSAoc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgb3IgZm9yY2VVcGRhdGUpIHdhcyBzY2hlZHVsZWQgJyArICdmcm9tIGluc2lkZSBhbiB1cGRhdGUgZnVuY3Rpb24uIFVwZGF0ZSBmdW5jdGlvbnMgc2hvdWxkIGJlIHB1cmUsICcgKyAnd2l0aCB6ZXJvIHNpZGUtZWZmZWN0cy4gQ29uc2lkZXIgdXNpbmcgY29tcG9uZW50RGlkVXBkYXRlIG9yIGEgJyArICdjYWxsYmFjay4nKTtcbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZSkge1xuICAvLyBDYXB0dXJlZCB1cGRhdGVzIGdvIGludG8gYSBzZXBhcmF0ZSBsaXN0LCBhbmQgb25seSBvbiB0aGUgd29yay1pbi1cbiAgLy8gcHJvZ3Jlc3MgcXVldWUuXG4gIHZhciB3b3JrSW5Qcm9ncmVzc1F1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1F1ZXVlID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVE9ETzogSSBwdXQgdGhpcyBoZXJlIHJhdGhlciB0aGFuIGNyZWF0ZVdvcmtJblByb2dyZXNzIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBjbG9uZSB0aGUgcXVldWUgdW5uZWNlc3NhcmlseS4gVGhlcmUncyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG9cbiAgICAvLyBzdHJ1Y3R1cmUgdGhpcy5cbiAgICB3b3JrSW5Qcm9ncmVzc1F1ZXVlID0gZW5zdXJlV29ya0luUHJvZ3Jlc3NRdWV1ZUlzQUNsb25lKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzc1F1ZXVlKTtcbiAgfVxuXG4gIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1F1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlbmRlciBwaGFzZSB1cGRhdGVcbiAgICB3b3JrSW5Qcm9ncmVzc1F1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGUgPSB3b3JrSW5Qcm9ncmVzc1F1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZSA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1F1ZXVlLmxhc3RDYXB0dXJlZFVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIHdvcmtJblByb2dyZXNzUXVldWUubGFzdENhcHR1cmVkVXBkYXRlID0gdXBkYXRlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVdvcmtJblByb2dyZXNzUXVldWVJc0FDbG9uZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUpIHtcbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgLy8gSWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgcXVldWUsXG4gICAgLy8gd2UgbmVlZCB0byBjbG9uZSBpdCBmaXJzdC5cbiAgICBpZiAocXVldWUgPT09IGN1cnJlbnQudXBkYXRlUXVldWUpIHtcbiAgICAgIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjbG9uZVVwZGF0ZVF1ZXVlKHF1ZXVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHF1ZXVlO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIHByZXZTdGF0ZSwgbmV4dFByb3BzLCBpbnN0YW5jZSkge1xuICBzd2l0Y2ggKHVwZGF0ZS50YWcpIHtcbiAgICBjYXNlIFJlcGxhY2VTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXlsb2FkID0gdXBkYXRlLnBheWxvYWQ7XG4gICAgICAgIGlmICh0eXBlb2YgX3BheWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyB8fCBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHNGb3JTdHJpY3RNb2RlICYmIHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgICAgIF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGF0ZSBvYmplY3RcbiAgICAgICAgcmV0dXJuIF9wYXlsb2FkO1xuICAgICAgfVxuICAgIGNhc2UgQ2FwdHVyZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG4gICAgY2FzZSBVcGRhdGVTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXlsb2FkMiA9IHVwZGF0ZS5wYXlsb2FkO1xuICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gdm9pZCAwO1xuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkMiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFVwZGF0ZXIgZnVuY3Rpb25cbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzIHx8IGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0c0ZvclN0cmljdE1vZGUgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdE1vZGUpIHtcbiAgICAgICAgICAgICAgX3BheWxvYWQyLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQyLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUGFydGlhbCBzdGF0ZSBvYmplY3RcbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIE51bGwgYW5kIHVuZGVmaW5lZCBhcmUgdHJlYXRlZCBhcyBuby1vcHMuXG4gICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuICAgICAgICByZXR1cm4gX2Fzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuICAgIGNhc2UgRm9yY2VVcGRhdGU6XG4gICAgICB7XG4gICAgICAgIGhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gcHJldlN0YXRlO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCBwcm9wcywgaW5zdGFuY2UsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgcXVldWUgPSBlbnN1cmVXb3JrSW5Qcm9ncmVzc1F1ZXVlSXNBQ2xvbmUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlKTtcblxuICB7XG4gICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gcXVldWU7XG4gIH1cblxuICAvLyBUaGVzZSB2YWx1ZXMgbWF5IGNoYW5nZSBhcyB3ZSBwcm9jZXNzIHRoZSBxdWV1ZS5cbiAgdmFyIG5ld0Jhc2VTdGF0ZSA9IHF1ZXVlLmJhc2VTdGF0ZTtcbiAgdmFyIG5ld0ZpcnN0VXBkYXRlID0gbnVsbDtcbiAgdmFyIG5ld0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiB1cGRhdGVzIHRvIGNvbXB1dGUgdGhlIHJlc3VsdC5cbiAgdmFyIHVwZGF0ZSA9IHF1ZXVlLmZpcnN0VXBkYXRlO1xuICB2YXIgcmVzdWx0U3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gIHdoaWxlICh1cGRhdGUgIT09IG51bGwpIHtcbiAgICB2YXIgdXBkYXRlRXhwaXJhdGlvblRpbWUgPSB1cGRhdGUuZXhwaXJhdGlvblRpbWU7XG4gICAgaWYgKHVwZGF0ZUV4cGlyYXRpb25UaW1lIDwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIGlmIChuZXdGaXJzdFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBza2lwcGVkIHVwZGF0ZS4gSXQgd2lsbCBiZSB0aGUgZmlyc3QgdXBkYXRlIGluXG4gICAgICAgIC8vIHRoZSBuZXcgbGlzdC5cbiAgICAgICAgbmV3Rmlyc3RVcGRhdGUgPSB1cGRhdGU7XG4gICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZSB0aGF0IHdhcyBza2lwcGVkLCB0aGUgY3VycmVudCByZXN1bHRcbiAgICAgICAgLy8gaXMgdGhlIG5ldyBiYXNlIHN0YXRlLlxuICAgICAgICBuZXdCYXNlU3RhdGUgPSByZXN1bHRTdGF0ZTtcbiAgICAgIH1cbiAgICAgIC8vIFNpbmNlIHRoaXMgdXBkYXRlIHdpbGwgcmVtYWluIGluIHRoZSBsaXN0LCB1cGRhdGUgdGhlIHJlbWFpbmluZ1xuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKG5ld0V4cGlyYXRpb25UaW1lIDwgdXBkYXRlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3RXhwaXJhdGlvblRpbWUgPSB1cGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFByb2Nlc3MgaXQgYW5kIGNvbXB1dGVcbiAgICAgIC8vIGEgbmV3IHJlc3VsdC5cbiAgICAgIHJlc3VsdFN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCByZXN1bHRTdGF0ZSwgcHJvcHMsIGluc3RhbmNlKTtcbiAgICAgIHZhciBfY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgICBpZiAoX2NhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDYWxsYmFjaztcbiAgICAgICAgLy8gU2V0IHRoaXMgdG8gbnVsbCwgaW4gY2FzZSBpdCB3YXMgbXV0YXRlZCBkdXJpbmcgYW4gYWJvcnRlZCByZW5kZXIuXG4gICAgICAgIHVwZGF0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgICAgaWYgKHF1ZXVlLmxhc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICBxdWV1ZS5maXJzdEVmZmVjdCA9IHF1ZXVlLmxhc3RFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcXVldWUubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RFZmZlY3QgPSB1cGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29udGludWUgdG8gdGhlIG5leHQgdXBkYXRlLlxuICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICB9XG5cbiAgLy8gU2VwYXJhdGVseSwgaXRlcmF0ZSB0aG91Z2ggdGhlIGxpc3Qgb2YgY2FwdHVyZWQgdXBkYXRlcy5cbiAgdmFyIG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUgPSBudWxsO1xuICB1cGRhdGUgPSBxdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIF91cGRhdGVFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAoX3VwZGF0ZUV4cGlyYXRpb25UaW1lIDwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgbm90IGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gU2tpcCBpdC5cbiAgICAgIGlmIChuZXdGaXJzdENhcHR1cmVkVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHNraXBwZWQgY2FwdHVyZWQgdXBkYXRlLiBJdCB3aWxsIGJlIHRoZSBmaXJzdFxuICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIG5ldyBsaXN0LlxuICAgICAgICBuZXdGaXJzdENhcHR1cmVkVXBkYXRlID0gdXBkYXRlO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUgdGhhdCB3YXMgc2tpcHBlZCwgdGhlIGN1cnJlbnQgcmVzdWx0IGlzXG4gICAgICAgIC8vIHRoZSBuZXcgYmFzZSBzdGF0ZS5cbiAgICAgICAgaWYgKG5ld0ZpcnN0VXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gcmVzdWx0U3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNpbmNlIHRoaXMgdXBkYXRlIHdpbGwgcmVtYWluIGluIHRoZSBsaXN0LCB1cGRhdGUgdGhlIHJlbWFpbmluZ1xuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKG5ld0V4cGlyYXRpb25UaW1lIDwgX3VwZGF0ZUV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gX3VwZGF0ZUV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS4gUHJvY2VzcyBpdCBhbmQgY29tcHV0ZVxuICAgICAgLy8gYSBuZXcgcmVzdWx0LlxuICAgICAgcmVzdWx0U3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIHJlc3VsdFN0YXRlLCBwcm9wcywgaW5zdGFuY2UpO1xuICAgICAgdmFyIF9jYWxsYmFjazIgPSB1cGRhdGUuY2FsbGJhY2s7XG4gICAgICBpZiAoX2NhbGxiYWNrMiAhPT0gbnVsbCkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ2FsbGJhY2s7XG4gICAgICAgIC8vIFNldCB0aGlzIHRvIG51bGwsIGluIGNhc2UgaXQgd2FzIG11dGF0ZWQgZHVyaW5nIGFuIGFib3J0ZWQgcmVuZGVyLlxuICAgICAgICB1cGRhdGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAgIGlmIChxdWV1ZS5sYXN0Q2FwdHVyZWRFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICBxdWV1ZS5maXJzdENhcHR1cmVkRWZmZWN0ID0gcXVldWUubGFzdENhcHR1cmVkRWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1ZXVlLmxhc3RDYXB0dXJlZEVmZmVjdC5uZXh0RWZmZWN0ID0gdXBkYXRlO1xuICAgICAgICAgIHF1ZXVlLmxhc3RDYXB0dXJlZEVmZmVjdCA9IHVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgfVxuXG4gIGlmIChuZXdGaXJzdFVwZGF0ZSA9PT0gbnVsbCkge1xuICAgIHF1ZXVlLmxhc3RVcGRhdGUgPSBudWxsO1xuICB9XG4gIGlmIChuZXdGaXJzdENhcHR1cmVkVXBkYXRlID09PSBudWxsKSB7XG4gICAgcXVldWUubGFzdENhcHR1cmVkVXBkYXRlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ2FsbGJhY2s7XG4gIH1cbiAgaWYgKG5ld0ZpcnN0VXBkYXRlID09PSBudWxsICYmIG5ld0ZpcnN0Q2FwdHVyZWRVcGRhdGUgPT09IG51bGwpIHtcbiAgICAvLyBXZSBwcm9jZXNzZWQgZXZlcnkgdXBkYXRlLCB3aXRob3V0IHNraXBwaW5nLiBUaGF0IG1lYW5zIHRoZSBuZXcgYmFzZVxuICAgIC8vIHN0YXRlIGlzIHRoZSBzYW1lIGFzIHRoZSByZXN1bHQgc3RhdGUuXG4gICAgbmV3QmFzZVN0YXRlID0gcmVzdWx0U3RhdGU7XG4gIH1cblxuICBxdWV1ZS5iYXNlU3RhdGUgPSBuZXdCYXNlU3RhdGU7XG4gIHF1ZXVlLmZpcnN0VXBkYXRlID0gbmV3Rmlyc3RVcGRhdGU7XG4gIHF1ZXVlLmZpcnN0Q2FwdHVyZWRVcGRhdGUgPSBuZXdGaXJzdENhcHR1cmVkVXBkYXRlO1xuXG4gIC8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuICAvLyBUaGlzIHNob3VsZCBiZSBmaW5lIGJlY2F1c2UgdGhlIG9ubHkgdHdvIG90aGVyIHRoaW5ncyB0aGF0IGNvbnRyaWJ1dGUgdG9cbiAgLy8gZXhwaXJhdGlvbiB0aW1lIGFyZSBwcm9wcyBhbmQgY29udGV4dC4gV2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIHRoZVxuICAvLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuICAvLyBkZWFsdCB3aXRoIHRoZSBwcm9wcy4gQ29udGV4dCBpbiBjb21wb25lbnRzIHRoYXQgc3BlY2lmeVxuICAvLyBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdHJpY2t5OyBidXQgd2UnbGwgaGF2ZSB0byBhY2NvdW50IGZvclxuICAvLyB0aGF0IHJlZ2FyZGxlc3MuXG4gIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gbmV3RXhwaXJhdGlvblRpbWU7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSByZXN1bHRTdGF0ZTtcblxuICB7XG4gICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgISh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgY2FsbGJhY2spIDogdm9pZCAwO1xuICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpIHtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHtcbiAgcmV0dXJuIGhhc0ZvcmNlVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRVcGRhdGVRdWV1ZShmaW5pc2hlZFdvcmssIGZpbmlzaGVkUXVldWUsIGluc3RhbmNlLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAvLyBJZiB0aGUgZmluaXNoZWQgcmVuZGVyIGluY2x1ZGVkIGNhcHR1cmVkIHVwZGF0ZXMsIGFuZCB0aGVyZSBhcmUgc3RpbGxcbiAgLy8gbG93ZXIgcHJpb3JpdHkgdXBkYXRlcyBsZWZ0IG92ZXIsIHdlIG5lZWQgdG8ga2VlcCB0aGUgY2FwdHVyZWQgdXBkYXRlc1xuICAvLyBpbiB0aGUgcXVldWUgc28gdGhhdCB0aGV5IGFyZSByZWJhc2VkIGFuZCBub3QgZHJvcHBlZCBvbmNlIHdlIHByb2Nlc3MgdGhlXG4gIC8vIHF1ZXVlIGFnYWluIGF0IHRoZSBsb3dlciBwcmlvcml0eS5cbiAgaWYgKGZpbmlzaGVkUXVldWUuZmlyc3RDYXB0dXJlZFVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIEpvaW4gdGhlIGNhcHR1cmVkIHVwZGF0ZSBsaXN0IHRvIHRoZSBlbmQgb2YgdGhlIG5vcm1hbCBsaXN0LlxuICAgIGlmIChmaW5pc2hlZFF1ZXVlLmxhc3RVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgIGZpbmlzaGVkUXVldWUubGFzdFVwZGF0ZS5uZXh0ID0gZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlO1xuICAgICAgZmluaXNoZWRRdWV1ZS5sYXN0VXBkYXRlID0gZmluaXNoZWRRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGU7XG4gICAgfVxuICAgIC8vIENsZWFyIHRoZSBsaXN0IG9mIGNhcHR1cmVkIHVwZGF0ZXMuXG4gICAgZmluaXNoZWRRdWV1ZS5maXJzdENhcHR1cmVkVXBkYXRlID0gZmluaXNoZWRRdWV1ZS5sYXN0Q2FwdHVyZWRVcGRhdGUgPSBudWxsO1xuICB9XG5cbiAgLy8gQ29tbWl0IHRoZSBlZmZlY3RzXG4gIGNvbW1pdFVwZGF0ZUVmZmVjdHMoZmluaXNoZWRRdWV1ZS5maXJzdEVmZmVjdCwgaW5zdGFuY2UpO1xuICBmaW5pc2hlZFF1ZXVlLmZpcnN0RWZmZWN0ID0gZmluaXNoZWRRdWV1ZS5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICBjb21taXRVcGRhdGVFZmZlY3RzKGZpbmlzaGVkUXVldWUuZmlyc3RDYXB0dXJlZEVmZmVjdCwgaW5zdGFuY2UpO1xuICBmaW5pc2hlZFF1ZXVlLmZpcnN0Q2FwdHVyZWRFZmZlY3QgPSBmaW5pc2hlZFF1ZXVlLmxhc3RDYXB0dXJlZEVmZmVjdCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFVwZGF0ZUVmZmVjdHMoZWZmZWN0LCBpbnN0YW5jZSkge1xuICB3aGlsZSAoZWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIF9jYWxsYmFjazMgPSBlZmZlY3QuY2FsbGJhY2s7XG4gICAgaWYgKF9jYWxsYmFjazMgIT09IG51bGwpIHtcbiAgICAgIGVmZmVjdC5jYWxsYmFjayA9IG51bGw7XG4gICAgICBjYWxsQ2FsbGJhY2soX2NhbGxiYWNrMywgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBlZmZlY3QgPSBlZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2UpIHtcbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yLCBjYWxsIHRoaXMgZnVuY3Rpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgdGhyb3duXG4gIC8vIHNvIHRoZSBzdGFjayBpcyBhY2N1cmF0ZS5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3RhY2s6IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gVGFnIHRoZSBmaWJlciB3aXRoIGFuIHVwZGF0ZSBlZmZlY3QuIFRoaXMgdHVybnMgYSBQbGFjZW1lbnQgaW50b1xuICAvLyBhIFBsYWNlbWVudEFuZFVwZGF0ZS5cbiAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKSB7XG4gIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG59XG5cbnZhciBhcHBlbmRBbGxDaGlsZHJlbiA9IHZvaWQgMDtcbnZhciB1cGRhdGVIb3N0Q29udGFpbmVyID0gdm9pZCAwO1xudmFyIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IHZvaWQgMDtcbnZhciB1cGRhdGVIb3N0VGV4dCQxID0gdm9pZCAwO1xuaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgLy8gTXV0YXRpb24gbW9kZVxuXG4gIGFwcGVuZEFsbENoaWxkcmVuID0gZnVuY3Rpb24gKHBhcmVudCwgd29ya0luUHJvZ3Jlc3MsIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSwgaXNIaWRkZW4pIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0YWwgY2hpbGQsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9O1xuXG4gIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBOb29wXG4gIH07XG4gIHVwZGF0ZUhvc3RDb21wb25lbnQkMSA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkIHRvXG4gICAgLy8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgICAgLy8gSW4gbXV0YXRpb24gbW9kZSwgdGhpcyBpcyBzdWZmaWNpZW50IGZvciBhIGJhaWxvdXQgYmVjYXVzZVxuICAgICAgLy8gd2Ugd29uJ3QgdG91Y2ggdGhpcyBub2RlIGV2ZW4gaWYgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgLy8gVE9ETzogRXhwZXJpZW5jaW5nIGFuIGVycm9yIHdoZXJlIG9sZFByb3BzIGlzIG51bGwuIFN1Z2dlc3RzIGEgaG9zdFxuICAgIC8vIGNvbXBvbmVudCBpcyBoaXR0aW5nIHRoZSByZXN1bWUgcGF0aC4gRmlndXJlIG91dCB3aHkuIFBvc3NpYmx5XG4gICAgLy8gcmVsYXRlZCB0byBgaGlkZGVuYC5cbiAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpO1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGlzIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9O1xuICB1cGRhdGVIb3N0VGV4dCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbn0gZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG5cbiAgYXBwZW5kQWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAocGFyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gICAgICBicmFuY2hlczogaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlKSB7XG4gICAgICAgICAgdmFyIHByb3BzID0gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSGlkZSBpdC5cbiAgICAgICAgICAgIGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNoaWxkIHdhcyBwcmV2aW91c2x5IGluc2lkZSBhIHRpbWVkIG91dCB0cmVlLiBJZiBpdCB3YXMgbm90XG4gICAgICAgICAgICAvLyB1cGRhdGVkIGR1cmluZyB0aGlzIHJlbmRlciwgaXQgbWF5IG5lZWQgdG8gYmUgdW5oaWRkZW4uIENsb25lXG4gICAgICAgICAgICAvLyBhZ2FpbiB0byBiZSBzdXJlLlxuICAgICAgICAgICAgaW5zdGFuY2UgPSBjbG9uZVVuaGlkZGVuSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUpIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IG5vZGUubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIF9pbnN0YW5jZSA9IGNyZWF0ZUhpZGRlblRleHRJbnN0YW5jZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfaW5zdGFuY2UgPSBjcmVhdGVUZXh0SW5zdGFuY2UodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zdGF0ZU5vZGUgPSBfaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgX2luc3RhbmNlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbm9kZS5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBuZXdTdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgb2xkSXNIaWRkZW4gPSBvbGRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgICB2YXIgbmV3SXNIaWRkZW4gPSBuZXdTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgICBpZiAob2xkSXNIaWRkZW4gIT09IG5ld0lzSGlkZGVuKSB7XG4gICAgICAgICAgICAvLyBUaGUgcGxhY2Vob2xkZXIgZWl0aGVyIGp1c3QgdGltZWQgb3V0IG9yIHN3aXRjaGVkIGJhY2sgdG8gdGhlIG5vcm1hbFxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gYWZ0ZXIgaGF2aW5nIHByZXZpb3VzbHkgdGltZWQgb3V0LiBUb2dnbGUgdGhlIHZpc2liaWxpdHkgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBkaXJlY3QgaG9zdCBjaGlsZHJlbi5cbiAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRQYXJlbnQgPSBuZXdJc0hpZGRlbiA/IG5vZGUuY2hpbGQgOiBub2RlO1xuICAgICAgICAgICAgaWYgKHByaW1hcnlDaGlsZFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIHByaW1hcnlDaGlsZFBhcmVudCwgdHJ1ZSwgbmV3SXNIaWRkZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxhYmVsc1xuICAgICAgICAgICAgYnJlYWsgYnJhbmNoZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29udGludWUgdHJhdmVyc2luZyBsaWtlIG5vcm1hbFxuICAgICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIGNvcnJlY3QgYnV0IEZsb3cgaXMgY29uZnVzZWQgYnkgdGhlIGxhYmVsZWQgYnJlYWsuXG4gICAgICBub2RlID0gbm9kZTtcbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH07XG5cbiAgLy8gQW4gdW5mb3J0dW5hdGUgZm9yayBvZiBhcHBlbmRBbGxDaGlsZHJlbiBiZWNhdXNlIHdlIGhhdmUgdHdvIGRpZmZlcmVudCBwYXJlbnQgdHlwZXMuXG4gIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbGFiZWxzXG4gICAgICBicmFuY2hlczogaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlKSB7XG4gICAgICAgICAgdmFyIHByb3BzID0gbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gbm9kZS50eXBlO1xuICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSGlkZSBpdC5cbiAgICAgICAgICAgIGluc3RhbmNlID0gY2xvbmVIaWRkZW5JbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGlzIGNoaWxkIHdhcyBwcmV2aW91c2x5IGluc2lkZSBhIHRpbWVkIG91dCB0cmVlLiBJZiBpdCB3YXMgbm90XG4gICAgICAgICAgICAvLyB1cGRhdGVkIGR1cmluZyB0aGlzIHJlbmRlciwgaXQgbWF5IG5lZWQgdG8gYmUgdW5oaWRkZW4uIENsb25lXG4gICAgICAgICAgICAvLyBhZ2FpbiB0byBiZSBzdXJlLlxuICAgICAgICAgICAgaW5zdGFuY2UgPSBjbG9uZVVuaGlkZGVuSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UyID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUpIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IG5vZGUubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIF9pbnN0YW5jZTIgPSBjcmVhdGVIaWRkZW5UZXh0SW5zdGFuY2UodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2luc3RhbmNlMiA9IGNyZWF0ZVRleHRJbnN0YW5jZSh0ZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTI7XG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBfaW5zdGFuY2UyKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbm9kZS5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgIHZhciBuZXdTdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgb2xkSXNIaWRkZW4gPSBvbGRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgICB2YXIgbmV3SXNIaWRkZW4gPSBuZXdTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgICBpZiAob2xkSXNIaWRkZW4gIT09IG5ld0lzSGlkZGVuKSB7XG4gICAgICAgICAgICAvLyBUaGUgcGxhY2Vob2xkZXIgZWl0aGVyIGp1c3QgdGltZWQgb3V0IG9yIHN3aXRjaGVkIGJhY2sgdG8gdGhlIG5vcm1hbFxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gYWZ0ZXIgaGF2aW5nIHByZXZpb3VzbHkgdGltZWQgb3V0LiBUb2dnbGUgdGhlIHZpc2liaWxpdHkgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBkaXJlY3QgaG9zdCBjaGlsZHJlbi5cbiAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRQYXJlbnQgPSBuZXdJc0hpZGRlbiA/IG5vZGUuY2hpbGQgOiBub2RlO1xuICAgICAgICAgICAgaWYgKHByaW1hcnlDaGlsZFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKGNvbnRhaW5lckNoaWxkU2V0LCBwcmltYXJ5Q2hpbGRQYXJlbnQsIHRydWUsIG5ld0lzSGlkZGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICAgICAgICAgIGJyZWFrIGJyYW5jaGVzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvbnRpbnVlIHRyYXZlcnNpbmcgbGlrZSBub3JtYWxcbiAgICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBjb3JyZWN0IGJ1dCBGbG93IGlzIGNvbmZ1c2VkIGJ5IHRoZSBsYWJlbGVkIGJyZWFrLlxuICAgICAgbm9kZSA9IG5vZGU7XG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9O1xuICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHBvcnRhbE9yUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG4gICAgICB2YXIgbmV3Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXIpO1xuICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lciwgbmV3Q2hpbGRTZXQpO1xuICAgIH1cbiAgfTtcbiAgdXBkYXRlSG9zdENvbXBvbmVudCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCB0aGVuIG5vbmUgb2Ygb3VyIGNoaWxkcmVuIGhhZCBhbnkgdXBkYXRlcy5cbiAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB3ZSBjYW4gcmV1c2UgYWxsIG9mIHRoZW0uXG4gICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKHJlY3ljbGFibGVJbnN0YW5jZSwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCk7XG4gICAgfVxuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiB1cGRhdGVQYXlsb2FkID09PSBudWxsKSB7XG4gICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgIC8vIE90aGVyd2lzZSBwYXJlbnRzIHdvbid0IGtub3cgdGhhdCB0aGVyZSBhcmUgbmV3IGNoaWxkcmVuIHRvIHByb3BhZ2F0ZSB1cHdhcmRzLlxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIGZhbHNlKTtcbiAgICB9XG4gIH07XG4gIHVwZGF0ZUhvc3RUZXh0JDEgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAvLyBXZSdsbCBoYXZlIHRvIG1hcmsgaXQgYXMgaGF2aW5nIGFuIGVmZmVjdCwgZXZlbiB0aG91Z2ggd2Ugd29uJ3QgdXNlIHRoZSBlZmZlY3QgZm9yIGFueXRoaW5nLlxuICAgICAgLy8gVGhpcyBsZXRzIHRoZSBwYXJlbnRzIGtub3cgdGhhdCBhdCBsZWFzdCBvbmUgb2YgdGhlaXIgY2hpbGRyZW4gaGFzIGNoYW5nZWQuXG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBObyBob3N0IG9wZXJhdGlvbnNcbiAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIE5vb3BcbiAgfTtcbiAgdXBkYXRlSG9zdENvbXBvbmVudCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgLy8gTm9vcFxuICB9O1xuICB1cGRhdGVIb3N0VGV4dCQxID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgLy8gTm9vcFxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgcG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBoeWRyYXRlZCwgcG9wIHNvIHRoYXQgd2UgY2FuIGRlbGV0ZSBhbnkgcmVtYWluaW5nIGNoaWxkcmVuXG4gICAgICAgICAgLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxuICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBUaGlzIHJlc2V0cyB0aGUgaGFja3kgc3RhdGUgdG8gZml4IGlzTW91bnRlZCBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQucmVmICE9PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgICAgICAgIG1hcmtSZWYkMSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgLy8gXCJzdGFja1wiIGFzIHRoZSBwYXJlbnQuIFRoZW4gYXBwZW5kIGNoaWxkcmVuIGFzIHdlIGdvIGluIGJlZ2luV29ya1xuICAgICAgICAgIC8vIG9yIGNvbXBsZXRlV29yayBkZXBlbmRpbmcgb24gd2Ugd2FudCB0byBhZGQgdGhlbiB0b3AtPmRvd24gb3JcbiAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgdmFyIHdhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGlmICh3YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgIC8vIHRvIGNvbnNvbGlkYXRlLlxuICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWRzIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cbiAgICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAgICAgbWFya1JlZiQxKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgdXBkYXRlSG9zdFRleHQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgISh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgX3Jvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBicmVhaztcbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkLiBSZS1yZW5kZXIgd2l0aCB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSByZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAvLyBEbyBub3QgcmVzZXQgdGhlIGVmZmVjdCBsaXN0LlxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0RGlkVGltZW91dCA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHByZXZEaWRUaW1lb3V0ID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIW5leHREaWRUaW1lb3V0ICYmIHByZXZEaWRUaW1lb3V0KSB7XG4gICAgICAgICAgLy8gV2UganVzdCBzd2l0Y2hlZCBmcm9tIHRoZSBmYWxsYmFjayB0byB0aGUgbm9ybWFsIGNoaWxkcmVuLiBEZWxldGVcbiAgICAgICAgICAvLyB0aGUgZmFsbGJhY2suXG4gICAgICAgICAgLy8gVE9ETzogV291bGQgaXQgYmUgYmV0dGVyIHRvIHN0b3JlIHRoZSBmYWxsYmFjayBmcmFnbWVudCBvblxuICAgICAgICAgIHZhciBjdXJyZW50RmFsbGJhY2tDaGlsZCA9IGN1cnJlbnQuY2hpbGQuc2libGluZztcbiAgICAgICAgICBpZiAoY3VycmVudEZhbGxiYWNrQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERlbGV0aW9ucyBnbyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdFxuICAgICAgICAgICAgdmFyIGZpcnN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgICBpZiAoZmlyc3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBjdXJyZW50RmFsbGJhY2tDaGlsZDtcbiAgICAgICAgICAgICAgY3VycmVudEZhbGxiYWNrQ2hpbGQubmV4dEVmZmVjdCA9IGZpcnN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gY3VycmVudEZhbGxiYWNrQ2hpbGQ7XG4gICAgICAgICAgICAgIGN1cnJlbnRGYWxsYmFja0NoaWxkLm5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudEZhbGxiYWNrQ2hpbGQuZWZmZWN0VGFnID0gRGVsZXRpb247XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0IHx8IHByZXZEaWRUaW1lb3V0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGNoaWxkcmVuIGFyZSBoaWRkZW4sIG9yIGlmIHRoZXkgd2VyZSBwcmV2aW91cyBoaWRkZW4sIHNjaGVkdWxlXG4gICAgICAgICAgLy8gYW4gZWZmZWN0IHRvIHRvZ2dsZSB0aGVpciB2aXNpYmlsaXR5LiBUaGlzIGlzIGFsc28gdXNlZCB0byBhdHRhY2ggYVxuICAgICAgICAgIC8vIHJldHJ5IGxpc3RlbmVyIHRvIHRoZSBwcm9taXNlLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTW9kZTpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICBicmVhaztcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAvLyBQb3AgcHJvdmlkZXIgZmliZXJcbiAgICAgIHBvcFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFNhbWUgYXMgY2xhc3MgY29tcG9uZW50IGNhc2UuIEkgcHV0IGl0IGRvd24gaGVyZSBzbyB0aGF0IHRoZSB0YWdzIGFyZVxuICAgICAgICAvLyBzZXF1ZW50aWFsIHRvIGVuc3VyZSB0aGlzIHN3aXRjaCBpcyBjb21waWxlZCB0byBhIGp1bXAgdGFibGUuXG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKF9Db21wb25lbnQpKSB7XG4gICAgICAgICAgcG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmIChlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQyID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgIV93YXNIeWRyYXRlZDIgPyBpbnZhcmlhbnQoZmFsc2UsICdBIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50IHdhcyBjb21wbGV0ZWQgd2l0aG91dCBhIGh5ZHJhdGVkIG5vZGUuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSA9PT0gTm9FZmZlY3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgYm91bmRhcnkgZGlkIG5vdCBzdXNwZW5kIHNvIGl0J3Mgbm93IGh5ZHJhdGVkLlxuICAgICAgICAgICAgLy8gVG8gaGFuZGxlIGFueSBmdXR1cmUgc3VzcGVuc2UgY2FzZXMsIHdlJ3JlIGdvaW5nIHRvIG5vdyB1cGdyYWRlIGl0XG4gICAgICAgICAgICAvLyB0byBhIFN1c3BlbnNlIGNvbXBvbmVudC4gV2UgZGV0YWNoIGl0IGZyb20gdGhlIGV4aXN0aW5nIGN1cnJlbnQgZmliZXIuXG4gICAgICAgICAgICBjdXJyZW50LmFsdGVybmF0ZSA9IG51bGw7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gU3VzcGVuc2VDb21wb25lbnQ7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ2FwdHVyZVN1c3BlbnNlKHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIEluIG9yZGVyIHRvIGNhcHR1cmUsIHRoZSBTdXNwZW5zZSBjb21wb25lbnQgbXVzdCBoYXZlIGEgZmFsbGJhY2sgcHJvcC5cbiAgaWYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMuZmFsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBJZiBpdCB3YXMgdGhlIHByaW1hcnkgY2hpbGRyZW4gdGhhdCBqdXN0IHN1c3BlbmRlZCwgY2FwdHVyZSBhbmQgcmVuZGVyIHRoZVxuICAvLyBmYWxsYmFjay4gT3RoZXJ3aXNlLCBkb24ndCBjYXB0dXJlIGFuZCBidWJibGUgdG8gdGhlIG5leHQgYm91bmRhcnkuXG4gIHZhciBuZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICByZXR1cm4gbmV4dFN0YXRlID09PSBudWxsO1xufVxuXG4vLyBUaGlzIG1vZHVsZSBpcyBmb3JrZWQgaW4gZGlmZmVyZW50IGVudmlyb25tZW50cy5cbi8vIEJ5IGRlZmF1bHQsIHJldHVybiBgdHJ1ZWAgdG8gbG9nIGVycm9ycyB0byB0aGUgY29uc29sZS5cbi8vIEZvcmtzIGNhbiByZXR1cm4gYGZhbHNlYCBpZiB0aGlzIGlzbid0IGRlc2lyYWJsZS5cbmZ1bmN0aW9uIHNob3dFcnJvckRpYWxvZyhjYXB0dXJlZEVycm9yKSB7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGNhcHR1cmVkRXJyb3IpIHtcbiAgdmFyIGxvZ0Vycm9yID0gc2hvd0Vycm9yRGlhbG9nKGNhcHR1cmVkRXJyb3IpO1xuXG4gIC8vIEFsbG93IGluamVjdGVkIHNob3dFcnJvckRpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cbiAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50TmFtZSxcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeU5hbWUsXG4gICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeUZvdW5kLFxuICAgICAgICB3aWxsUmV0cnkgPSBjYXB0dXJlZEVycm9yLndpbGxSZXRyeTtcblxuICAgIC8vIEJyb3dzZXJzIHN1cHBvcnQgc2lsZW5jaW5nIHVuY2F1Z2h0IGVycm9ycyBieSBjYWxsaW5nXG4gICAgLy8gYHByZXZlbnREZWZhdWx0KClgIGluIHdpbmRvdyBgZXJyb3JgIGhhbmRsZXIuXG4gICAgLy8gV2UgcmVjb3JkIHRoaXMgaW5mb3JtYXRpb24gYXMgYW4gZXhwYW5kbyBvbiB0aGUgZXJyb3IuXG5cbiAgICBpZiAoZXJyb3IgIT0gbnVsbCAmJiBlcnJvci5fc3VwcHJlc3NMb2dnaW5nKSB7XG4gICAgICBpZiAoZXJyb3JCb3VuZGFyeUZvdW5kICYmIHdpbGxSZXRyeSkge1xuICAgICAgICAvLyBUaGUgZXJyb3IgaXMgcmVjb3ZlcmFibGUgYW5kIHdhcyBzaWxlbmNlZC5cbiAgICAgICAgLy8gSWdub3JlIGl0IGFuZCBkb24ndCBwcmludCB0aGUgc3RhY2sgYWRkZW5kdW0uXG4gICAgICAgIC8vIFRoaXMgaXMgaGFuZHkgZm9yIHRlc3RpbmcgZXJyb3IgYm91bmRhcmllcyB3aXRob3V0IG5vaXNlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBUaGUgZXJyb3IgaXMgZmF0YWwuIFNpbmNlIHRoZSBzaWxlbmNpbmcgbWlnaHQgaGF2ZVxuICAgICAgLy8gYmVlbiBhY2NpZGVudGFsLCB3ZSdsbCBzdXJmYWNlIGl0IGFueXdheS5cbiAgICAgIC8vIEhvd2V2ZXIsIHRoZSBicm93c2VyIHdvdWxkIGhhdmUgc2lsZW5jZWQgdGhlIG9yaWdpbmFsIGVycm9yXG4gICAgICAvLyBzbyB3ZSdsbCBwcmludCBpdCBmaXJzdCwgYW5kIHRoZW4gcHJpbnQgdGhlIHN0YWNrIGFkZGVuZHVtLlxuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAvLyBGb3IgYSBtb3JlIGRldGFpbGVkIGRlc2NyaXB0aW9uIG9mIHRoaXMgYmxvY2ssIHNlZTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEzMzg0XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDwnICsgY29tcG9uZW50TmFtZSArICc+IGNvbXBvbmVudDonIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzOic7XG5cbiAgICB2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgLy8gZXJyb3JCb3VuZGFyeUZvdW5kIGNoZWNrIGlzIHN1ZmZpY2llbnQ7IGVycm9yQm91bmRhcnlOYW1lIGNoZWNrIGlzIHRvIHNhdGlzZnkgRmxvdy5cbiAgICBpZiAoZXJyb3JCb3VuZGFyeUZvdW5kICYmIGVycm9yQm91bmRhcnlOYW1lKSB7XG4gICAgICBpZiAod2lsbFJldHJ5KSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1JlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoICcgKyAoJ3VzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdUaGlzIGVycm9yIHdhcyBpbml0aWFsbHkgaGFuZGxlZCBieSB0aGUgZXJyb3IgYm91bmRhcnkgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy5cXG4nICsgJ1JlY3JlYXRpbmcgdGhlIHRyZWUgZnJvbSBzY3JhdGNoIGZhaWxlZCBzbyBSZWFjdCB3aWxsIHVubW91bnQgdGhlIHRyZWUuJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnQ29uc2lkZXIgYWRkaW5nIGFuIGVycm9yIGJvdW5kYXJ5IHRvIHlvdXIgdHJlZSB0byBjdXN0b21pemUgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IuXFxuJyArICdWaXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWVycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLic7XG4gICAgfVxuICAgIHZhciBjb21iaW5lZE1lc3NhZ2UgPSAnJyArIGNvbXBvbmVudE5hbWVNZXNzYWdlICsgY29tcG9uZW50U3RhY2sgKyAnXFxuXFxuJyArICgnJyArIGVycm9yQm91bmRhcnlNZXNzYWdlKTtcblxuICAgIC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aXRoIGp1c3QgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAgICAvLyBXZSBkb24ndCBpbmNsdWRlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIGFuZCBKUyBzdGFjayBiZWNhdXNlIHRoZSBicm93c2VyXG4gICAgLy8gaGFzIGFscmVhZHkgcHJpbnRlZCBpdC4gRXZlbiBpZiB0aGUgYXBwbGljYXRpb24gc3dhbGxvd3MgdGhlIGVycm9yLCBpdCBpcyBzdGlsbFxuICAgIC8vIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciB0aGFua3MgdG8gdGhlIERFVi1vbmx5IGZha2UgZXZlbnQgdHJpY2sgaW4gUmVhY3RFcnJvclV0aWxzLlxuICAgIGNvbnNvbGUuZXJyb3IoY29tYmluZWRNZXNzYWdlKTtcbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBudWxsO1xue1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG5ldyBTZXQoKTtcbn1cblxudmFyIFBvc3NpYmx5V2Vha1NldCQxID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbicgPyBXZWFrU2V0IDogU2V0O1xuXG5mdW5jdGlvbiBsb2dFcnJvcihib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHZhciBzb3VyY2UgPSBlcnJvckluZm8uc291cmNlO1xuICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gIGlmIChzdGFjayA9PT0gbnVsbCAmJiBzb3VyY2UgIT09IG51bGwpIHtcbiAgICBzdGFjayA9IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpO1xuICB9XG5cbiAgdmFyIGNhcHR1cmVkRXJyb3IgPSB7XG4gICAgY29tcG9uZW50TmFtZTogc291cmNlICE9PSBudWxsID8gZ2V0Q29tcG9uZW50TmFtZShzb3VyY2UudHlwZSkgOiBudWxsLFxuICAgIGNvbXBvbmVudFN0YWNrOiBzdGFjayAhPT0gbnVsbCA/IHN0YWNrIDogJycsXG4gICAgZXJyb3I6IGVycm9ySW5mby52YWx1ZSxcbiAgICBlcnJvckJvdW5kYXJ5OiBudWxsLFxuICAgIGVycm9yQm91bmRhcnlOYW1lOiBudWxsLFxuICAgIGVycm9yQm91bmRhcnlGb3VuZDogZmFsc2UsXG4gICAgd2lsbFJldHJ5OiBmYWxzZVxuICB9O1xuXG4gIGlmIChib3VuZGFyeSAhPT0gbnVsbCAmJiBib3VuZGFyeS50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5ID0gYm91bmRhcnkuc3RhdGVOb2RlO1xuICAgIGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lKGJvdW5kYXJ5LnR5cGUpO1xuICAgIGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeUZvdW5kID0gdHJ1ZTtcbiAgICBjYXB0dXJlZEVycm9yLndpbGxSZXRyeSA9IHRydWU7XG4gIH1cblxuICB0cnkge1xuICAgIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBtdXN0IG5vdCB0aHJvdywgb3IgUmVhY3QgaW50ZXJuYWwgc3RhdGUgd2lsbCBnZXQgbWVzc2VkIHVwLlxuICAgIC8vIElmIGNvbnNvbGUuZXJyb3IgaXMgb3ZlcnJpZGRlbiwgb3IgbG9nQ2FwdHVyZWRFcnJvcigpIHNob3dzIGEgZGlhbG9nIHRoYXQgdGhyb3dzLFxuICAgIC8vIHdlIHdhbnQgdG8gcmVwb3J0IHRoaXMgZXJyb3Igb3V0c2lkZSBvZiB0aGUgbm9ybWFsIHN0YWNrIGFzIGEgbGFzdCByZXNvcnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzE4OFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyID0gZnVuY3Rpb24gKGN1cnJlbnQkJDEsIGluc3RhbmNlKSB7XG4gIHN0YXJ0UGhhc2VUaW1lcihjdXJyZW50JCQxLCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50JCQxLm1lbW9pemVkUHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gY3VycmVudCQkMS5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICBzdG9wUGhhc2VUaW1lcigpO1xufTtcblxuLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cbmZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50JCQxLCBpbnN0YW5jZSkge1xuICB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCQkMSwgaW5zdGFuY2UpO1xuICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICB2YXIgdW5tb3VudEVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCQkMSwgdW5tb3VudEVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQkJDEpIHtcbiAgdmFyIHJlZiA9IGN1cnJlbnQkJDEucmVmO1xuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIHJlZiwgbnVsbCwgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQkJDEsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseUNhbGxEZXN0cm95KGN1cnJlbnQkJDEsIGRlc3Ryb3kpIHtcbiAge1xuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayhudWxsLCBkZXN0cm95LCBudWxsKTtcbiAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgdmFyIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCQkMSwgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkxpZmVDeWNsZXMoY3VycmVudCQkMSwgZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3QoVW5tb3VudFNuYXBzaG90LCBOb0VmZmVjdCQxLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBTbmFwc2hvdCkge1xuICAgICAgICAgIGlmIChjdXJyZW50JCQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudCQkMS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQkJDEubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZScpO1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICAgICAgICAgICEoaW5zdGFuY2UucHJvcHMgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSA/IHdhcm5pbmckMShmYWxzZSwgJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgIShpbnN0YW5jZS5zdGF0ZSA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpID8gd2FybmluZyQxKGZhbHNlLCAnRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IHByZXZQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIHByZXZQcm9wcyksIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBkaWRXYXJuU2V0ID0gZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU7XG4gICAgICAgICAgICAgIGlmIChzbmFwc2hvdCA9PT0gdW5kZWZpbmVkICYmICFkaWRXYXJuU2V0LmhhcyhmaW5pc2hlZFdvcmsudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBkaWRXYXJuU2V0LmFkZChmaW5pc2hlZFdvcmsudHlwZSk7XG4gICAgICAgICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKTogQSBzbmFwc2hvdCB2YWx1ZSAob3IgbnVsbCkgJyArICdtdXN0IGJlIHJldHVybmVkLiBZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IHNuYXBzaG90O1xuICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgLy8gTm90aGluZyB0byBkbyBmb3IgdGhlc2UgY29tcG9uZW50IHR5cGVzXG4gICAgICByZXR1cm47XG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3QodW5tb3VudFRhZywgbW91bnRUYWcsIGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcbiAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgIGRvIHtcbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIHVubW91bnRUYWcpICE9PSBOb0VmZmVjdCQxKSB7XG4gICAgICAgIC8vIFVubW91bnRcbiAgICAgICAgdmFyIGRlc3Ryb3kgPSBlZmZlY3QuZGVzdHJveTtcbiAgICAgICAgZWZmZWN0LmRlc3Ryb3kgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChkZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgoZWZmZWN0LnRhZyAmIG1vdW50VGFnKSAhPT0gTm9FZmZlY3QkMSkge1xuICAgICAgICAvLyBNb3VudFxuICAgICAgICB2YXIgY3JlYXRlID0gZWZmZWN0LmNyZWF0ZTtcbiAgICAgICAgZWZmZWN0LmRlc3Ryb3kgPSBjcmVhdGUoKTtcblxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9kZXN0cm95ID0gZWZmZWN0LmRlc3Ryb3k7XG4gICAgICAgICAgaWYgKF9kZXN0cm95ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIF9kZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgYWRkZW5kdW0gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAoX2Rlc3Ryb3kgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYWRkZW5kdW0gPSAnIFlvdSByZXR1cm5lZCBudWxsLiBJZiB5b3VyIGVmZmVjdCBkb2VzIG5vdCByZXF1aXJlIGNsZWFuICcgKyAndXAsIHJldHVybiB1bmRlZmluZWQgKG9yIG5vdGhpbmcpLic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBfZGVzdHJveS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJ1xcblxcbkl0IGxvb2tzIGxpa2UgeW91IHdyb3RlIHVzZUVmZmVjdChhc3luYyAoKSA9PiAuLi4pIG9yIHJldHVybmVkIGEgUHJvbWlzZS4gJyArICdJbnN0ZWFkLCB3cml0ZSB0aGUgYXN5bmMgZnVuY3Rpb24gaW5zaWRlIHlvdXIgZWZmZWN0ICcgKyAnYW5kIGNhbGwgaXQgaW1tZWRpYXRlbHk6XFxuXFxuJyArICd1c2VFZmZlY3QoKCkgPT4ge1xcbicgKyAnICBhc3luYyBmdW5jdGlvbiBmZXRjaERhdGEoKSB7XFxuJyArICcgICAgLy8gWW91IGNhbiBhd2FpdCBoZXJlXFxuJyArICcgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNeUFQSS5nZXREYXRhKHNvbWVJZCk7XFxuJyArICcgICAgLy8gLi4uXFxuJyArICcgIH1cXG4nICsgJyAgZmV0Y2hEYXRhKCk7XFxuJyArICd9LCBbc29tZUlkXSk7IC8vIE9yIFtdIGlmIGVmZmVjdCBkb2VzblxcJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcbicgKyAnTGVhcm4gbW9yZSBhYm91dCBkYXRhIGZldGNoaW5nIHdpdGggSG9va3M6IGh0dHBzOi8vZmIubWUvcmVhY3QtaG9va3MtZGF0YS1mZXRjaGluZyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkOiAnICsgX2Rlc3Ryb3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdBbiBlZmZlY3QgZnVuY3Rpb24gbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGJlc2lkZXMgYSBmdW5jdGlvbiwgJyArICd3aGljaCBpcyB1c2VkIGZvciBjbGVhbi11cC4lcyVzJywgYWRkZW5kdW0sIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVIb29rRWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgY29tbWl0SG9va0VmZmVjdExpc3QoVW5tb3VudFBhc3NpdmUsIE5vRWZmZWN0JDEsIGZpbmlzaGVkV29yayk7XG4gIGNvbW1pdEhvb2tFZmZlY3RMaXN0KE5vRWZmZWN0JDEsIE1vdW50UGFzc2l2ZSwgZmluaXNoZWRXb3JrKTtcbn1cblxuZnVuY3Rpb24gY29tbWl0TGlmZUN5Y2xlcyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQkJDEsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdChVbm1vdW50TGF5b3V0LCBNb3VudExheW91dCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCQkMSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gICAgICAgICAgICAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlID09PSBmaW5pc2hlZFdvcmsuZWxlbWVudFR5cGUgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAhKGluc3RhbmNlLnByb3BzID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykgPyB3YXJuaW5nJDEoZmFsc2UsICdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRNb3VudC4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpIHx8ICdpbnN0YW5jZScpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAgICEoaW5zdGFuY2Uuc3RhdGUgPT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSA/IHdhcm5pbmckMShmYWxzZSwgJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZE1vdW50LiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlID09PSBmaW5pc2hlZFdvcmsudHlwZSA/IGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcyA6IHJlc29sdmVEZWZhdWx0UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudCQkMS5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgICAgICAgICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsudHlwZSA9PT0gZmluaXNoZWRXb3JrLmVsZW1lbnRUeXBlICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgIShpbnN0YW5jZS5wcm9wcyA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpID8gd2FybmluZyQxKGZhbHNlLCAnRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgIShpbnN0YW5jZS5zdGF0ZSA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpID8gd2FybmluZyQxKGZhbHNlLCAnRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO1xuICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgPT09IGZpbmlzaGVkV29yay5lbGVtZW50VHlwZSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICAgICAgICAhKGluc3RhbmNlLnByb3BzID09PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykgPyB3YXJuaW5nJDEoZmFsc2UsICdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lKGZpbmlzaGVkV29yay50eXBlKSB8fCAnaW5zdGFuY2UnKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgIShpbnN0YW5jZS5zdGF0ZSA9PT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpID8gd2FybmluZyQxKGZhbHNlLCAnRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZShmaW5pc2hlZFdvcmsudHlwZSkgfHwgJ2luc3RhbmNlJykgOiB2b2lkIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29tbWl0VXBkYXRlUXVldWUoZmluaXNoZWRXb3JrLCBfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSwgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbiAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cbiAgICAgICAgaWYgKGN1cnJlbnQkJDEgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgY29tbWl0TW91bnQoX2luc3RhbmNlMiwgdHlwZSwgcHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggcG9ydGFscy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgICAgdmFyIG9uUmVuZGVyID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMub25SZW5kZXI7XG5cbiAgICAgICAgICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgICAgICAgICAgb25SZW5kZXIoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsIGN1cnJlbnQkJDEgPT09IG51bGwgPyAnbW91bnQnIDogJ3VwZGF0ZScsIGZpbmlzaGVkV29yay5hY3R1YWxEdXJhdGlvbiwgZmluaXNoZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24sIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsIGdldENvbW1pdFRpbWUoKSwgZmluaXNoZWRSb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb25SZW5kZXIoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsIGN1cnJlbnQkJDEgPT09IG51bGwgPyAnbW91bnQnIDogJ3VwZGF0ZScsIGZpbmlzaGVkV29yay5hY3R1YWxEdXJhdGlvbiwgZmluaXNoZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24sIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsIGdldENvbW1pdFRpbWUoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihmaW5pc2hlZFdvcmssIGlzSGlkZGVuKSB7XG4gIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgIGhpZGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5oaWRlSW5zdGFuY2Uobm9kZS5zdGF0ZU5vZGUsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UzID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgIGhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlMyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5oaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZTMsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50ICYmIG5vZGUubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBGb3VuZCBhIG5lc3RlZCBTdXNwZW5zZSBjb21wb25lbnQgdGhhdCB0aW1lZCBvdXQuIFNraXAgb3ZlciB0aGVcbiAgICAgICAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IG5vZGUuY2hpbGQuc2libGluZztcbiAgICAgICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgIHZhciBpbnN0YW5jZVRvVXNlID0gdm9pZCAwO1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlZihpbnN0YW5jZVRvVXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoIXJlZi5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnVW5leHBlY3RlZCByZWYgb2JqZWN0IHByb3ZpZGVkIGZvciAlcy4gJyArICdVc2UgZWl0aGVyIGEgcmVmLXNldHRlciBmdW5jdGlvbiBvciBSZWFjdC5jcmVhdGVSZWYoKS4lcycsIGdldENvbXBvbmVudE5hbWUoZmluaXNoZWRXb3JrLnR5cGUpLCBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCQkMSkge1xuICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQkJDEucmVmO1xuICBpZiAoY3VycmVudFJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgY3VycmVudFJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY3VycmVudFJlZihudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLy8gVXNlci1vcmlnaW5hdGluZyBlcnJvcnMgKGxpZmVjeWNsZXMgYW5kIHJlZnMpIHNob3VsZCBub3QgaW50ZXJydXB0XG4vLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuLy8gaW50ZXJydXB0IGRlbGV0aW9uLCBzbyBpdCdzIG9rYXlcbmZ1bmN0aW9uIGNvbW1pdFVubW91bnQoY3VycmVudCQkMSkge1xuICBvbkNvbW1pdFVubW91bnQoY3VycmVudCQkMSk7XG5cbiAgc3dpdGNoIChjdXJyZW50JCQxLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGN1cnJlbnQkJDEudXBkYXRlUXVldWU7XG4gICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUubGFzdEVmZmVjdDtcbiAgICAgICAgICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgICAgICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICB2YXIgZGVzdHJveSA9IGVmZmVjdC5kZXN0cm95O1xuICAgICAgICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCQkMSwgZGVzdHJveSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQkJDEpO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50JCQxLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50JCQxLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQkJDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHJlY3Vyc2l2ZS5cbiAgICAgICAgLy8gV2UgYXJlIGFsc28gbm90IHVzaW5nIHRoaXMgcGFyZW50IGJlY2F1c2VcbiAgICAgICAgLy8gdGhlIHBvcnRhbCB3aWxsIGdldCBwdXNoZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQkJDEpO1xuICAgICAgICB9IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50JCQxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TmVzdGVkVW5tb3VudHMocm9vdCkge1xuICAvLyBXaGlsZSB3ZSdyZSBpbnNpZGUgYSByZW1vdmVkIGhvc3Qgbm9kZSB3ZSBkb24ndCB3YW50IHRvIGNhbGxcbiAgLy8gcmVtb3ZlQ2hpbGQgb24gdGhlIGlubmVyIG5vZGVzIGJlY2F1c2UgdGhleSdyZSByZW1vdmVkIGJ5IHRoZSB0b3BcbiAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAvLyBjb21wb3NpdGVzIGJlZm9yZSB0aGlzIGhvc3Qgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUuIFRoZXJlZm9yZVxuICB2YXIgbm9kZSA9IHJvb3Q7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHRoZXkgbWF5IGNvbnRhaW4gbW9yZSBjb21wb3NpdGUgb3IgaG9zdCBub2Rlcy5cbiAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsICYmIChcbiAgICAvLyBJZiB3ZSB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgdXNpbmcgY29tbWl0VW5tb3VudCBhYm92ZS5cbiAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICFzdXBwb3J0c011dGF0aW9uIHx8IG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXIoY3VycmVudCQkMSkge1xuICAvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlcnMgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLiBJZGVhbGx5LCB3ZVxuICAvLyBzaG91bGQgY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAvLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC4gVGhpcyBjaGlsZFxuICAvLyBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICBjdXJyZW50JCQxLnJldHVybiA9IG51bGw7XG4gIGN1cnJlbnQkJDEuY2hpbGQgPSBudWxsO1xuICBjdXJyZW50JCQxLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICBjdXJyZW50JCQxLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgdmFyIGFsdGVybmF0ZSA9IGN1cnJlbnQkJDEuYWx0ZXJuYXRlO1xuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLnJldHVybiA9IG51bGw7XG4gICAgYWx0ZXJuYXRlLmNoaWxkID0gbnVsbDtcbiAgICBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgYWx0ZXJuYXRlLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50JCQxKSB7XG4gIGlmICghc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwb3J0YWwgPSBjdXJyZW50JCQxLnN0YXRlTm9kZTtcbiAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWwuY29udGFpbmVySW5mbztcblxuICB2YXIgZW1wdHlDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckluZm8pO1xuICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgZW1wdHlDaGlsZFNldCk7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdENvbnRhaW5lcihmaW5pc2hlZFdvcmspIHtcbiAgaWYgKCFzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgICBfcGVuZGluZ0NoaWxkcmVuID0gcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgX3BlbmRpbmdDaGlsZHJlbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIb3N0UGFyZW50RmliZXIoZmliZXIpIHtcbiAgdmFyIHBhcmVudCA9IGZpYmVyLnJldHVybjtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbmZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgLy8gbm9kZS4gVW5mb3J0dW5hdGVseSwgaWYgbXVsdGlwbGUgaW5zZXJ0aW9ucyBhcmUgZG9uZSBpbiBhIHJvdyB3ZSBoYXZlIHRvXG4gIC8vIHNlYXJjaCBwYXN0IHRoZW0uIFRoaXMgbGVhZHMgdG8gZXhwb25lbnRpYWwgc2VhcmNoIGZvciB0aGUgbmV4dCBzaWJsaW5nLlxuICB2YXIgbm9kZSA9IGZpYmVyO1xuICBzaWJsaW5nczogd2hpbGUgKHRydWUpIHtcbiAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IGlzSG9zdFBhcmVudChub2RlLnJldHVybikpIHtcbiAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB3aGlsZSAobm9kZS50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgbm9kZS50YWcgIT09IEhvc3RUZXh0ICYmIG5vZGUudGFnICE9PSBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbiAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG4gICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIHRoaXMgaG9zdCBub2RlIGlzIHN0YWJsZSBvciBhYm91dCB0byBiZSBwbGFjZWQuXG4gICAgaWYgKCEobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAvLyBGb3VuZCBpdCFcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTtcblxuICAvLyBOb3RlOiB0aGVzZSB0d28gdmFyaWFibGVzICptdXN0KiBhbHdheXMgYmUgdXBkYXRlZCB0b2dldGhlci5cbiAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cbiAgaWYgKHBhcmVudEZpYmVyLmVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgIC8vIFJlc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHBhcmVudCBiZWZvcmUgZG9pbmcgYW55IGluc2VydGlvbnNcbiAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcbiAgICBwYXJlbnRGaWJlci5lZmZlY3RUYWcgJj0gfkNvbnRlbnRSZXNldDtcbiAgfVxuXG4gIHZhciBiZWZvcmUgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydEJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcGVuZENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgLy8gSWYgdGhlIGluc2VydGlvbiBpdHNlbGYgaXMgYSBwb3J0YWwsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCQkMSkge1xuICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBkZWxldGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgdmFyIG5vZGUgPSBjdXJyZW50JCQxO1xuXG4gIC8vIEVhY2ggaXRlcmF0aW9uLCBjdXJyZW50UGFyZW50IGlzIHBvcHVsYXRlZCB3aXRoIG5vZGUncyBob3N0IHBhcmVudCBpZiBub3RcbiAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG4gIHZhciBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuXG4gIC8vIE5vdGU6IHRoZXNlIHR3byB2YXJpYWJsZXMgKm11c3QqIGFsd2F5cyBiZSB1cGRhdGVkIHRvZ2V0aGVyLlxuICB2YXIgY3VycmVudFBhcmVudCA9IHZvaWQgMDtcbiAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHZvaWQgMDtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghY3VycmVudFBhcmVudElzVmFsaWQpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLnJldHVybjtcbiAgICAgIGZpbmRQYXJlbnQ6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgICEocGFyZW50ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhub2RlKTtcbiAgICAgIC8vIEFmdGVyIGFsbCB0aGUgY2hpbGRyZW4gaGF2ZSB1bm1vdW50ZWQsIGl0IGlzIG5vdyBzYWZlIHRvIHJlbW92ZSB0aGVcbiAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgIGlmIChjdXJyZW50UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbW92ZUNoaWxkKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH1cbiAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgfSBlbHNlIGlmIChlbmFibGVTdXNwZW5zZVNlcnZlclJlbmRlcmVyICYmIG5vZGUudGFnID09PSBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgIC8vIERlbGV0ZSB0aGUgZGVoeWRyYXRlZCBzdXNwZW5zZSBib3VuZGFyeSBhbmQgYWxsIG9mIGl0cyBjb250ZW50LlxuICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeShjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG4gICAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHBvcnRhbHMgbWlnaHQgY29udGFpbiBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudCQkMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGN1cnJlbnQkJDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gb3V0IG9mIHRoZSBwb3J0YWwsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgcGFyZW50LlxuICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZWxldGlvbihjdXJyZW50JCQxKSB7XG4gIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgZGVsZXRlIGFsbCBob3N0IG5vZGVzIGZyb20gdGhlIHBhcmVudC5cbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50JCQxKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQkJDEpO1xuICB9XG4gIGRldGFjaEZpYmVyKGN1cnJlbnQkJDEpO1xufVxuXG5mdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQkJDEsIGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBOb3RlOiBXZSBjdXJyZW50bHkgbmV2ZXIgdXNlIE1vdW50TXV0YXRpb24sIGJ1dCB1c2VMYXlvdXQgdXNlc1xuICAgICAgICAgIC8vIFVubW91bnRNdXRhdGlvbi5cbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdChVbm1vdW50TXV0YXRpb24sIE1vdW50TXV0YXRpb24sIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gTm90ZTogV2UgY3VycmVudGx5IG5ldmVyIHVzZSBNb3VudE11dGF0aW9uLCBidXQgdXNlTGF5b3V0IHVzZXNcbiAgICAgICAgLy8gVW5tb3VudE11dGF0aW9uLlxuICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdChVbm1vdW50TXV0YXRpb24sIE1vdW50TXV0YXRpb24sIGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCQkMSAhPT0gbnVsbCA/IGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCQkMSAhPT0gbnVsbCA/IGN1cnJlbnQkJDEubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgdmFyIG5ld0RpZFRpbWVvdXQgPSB2b2lkIDA7XG4gICAgICAgIHZhciBwcmltYXJ5Q2hpbGRQYXJlbnQgPSBmaW5pc2hlZFdvcms7XG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0RpZFRpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdEaWRUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICBwcmltYXJ5Q2hpbGRQYXJlbnQgPSBmaW5pc2hlZFdvcmsuY2hpbGQ7XG4gICAgICAgICAgaWYgKG5ld1N0YXRlLnRpbWVkT3V0QXQgPT09IE5vV29yaykge1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoaWxkcmVuIGhhZCBub3QgYWxyZWFkeSB0aW1lZCBvdXQsIHJlY29yZCB0aGUgdGltZS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBjb21wdXRlIHRoZSBlbGFwc2VkIHRpbWUgZHVyaW5nIHN1YnNlcXVlbnRcbiAgICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlbmRlciB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgICBuZXdTdGF0ZS50aW1lZE91dEF0ID0gcmVxdWVzdEN1cnJlbnRUaW1lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByaW1hcnlDaGlsZFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKHByaW1hcnlDaGlsZFBhcmVudCwgbmV3RGlkVGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGJvdW5kYXJ5IGp1c3QgdGltZWQgb3V0LCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHNldCBvZiB0aGVuYWJsZXMuXG4gICAgICAgIC8vIEZvciBlYWNoIHRoZW5hYmxlLCBhdHRhY2ggYSBsaXN0ZW5lciBzbyB0aGF0IHdoZW4gaXQgcmVzb2x2ZXMsIFJlYWN0XG4gICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlLXJlbmRlciB0aGUgYm91bmRhcnkgaW4gdGhlIHByaW1hcnkgKHByZS10aW1lb3V0KSBzdGF0ZS5cbiAgICAgICAgdmFyIHRoZW5hYmxlcyA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgaWYgKHRoZW5hYmxlcyAhPT0gbnVsbCkge1xuICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgdmFyIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmIChyZXRyeUNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQkMSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGVuYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAodGhlbmFibGUpIHtcbiAgICAgICAgICAgIC8vIE1lbW9pemUgdXNpbmcgdGhlIGJvdW5kYXJ5IGZpYmVyIHRvIHByZXZlbnQgcmVkdW5kYW50IGxpc3RlbmVycy5cbiAgICAgICAgICAgIHZhciByZXRyeSA9IHJldHJ5VGltZWRPdXRCb3VuZGFyeS5iaW5kKG51bGwsIGZpbmlzaGVkV29yaywgdGhlbmFibGUpO1xuICAgICAgICAgICAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICAgICAgICAgICAgcmV0cnkgPSB0cmFjaW5nLnVuc3RhYmxlX3dyYXAocmV0cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXRyeUNhY2hlLmhhcyh0aGVuYWJsZSkpIHtcbiAgICAgICAgICAgICAgcmV0cnlDYWNoZS5hZGQodGhlbmFibGUpO1xuICAgICAgICAgICAgICB0aGVuYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRSZXNldFRleHRDb250ZW50KGN1cnJlbnQkJDEpIHtcbiAgaWYgKCFzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHJlc2V0VGV4dENvbnRlbnQoY3VycmVudCQkMS5zdGF0ZU5vZGUpO1xufVxuXG52YXIgUG9zc2libHlXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbicgPyBXZWFrU2V0IDogU2V0O1xudmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcblxuZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUoZXhwaXJhdGlvblRpbWUpO1xuICAvLyBVbm1vdW50IHRoZSByb290IGJ5IHJlbmRlcmluZyBudWxsLlxuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG4gIHVwZGF0ZS5wYXlsb2FkID0geyBlbGVtZW50OiBudWxsIH07XG4gIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIG9uVW5jYXVnaHRFcnJvcihlcnJvcik7XG4gICAgbG9nRXJyb3IoZmliZXIsIGVycm9ySW5mbyk7XG4gIH07XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoZmliZXIsIGVycm9ySW5mbywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShleHBpcmF0aW9uVGltZSk7XG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlO1xuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZmliZXIudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7XG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcik7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpbnN0ID0gZmliZXIuc3RhdGVOb2RlO1xuICBpZiAoaW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdC5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGZ1bmN0aW9uIGNhbGxiYWNrKCkge1xuICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG4gICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgLy8gVGhpcyBnZXRzIHJlc2V0IGJlZm9yZSB3ZSB5aWVsZCBiYWNrIHRvIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpc1xuICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIGxvZ0Vycm9yKGZpYmVyLCBlcnJvckluZm8pO1xuICAgICAgdGhpcy5jb21wb25lbnREaWRDYXRjaChlcnJvciwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnXG4gICAgICB9KTtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBJZiBjb21wb25lbnREaWRDYXRjaCBpcyB0aGUgb25seSBlcnJvciBib3VuZGFyeSBtZXRob2QgZGVmaW5lZCxcbiAgICAgICAgICAvLyB0aGVuIGl0IG5lZWRzIHRvIGNhbGwgc2V0U3RhdGUgdG8gcmVjb3ZlciBmcm9tIGVycm9ycy5cbiAgICAgICAgICAvLyBJZiBubyBzdGF0ZSB1cGRhdGUgaXMgc2NoZWR1bGVkIHRoZW4gdGhlIGJvdW5kYXJ5IHdpbGwgc3dhbGxvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgIShmaWJlci5leHBpcmF0aW9uVGltZSA9PT0gU3luYykgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclczogRXJyb3IgYm91bmRhcmllcyBzaG91bGQgaW1wbGVtZW50IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpLiAnICsgJ0luIHRoYXQgbWV0aG9kLCByZXR1cm4gYSBzdGF0ZSB1cGRhdGUgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIG9yIGZhbGxiYWNrIFVJLicsIGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1Vua25vd24nKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHJlbmRlckV4cGlyYXRpb25UaW1lLCB0aGVuYWJsZSkge1xuICAvLyBBdHRhY2ggYSBsaXN0ZW5lciB0byB0aGUgcHJvbWlzZSB0byBcInBpbmdcIiB0aGUgcm9vdCBhbmQgcmV0cnkuIEJ1dFxuICAvLyBvbmx5IGlmIG9uZSBkb2VzIG5vdCBhbHJlYWR5IGV4aXN0IGZvciB0aGUgY3VycmVudCByZW5kZXIgZXhwaXJhdGlvblxuICAvLyB0aW1lICh3aGljaCBhY3RzIGxpa2UgYSBcInRocmVhZCBJRFwiIGhlcmUpLlxuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIHZhciB0aHJlYWRJRHMgPSB2b2lkIDA7XG4gIGlmIChwaW5nQ2FjaGUgPT09IG51bGwpIHtcbiAgICBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbiAgICB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG4gICAgcGluZ0NhY2hlLnNldCh0aGVuYWJsZSwgdGhyZWFkSURzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJlYWRJRHMgPSBwaW5nQ2FjaGUuZ2V0KHRoZW5hYmxlKTtcbiAgICBpZiAodGhyZWFkSURzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBpbmdDYWNoZS5zZXQodGhlbmFibGUsIHRocmVhZElEcyk7XG4gICAgfVxuICB9XG4gIGlmICghdGhyZWFkSURzLmhhcyhyZW5kZXJFeHBpcmF0aW9uVGltZSkpIHtcbiAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSB0aHJlYWQgSUQgdG8gcHJldmVudCByZWR1bmRhbnQgbGlzdGVuZXJzLlxuICAgIHRocmVhZElEcy5hZGQocmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciBwaW5nID0gcGluZ1N1c3BlbmRlZFJvb3QuYmluZChudWxsLCByb290LCB0aGVuYWJsZSwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgICBwaW5nID0gdHJhY2luZy51bnN0YWJsZV93cmFwKHBpbmcpO1xuICAgIH1cbiAgICB0aGVuYWJsZS50aGVuKHBpbmcsIHBpbmcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93RXhjZXB0aW9uKHJvb3QsIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgdmFsdWUsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS5cbiAgc291cmNlRmliZXIuZWZmZWN0VGFnIHw9IEluY29tcGxldGU7XG4gIC8vIEl0cyBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gIHNvdXJjZUZpYmVyLmZpcnN0RWZmZWN0ID0gc291cmNlRmliZXIubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGlzIGlzIGEgdGhlbmFibGUuXG4gICAgdmFyIHRoZW5hYmxlID0gdmFsdWU7XG5cbiAgICAvLyBGaW5kIHRoZSBlYXJsaWVzdCB0aW1lb3V0IHRocmVzaG9sZCBvZiBhbGwgdGhlIHBsYWNlaG9sZGVycyBpbiB0aGVcbiAgICAvLyBhbmNlc3RvciBwYXRoLiBXZSBjb3VsZCBhdm9pZCB0aGlzIHRyYXZlcnNhbCBieSBzdG9yaW5nIHRoZSB0aHJlc2hvbGRzIG9uXG4gICAgLy8gdGhlIHN0YWNrLCBidXQgd2UgY2hvb3NlIG5vdCB0byBiZWNhdXNlIHdlIG9ubHkgaGl0IHRoaXMgcGF0aCBpZiB3ZSdyZVxuICAgIC8vIElPLWJvdW5kIChpLmUuIGlmIHNvbWV0aGluZyBzdXNwZW5kcykuIFdoZXJlYXMgdGhlIHN0YWNrIGlzIHVzZWQgZXZlbiBpblxuICAgIC8vIHRoZSBub24tSU8tIGJvdW5kIGNhc2UuXG4gICAgdmFyIF93b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICAgIHZhciBlYXJsaWVzdFRpbWVvdXRNcyA9IC0xO1xuICAgIHZhciBzdGFydFRpbWVNcyA9IC0xO1xuICAgIGRvIHtcbiAgICAgIGlmIChfd29ya0luUHJvZ3Jlc3MudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgICAgICB2YXIgY3VycmVudCQkMSA9IF93b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50JCQxICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IGN1cnJlbnQkJDEubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICBpZiAoY3VycmVudFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBSZWFjaGVkIGEgYm91bmRhcnkgdGhhdCBhbHJlYWR5IHRpbWVkIG91dC4gRG8gbm90IHNlYXJjaFxuICAgICAgICAgICAgLy8gYW55IGZ1cnRoZXIuXG4gICAgICAgICAgICB2YXIgdGltZWRPdXRBdCA9IGN1cnJlbnRTdGF0ZS50aW1lZE91dEF0O1xuICAgICAgICAgICAgc3RhcnRUaW1lTXMgPSBleHBpcmF0aW9uVGltZVRvTXModGltZWRPdXRBdCk7XG4gICAgICAgICAgICAvLyBEbyBub3Qgc2VhcmNoIGFueSBmdXJ0aGVyLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0aW1lb3V0UHJvcE1zID0gX3dvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5tYXhEdXJhdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiB0aW1lb3V0UHJvcE1zID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGlmICh0aW1lb3V0UHJvcE1zIDw9IDApIHtcbiAgICAgICAgICAgIGVhcmxpZXN0VGltZW91dE1zID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVhcmxpZXN0VGltZW91dE1zID09PSAtMSB8fCB0aW1lb3V0UHJvcE1zIDwgZWFybGllc3RUaW1lb3V0TXMpIHtcbiAgICAgICAgICAgIGVhcmxpZXN0VGltZW91dE1zID0gdGltZW91dFByb3BNcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIElmIHRoZXJlIGlzIGEgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50IHdlIGRvbid0IGhhdmUgdG8gZG8gYW55dGhpbmcgYmVjYXVzZVxuICAgICAgLy8gaWYgc29tZXRoaW5nIHN1c3BlbmRzIGluc2lkZSBpdCwgd2Ugd2lsbCBzaW1wbHkgbGVhdmUgdGhhdCBhcyBkZWh5ZHJhdGVkLiBJdFxuICAgICAgLy8gd2lsbCBuZXZlciB0aW1lb3V0LlxuICAgICAgX3dvcmtJblByb2dyZXNzID0gX3dvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB9IHdoaWxlIChfd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpO1xuXG4gICAgLy8gU2NoZWR1bGUgdGhlIG5lYXJlc3QgU3VzcGVuc2UgdG8gcmUtcmVuZGVyIHRoZSB0aW1lZCBvdXQgdmlldy5cbiAgICBfd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICBkbyB7XG4gICAgICBpZiAoX3dvcmtJblByb2dyZXNzLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiYgc2hvdWxkQ2FwdHVyZVN1c3BlbnNlKF93b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgLy8gRm91bmQgdGhlIG5lYXJlc3QgYm91bmRhcnkuXG5cbiAgICAgICAgLy8gU3Rhc2ggdGhlIHByb21pc2Ugb24gdGhlIGJvdW5kYXJ5IGZpYmVyLiBJZiB0aGUgYm91bmRhcnkgdGltZXMgb3V0LCB3ZSdsbFxuICAgICAgICB2YXIgdGhlbmFibGVzID0gX3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgICBpZiAodGhlbmFibGVzID09PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gbmV3IFNldCgpO1xuICAgICAgICAgIHVwZGF0ZVF1ZXVlLmFkZCh0aGVuYWJsZSk7XG4gICAgICAgICAgX3dvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhlbmFibGVzLmFkZCh0aGVuYWJsZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgYm91bmRhcnkgaXMgb3V0c2lkZSBvZiBjb25jdXJyZW50IG1vZGUsIHdlIHNob3VsZCAqbm90KlxuICAgICAgICAvLyBzdXNwZW5kIHRoZSBjb21taXQuIFByZXRlbmQgYXMgaWYgdGhlIHN1c3BlbmRlZCBjb21wb25lbnQgcmVuZGVyZWRcbiAgICAgICAgLy8gbnVsbCBhbmQga2VlcCByZW5kZXJpbmcuIEluIHRoZSBjb21taXQgcGhhc2UsIHdlJ2xsIHNjaGVkdWxlIGFcbiAgICAgICAgLy8gc3Vic2VxdWVudCBzeW5jaHJvbm91cyB1cGRhdGUgdG8gcmUtcmVuZGVyIHRoZSBTdXNwZW5zZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gTm90ZTogSXQgZG9lc24ndCBtYXR0ZXIgd2hldGhlciB0aGUgY29tcG9uZW50IHRoYXQgc3VzcGVuZGVkIHdhc1xuICAgICAgICAvLyBpbnNpZGUgYSBjb25jdXJyZW50IG1vZGUgdHJlZS4gSWYgdGhlIFN1c3BlbnNlIGlzIG91dHNpZGUgb2YgaXQsIHdlXG4gICAgICAgIC8vIHNob3VsZCAqbm90KiBzdXNwZW5kIHRoZSBjb21taXQuXG4gICAgICAgIGlmICgoX3dvcmtJblByb2dyZXNzLm1vZGUgJiBDb25jdXJyZW50TW9kZSkgPT09IE5vRWZmZWN0KSB7XG4gICAgICAgICAgX3dvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBEaWRDYXB0dXJlO1xuXG4gICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gY29tbWl0IHRoaXMgZmliZXIgZXZlbiB0aG91Z2ggaXQgZGlkbid0IGNvbXBsZXRlLlxuICAgICAgICAgIC8vIEJ1dCB3ZSBzaG91bGRuJ3QgY2FsbCBhbnkgbGlmZWN5Y2xlIG1ldGhvZHMgb3IgY2FsbGJhY2tzLiBSZW1vdmVcbiAgICAgICAgICAvLyBhbGwgbGlmZWN5Y2xlIGVmZmVjdCB0YWdzLlxuICAgICAgICAgIHNvdXJjZUZpYmVyLmVmZmVjdFRhZyAmPSB+KExpZmVjeWNsZUVmZmVjdE1hc2sgfCBJbmNvbXBsZXRlKTtcblxuICAgICAgICAgIGlmIChzb3VyY2VGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFNvdXJjZUZpYmVyID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTb3VyY2VGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IG1vdW50LiBDaGFuZ2UgdGhlIHRhZyBzbyBpdCdzIG5vdCBtaXN0YWtlbiBmb3IgYVxuICAgICAgICAgICAgICAvLyBjb21wbGV0ZWQgY2xhc3MgY29tcG9uZW50LiBGb3IgZXhhbXBsZSwgd2Ugc2hvdWxkIG5vdCBjYWxsXG4gICAgICAgICAgICAgIC8vIGNvbXBvbmVudFdpbGxVbm1vdW50IGlmIGl0IGlzIGRlbGV0ZWQuXG4gICAgICAgICAgICAgIHNvdXJjZUZpYmVyLnRhZyA9IEluY29tcGxldGVDbGFzc0NvbXBvbmVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFdoZW4gd2UgdHJ5IHJlbmRlcmluZyBhZ2Fpbiwgd2Ugc2hvdWxkIG5vdCByZXVzZSB0aGUgY3VycmVudCBmaWJlcixcbiAgICAgICAgICAgICAgLy8gc2luY2UgaXQncyBrbm93biB0byBiZSBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFVzZSBhIGZvcmNlIHVwZHRlIHRvXG4gICAgICAgICAgICAgIC8vIHByZXZlbnQgYSBiYWlsIG91dC5cbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShTeW5jKTtcbiAgICAgICAgICAgICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuICAgICAgICAgICAgICBlbnF1ZXVlVXBkYXRlKHNvdXJjZUZpYmVyLCB1cGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS4gTWFyayBpdCB3aXRoIFN5bmMgcHJpb3JpdHkgdG9cbiAgICAgICAgICAvLyBpbmRpY2F0ZSB0aGF0IGl0IHN0aWxsIGhhcyBwZW5kaW5nIHdvcmsuXG4gICAgICAgICAgc291cmNlRmliZXIuZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuXG4gICAgICAgICAgLy8gRXhpdCB3aXRob3V0IHN1c3BlbmRpbmcuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29uZmlybWVkIHRoYXQgdGhlIGJvdW5kYXJ5IGlzIGluIGEgY29uY3VycmVudCBtb2RlIHRyZWUuIENvbnRpbnVlXG4gICAgICAgIC8vIHdpdGggdGhlIG5vcm1hbCBzdXNwZW5kIHBhdGguXG5cbiAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHJlbmRlckV4cGlyYXRpb25UaW1lLCB0aGVuYWJsZSk7XG5cbiAgICAgICAgdmFyIGFic29sdXRlVGltZW91dE1zID0gdm9pZCAwO1xuICAgICAgICBpZiAoZWFybGllc3RUaW1lb3V0TXMgPT09IC0xKSB7XG4gICAgICAgICAgLy8gSWYgbm8gZXhwbGljaXQgdGhyZXNob2xkIGlzIGdpdmVuLCBkZWZhdWx0IHRvIGFuIGFyYml0cmFyaWx5IGxhcmdlXG4gICAgICAgICAgLy8gdmFsdWUuIFRoZSBhY3R1YWwgc2l6ZSBkb2Vzbid0IG1hdHRlciBiZWNhdXNlIHRoZSB0aHJlc2hvbGQgZm9yIHRoZVxuICAgICAgICAgIC8vIHdob2xlIHRyZWUgd2lsbCBiZSBjbGFtcGVkIHRvIHRoZSBleHBpcmF0aW9uIHRpbWUuXG4gICAgICAgICAgYWJzb2x1dGVUaW1lb3V0TXMgPSBtYXhTaWduZWQzMUJpdEludDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RhcnRUaW1lTXMgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHN1c3BlbmQgaGFwcGVuZWQgb3V0c2lkZSBvZiBhbnkgYWxyZWFkeSB0aW1lZC1vdXRcbiAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVycy4gV2UgZG9uJ3Qga25vdyBleGFjdGx5IHdoZW4gdGhlIHVwZGF0ZSB3YXNcbiAgICAgICAgICAgIC8vIHNjaGVkdWxlZCwgYnV0IHdlIGNhbiBpbmZlciBhbiBhcHByb3hpbWF0ZSBzdGFydCB0aW1lIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBleHBpcmF0aW9uIHRpbWUuIEZpcnN0LCBmaW5kIHRoZSBlYXJsaWVzdCB1bmNvbW1pdHRlZCBleHBpcmF0aW9uXG4gICAgICAgICAgICAvLyB0aW1lIGluIHRoZSB0cmVlLCBpbmNsdWRpbmcgd29yayB0aGF0IGlzIHN1c3BlbmRlZC4gVGhlbiBzdWJ0cmFjdFxuICAgICAgICAgICAgLy8gdGhlIG9mZnNldCB1c2VkIHRvIGNvbXB1dGUgYW4gYXN5bmMgdXBkYXRlJ3MgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGNhdXNlIGhpZ2ggcHJpb3JpdHkgKGludGVyYWN0aXZlKSB3b3JrIHRvIGV4cGlyZVxuICAgICAgICAgICAgLy8gZWFybGllciB0aGFuIG5lY2Vzc2FyeSwgYnV0IHdlIGNhbiBhY2NvdW50IGZvciB0aGlzIGJ5IGFkanVzdGluZ1xuICAgICAgICAgICAgLy8gZm9yIHRoZSBKdXN0IE5vdGljZWFibGUgRGlmZmVyZW5jZS5cbiAgICAgICAgICAgIHZhciBlYXJsaWVzdEV4cGlyYXRpb25UaW1lID0gZmluZEVhcmxpZXN0T3V0c3RhbmRpbmdQcmlvcml0eUxldmVsKHJvb3QsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIHZhciBlYXJsaWVzdEV4cGlyYXRpb25UaW1lTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZWFybGllc3RFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBzdGFydFRpbWVNcyA9IGVhcmxpZXN0RXhwaXJhdGlvblRpbWVNcyAtIExPV19QUklPUklUWV9FWFBJUkFUSU9OO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhYnNvbHV0ZVRpbWVvdXRNcyA9IHN0YXJ0VGltZU1zICsgZWFybGllc3RUaW1lb3V0TXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNYXJrIHRoZSBlYXJsaWVzdCB0aW1lb3V0IGluIHRoZSBzdXNwZW5kZWQgZmliZXIncyBhbmNlc3RvciBwYXRoLlxuICAgICAgICAvLyBBZnRlciBjb21wbGV0aW5nIHRoZSByb290LCB3ZSdsbCB0YWtlIHRoZSBsYXJnZXN0IG9mIGFsbCB0aGVcbiAgICAgICAgLy8gc3VzcGVuZGVkIGZpYmVyJ3MgdGltZW91dHMgYW5kIHVzZSBpdCB0byBjb21wdXRlIGEgdGltZW91dCBmb3IgdGhlXG4gICAgICAgIC8vIHdob2xlIHRyZWUuXG4gICAgICAgIHJlbmRlckRpZFN1c3BlbmQocm9vdCwgYWJzb2x1dGVUaW1lb3V0TXMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgICAgICBfd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgIF93b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIgJiYgX3dvcmtJblByb2dyZXNzLnRhZyA9PT0gRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCByZW5kZXJFeHBpcmF0aW9uVGltZSwgdGhlbmFibGUpO1xuXG4gICAgICAgIC8vIFNpbmNlIHdlIGFscmVhZHkgaGF2ZSBhIGN1cnJlbnQgZmliZXIsIHdlIGNhbiBlYWdlcmx5IGFkZCBhIHJldHJ5IGxpc3RlbmVyLlxuICAgICAgICB2YXIgcmV0cnlDYWNoZSA9IF93b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICBpZiAocmV0cnlDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHJ5Q2FjaGUgPSBfd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKTtcbiAgICAgICAgICB2YXIgX2N1cnJlbnQgPSBfd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuICAgICAgICAgICFfY3VycmVudCA/IGludmFyaWFudChmYWxzZSwgJ0EgZGVoeWRyYXRlZCBzdXNwZW5zZSBib3VuZGFyeSBtdXN0IGNvbW1pdCBiZWZvcmUgdHJ5aW5nIHRvIHJlbmRlci4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBfY3VycmVudC5tZW1vaXplZFN0YXRlID0gcmV0cnlDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSBib3VuZGFyeSBmaWJlciB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgICAgIGlmICghcmV0cnlDYWNoZS5oYXModGhlbmFibGUpKSB7XG4gICAgICAgICAgcmV0cnlDYWNoZS5hZGQodGhlbmFibGUpO1xuICAgICAgICAgIHZhciByZXRyeSA9IHJldHJ5VGltZWRPdXRCb3VuZGFyeS5iaW5kKG51bGwsIF93b3JrSW5Qcm9ncmVzcywgdGhlbmFibGUpO1xuICAgICAgICAgIGlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gICAgICAgICAgICByZXRyeSA9IHRyYWNpbmcudW5zdGFibGVfd3JhcChyZXRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoZW5hYmxlLnRoZW4ocmV0cnksIHJldHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBfd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICAgIF93b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IHJlbmRlckV4cGlyYXRpb25UaW1lO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGJvdW5kYXJ5IGFscmVhZHkgY2FwdHVyZWQgZHVyaW5nIHRoaXMgcmVuZGVyLiBDb250aW51ZSB0byB0aGUgbmV4dFxuICAgICAgLy8gYm91bmRhcnkuXG4gICAgICBfd29ya0luUHJvZ3Jlc3MgPSBfd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgIH0gd2hpbGUgKF93b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7XG4gICAgLy8gTm8gYm91bmRhcnkgd2FzIGZvdW5kLiBGYWxsdGhyb3VnaCB0byBlcnJvciBtb2RlLlxuICAgIC8vIFRPRE86IFVzZSBpbnZhcmlhbnQgc28gdGhlIG1lc3NhZ2UgaXMgc3RyaXBwZWQgaW4gcHJvZD9cbiAgICB2YWx1ZSA9IG5ldyBFcnJvcigoZ2V0Q29tcG9uZW50TmFtZShzb3VyY2VGaWJlci50eXBlKSB8fCAnQSBSZWFjdCBjb21wb25lbnQnKSArICcgc3VzcGVuZGVkIHdoaWxlIHJlbmRlcmluZywgYnV0IG5vIGZhbGxiYWNrIFVJIHdhcyBzcGVjaWZpZWQuXFxuJyArICdcXG4nICsgJ0FkZCBhIDxTdXNwZW5zZSBmYWxsYmFjaz0uLi4+IGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIHRyZWUgdG8gJyArICdwcm92aWRlIGEgbG9hZGluZyBpbmRpY2F0b3Igb3IgcGxhY2Vob2xkZXIgdG8gZGlzcGxheS4nICsgZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZUZpYmVyKSk7XG4gIH1cblxuICAvLyBXZSBkaWRuJ3QgZmluZCBhIGJvdW5kYXJ5IHRoYXQgY291bGQgaGFuZGxlIHRoaXMgdHlwZSBvZiBleGNlcHRpb24uIFN0YXJ0XG4gIC8vIG92ZXIgYW5kIHRyYXZlcnNlIHBhcmVudCBwYXRoIGFnYWluLCB0aGlzIHRpbWUgdHJlYXRpbmcgdGhlIGV4Y2VwdGlvblxuICAvLyBhcyBhbiBlcnJvci5cbiAgcmVuZGVyRGlkRXJyb3IoKTtcbiAgdmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuICBkbyB7XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2Vycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgdmFyIF91cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF9lcnJvckluZm8sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIF91cGRhdGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgLy8gQ2FwdHVyZSBhbmQgcmV0cnlcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IHZhbHVlO1xuICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJiBEaWRDYXB0dXJlKSA9PT0gTm9FZmZlY3QgJiYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJyB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gcmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHJlLXJlbmRlciB1c2luZyB1cGRhdGVkIHN0YXRlXG4gICAgICAgICAgdmFyIF91cGRhdGUyID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgZXJyb3JJbmZvLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBfdXBkYXRlMik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7XG59XG5cbmZ1bmN0aW9uIHVud2luZFdvcmsod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgcG9wQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVmZmVjdFRhZyA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgICAgaWYgKGVmZmVjdFRhZyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgX2VmZmVjdFRhZyA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgICAgISgoX2VmZmVjdFRhZyAmIERpZENhcHR1cmUpID09PSBOb0VmZmVjdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGUgcm9vdCBmYWlsZWQgdG8gdW5tb3VudCBhZnRlciBhbiBlcnJvci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBfZWZmZWN0VGFnICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBwb3BIeWRyYXRpb25TdGF0ZVxuICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfZWZmZWN0VGFnMiA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgICAgaWYgKF9lZmZlY3RUYWcyICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IF9lZmZlY3RUYWcyICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgICAgIC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICBjYXNlIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIpIHtcbiAgICAgICAgICAvLyBUT0RPOiBwb3BIeWRyYXRpb25TdGF0ZVxuICAgICAgICAgIHZhciBfZWZmZWN0VGFnMyA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgICAgICBpZiAoX2VmZmVjdFRhZzMgJiBTaG91bGRDYXB0dXJlKSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBfZWZmZWN0VGFnMyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgIC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcG9wUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVud2luZEludGVycnVwdGVkV29yayhpbnRlcnJ1cHRlZFdvcmspIHtcbiAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gaW50ZXJydXB0ZWRXb3JrLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7XG4gICAgICAgIGlmIChjaGlsZENvbnRleHRUeXBlcyAhPT0gbnVsbCAmJiBjaGlsZENvbnRleHRUeXBlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcG9wQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICBwb3BQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBSZWFjdEN1cnJlbnRPd25lciQyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5cblxudmFyIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHZvaWQgMDtcbnZhciBkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQgPSB2b2lkIDA7XG52YXIgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSB2b2lkIDA7XG52YXIgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMgPSB2b2lkIDA7XG5cbmlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gIC8vIFByb3ZpZGUgZXhwbGljaXQgZXJyb3IgbWVzc2FnZSB3aGVuIHByb2R1Y3Rpb24rcHJvZmlsaW5nIGJ1bmRsZSBvZiBlLmcuIHJlYWN0LWRvbVxuICAvLyBpcyB1c2VkIHdpdGggcHJvZHVjdGlvbiAobm9uLXByb2ZpbGluZykgYnVuZGxlIG9mIHNjaGVkdWxlci90cmFjaW5nXG4gICEodHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZiAhPSBudWxsICYmIHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0l0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gcnVuIHRoZSBwcm9maWxpbmcgdmVyc2lvbiBvZiBhIHJlbmRlcmVyIChmb3IgZXhhbXBsZSwgYHJlYWN0LWRvbS9wcm9maWxpbmdgKSB3aXRob3V0IGFsc28gcmVwbGFjaW5nIHRoZSBgc2NoZWR1bGVyL3RyYWNpbmdgIG1vZHVsZSB3aXRoIGBzY2hlZHVsZXIvdHJhY2luZy1wcm9maWxpbmdgLiBZb3VyIGJ1bmRsZXIgbWlnaHQgaGF2ZSBhIHNldHRpbmcgZm9yIGFsaWFzaW5nIGJvdGggbW9kdWxlcy4gTGVhcm4gbW9yZSBhdCBodHRwOi8vZmIubWUvcmVhY3QtcHJvZmlsaW5nJykgOiB2b2lkIDA7XG59XG5cbntcbiAgZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uID0gZmFsc2U7XG4gIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbiAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSBmdW5jdGlvbiAoZmliZXIsIGlzQ2xhc3MpIHtcbiAgICAvLyBXZSBzaG93IHRoZSB3aG9sZSBzdGFjayBidXQgZGVkdXBlIG9uIHRoZSB0b3AgY29tcG9uZW50J3MgbmFtZSBiZWNhdXNlXG4gICAgLy8gdGhlIHByb2JsZW1hdGljIGNvZGUgYWxtb3N0IGFsd2F5cyBsaWVzIGluc2lkZSB0aGF0IGNvbXBvbmVudC5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ1JlYWN0Q29tcG9uZW50JztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgXCJDYW4ndCBwZXJmb3JtIGEgUmVhY3Qgc3RhdGUgdXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgXCIgKyAnaXMgYSBuby1vcCwgYnV0IGl0IGluZGljYXRlcyBhIG1lbW9yeSBsZWFrIGluIHlvdXIgYXBwbGljYXRpb24uIFRvICcgKyAnZml4LCBjYW5jZWwgYWxsIHN1YnNjcmlwdGlvbnMgYW5kIGFzeW5jaHJvbm91cyB0YXNrcyBpbiAlcy4lcycsIGlzQ2xhc3MgPyAndGhlIGNvbXBvbmVudFdpbGxVbm1vdW50IG1ldGhvZCcgOiAnYSB1c2VFZmZlY3QgY2xlYW51cCBmdW5jdGlvbicsIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChmaWJlcikpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gIH07XG5cbiAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBzd2l0Y2ggKHBoYXNlKSB7XG4gICAgICBjYXNlICdnZXRDaGlsZENvbnRleHQnOlxuICAgICAgICBpZiAoZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ3NldFN0YXRlKC4uLik6IENhbm5vdCBjYWxsIHNldFN0YXRlKCkgaW5zaWRlIGdldENoaWxkQ29udGV4dCgpJyk7XG4gICAgICAgIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVuZGVyJzpcbiAgICAgICAgaWYgKGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgJ2ByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gVXNlZCB0byBlbnN1cmUgY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbiBpcyBtb25vdG9uaWNhbGx5IGRlY3JlYXNpbmcuXG52YXIgbGFzdFVuaXF1ZUFzeW5jRXhwaXJhdGlvbiA9IFN5bmMgLSAxO1xuXG52YXIgaXNXb3JraW5nID0gZmFsc2U7XG5cbi8vIFRoZSBuZXh0IHdvcmsgaW4gcHJvZ3Jlc3MgZmliZXIgdGhhdCB3ZSdyZSBjdXJyZW50bHkgd29ya2luZyBvbi5cbnZhciBuZXh0VW5pdE9mV29yayA9IG51bGw7XG52YXIgbmV4dFJvb3QgPSBudWxsO1xuLy8gVGhlIHRpbWUgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB3b3JrLlxudmFyIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbnZhciBuZXh0TGF0ZXN0QWJzb2x1dGVUaW1lb3V0TXMgPSAtMTtcbnZhciBuZXh0UmVuZGVyRGlkRXJyb3IgPSBmYWxzZTtcblxuLy8gVGhlIG5leHQgZmliZXIgd2l0aCBhbiBlZmZlY3QgdGhhdCB3ZSdyZSBjdXJyZW50bHkgY29tbWl0dGluZy5cbnZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxudmFyIGlzQ29tbWl0dGluZyQxID0gZmFsc2U7XG52YXIgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsO1xudmFyIHBhc3NpdmVFZmZlY3RDYWxsYmFja0hhbmRsZSA9IG51bGw7XG52YXIgcGFzc2l2ZUVmZmVjdENhbGxiYWNrID0gbnVsbDtcblxudmFyIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcblxuLy8gVXNlZCBmb3IgcGVyZm9ybWFuY2UgdHJhY2tpbmcuXG52YXIgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG5cbnZhciBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID0gdm9pZCAwO1xudmFyIHJlcGxheVVuaXRPZldvcmsgPSB2b2lkIDA7XG52YXIgbWF5UmVwbGF5RmFpbGVkVW5pdE9mV29yayA9IHZvaWQgMDtcbnZhciBpc1JlcGxheWluZ0ZhaWxlZFVuaXRPZldvcmsgPSB2b2lkIDA7XG52YXIgb3JpZ2luYWxSZXBsYXlFcnJvciA9IHZvaWQgMDtcbnZhciByZXRocm93T3JpZ2luYWxFcnJvciA9IHZvaWQgMDtcbmlmICh0cnVlICYmIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrKSB7XG4gIHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMgPSBudWxsO1xuICBtYXlSZXBsYXlGYWlsZWRVbml0T2ZXb3JrID0gdHJ1ZTtcbiAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gZmFsc2U7XG4gIG9yaWdpbmFsUmVwbGF5RXJyb3IgPSBudWxsO1xuICByZXBsYXlVbml0T2ZXb3JrID0gZnVuY3Rpb24gKGZhaWxlZFVuaXRPZldvcmssIHRocm93blZhbHVlLCBpc1lpZWxkeSkge1xuICAgIGlmICh0aHJvd25WYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGhyb3duVmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aHJvd25WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBEb24ndCByZXBsYXkgcHJvbWlzZXMuIFRyZWF0IGV2ZXJ5dGhpbmcgZWxzZSBsaWtlIGFuIGVycm9yLlxuICAgICAgLy8gVE9ETzogTmVlZCB0byBmaWd1cmUgb3V0IGEgZGlmZmVyZW50IHN0cmF0ZWd5IGlmL3doZW4gd2UgYWRkXG4gICAgICAvLyBzdXBwb3J0IGZvciBjYXRjaGluZyBvdGhlciB0eXBlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBzdGF0ZSBvZiB0aGUgd29yay1pbi1wcm9ncmVzc1xuICAgIGlmIChzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIERvbid0IHRocm93IGJlY2F1c2UgdGhpcyBjb2RlIGlzIERFVi1vbmx5LlxuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnQ291bGQgbm90IHJlcGxheSByZW5kZXJpbmcgYWZ0ZXIgYW4gZXJyb3IuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhc3NpZ25GaWJlclByb3BlcnRpZXNJbkRFVihmYWlsZWRVbml0T2ZXb3JrLCBzdGFzaGVkV29ya0luUHJvZ3Jlc3NQcm9wZXJ0aWVzKTtcblxuICAgIHN3aXRjaCAoZmFpbGVkVW5pdE9mV29yay50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoZmFpbGVkVW5pdE9mV29yayk7XG4gICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdChmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgQ29tcG9uZW50ID0gZmFpbGVkVW5pdE9mV29yay50eXBlO1xuICAgICAgICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICAgICAgICBwb3BDb250ZXh0KGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGZhaWxlZFVuaXRPZldvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgICBwb3BQcm92aWRlcihmYWlsZWRVbml0T2ZXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlcGxheSB0aGUgYmVnaW4gcGhhc2UuXG4gICAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gdHJ1ZTtcbiAgICBvcmlnaW5hbFJlcGxheUVycm9yID0gdGhyb3duVmFsdWU7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIHdvcmtMb29wLCBudWxsLCBpc1lpZWxkeSk7XG4gICAgaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrID0gZmFsc2U7XG4gICAgb3JpZ2luYWxSZXBsYXlFcnJvciA9IG51bGw7XG4gICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciByZXBsYXlFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgIGlmIChyZXBsYXlFcnJvciAhPSBudWxsICYmIHRocm93blZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBSZWFkaW5nIHRoZSBleHBhbmRvIHByb3BlcnR5IGlzIGludGVudGlvbmFsbHlcbiAgICAgICAgICAvLyBpbnNpZGUgYHRyeWAgYmVjYXVzZSBpdCBtaWdodCBiZSBhIGdldHRlciBvciBQcm94eS5cbiAgICAgICAgICBpZiAocmVwbGF5RXJyb3IuX3N1cHByZXNzTG9nZ2luZykge1xuICAgICAgICAgICAgLy8gQWxzbyBzdXBwcmVzcyBsb2dnaW5nIGZvciB0aGUgb3JpZ2luYWwgZXJyb3IuXG4gICAgICAgICAgICB0aHJvd25WYWx1ZS5fc3VwcHJlc3NMb2dnaW5nID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGlubmVyKSB7XG4gICAgICAgICAgLy8gSWdub3JlLlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBiZWdpbiBwaGFzZSBkaWQgbm90IGZhaWwgdGhlIHNlY29uZCB0aW1lLCBzZXQgdGhpcyBwb2ludGVyXG4gICAgICAvLyBiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZS5cbiAgICAgIG5leHRVbml0T2ZXb3JrID0gZmFpbGVkVW5pdE9mV29yaztcbiAgICB9XG4gIH07XG4gIHJldGhyb3dPcmlnaW5hbEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG9yaWdpbmFsUmVwbGF5RXJyb3I7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc2V0U3RhY2soKSB7XG4gIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgIHZhciBpbnRlcnJ1cHRlZFdvcmsgPSBuZXh0VW5pdE9mV29yay5yZXR1cm47XG4gICAgd2hpbGUgKGludGVycnVwdGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgdW53aW5kSW50ZXJydXB0ZWRXb3JrKGludGVycnVwdGVkV29yayk7XG4gICAgICBpbnRlcnJ1cHRlZFdvcmsgPSBpbnRlcnJ1cHRlZFdvcmsucmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gICAgY2hlY2tUaGF0U3RhY2tJc0VtcHR5KCk7XG4gIH1cblxuICBuZXh0Um9vdCA9IG51bGw7XG4gIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gLTE7XG4gIG5leHRSZW5kZXJEaWRFcnJvciA9IGZhbHNlO1xuICBuZXh0VW5pdE9mV29yayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEFsbEhvc3RFZmZlY3RzKCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHNldEN1cnJlbnRGaWJlcihuZXh0RWZmZWN0KTtcbiAgICB9XG4gICAgcmVjb3JkRWZmZWN0KCk7XG5cbiAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICBpZiAoZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgIHZhciBjdXJyZW50JCQxID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICBpZiAoY3VycmVudCQkMSAhPT0gbnVsbCkge1xuICAgICAgICBjb21taXREZXRhY2hSZWYoY3VycmVudCQkMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlIGZvbGxvd2luZyBzd2l0Y2ggc3RhdGVtZW50IGlzIG9ubHkgY29uY2VybmVkIGFib3V0IHBsYWNlbWVudCxcbiAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5XG4gICAgLy8gcG9zc2libGUgYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlXG4gICAgLy8gZWZmZWN0IHRhZyBhbmQgc3dpdGNoIG9uIHRoYXQgdmFsdWUuXG4gICAgdmFyIHByaW1hcnlFZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiAoUGxhY2VtZW50IHwgVXBkYXRlIHwgRGVsZXRpb24pO1xuICAgIHN3aXRjaCAocHJpbWFyeUVmZmVjdFRhZykge1xuICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWRcbiAgICAgICAgICAvLyBkb2VzIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGVcbiAgICAgICAgICAvLyB0byBraWxsIHRoaXMuXG4gICAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBQbGFjZW1lbnRBbmRVcGRhdGU6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBQbGFjZW1lbnRcbiAgICAgICAgICBjb21taXRQbGFjZW1lbnQobmV4dEVmZmVjdCk7XG4gICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG5cbiAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICB2YXIgX2N1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50LCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSBVcGRhdGU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2N1cnJlbnQyID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0V29yayhfY3VycmVudDIsIG5leHRFZmZlY3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlIERlbGV0aW9uOlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0RGVsZXRpb24obmV4dEVmZmVjdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxuXG4gIHtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcygpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgfVxuXG4gICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgIGlmIChlZmZlY3RUYWcgJiBTbmFwc2hvdCkge1xuICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICB2YXIgY3VycmVudCQkMSA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25MaWZlQ3ljbGVzKGN1cnJlbnQkJDEsIG5leHRFZmZlY3QpO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gIH1cblxuICB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRBbGxMaWZlQ3ljbGVzKGZpbmlzaGVkUm9vdCwgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpIHtcbiAge1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO1xuXG4gICAgaWYgKHdhcm5BYm91dERlcHJlY2F0ZWRMaWZlY3ljbGVzKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaFBlbmRpbmdEZXByZWNhdGlvbldhcm5pbmdzKCk7XG4gICAgfVxuICB9XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgIH1cbiAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICBpZiAoZWZmZWN0VGFnICYgKFVwZGF0ZSB8IENhbGxiYWNrKSkge1xuICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICB2YXIgY3VycmVudCQkMSA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgY29tbWl0TGlmZUN5Y2xlcyhmaW5pc2hlZFJvb3QsIGN1cnJlbnQkJDEsIG5leHRFZmZlY3QsIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICB9XG5cbiAgICBpZiAoZWZmZWN0VGFnICYgUGFzc2l2ZSkge1xuICAgICAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBmaW5pc2hlZFJvb3Q7XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgfVxuICB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlRWZmZWN0cyhyb290LCBmaXJzdEVmZmVjdCkge1xuICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGw7XG4gIHBhc3NpdmVFZmZlY3RDYWxsYmFja0hhbmRsZSA9IG51bGw7XG4gIHBhc3NpdmVFZmZlY3RDYWxsYmFjayA9IG51bGw7XG5cbiAgLy8gU2V0IHRoaXMgdG8gdHJ1ZSB0byBwcmV2ZW50IHJlLWVudHJhbmN5XG4gIHZhciBwcmV2aW91c0lzUmVuZGVyaW5nID0gaXNSZW5kZXJpbmc7XG4gIGlzUmVuZGVyaW5nID0gdHJ1ZTtcblxuICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gIGRvIHtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50RmliZXIoZWZmZWN0KTtcbiAgICB9XG5cbiAgICBpZiAoZWZmZWN0LmVmZmVjdFRhZyAmIFBhc3NpdmUpIHtcbiAgICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0UGFzc2l2ZUhvb2tFZmZlY3RzLCBudWxsLCBlZmZlY3QpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGVmZmVjdCwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBlZmZlY3QgPSBlZmZlY3QubmV4dEVmZmVjdDtcbiAgfSB3aGlsZSAoZWZmZWN0ICE9PSBudWxsKTtcbiAge1xuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIH1cblxuICBpc1JlbmRlcmluZyA9IHByZXZpb3VzSXNSZW5kZXJpbmc7XG5cbiAgLy8gQ2hlY2sgaWYgd29yayB3YXMgc2NoZWR1bGVkIGJ5IG9uZSBvZiB0aGUgZWZmZWN0c1xuICB2YXIgcm9vdEV4cGlyYXRpb25UaW1lID0gcm9vdC5leHBpcmF0aW9uVGltZTtcbiAgaWYgKHJvb3RFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgcmVxdWVzdFdvcmsocm9vdCwgcm9vdEV4cGlyYXRpb25UaW1lKTtcbiAgfVxuICAvLyBGbHVzaCBhbnkgc3luYyB3b3JrIHRoYXQgd2FzIHNjaGVkdWxlZCBieSBlZmZlY3RzXG4gIGlmICghaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzUmVuZGVyaW5nKSB7XG4gICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkge1xuICByZXR1cm4gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgIT09IG51bGwgJiYgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZChpbnN0YW5jZSkge1xuICBpZiAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPT09IG51bGwpIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW2luc3RhbmNlXSk7XG4gIH0gZWxzZSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuYWRkKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCkge1xuICBpZiAocGFzc2l2ZUVmZmVjdENhbGxiYWNrSGFuZGxlICE9PSBudWxsKSB7XG4gICAgY2FuY2VsUGFzc2l2ZUVmZmVjdHMocGFzc2l2ZUVmZmVjdENhbGxiYWNrSGFuZGxlKTtcbiAgfVxuICBpZiAocGFzc2l2ZUVmZmVjdENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgLy8gV2UgY2FsbCB0aGUgc2NoZWR1bGVkIGNhbGxiYWNrIGluc3RlYWQgb2YgY29tbWl0UGFzc2l2ZUVmZmVjdHMgZGlyZWN0bHlcbiAgICAvLyB0byBlbnN1cmUgdHJhY2luZyB3b3JrcyBjb3JyZWN0bHkuXG4gICAgcGFzc2l2ZUVmZmVjdENhbGxiYWNrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdChyb290LCBmaW5pc2hlZFdvcmspIHtcbiAgaXNXb3JraW5nID0gdHJ1ZTtcbiAgaXNDb21taXR0aW5nJDEgPSB0cnVlO1xuICBzdGFydENvbW1pdFRpbWVyKCk7XG5cbiAgIShyb290LmN1cnJlbnQgIT09IGZpbmlzaGVkV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IHRoZSBzYW1lIHRyZWUgYXMgYmVmb3JlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIHJlbGF0ZWQgdG8gdGhlIHJldHVybiBmaWVsZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIGNvbW1pdHRlZEV4cGlyYXRpb25UaW1lID0gcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWU7XG4gICEoY29tbWl0dGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgY29tbWl0IGFuIGluY29tcGxldGUgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgLy8gVXBkYXRlIHRoZSBwZW5kaW5nIHByaW9yaXR5IGxldmVscyB0byBhY2NvdW50IGZvciB0aGUgd29yayB0aGF0IHdlIGFyZVxuICAvLyBhYm91dCB0byBjb21taXQuIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSBjYWxsaW5nIHRoZSBsaWZlY3ljbGVzLCBzaW5jZVxuICAvLyB0aGV5IG1heSBzY2hlZHVsZSBhZGRpdGlvbmFsIHVwZGF0ZXMuXG4gIHZhciB1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCA9IGZpbmlzaGVkV29yay5leHBpcmF0aW9uVGltZTtcbiAgdmFyIGNoaWxkRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQgPSBmaW5pc2hlZFdvcmsuY2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgdmFyIGVhcmxpZXN0UmVtYWluaW5nVGltZUJlZm9yZUNvbW1pdCA9IGNoaWxkRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQgPiB1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdCA/IGNoaWxkRXhwaXJhdGlvblRpbWVCZWZvcmVDb21taXQgOiB1cGRhdGVFeHBpcmF0aW9uVGltZUJlZm9yZUNvbW1pdDtcbiAgbWFya0NvbW1pdHRlZFByaW9yaXR5TGV2ZWxzKHJvb3QsIGVhcmxpZXN0UmVtYWluaW5nVGltZUJlZm9yZUNvbW1pdCk7XG5cbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBudWxsO1xuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIC8vIFJlc3RvcmUgYW55IHBlbmRpbmcgaW50ZXJhY3Rpb25zIGF0IHRoaXMgcG9pbnQsXG4gICAgLy8gU28gdGhhdCBjYXNjYWRpbmcgd29yayB0cmlnZ2VyZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2Ugd2lsbCBiZSBhY2NvdW50ZWQgZm9yLlxuICAgIHByZXZJbnRlcmFjdGlvbnMgPSB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucztcbiAgfVxuXG4gIC8vIFJlc2V0IHRoaXMgdG8gbnVsbCBiZWZvcmUgY2FsbGluZyBsaWZlY3ljbGVzXG4gIFJlYWN0Q3VycmVudE93bmVyJDIuY3VycmVudCA9IG51bGw7XG5cbiAgdmFyIGZpcnN0RWZmZWN0ID0gdm9pZCAwO1xuICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAvLyBBIGZpYmVyJ3MgZWZmZWN0IGxpc3QgY29uc2lzdHMgb25seSBvZiBpdHMgY2hpbGRyZW4sIG5vdCBpdHNlbGYuIFNvIGlmXG4gICAgLy8gdGhlIHJvb3QgaGFzIGFuIGVmZmVjdCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC4gVGhlXG4gICAgLy8gcmVzdWx0aW5nIGxpc3QgaXMgdGhlIHNldCB0aGF0IHdvdWxkIGJlbG9uZyB0byB0aGUgcm9vdCdzIHBhcmVudCwgaWZcbiAgICAvLyBpdCBoYWQgb25lOyB0aGF0IGlzLCBhbGwgdGhlIGVmZmVjdHMgaW4gdGhlIHRyZWUgaW5jbHVkaW5nIHRoZSByb290LlxuICAgIGlmIChmaW5pc2hlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlcmUgaXMgbm8gZWZmZWN0IG9uIHRoZSByb290LlxuICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrLmZpcnN0RWZmZWN0O1xuICB9XG5cbiAgcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuXG4gIC8vIEludm9rZSBpbnN0YW5jZXMgb2YgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgYmVmb3JlIG11dGF0aW9uLlxuICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gIHN0YXJ0Q29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAge1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrKG51bGwsIGNvbW1pdEJlZm9yZU11dGF0aW9uTGlmZWN5Y2xlcywgbnVsbCk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKG5leHRFZmZlY3QsIGVycm9yKTtcbiAgICAgIC8vIENsZWFuLXVwXG4gICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wQ29tbWl0U25hcHNob3RFZmZlY3RzVGltZXIoKTtcblxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgY29tbWl0IHRpbWUgdG8gYmUgc2hhcmVkIGJ5IGFsbCBQcm9maWxlcnMgaW4gdGhpcyBiYXRjaC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdGhlbSB0byBiZSBncm91cGVkIGxhdGVyLlxuICAgIHJlY29yZENvbW1pdFRpbWUoKTtcbiAgfVxuXG4gIC8vIENvbW1pdCBhbGwgdGhlIHNpZGUtZWZmZWN0cyB3aXRoaW4gYSB0cmVlLiBXZSdsbCBkbyB0aGlzIGluIHR3byBwYXNzZXMuXG4gIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gIC8vIHJlZiB1bm1vdW50cy5cbiAgbmV4dEVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9lcnJvciA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0QWxsSG9zdEVmZmVjdHMsIG51bGwpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgX2RpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgX2Vycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX2RpZEVycm9yKSB7XG4gICAgICAhKG5leHRFZmZlY3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgbmV4dCBlZmZlY3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IpO1xuICAgICAgLy8gQ2xlYW4tdXBcbiAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCk7XG5cbiAgcmVzZXRBZnRlckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuXG4gIC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUgaXMgbm93IHRoZSBjdXJyZW50IHRyZWUuIFRoaXMgbXVzdCBjb21lIGFmdGVyXG4gIC8vIHRoZSBmaXJzdCBwYXNzIG9mIHRoZSBjb21taXQgcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGxcbiAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gIC8vIHRoZSBmaW5pc2hlZCB3b3JrIGlzIGN1cnJlbnQgZHVyaW5nIGNvbXBvbmVudERpZE1vdW50L1VwZGF0ZS5cbiAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrO1xuXG4gIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgLy8gTGlmZS1jeWNsZXMgaGFwcGVuIGFzIGEgc2VwYXJhdGUgcGFzcyBzbyB0aGF0IGFsbCBwbGFjZW1lbnRzLCB1cGRhdGVzLFxuICAvLyBhbmQgZGVsZXRpb25zIGluIHRoZSBlbnRpcmUgdHJlZSBoYXZlIGFscmVhZHkgYmVlbiBpbnZva2VkLlxuICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gIHN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIF9kaWRFcnJvcjIgPSBmYWxzZTtcbiAgICB2YXIgX2Vycm9yMiA9IHZvaWQgMDtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2sobnVsbCwgY29tbWl0QWxsTGlmZUN5Y2xlcywgbnVsbCwgcm9vdCwgY29tbWl0dGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgX2RpZEVycm9yMiA9IHRydWU7XG4gICAgICAgIF9lcnJvcjIgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfZGlkRXJyb3IyKSB7XG4gICAgICAhKG5leHRFZmZlY3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgbmV4dCBlZmZlY3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IyKTtcbiAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGZpcnN0RWZmZWN0ICE9PSBudWxsICYmIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKSB7XG4gICAgLy8gVGhpcyBjb21taXQgaW5jbHVkZWQgYSBwYXNzaXZlIGVmZmVjdC4gVGhlc2UgZG8gbm90IG5lZWQgdG8gZmlyZSB1bnRpbFxuICAgIC8vIGFmdGVyIHRoZSBuZXh0IHBhaW50LiBTY2hlZHVsZSBhbiBjYWxsYmFjayB0byBmaXJlIHRoZW0gaW4gYW4gYXN5bmNcbiAgICAvLyBldmVudC4gVG8gZW5zdXJlIHNlcmlhbCBleGVjdXRpb24sIHRoZSBjYWxsYmFjayB3aWxsIGJlIGZsdXNoZWQgZWFybHkgaWZcbiAgICAvLyB3ZSBlbnRlciByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyBjb21taXQgcGhhc2UgYmVmb3JlIHRoZW4uXG4gICAgdmFyIGNhbGxiYWNrID0gY29tbWl0UGFzc2l2ZUVmZmVjdHMuYmluZChudWxsLCByb290LCBmaXJzdEVmZmVjdCk7XG4gICAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICAgIC8vIFRPRE86IEF2b2lkIHRoaXMgZXh0cmEgY2FsbGJhY2sgYnkgbXV0YXRpbmcgdGhlIHRyYWNpbmcgcmVmIGRpcmVjdGx5LFxuICAgICAgLy8gbGlrZSB3ZSBkbyBhdCB0aGUgYmVnaW5uaW5nIG9mIGNvbW1pdFJvb3QuIEkndmUgb3B0ZWQgbm90IHRvIGRvIHRoYXRcbiAgICAgIC8vIGhlcmUgYmVjYXVzZSB0aGF0IGNvZGUgaXMgc3RpbGwgaW4gZmx1eC5cbiAgICAgIGNhbGxiYWNrID0gdHJhY2luZy51bnN0YWJsZV93cmFwKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcGFzc2l2ZUVmZmVjdENhbGxiYWNrSGFuZGxlID0gc2NoZWR1bGVyLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShzY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzY2hlZHVsZVBhc3NpdmVFZmZlY3RzKGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgICBwYXNzaXZlRWZmZWN0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIGlzQ29tbWl0dGluZyQxID0gZmFsc2U7XG4gIGlzV29ya2luZyA9IGZhbHNlO1xuICBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gIHN0b3BDb21taXRUaW1lcigpO1xuICBvbkNvbW1pdFJvb3QoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSk7XG4gIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tbWl0V29yayhmaW5pc2hlZFdvcmspO1xuICB9XG5cbiAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQgPSBmaW5pc2hlZFdvcmsuZXhwaXJhdGlvblRpbWU7XG4gIHZhciBjaGlsZEV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQgPSBmaW5pc2hlZFdvcmsuY2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgdmFyIGVhcmxpZXN0UmVtYWluaW5nVGltZUFmdGVyQ29tbWl0ID0gY2hpbGRFeHBpcmF0aW9uVGltZUFmdGVyQ29tbWl0ID4gdXBkYXRlRXhwaXJhdGlvblRpbWVBZnRlckNvbW1pdCA/IGNoaWxkRXhwaXJhdGlvblRpbWVBZnRlckNvbW1pdCA6IHVwZGF0ZUV4cGlyYXRpb25UaW1lQWZ0ZXJDb21taXQ7XG4gIGlmIChlYXJsaWVzdFJlbWFpbmluZ1RpbWVBZnRlckNvbW1pdCA9PT0gTm9Xb3JrKSB7XG4gICAgLy8gSWYgdGhlcmUncyBubyByZW1haW5pbmcgd29yaywgd2UgY2FuIGNsZWFyIHRoZSBzZXQgb2YgYWxyZWFkeSBmYWlsZWRcbiAgICAvLyBlcnJvciBib3VuZGFyaWVzLlxuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID0gbnVsbDtcbiAgfVxuICBvbkNvbW1pdChyb290LCBlYXJsaWVzdFJlbWFpbmluZ1RpbWVBZnRlckNvbW1pdCk7XG5cbiAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuXG4gICAgdmFyIHN1YnNjcmliZXIgPSB2b2lkIDA7XG5cbiAgICB0cnkge1xuICAgICAgc3Vic2NyaWJlciA9IHRyYWNpbmcuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCAmJiByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zLnNpemUgPiAwKSB7XG4gICAgICAgIHZhciB0aHJlYWRJRCA9IGNvbXB1dGVUaHJlYWRJRChjb21taXR0ZWRFeHBpcmF0aW9uVGltZSwgcm9vdC5pbnRlcmFjdGlvblRocmVhZElEKTtcbiAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gSXQncyBub3Qgc2FmZSBmb3IgY29tbWl0Um9vdCgpIHRvIHRocm93LlxuICAgICAgLy8gU3RvcmUgdGhlIGVycm9yIGZvciBub3cgYW5kIHdlJ2xsIHJlLXRocm93IGluIGZpbmlzaFJlbmRlcmluZygpLlxuICAgICAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIC8vIENsZWFyIGNvbXBsZXRlZCBpbnRlcmFjdGlvbnMgZnJvbSB0aGUgcGVuZGluZyBNYXAuXG4gICAgICAvLyBVbmxlc3MgdGhlIHJlbmRlciB3YXMgc3VzcGVuZGVkIG9yIGNhc2NhZGluZyB3b3JrIHdhcyBzY2hlZHVsZWQsXG4gICAgICAvLyBJbiB3aGljaCBjYXNl4oCTIGxlYXZlIHBlbmRpbmcgaW50ZXJhY3Rpb25zIHVudGlsIHRoZSBzdWJzZXF1ZW50IHJlbmRlci5cbiAgICAgIHZhciBwZW5kaW5nSW50ZXJhY3Rpb25NYXAgPSByb290LnBlbmRpbmdJbnRlcmFjdGlvbk1hcDtcbiAgICAgIHBlbmRpbmdJbnRlcmFjdGlvbk1hcC5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsZWRJbnRlcmFjdGlvbnMsIHNjaGVkdWxlZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIE9ubHkgZGVjcmVtZW50IHRoZSBwZW5kaW5nIGludGVyYWN0aW9uIGNvdW50IGlmIHdlJ3JlIGRvbmUuXG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgc3RpbGwgd29yayBhdCB0aGUgY3VycmVudCBwcmlvcml0eSxcbiAgICAgICAgLy8gVGhhdCBpbmRpY2F0ZXMgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igc3VzcGVuc2UgZGF0YS5cbiAgICAgICAgaWYgKHNjaGVkdWxlZEV4cGlyYXRpb25UaW1lID4gZWFybGllc3RSZW1haW5pbmdUaW1lQWZ0ZXJDb21taXQpIHtcbiAgICAgICAgICBwZW5kaW5nSW50ZXJhY3Rpb25NYXAuZGVsZXRlKHNjaGVkdWxlZEV4cGlyYXRpb25UaW1lKTtcblxuICAgICAgICAgIHNjaGVkdWxlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgaW50ZXJhY3Rpb24uX19jb3VudC0tO1xuXG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCAmJiBpbnRlcmFjdGlvbi5fX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgc2FmZSBmb3IgY29tbWl0Um9vdCgpIHRvIHRocm93LlxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBlcnJvciBmb3Igbm93IGFuZCB3ZSdsbCByZS10aHJvdyBpbiBmaW5pc2hSZW5kZXJpbmcoKS5cbiAgICAgICAgICAgICAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCByZW5kZXJUaW1lKSB7XG4gIGlmIChyZW5kZXJUaW1lICE9PSBOZXZlciAmJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZEV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgIC8vIFRoZSBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCBhcmUgaGlkZGVuLiBEb24ndCBidWJibGUgdGhlaXJcbiAgICAvLyBleHBpcmF0aW9uIHRpbWVzLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXdDaGlsZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lciAmJiB3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAvLyBXZSdyZSBpbiBwcm9maWxpbmcgbW9kZS5cbiAgICAvLyBMZXQncyB1c2UgdGhpcyBzYW1lIHRyYXZlcnNhbCB0byB1cGRhdGUgdGhlIHJlbmRlciBkdXJhdGlvbnMuXG4gICAgdmFyIGFjdHVhbER1cmF0aW9uID0gd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb247XG4gICAgdmFyIHRyZWVCYXNlRHVyYXRpb24gPSB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uO1xuXG4gICAgLy8gV2hlbiBhIGZpYmVyIGlzIGNsb25lZCwgaXRzIGFjdHVhbER1cmF0aW9uIGlzIHJlc2V0IHRvIDAuXG4gICAgLy8gVGhpcyB2YWx1ZSB3aWxsIG9ubHkgYmUgdXBkYXRlZCBpZiB3b3JrIGlzIGRvbmUgb24gdGhlIGZpYmVyIChpLmUuIGl0IGRvZXNuJ3QgYmFpbG91dCkuXG4gICAgLy8gV2hlbiB3b3JrIGlzIGRvbmUsIGl0IHNob3VsZCBidWJibGUgdG8gdGhlIHBhcmVudCdzIGFjdHVhbER1cmF0aW9uLlxuICAgIC8vIElmIHRoZSBmaWJlciBoYXMgbm90IGJlZW4gY2xvbmVkIHRob3VnaCwgKG1lYW5pbmcgbm8gd29yayB3YXMgZG9uZSksXG4gICAgLy8gVGhlbiB0aGlzIHZhbHVlIHdpbGwgcmVmbGVjdCB0aGUgYW1vdW50IG9mIHRpbWUgc3BlbnQgd29ya2luZyBvbiBhIHByZXZpb3VzIHJlbmRlci5cbiAgICAvLyBJbiB0aGF0IGNhc2UgaXQgc2hvdWxkIG5vdCBidWJibGUuXG4gICAgLy8gV2UgZGV0ZXJtaW5lIHdoZXRoZXIgaXQgd2FzIGNsb25lZCBieSBjb21wYXJpbmcgdGhlIGNoaWxkIHBvaW50ZXIuXG4gICAgdmFyIHNob3VsZEJ1YmJsZUFjdHVhbER1cmF0aW9ucyA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlLmNoaWxkO1xuXG4gICAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICB2YXIgY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZSA9IGNoaWxkLmV4cGlyYXRpb25UaW1lO1xuICAgICAgdmFyIGNoaWxkQ2hpbGRFeHBpcmF0aW9uVGltZSA9IGNoaWxkLmNoaWxkRXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAoY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZSA+IG5ld0NoaWxkRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9IGNoaWxkVXBkYXRlRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lID4gbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICBuZXdDaGlsZEV4cGlyYXRpb25UaW1lID0gY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZEJ1YmJsZUFjdHVhbER1cmF0aW9ucykge1xuICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgIH1cbiAgICAgIHRyZWVCYXNlRHVyYXRpb24gKz0gY2hpbGQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gdHJlZUJhc2VEdXJhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX2NoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKF9jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9jaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lID0gX2NoaWxkLmV4cGlyYXRpb25UaW1lO1xuICAgICAgdmFyIF9jaGlsZENoaWxkRXhwaXJhdGlvblRpbWUgPSBfY2hpbGQuY2hpbGRFeHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChfY2hpbGRVcGRhdGVFeHBpcmF0aW9uVGltZSA+IG5ld0NoaWxkRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbmV3Q2hpbGRFeHBpcmF0aW9uVGltZSA9IF9jaGlsZFVwZGF0ZUV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKF9jaGlsZENoaWxkRXhwaXJhdGlvblRpbWUgPiBuZXdDaGlsZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5ld0NoaWxkRXhwaXJhdGlvblRpbWUgPSBfY2hpbGRDaGlsZEV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGRFeHBpcmF0aW9uVGltZSA9IG5ld0NoaWxkRXhwaXJhdGlvblRpbWU7XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBBdHRlbXB0IHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IHVuaXQgb2Ygd29yaywgdGhlbiBtb3ZlIHRvIHRoZVxuICAvLyBuZXh0IHNpYmxpbmcuIElmIHRoZXJlIGFyZSBubyBtb3JlIHNpYmxpbmdzLCByZXR1cm4gdG8gdGhlXG4gIC8vIHBhcmVudCBmaWJlci5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCQkMSA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICB7XG4gICAgICBzZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciByZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcbiAgICB2YXIgc2libGluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3Muc2libGluZztcblxuICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICYgSW5jb21wbGV0ZSkgPT09IE5vRWZmZWN0KSB7XG4gICAgICBpZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgICAgICAvLyBEb24ndCByZXBsYXkgaWYgaXQgZmFpbHMgZHVyaW5nIGNvbXBsZXRpb24gcGhhc2UuXG4gICAgICAgIG1heVJlcGxheUZhaWxlZFVuaXRPZldvcmsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgZmliZXIgY29tcGxldGVkLlxuICAgICAgLy8gUmVtZW1iZXIgd2UncmUgY29tcGxldGluZyB0aGlzIHVuaXQgc28gd2UgY2FuIGZpbmQgYSBib3VuZGFyeSBpZiBpdCBmYWlscy5cbiAgICAgIG5leHRVbml0T2ZXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgICAgc3RhcnRQcm9maWxlclRpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0VW5pdE9mV29yayA9IGNvbXBsZXRlV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIC8vIFVwZGF0ZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGVycm9yLlxuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBjb21wbGV0ZVdvcmsoY3VycmVudCQkMSwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAodHJ1ZSAmJiByZXBsYXlGYWlsZWRVbml0T2ZXb3JrV2l0aEludm9rZUd1YXJkZWRDYWxsYmFjaykge1xuICAgICAgICAvLyBXZSdyZSBvdXQgb2YgY29tcGxldGlvbiBwaGFzZSBzbyByZXBsYXlpbmcgaXMgZmluZSBub3cuXG4gICAgICAgIG1heVJlcGxheUZhaWxlZFVuaXRPZldvcmsgPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXNldENoaWxkRXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDb21wbGV0aW5nIHRoaXMgZmliZXIgc3Bhd25lZCBuZXcgd29yay4gV29yayBvbiB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBuZXh0VW5pdE9mV29yaztcbiAgICAgIH1cblxuICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsICYmXG4gICAgICAvLyBEbyBub3QgYXBwZW5kIGVmZmVjdHMgdG8gcGFyZW50cyBpZiBhIHNpYmxpbmcgZmFpbGVkIHRvIGNvbXBsZXRlXG4gICAgICAocmV0dXJuRmliZXIuZWZmZWN0VGFnICYgSW5jb21wbGV0ZSkgPT09IE5vRWZmZWN0KSB7XG4gICAgICAgIC8vIEFwcGVuZCBhbGwgdGhlIGVmZmVjdHMgb2YgdGhlIHN1YnRyZWUgYW5kIHRoaXMgZmliZXIgb250byB0aGUgZWZmZWN0XG4gICAgICAgIC8vIGxpc3Qgb2YgdGhlIHBhcmVudC4gVGhlIGNvbXBsZXRpb24gb3JkZXIgb2YgdGhlIGNoaWxkcmVuIGFmZmVjdHMgdGhlXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0IG9yZGVyLlxuICAgICAgICBpZiAocmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgZmliZXIgaGFkIHNpZGUtZWZmZWN0cywgd2UgYXBwZW5kIGl0IEFGVEVSIHRoZSBjaGlsZHJlbidzXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gV2UgY2FuIHBlcmZvcm0gY2VydGFpbiBzaWRlLWVmZmVjdHMgZWFybGllciBpZlxuICAgICAgICAvLyBuZWVkZWQsIGJ5IGRvaW5nIG11bHRpcGxlIHBhc3NlcyBvdmVyIHRoZSBlZmZlY3QgbGlzdC4gV2UgZG9uJ3Qgd2FudFxuICAgICAgICAvLyB0byBzY2hlZHVsZSBvdXIgb3duIHNpZGUtZWZmZWN0IG9uIG91ciBvd24gbGlzdCBiZWNhdXNlIGlmIGVuZCB1cFxuICAgICAgICAvLyByZXVzaW5nIGNoaWxkcmVuIHdlJ2xsIHNjaGVkdWxlIHRoaXMgZWZmZWN0IG9udG8gaXRzZWxmIHNpbmNlIHdlJ3JlXG4gICAgICAgIC8vIGF0IHRoZSBlbmQuXG4gICAgICAgIHZhciBlZmZlY3RUYWcgPSB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWc7XG4gICAgICAgIC8vIFNraXAgYm90aCBOb1dvcmsgYW5kIFBlcmZvcm1lZFdvcmsgdGFncyB3aGVuIGNyZWF0aW5nIHRoZSBlZmZlY3QgbGlzdC5cbiAgICAgICAgLy8gUGVyZm9ybWVkV29yayBlZmZlY3QgaXMgcmVhZCBieSBSZWFjdCBEZXZUb29scyBidXQgc2hvdWxkbid0IGJlIGNvbW1pdHRlZC5cbiAgICAgICAgaWYgKGVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyVGltZXIgJiYgd29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgICAgIC8vIFJlY29yZCB0aGUgcmVuZGVyIGR1cmF0aW9uIGZvciB0aGUgZmliZXIgdGhhdCBlcnJvcmVkLlxuICAgICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKHdvcmtJblByb2dyZXNzLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gSW5jbHVkZSB0aGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGZhaWxlZCBjaGlsZHJlbiBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgdmFyIGFjdHVhbER1cmF0aW9uID0gd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb247XG4gICAgICAgIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlIGJlY2F1c2Ugc29tZXRoaW5nIHRocmV3LiBQb3AgdmFsdWVzIG9mZlxuICAgICAgLy8gdGhlIHN0YWNrIHdpdGhvdXQgZW50ZXJpbmcgdGhlIGNvbXBsZXRlIHBoYXNlLiBJZiB0aGlzIGlzIGEgYm91bmRhcnksXG4gICAgICAvLyBjYXB0dXJlIHZhbHVlcyBpZiBwb3NzaWJsZS5cbiAgICAgIHZhciBuZXh0ID0gdW53aW5kV29yayh3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIC8vIEJlY2F1c2UgdGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlLCBkb24ndCByZXNldCBpdHMgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmIERpZENhcHR1cmUpIHtcbiAgICAgICAgLy8gUmVzdGFydGluZyBhbiBlcnJvciBib3VuZGFyeVxuICAgICAgICBzdG9wRmFpbGVkV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBjb21wbGV0aW5nIHRoaXMgd29yayBzcGF3bmVkIG5ldyB3b3JrLCBkbyB0aGF0IG5leHQuIFdlJ2xsIGNvbWVcbiAgICAgICAgLy8gYmFjayBoZXJlIGFnYWluLlxuICAgICAgICAvLyBTaW5jZSB3ZSdyZSByZXN0YXJ0aW5nLCByZW1vdmUgYW55dGhpbmcgdGhhdCBpcyBub3QgYSBob3N0IGVmZmVjdFxuICAgICAgICAvLyBmcm9tIHRoZSBlZmZlY3QgdGFnLlxuICAgICAgICBuZXh0LmVmZmVjdFRhZyAmPSBIb3N0RWZmZWN0TWFzaztcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBNYXJrIHRoZSBwYXJlbnQgZmliZXIgYXMgaW5jb21wbGV0ZSBhbmQgY2xlYXIgaXRzIGVmZmVjdCBsaXN0LlxuICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm5GaWJlci5lZmZlY3RUYWcgfD0gSW5jb21wbGV0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgICByZXR1cm4gc2libGluZ0ZpYmVyO1xuICAgICAgfSBlbHNlIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG1vcmUgd29yayBpbiB0aGlzIHJldHVybkZpYmVyLiBDb21wbGV0ZSB0aGUgcmV0dXJuRmliZXIuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2l0aG91dCB0aGlzIGV4cGxpY2l0IG51bGwgcmV0dXJuIEZsb3cgY29tcGxhaW5zIG9mIGludmFsaWQgcmV0dXJuIHR5cGVcbiAgLy8gVE9ETyBSZW1vdmUgdGhlIGFib3ZlIHdoaWxlKHRydWUpIGxvb3BcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAvLyBwcm9ncmVzcy5cbiAgdmFyIGN1cnJlbnQkJDEgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICB7XG4gICAgc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIGlmICh0cnVlICYmIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrKSB7XG4gICAgc3Rhc2hlZFdvcmtJblByb2dyZXNzUHJvcGVydGllcyA9IGFzc2lnbkZpYmVyUHJvcGVydGllc0luREVWKHN0YXNoZWRXb3JrSW5Qcm9ncmVzc1Byb3BlcnRpZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBuZXh0ID0gdm9pZCAwO1xuICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpIHtcbiAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50JCQxLCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgLy8gUmVjb3JkIHRoZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGJhaWxvdXQgKG9yIGVycm9yKS5cbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEod29ya0luUHJvZ3Jlc3MsIHRydWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQkJDEsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIH1cblxuICB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICBpZiAoaXNSZXBsYXlpbmdGYWlsZWRVbml0T2ZXb3JrKSB7XG4gICAgICAvLyBDdXJyZW50bHkgcmVwbGF5aW5nIGEgZmFpbGVkIHVuaXQgb2Ygd29yay4gVGhpcyBzaG91bGQgYmUgdW5yZWFjaGFibGUsXG4gICAgICAvLyBiZWNhdXNlIHRoZSByZW5kZXIgcGhhc2UgaXMgbWVhbnQgdG8gYmUgaWRlbXBvdGVudCwgYW5kIGl0IHNob3VsZFxuICAgICAgLy8gaGF2ZSB0aHJvd24gYWdhaW4uIFNpbmNlIGl0IGRpZG4ndCwgcmV0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IsIHNvXG4gICAgICAvLyBSZWFjdCdzIGludGVybmFsIHN0YWNrIGlzIG5vdCBtaXNhbGlnbmVkLlxuICAgICAgcmV0aHJvd09yaWdpbmFsRXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBSZWFjdEN1cnJlbnRPd25lciQyLmN1cnJlbnQgPSBudWxsO1xuXG4gIHJldHVybiBuZXh0O1xufVxuXG5mdW5jdGlvbiB3b3JrTG9vcChpc1lpZWxkeSkge1xuICBpZiAoIWlzWWllbGR5KSB7XG4gICAgLy8gRmx1c2ggd29yayB3aXRob3V0IHlpZWxkaW5nXG4gICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlcmUncyBhIGhpZ2hlciBwcmlvcml0eSBldmVudFxuICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGRUb1JlbmRlcmVyKCkpIHtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJSb290KHJvb3QsIGlzWWllbGR5KSB7XG4gICEhaXNXb3JraW5nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyUm9vdCB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblxuICBpc1dvcmtpbmcgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gcm9vdC5uZXh0RXhwaXJhdGlvblRpbWVUb1dvcmtPbjtcblxuICAvLyBDaGVjayBpZiB3ZSdyZSBzdGFydGluZyBmcm9tIGEgZnJlc2ggc3RhY2ssIG9yIGlmIHdlJ3JlIHJlc3VtaW5nIGZyb21cbiAgLy8gcHJldmlvdXNseSB5aWVsZGVkIHdvcmsuXG4gIGlmIChleHBpcmF0aW9uVGltZSAhPT0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIHx8IHJvb3QgIT09IG5leHRSb290IHx8IG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgLy8gUmVzZXQgdGhlIHN0YWNrIGFuZCBzdGFydCB3b3JraW5nIGZyb20gdGhlIHJvb3QuXG4gICAgcmVzZXRTdGFjaygpO1xuICAgIG5leHRSb290ID0gcm9vdDtcbiAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICBuZXh0VW5pdE9mV29yayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKG5leHRSb290LmN1cnJlbnQsIG51bGwsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGludGVyYWN0aW9ucyB0aGlzIGJhdGNoIG9mIHdvcmsgY3VycmVudGx5IGluY2x1ZGVzLFxuICAgICAgLy8gU28gdGhhdCB3ZSBjYW4gYWNjdXJhdGVseSBhdHRyaWJ1dGUgdGltZSBzcGVudCB3b3JraW5nIG9uIGl0LFxuICAgICAgdmFyIGludGVyYWN0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgIHJvb3QucGVuZGluZ0ludGVyYWN0aW9uTWFwLmZvckVhY2goZnVuY3Rpb24gKHNjaGVkdWxlZEludGVyYWN0aW9ucywgc2NoZWR1bGVkRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgaWYgKHNjaGVkdWxlZEV4cGlyYXRpb25UaW1lID49IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgc2NoZWR1bGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb25zLmFkZChpbnRlcmFjdGlvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCBzZXQgb2YgaW50ZXJhY3Rpb25zIG9uIHRoZSBGaWJlclJvb3QgZm9yIGEgZmV3IHJlYXNvbnM6XG4gICAgICAvLyBXZSBjYW4gcmUtdXNlIGl0IGluIGhvdCBmdW5jdGlvbnMgbGlrZSByZW5kZXJSb290KCkgd2l0aG91dCBoYXZpbmcgdG8gcmVjYWxjdWxhdGUgaXQuXG4gICAgICAvLyBXZSB3aWxsIGFsc28gdXNlIGl0IGluIGNvbW1pdFdvcmsoKSB0byBwYXNzIHRvIGFueSBQcm9maWxlciBvblJlbmRlcigpIGhvb2tzLlxuICAgICAgLy8gVGhpcyBhbHNvIHByb3ZpZGVzIERldlRvb2xzIHdpdGggYSB3YXkgdG8gYWNjZXNzIGl0IHdoZW4gdGhlIG9uQ29tbWl0Um9vdCgpIGhvb2sgaXMgY2FsbGVkLlxuICAgICAgcm9vdC5tZW1vaXplZEludGVyYWN0aW9ucyA9IGludGVyYWN0aW9ucztcblxuICAgICAgaWYgKGludGVyYWN0aW9ucy5zaXplID4gMCkge1xuICAgICAgICB2YXIgc3Vic2NyaWJlciA9IHRyYWNpbmcuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIHRocmVhZElEID0gY29tcHV0ZVRocmVhZElEKGV4cGlyYXRpb25UaW1lLCByb290LmludGVyYWN0aW9uVGhyZWFkSUQpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFdvcmsgdGhyb3duIGJ5IGFuIGludGVyYWN0aW9uIHRyYWNpbmcgc3Vic2NyaWJlciBzaG91bGQgYmUgcmV0aHJvd24sXG4gICAgICAgICAgICAvLyBCdXQgb25seSBvbmNlIGl0J3Mgc2FmZSAodG8gYXZvaWQgbGVhdmluZyB0aGUgc2NoZWR1bGVyIGluIGFuIGludmFsaWQgc3RhdGUpLlxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGVycm9yIGZvciBub3cgYW5kIHdlJ2xsIHJlLXRocm93IGluIGZpbmlzaFJlbmRlcmluZygpLlxuICAgICAgICAgICAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgICAgICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgIHVuaGFuZGxlZEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBudWxsO1xuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIC8vIFdlJ3JlIGFib3V0IHRvIHN0YXJ0IG5ldyB0cmFjZWQgd29yay5cbiAgICAvLyBSZXN0b3JlIHBlbmRpbmcgaW50ZXJhY3Rpb25zIHNvIGNhc2NhZGluZyB3b3JrIHRyaWdnZXJlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSB3aWxsIGJlIGFjY291bnRlZCBmb3IuXG4gICAgcHJldkludGVyYWN0aW9ucyA9IHRyYWNpbmcuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcbiAgICB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSByb290Lm1lbW9pemVkSW50ZXJhY3Rpb25zO1xuICB9XG5cbiAgdmFyIGRpZEZhdGFsID0gZmFsc2U7XG5cbiAgc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKTtcblxuICBkbyB7XG4gICAgdHJ5IHtcbiAgICAgIHdvcmtMb29wKGlzWWllbGR5KTtcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgcmVzZXRDb250ZXh0RGVwZW5kZW5jZXMoKTtcbiAgICAgIHJlc2V0SG9va3MoKTtcblxuICAgICAgLy8gUmVzZXQgaW4gY2FzZSBjb21wbGV0aW9uIHRocm93cy5cbiAgICAgIC8vIFRoaXMgaXMgb25seSB1c2VkIGluIERFViBhbmQgd2hlbiByZXBsYXlpbmcgaXMgb24uXG4gICAgICB2YXIgbWF5UmVwbGF5ID0gdm9pZCAwO1xuICAgICAgaWYgKHRydWUgJiYgcmVwbGF5RmFpbGVkVW5pdE9mV29ya1dpdGhJbnZva2VHdWFyZGVkQ2FsbGJhY2spIHtcbiAgICAgICAgbWF5UmVwbGF5ID0gbWF5UmVwbGF5RmFpbGVkVW5pdE9mV29yaztcbiAgICAgICAgbWF5UmVwbGF5RmFpbGVkVW5pdE9mV29yayA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0VW5pdE9mV29yayA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgZmF0YWwgZXJyb3IuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgICAgb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyICYmIG5leHRVbml0T2ZXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgICAgICAgIC8vIFJlY29yZCB0aGUgdGltZSBzcGVudCByZW5kZXJpbmcgYmVmb3JlIGFuIGVycm9yIHdhcyB0aHJvd24uXG4gICAgICAgICAgLy8gVGhpcyBhdm9pZHMgaW5hY2N1cmF0ZSBQcm9maWxlciBkdXJhdGlvbnMgaW4gdGhlIGNhc2Ugb2YgYSBzdXNwZW5kZWQgcmVuZGVyLlxuICAgICAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEobmV4dFVuaXRPZldvcmssIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIC8vIFJlc2V0IGdsb2JhbCBkZWJ1ZyBzdGF0ZVxuICAgICAgICAgIC8vIFdlIGFzc3VtZSB0aGlzIGlzIGRlZmluZWQgaW4gREVWXG4gICAgICAgICAgcmVzZXRDdXJyZW50bHlQcm9jZXNzaW5nUXVldWUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cnVlICYmIHJlcGxheUZhaWxlZFVuaXRPZldvcmtXaXRoSW52b2tlR3VhcmRlZENhbGxiYWNrKSB7XG4gICAgICAgICAgaWYgKG1heVJlcGxheSkge1xuICAgICAgICAgICAgdmFyIGZhaWxlZFVuaXRPZldvcmsgPSBuZXh0VW5pdE9mV29yaztcbiAgICAgICAgICAgIHJlcGxheVVuaXRPZldvcmsoZmFpbGVkVW5pdE9mV29yaywgdGhyb3duVmFsdWUsIGlzWWllbGR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiB3ZSBhbHJlYWR5IGtub3cgdGhpcyBpc24ndCB0cnVlIGluIHNvbWUgY2FzZXMuXG4gICAgICAgIC8vIEF0IGxlYXN0IHRoaXMgc2hvd3MgYSBuaWNlciBlcnJvciBtZXNzYWdlIHVudGlsIHdlIGZpZ3VyZSBvdXQgdGhlIGNhdXNlLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyNDQ5I2lzc3VlY29tbWVudC0zODY3Mjc0MzFcbiAgICAgICAgIShuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdGYWlsZWQgdG8gcmVwbGF5IHJlbmRlcmluZyBhZnRlciBhbiBlcnJvci4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSB3aXRoIGEgcmVwcm9kdWNpbmcgY2FzZSB0byBoZWxwIHVzIGZpbmQgaXQuJykgOiB2b2lkIDA7XG5cbiAgICAgICAgdmFyIHNvdXJjZUZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgICAgIHZhciByZXR1cm5GaWJlciA9IHNvdXJjZUZpYmVyLnJldHVybjtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcm9vdC4gVGhlIHJvb3QgY291bGQgY2FwdHVyZSBpdHMgb3duIGVycm9ycy4gSG93ZXZlcixcbiAgICAgICAgICAvLyB3ZSBkb24ndCBrbm93IGlmIGl0IGVycm9ycyBiZWZvcmUgb3IgYWZ0ZXIgd2UgcHVzaGVkIHRoZSBob3N0XG4gICAgICAgICAgLy8gY29udGV4dC4gVGhpcyBpbmZvcm1hdGlvbiBpcyBuZWVkZWQgdG8gYXZvaWQgYSBzdGFjayBtaXNtYXRjaC5cbiAgICAgICAgICAvLyBCZWNhdXNlIHdlJ3JlIG5vdCBzdXJlLCB0cmVhdCB0aGlzIGFzIGEgZmF0YWwgZXJyb3IuIFdlIGNvdWxkIHRyYWNrXG4gICAgICAgICAgLy8gd2hpY2ggcGhhc2UgaXQgZmFpbHMgaW4sIGJ1dCBkb2Vzbid0IHNlZW0gd29ydGggaXQuIEF0IGxlYXN0XG4gICAgICAgICAgLy8gZm9yIG5vdy5cbiAgICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICAgICAgb25VbmNhdWdodEVycm9yKHRocm93blZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvd0V4Y2VwdGlvbihyb290LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHRocm93blZhbHVlLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gY29tcGxldGVVbml0T2ZXb3JrKHNvdXJjZUZpYmVyKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBicmVhaztcbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICAvLyBUcmFjZWQgd29yayBpcyBkb25lIGZvciBub3c7IHJlc3RvcmUgdGhlIHByZXZpb3VzIGludGVyYWN0aW9ucy5cbiAgICB0cmFjaW5nLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuICB9XG5cbiAgLy8gV2UncmUgZG9uZSBwZXJmb3JtaW5nIHdvcmsuIFRpbWUgdG8gY2xlYW4gdXAuXG4gIGlzV29ya2luZyA9IGZhbHNlO1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gIHJlc2V0Q29udGV4dERlcGVuZGVuY2VzKCk7XG4gIHJlc2V0SG9va3MoKTtcblxuICAvLyBZaWVsZCBiYWNrIHRvIG1haW4gdGhyZWFkLlxuICBpZiAoZGlkRmF0YWwpIHtcbiAgICB2YXIgX2RpZENvbXBsZXRlUm9vdCA9IGZhbHNlO1xuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIF9kaWRDb21wbGV0ZVJvb3QpO1xuICAgIGludGVycnVwdGVkQnkgPSBudWxsO1xuICAgIC8vIFRoZXJlIHdhcyBhIGZhdGFsIGVycm9yLlxuICAgIHtcbiAgICAgIHJlc2V0U3RhY2tBZnRlckZhdGFsRXJyb3JJbkRldigpO1xuICAgIH1cbiAgICAvLyBgbmV4dFJvb3RgIHBvaW50cyB0byB0aGUgaW4tcHJvZ3Jlc3Mgcm9vdC4gQSBub24tbnVsbCB2YWx1ZSBpbmRpY2F0ZXNcbiAgICAvLyB0aGF0IHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYW4gYXN5bmMgcmVuZGVyLiBTZXQgaXQgdG8gbnVsbCB0byBpbmRpY2F0ZVxuICAgIC8vIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIHRvIGJlIGRvbmUgaW4gdGhlIGN1cnJlbnQgYmF0Y2guXG4gICAgbmV4dFJvb3QgPSBudWxsO1xuICAgIG9uRmF0YWwocm9vdCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBzdGlsbCByZW1haW5pbmcgYXN5bmMgd29yayBpbiB0aGlzIHRyZWUsIGJ1dCB3ZSByYW4gb3V0IG9mIHRpbWVcbiAgICAvLyBpbiB0aGUgY3VycmVudCBmcmFtZS4gWWllbGQgYmFjayB0byB0aGUgcmVuZGVyZXIuIFVubGVzcyB3ZSdyZVxuICAgIC8vIGludGVycnVwdGVkIGJ5IGEgaGlnaGVyIHByaW9yaXR5IHVwZGF0ZSwgd2UnbGwgY29udGludWUgbGF0ZXIgZnJvbSB3aGVyZVxuICAgIC8vIHdlIGxlZnQgb2ZmLlxuICAgIHZhciBfZGlkQ29tcGxldGVSb290MiA9IGZhbHNlO1xuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIF9kaWRDb21wbGV0ZVJvb3QyKTtcbiAgICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcbiAgICBvbllpZWxkKHJvb3QpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFdlIGNvbXBsZXRlZCB0aGUgd2hvbGUgdHJlZS5cbiAgdmFyIGRpZENvbXBsZXRlUm9vdCA9IHRydWU7XG4gIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnksIGRpZENvbXBsZXRlUm9vdCk7XG4gIHZhciByb290V29ya0luUHJvZ3Jlc3MgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuICAhKHJvb3RXb3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdGaW5pc2hlZCByb290IHNob3VsZCBoYXZlIGEgd29yay1pbi1wcm9ncmVzcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAvLyBgbmV4dFJvb3RgIHBvaW50cyB0byB0aGUgaW4tcHJvZ3Jlc3Mgcm9vdC4gQSBub24tbnVsbCB2YWx1ZSBpbmRpY2F0ZXNcbiAgLy8gdGhhdCB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGFuIGFzeW5jIHJlbmRlci4gU2V0IGl0IHRvIG51bGwgdG8gaW5kaWNhdGVcbiAgLy8gdGhlcmUncyBubyBtb3JlIHdvcmsgdG8gYmUgZG9uZSBpbiB0aGUgY3VycmVudCBiYXRjaC5cbiAgbmV4dFJvb3QgPSBudWxsO1xuICBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcblxuICBpZiAobmV4dFJlbmRlckRpZEVycm9yKSB7XG4gICAgLy8gVGhlcmUgd2FzIGFuIGVycm9yXG4gICAgaWYgKGhhc0xvd2VyUHJpb3JpdHlXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgLy8gVGhlcmUncyBsb3dlciBwcmlvcml0eSB3b3JrLiBJZiBzbywgaXQgbWF5IGhhdmUgdGhlIGVmZmVjdCBvZiBmaXhpbmdcbiAgICAgIC8vIHRoZSBleGNlcHRpb24gdGhhdCB3YXMganVzdCB0aHJvd24uIEV4aXQgd2l0aG91dCBjb21taXR0aW5nLiBUaGlzIGlzXG4gICAgICAvLyBzaW1pbGFyIHRvIGEgc3VzcGVuZCwgYnV0IHdpdGhvdXQgYSB0aW1lb3V0IGJlY2F1c2Ugd2UncmUgbm90IHdhaXRpbmdcbiAgICAgIC8vIGZvciBhIHByb21pc2UgdG8gcmVzb2x2ZS4gUmVhY3Qgd2lsbCByZXN0YXJ0IGF0IHRoZSBsb3dlclxuICAgICAgLy8gcHJpb3JpdHkgbGV2ZWwuXG4gICAgICBtYXJrU3VzcGVuZGVkUHJpb3JpdHlMZXZlbChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICB2YXIgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIHZhciByb290RXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICAgICAgb25TdXNwZW5kKHJvb3QsIHJvb3RXb3JrSW5Qcm9ncmVzcywgc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUsIHJvb3RFeHBpcmF0aW9uVGltZSwgLTEgLy8gSW5kaWNhdGVzIG5vIHRpbWVvdXRcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChcbiAgICAvLyBUaGVyZSdzIG5vIGxvd2VyIHByaW9yaXR5IHdvcmssIGJ1dCB3ZSdyZSByZW5kZXJpbmcgYXN5bmNocm9ub3VzbHkuXG4gICAgLy8gU3luY2hyb25vdXNseSBhdHRlbXB0IHRvIHJlbmRlciB0aGUgc2FtZSBsZXZlbCBvbmUgbW9yZSB0aW1lLiBUaGlzIGlzXG4gICAgLy8gc2ltaWxhciB0byBhIHN1c3BlbmQsIGJ1dCB3aXRob3V0IGEgdGltZW91dCBiZWNhdXNlIHdlJ3JlIG5vdCB3YWl0aW5nXG4gICAgLy8gZm9yIGEgcHJvbWlzZSB0byByZXNvbHZlLlxuICAgICFyb290LmRpZEVycm9yICYmIGlzWWllbGR5KSB7XG4gICAgICByb290LmRpZEVycm9yID0gdHJ1ZTtcbiAgICAgIHZhciBfc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUgPSByb290Lm5leHRFeHBpcmF0aW9uVGltZVRvV29ya09uID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB2YXIgX3Jvb3RFeHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgb25TdXNwZW5kKHJvb3QsIHJvb3RXb3JrSW5Qcm9ncmVzcywgX3N1c3BlbmRlZEV4cGlyYXRpb25UaW1lLCBfcm9vdEV4cGlyYXRpb25UaW1lLCAtMSAvLyBJbmRpY2F0ZXMgbm8gdGltZW91dFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNZaWVsZHkgJiYgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zICE9PSAtMSkge1xuICAgIC8vIFRoZSB0cmVlIHdhcyBzdXNwZW5kZWQuXG4gICAgdmFyIF9zdXNwZW5kZWRFeHBpcmF0aW9uVGltZTIgPSBleHBpcmF0aW9uVGltZTtcbiAgICBtYXJrU3VzcGVuZGVkUHJpb3JpdHlMZXZlbChyb290LCBfc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUyKTtcblxuICAgIC8vIEZpbmQgdGhlIGVhcmxpZXN0IHVuY29tbWl0dGVkIGV4cGlyYXRpb24gdGltZSBpbiB0aGUgdHJlZSwgaW5jbHVkaW5nXG4gICAgLy8gd29yayB0aGF0IGlzIHN1c3BlbmRlZC4gVGhlIHRpbWVvdXQgdGhyZXNob2xkIGNhbm5vdCBiZSBsb25nZXIgdGhhblxuICAgIC8vIHRoZSBvdmVyYWxsIGV4cGlyYXRpb24uXG4gICAgdmFyIGVhcmxpZXN0RXhwaXJhdGlvblRpbWUgPSBmaW5kRWFybGllc3RPdXRzdGFuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIHZhciBlYXJsaWVzdEV4cGlyYXRpb25UaW1lTXMgPSBleHBpcmF0aW9uVGltZVRvTXMoZWFybGllc3RFeHBpcmF0aW9uVGltZSk7XG4gICAgaWYgKGVhcmxpZXN0RXhwaXJhdGlvblRpbWVNcyA8IG5leHRMYXRlc3RBYnNvbHV0ZVRpbWVvdXRNcykge1xuICAgICAgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gZWFybGllc3RFeHBpcmF0aW9uVGltZU1zO1xuICAgIH1cblxuICAgIC8vIFN1YnRyYWN0IHRoZSBjdXJyZW50IHRpbWUgZnJvbSB0aGUgYWJzb2x1dGUgdGltZW91dCB0byBnZXQgdGhlIG51bWJlclxuICAgIC8vIG9mIG1pbGxpc2Vjb25kcyB1bnRpbCB0aGUgdGltZW91dC4gSW4gb3RoZXIgd29yZHMsIGNvbnZlcnQgYW4gYWJzb2x1dGVcbiAgICAvLyB0aW1lc3RhbXAgdG8gYSByZWxhdGl2ZSB0aW1lLiBUaGlzIGlzIHRoZSB2YWx1ZSB0aGF0IGlzIHBhc3NlZFxuICAgIC8vIHRvIGBzZXRUaW1lb3V0YC5cbiAgICB2YXIgY3VycmVudFRpbWVNcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhyZXF1ZXN0Q3VycmVudFRpbWUoKSk7XG4gICAgdmFyIG1zVW50aWxUaW1lb3V0ID0gbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zIC0gY3VycmVudFRpbWVNcztcbiAgICBtc1VudGlsVGltZW91dCA9IG1zVW50aWxUaW1lb3V0IDwgMCA/IDAgOiBtc1VudGlsVGltZW91dDtcblxuICAgIC8vIFRPRE86IEFjY291bnQgZm9yIHRoZSBKdXN0IE5vdGljZWFibGUgRGlmZmVyZW5jZVxuXG4gICAgdmFyIF9yb290RXhwaXJhdGlvblRpbWUyID0gcm9vdC5leHBpcmF0aW9uVGltZTtcbiAgICBvblN1c3BlbmQocm9vdCwgcm9vdFdvcmtJblByb2dyZXNzLCBfc3VzcGVuZGVkRXhwaXJhdGlvblRpbWUyLCBfcm9vdEV4cGlyYXRpb25UaW1lMiwgbXNVbnRpbFRpbWVvdXQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFJlYWR5IHRvIGNvbW1pdC5cbiAgb25Db21wbGV0ZShyb290LCByb290V29ya0luUHJvZ3Jlc3MsIGV4cGlyYXRpb25UaW1lKTtcbn1cblxuZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3Ioc291cmNlRmliZXIsIHZhbHVlKSB7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gIHZhciBmaWJlciA9IHNvdXJjZUZpYmVyLnJldHVybjtcbiAgd2hpbGUgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHZhciBjdG9yID0gZmliZXIudHlwZTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgc291cmNlRmliZXIpO1xuICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGZpYmVyLCBlcnJvckluZm8sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUpO1xuICAgICAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2Vycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWUodmFsdWUsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgICB2YXIgX3VwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShmaWJlciwgX2Vycm9ySW5mbywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGVucXVldWVVcGRhdGUoZmliZXIsIF91cGRhdGUpO1xuICAgICAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgfVxuXG4gIGlmIChzb3VyY2VGaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gRXJyb3Igd2FzIHRocm93biBhdCB0aGUgcm9vdC4gVGhlcmUgaXMgbm8gcGFyZW50LCBzbyB0aGUgcm9vdFxuICAgIC8vIGl0c2VsZiBzaG91bGQgY2FwdHVyZSBpdC5cbiAgICB2YXIgcm9vdEZpYmVyID0gc291cmNlRmliZXI7XG4gICAgdmFyIF9lcnJvckluZm8yID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZSh2YWx1ZSwgcm9vdEZpYmVyKTtcbiAgICB2YXIgX3VwZGF0ZTIgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLCBfZXJyb3JJbmZvMiwgZXhwaXJhdGlvblRpbWUpO1xuICAgIGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCBfdXBkYXRlMik7XG4gICAgc2NoZWR1bGVXb3JrKHJvb3RGaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVUaHJlYWRJRChleHBpcmF0aW9uVGltZSwgaW50ZXJhY3Rpb25UaHJlYWRJRCkge1xuICAvLyBJbnRlcmFjdGlvbiB0aHJlYWRzIGFyZSB1bmlxdWUgcGVyIHJvb3QgYW5kIGV4cGlyYXRpb24gdGltZS5cbiAgcmV0dXJuIGV4cGlyYXRpb25UaW1lICogMTAwMCArIGludGVyYWN0aW9uVGhyZWFkSUQ7XG59XG5cbi8vIENyZWF0ZXMgYSB1bmlxdWUgYXN5bmMgZXhwaXJhdGlvbiB0aW1lLlxuZnVuY3Rpb24gY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbigpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gcmVxdWVzdEN1cnJlbnRUaW1lKCk7XG4gIHZhciByZXN1bHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKGN1cnJlbnRUaW1lKTtcbiAgaWYgKHJlc3VsdCA+PSBsYXN0VW5pcXVlQXN5bmNFeHBpcmF0aW9uKSB7XG4gICAgLy8gU2luY2Ugd2UgYXNzdW1lIHRoZSBjdXJyZW50IHRpbWUgbW9ub3RvbmljYWxseSBpbmNyZWFzZXMsIHdlIG9ubHkgaGl0XG4gICAgLy8gdGhpcyBicmFuY2ggd2hlbiBjb21wdXRlVW5pcXVlQXN5bmNFeHBpcmF0aW9uIGlzIGZpcmVkIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gd2l0aGluIGEgMjAwbXMgd2luZG93IChvciB3aGF0ZXZlciB0aGUgYXN5bmMgYnVja2V0IHNpemUgaXMpLlxuICAgIHJlc3VsdCA9IGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24gLSAxO1xuICB9XG4gIGxhc3RVbmlxdWVBc3luY0V4cGlyYXRpb24gPSByZXN1bHQ7XG4gIHJldHVybiBsYXN0VW5pcXVlQXN5bmNFeHBpcmF0aW9uO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGN1cnJlbnRUaW1lLCBmaWJlcikge1xuICB2YXIgcHJpb3JpdHlMZXZlbCA9IHNjaGVkdWxlci51bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbCgpO1xuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgaWYgKChmaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb0NvbnRleHQpIHtcbiAgICAvLyBPdXRzaWRlIG9mIGNvbmN1cnJlbnQgbW9kZSwgdXBkYXRlcyBhcmUgYWx3YXlzIHN5bmNocm9ub3VzLlxuICAgIGV4cGlyYXRpb25UaW1lID0gU3luYztcbiAgfSBlbHNlIGlmIChpc1dvcmtpbmcgJiYgIWlzQ29tbWl0dGluZyQxKSB7XG4gICAgLy8gRHVyaW5nIHJlbmRlciBwaGFzZSwgdXBkYXRlcyBleHBpcmUgZHVyaW5nIGFzIHRoZSBjdXJyZW50IHJlbmRlci5cbiAgICBleHBpcmF0aW9uVGltZSA9IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICAgIGNhc2Ugc2NoZWR1bGVyLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzY2hlZHVsZXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUludGVyYWN0aXZlRXhwaXJhdGlvbihjdXJyZW50VGltZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHk6XG4gICAgICAgIC8vIFRoaXMgaXMgYSBub3JtYWwsIGNvbmN1cnJlbnQgdXBkYXRlXG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbihjdXJyZW50VGltZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBzY2hlZHVsZXIudW5zdGFibGVfTG93UHJpb3JpdHk6XG4gICAgICBjYXNlIHNjaGVkdWxlci51bnN0YWJsZV9JZGxlUHJpb3JpdHk6XG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gTmV2ZXI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biBwcmlvcml0eSBsZXZlbC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZyBhIHRyZWUsIGRvIG5vdCB1cGRhdGUgYXQgdGhlIHNhbWVcbiAgICAvLyBleHBpcmF0aW9uIHRpbWUgdGhhdCBpcyBhbHJlYWR5IHJlbmRlcmluZy5cbiAgICBpZiAobmV4dFJvb3QgIT09IG51bGwgJiYgZXhwaXJhdGlvblRpbWUgPT09IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgZXhwaXJhdGlvblRpbWUgLT0gMTtcbiAgICB9XG4gIH1cblxuICAvLyBLZWVwIHRyYWNrIG9mIHRoZSBsb3dlc3QgcGVuZGluZyBpbnRlcmFjdGl2ZSBleHBpcmF0aW9uIHRpbWUuIFRoaXNcbiAgLy8gYWxsb3dzIHVzIHRvIHN5bmNocm9ub3VzbHkgZmx1c2ggYWxsIGludGVyYWN0aXZlIHVwZGF0ZXNcbiAgLy8gd2hlbiBuZWVkZWQuXG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byByZW5kZXJlcj9cbiAgaWYgKHByaW9yaXR5TGV2ZWwgPT09IHNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSAmJiAobG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGV4cGlyYXRpb25UaW1lIDwgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSkpIHtcbiAgICBsb3dlc3RQcmlvcml0eVBlbmRpbmdJbnRlcmFjdGl2ZUV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICByZXR1cm4gZXhwaXJhdGlvblRpbWU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmQocm9vdCwgYWJzb2x1dGVUaW1lb3V0TXMsIHN1c3BlbmRlZFRpbWUpIHtcbiAgLy8gU2NoZWR1bGUgdGhlIHRpbWVvdXQuXG4gIGlmIChhYnNvbHV0ZVRpbWVvdXRNcyA+PSAwICYmIG5leHRMYXRlc3RBYnNvbHV0ZVRpbWVvdXRNcyA8IGFic29sdXRlVGltZW91dE1zKSB7XG4gICAgbmV4dExhdGVzdEFic29sdXRlVGltZW91dE1zID0gYWJzb2x1dGVUaW1lb3V0TXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyRGlkRXJyb3IoKSB7XG4gIG5leHRSZW5kZXJEaWRFcnJvciA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBpbmdTdXNwZW5kZWRSb290KHJvb3QsIHRoZW5hYmxlLCBwaW5nVGltZSkge1xuICAvLyBBIHByb21pc2UgdGhhdCBwcmV2aW91c2x5IHN1c3BlbmRlZCBSZWFjdCBmcm9tIGNvbW1pdHRpbmcgaGFzIHJlc29sdmVkLlxuICAvLyBJZiBSZWFjdCBpcyBzdGlsbCBzdXNwZW5kZWQsIHRyeSBhZ2FpbiBhdCB0aGUgcHJldmlvdXMgbGV2ZWwgKHBpbmdUaW1lKS5cblxuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIGlmIChwaW5nQ2FjaGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgdGhlbmFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbiAgICBwaW5nQ2FjaGUuZGVsZXRlKHRoZW5hYmxlKTtcbiAgfVxuXG4gIGlmIChuZXh0Um9vdCAhPT0gbnVsbCAmJiBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IHBpbmdUaW1lKSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIHJlbmRlcmluZy4gUmVzdGFydCBmcm9tIHRoZSByb290LlxuICAgIG5leHRSb290ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb25maXJtIHRoYXQgdGhlIHJvb3QgaXMgc3RpbGwgc3VzcGVuZGVkIGF0IHRoaXMgbGV2ZWwuIE90aGVyd2lzZSBleGl0LlxuICAgIGlmIChpc1ByaW9yaXR5TGV2ZWxTdXNwZW5kZWQocm9vdCwgcGluZ1RpbWUpKSB7XG4gICAgICAvLyBQaW5nIGF0IHRoZSBvcmlnaW5hbCBsZXZlbFxuICAgICAgbWFya1BpbmdlZFByaW9yaXR5TGV2ZWwocm9vdCwgcGluZ1RpbWUpO1xuICAgICAgdmFyIHJvb3RFeHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocm9vdEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAgICAgcmVxdWVzdFdvcmsocm9vdCwgcm9vdEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHRoZW5hYmxlKSB7XG4gIC8vIFRoZSBib3VuZGFyeSBmaWJlciAoYSBTdXNwZW5zZSBjb21wb25lbnQpIHByZXZpb3VzbHkgdGltZWQgb3V0IGFuZCB3YXNcbiAgLy8gcmVuZGVyZWQgaW4gaXRzIGZhbGxiYWNrIHN0YXRlLiBPbmUgb2YgdGhlIHByb21pc2VzIHRoYXQgc3VzcGVuZGVkIGl0IGhhc1xuICAvLyByZXNvbHZlZCwgd2hpY2ggbWVhbnMgYXQgbGVhc3QgcGFydCBvZiB0aGUgdHJlZSB3YXMgbGlrZWx5IHVuYmxvY2tlZC4gVHJ5XG4gIHZhciByZXRyeUNhY2hlID0gdm9pZCAwO1xuICBpZiAoZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcikge1xuICAgIHN3aXRjaCAoYm91bmRhcnlGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgIHJldHJ5Q2FjaGUgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdQaW5nZWQgdW5rbm93biBzdXNwZW5zZSBib3VuZGFyeSB0eXBlLiBUaGlzIGlzIHByb2JhYmx5IGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gIH1cbiAgaWYgKHJldHJ5Q2FjaGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgdGhlbmFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbiAgICByZXRyeUNhY2hlLmRlbGV0ZSh0aGVuYWJsZSk7XG4gIH1cblxuICB2YXIgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgdmFyIHJldHJ5VGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudFRpbWUsIGJvdW5kYXJ5RmliZXIpO1xuICB2YXIgcm9vdCA9IHNjaGVkdWxlV29ya1RvUm9vdChib3VuZGFyeUZpYmVyLCByZXRyeVRpbWUpO1xuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIG1hcmtQZW5kaW5nUHJpb3JpdHlMZXZlbChyb290LCByZXRyeVRpbWUpO1xuICAgIHZhciByb290RXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICAgIGlmIChyb290RXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgcmVxdWVzdFdvcmsocm9vdCwgcm9vdEV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVXb3JrVG9Sb290KGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpO1xuXG4gIHtcbiAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0ZSB0aGUgc291cmNlIGZpYmVyJ3MgZXhwaXJhdGlvbiB0aW1lXG4gIGlmIChmaWJlci5leHBpcmF0aW9uVGltZSA8IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgfVxuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA8IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIH1cbiAgLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSB0aGUgY2hpbGQgZXhwaXJhdGlvbiB0aW1lLlxuICB2YXIgbm9kZSA9IGZpYmVyLnJldHVybjtcbiAgdmFyIHJvb3QgPSBudWxsO1xuICBpZiAobm9kZSA9PT0gbnVsbCAmJiBmaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgcm9vdCA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGU7XG4gICAgICBpZiAobm9kZS5jaGlsZEV4cGlyYXRpb25UaW1lIDwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbm9kZS5jaGlsZEV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPCBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZS5jaGlsZEV4cGlyYXRpb25UaW1lIDwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgYWx0ZXJuYXRlLmNoaWxkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCAmJiBub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW50ZXJhY3Rpb25zID0gdHJhY2luZy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICAgICAgaWYgKGludGVyYWN0aW9ucy5zaXplID4gMCkge1xuICAgICAgICB2YXIgcGVuZGluZ0ludGVyYWN0aW9uTWFwID0gcm9vdC5wZW5kaW5nSW50ZXJhY3Rpb25NYXA7XG4gICAgICAgIHZhciBwZW5kaW5nSW50ZXJhY3Rpb25zID0gcGVuZGluZ0ludGVyYWN0aW9uTWFwLmdldChleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChwZW5kaW5nSW50ZXJhY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghcGVuZGluZ0ludGVyYWN0aW9ucy5oYXMoaW50ZXJhY3Rpb24pKSB7XG4gICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcGVuZGluZyBhc3luYyB3b3JrIGNvdW50IGZvciBwcmV2aW91c2x5IHVuc2NoZWR1bGVkIGludGVyYWN0aW9uLlxuICAgICAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBlbmRpbmdJbnRlcmFjdGlvbnMuYWRkKGludGVyYWN0aW9uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZW5kaW5nSW50ZXJhY3Rpb25NYXAuc2V0KGV4cGlyYXRpb25UaW1lLCBuZXcgU2V0KGludGVyYWN0aW9ucykpO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBwZW5kaW5nIGFzeW5jIHdvcmsgY291bnQgZm9yIHRoZSBjdXJyZW50IGludGVyYWN0aW9ucy5cbiAgICAgICAgICBpbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQrKztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdWJzY3JpYmVyID0gdHJhY2luZy5fX3N1YnNjcmliZXJSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgdGhyZWFkSUQgPSBjb21wdXRlVGhyZWFkSUQoZXhwaXJhdGlvblRpbWUsIHJvb3QuaW50ZXJhY3Rpb25UaHJlYWRJRCk7XG4gICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3Q7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZk5vdEN1cnJlbnRseUJhdGNoaW5nSW5EZXYoZmliZXIpIHtcbiAge1xuICAgIGlmIChpc1JlbmRlcmluZyA9PT0gZmFsc2UgJiYgaXNCYXRjaGluZ1VwZGF0ZXMgPT09IGZhbHNlKSB7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbicgKyAnYWN0KCgpID0+IHtcXG4nICsgJyAgLyogZmlyZSBldmVudHMgdGhhdCB1cGRhdGUgc3RhdGUgKi9cXG4nICsgJ30pO1xcbicgKyAnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nICsgXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIGluIHRoZSBicm93c2VyLlwiICsgJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vZmIubWUvcmVhY3Qtd3JhcC10ZXN0cy13aXRoLWFjdCcgKyAnJXMnLCBnZXRDb21wb25lbnROYW1lKGZpYmVyLnR5cGUpLCBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoZmliZXIpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgcm9vdCA9IHNjaGVkdWxlV29ya1RvUm9vdChmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkKGZpYmVyLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghaXNXb3JraW5nICYmIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIGV4cGlyYXRpb25UaW1lID4gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBpbnRlcnJ1cHRpb24uIChVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy4pXG4gICAgaW50ZXJydXB0ZWRCeSA9IGZpYmVyO1xuICAgIHJlc2V0U3RhY2soKTtcbiAgfVxuICBtYXJrUGVuZGluZ1ByaW9yaXR5TGV2ZWwocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICBpZiAoXG4gIC8vIElmIHdlJ3JlIGluIHRoZSByZW5kZXIgcGhhc2UsIHdlIGRvbid0IG5lZWQgdG8gc2NoZWR1bGUgdGhpcyByb290XG4gIC8vIGZvciBhbiB1cGRhdGUsIGJlY2F1c2Ugd2UnbGwgZG8gaXQgYmVmb3JlIHdlIGV4aXQuLi5cbiAgIWlzV29ya2luZyB8fCBpc0NvbW1pdHRpbmckMSB8fFxuICAvLyAuLi51bmxlc3MgdGhpcyBpcyBhIGRpZmZlcmVudCByb290IHRoYW4gdGhlIG9uZSB3ZSdyZSByZW5kZXJpbmcuXG4gIG5leHRSb290ICE9PSByb290KSB7XG4gICAgdmFyIHJvb3RFeHBpcmF0aW9uVGltZSA9IHJvb3QuZXhwaXJhdGlvblRpbWU7XG4gICAgcmVxdWVzdFdvcmsocm9vdCwgcm9vdEV4cGlyYXRpb25UaW1lKTtcbiAgfVxuICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgLy8gUmVzZXQgdGhpcyBiYWNrIHRvIHplcm8gc28gc3Vic2VxdWVudCB1cGRhdGVzIGRvbid0IHRocm93LlxuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgcmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciBjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4sIGEsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIHNjaGVkdWxlci51bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkoc2NoZWR1bGVyLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5LCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuKGEsIGIsIGMsIGQpO1xuICB9KTtcbn1cblxuLy8gVE9ETzogRXZlcnl0aGluZyBiZWxvdyB0aGlzIGlzIHdyaXR0ZW4gYXMgaWYgaXQgaGFzIGJlZW4gbGlmdGVkIHRvIHRoZVxuLy8gcmVuZGVyZXJzLiBJJ2xsIGRvIHRoaXMgaW4gYSBmb2xsb3ctdXAuXG5cbi8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG52YXIgZmlyc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbnZhciBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG5cbnZhciBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xudmFyIGNhbGxiYWNrSUQgPSB2b2lkIDA7XG52YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbnZhciBuZXh0Rmx1c2hlZFJvb3QgPSBudWxsO1xudmFyIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG52YXIgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbnZhciBoYXNVbmhhbmRsZWRFcnJvciA9IGZhbHNlO1xudmFyIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcblxudmFyIGlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG52YXIgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuXG52YXIgY29tcGxldGVkQmF0Y2hlcyA9IG51bGw7XG5cbnZhciBvcmlnaW5hbFN0YXJ0VGltZU1zID0gc2NoZWR1bGVyLnVuc3RhYmxlX25vdygpO1xudmFyIGN1cnJlbnRSZW5kZXJlclRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUob3JpZ2luYWxTdGFydFRpbWVNcyk7XG52YXIgY3VycmVudFNjaGVkdWxlclRpbWUgPSBjdXJyZW50UmVuZGVyZXJUaW1lO1xuXG4vLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG52YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbnZhciBsYXN0Q29tbWl0dGVkUm9vdER1cmluZ1RoaXNCYXRjaCA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKSB7XG4gIHZhciBjdXJyZW50VGltZU1zID0gc2NoZWR1bGVyLnVuc3RhYmxlX25vdygpIC0gb3JpZ2luYWxTdGFydFRpbWVNcztcbiAgY3VycmVudFJlbmRlcmVyVGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShjdXJyZW50VGltZU1zKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uVGltZShyb290LCBleHBpcmF0aW9uVGltZSkge1xuICBpZiAoY2FsbGJhY2tFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgLy8gQSBjYWxsYmFjayBpcyBhbHJlYWR5IHNjaGVkdWxlZC4gQ2hlY2sgaXRzIGV4cGlyYXRpb24gdGltZSAodGltZW91dCkuXG4gICAgaWYgKGV4cGlyYXRpb25UaW1lIDwgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSkge1xuICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIHN1ZmZpY2llbnQgdGltZW91dC4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGNhbGxiYWNrSUQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gRXhpc3RpbmcgY2FsbGJhY2sgaGFzIGluc3VmZmljaWVudCB0aW1lb3V0LiBDYW5jZWwgYW5kIHNjaGVkdWxlIGFcbiAgICAgICAgLy8gbmV3IG9uZS5cbiAgICAgICAgc2NoZWR1bGVyLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrKGNhbGxiYWNrSUQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGUgcmVxdWVzdCBjYWxsYmFjayB0aW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcuIERvbid0IHN0YXJ0IGEgbmV3IG9uZS5cbiAgfSBlbHNlIHtcbiAgICBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCk7XG4gIH1cblxuICBjYWxsYmFja0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHZhciBjdXJyZW50TXMgPSBzY2hlZHVsZXIudW5zdGFibGVfbm93KCkgLSBvcmlnaW5hbFN0YXJ0VGltZU1zO1xuICB2YXIgZXhwaXJhdGlvblRpbWVNcyA9IGV4cGlyYXRpb25UaW1lVG9NcyhleHBpcmF0aW9uVGltZSk7XG4gIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvblRpbWVNcyAtIGN1cnJlbnRNcztcbiAgY2FsbGJhY2tJRCA9IHNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrKHBlcmZvcm1Bc3luY1dvcmssIHsgdGltZW91dDogdGltZW91dCB9KTtcbn1cblxuLy8gRm9yIGV2ZXJ5IGNhbGwgdG8gcmVuZGVyUm9vdCwgb25lIG9mIG9uRmF0YWwsIG9uQ29tcGxldGUsIG9uU3VzcGVuZCwgYW5kXG4vLyBvbllpZWxkIGlzIGNhbGxlZCB1cG9uIGV4aXRpbmcuIFdlIHVzZSB0aGVzZSBpbiBsaWV1IG9mIHJldHVybmluZyBhIHR1cGxlLlxuLy8gSSd2ZSBhbHNvIGNob3NlbiBub3QgdG8gaW5saW5lIHRoZW0gaW50byByZW5kZXJSb290IGJlY2F1c2UgdGhlc2Ugd2lsbFxuLy8gZXZlbnR1YWxseSBiZSBsaWZ0ZWQgaW50byB0aGUgcmVuZGVyZXIuXG5mdW5jdGlvbiBvbkZhdGFsKHJvb3QpIHtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBvbkNvbXBsZXRlKHJvb3QsIGZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpIHtcbiAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG59XG5cbmZ1bmN0aW9uIG9uU3VzcGVuZChyb290LCBmaW5pc2hlZFdvcmssIHN1c3BlbmRlZEV4cGlyYXRpb25UaW1lLCByb290RXhwaXJhdGlvblRpbWUsIG1zVW50aWxUaW1lb3V0KSB7XG4gIHJvb3QuZXhwaXJhdGlvblRpbWUgPSByb290RXhwaXJhdGlvblRpbWU7XG4gIGlmIChtc1VudGlsVGltZW91dCA9PT0gMCAmJiAhc2hvdWxkWWllbGRUb1JlbmRlcmVyKCkpIHtcbiAgICAvLyBEb24ndCB3YWl0IGFuIGFkZGl0aW9uYWwgdGljay4gQ29tbWl0IHRoZSB0cmVlIGltbWVkaWF0ZWx5LlxuICAgIHJvb3QucGVuZGluZ0NvbW1pdEV4cGlyYXRpb25UaW1lID0gc3VzcGVuZGVkRXhwaXJhdGlvblRpbWU7XG4gICAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gIH0gZWxzZSBpZiAobXNVbnRpbFRpbWVvdXQgPiAwKSB7XG4gICAgLy8gV2FpdCBgbXNVbnRpbFRpbWVvdXRgIG1pbGxpc2Vjb25kcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICByb290LnRpbWVvdXRIYW5kbGUgPSBzY2hlZHVsZVRpbWVvdXQob25UaW1lb3V0LmJpbmQobnVsbCwgcm9vdCwgZmluaXNoZWRXb3JrLCBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSksIG1zVW50aWxUaW1lb3V0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbllpZWxkKHJvb3QpIHtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBvblRpbWVvdXQocm9vdCwgZmluaXNoZWRXb3JrLCBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSkge1xuICAvLyBUaGUgcm9vdCB0aW1lZCBvdXQuIENvbW1pdCBpdC5cbiAgcm9vdC5wZW5kaW5nQ29tbWl0RXhwaXJhdGlvblRpbWUgPSBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gIC8vIFJlYWQgdGhlIGN1cnJlbnQgdGltZSBiZWZvcmUgZW50ZXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gV2UgY2FuIGJlXG4gIC8vIGNlcnRhaW4gdGhpcyB3b24ndCBjYXVzZSB0ZWFyaW5nIHJlbGF0ZWQgdG8gYmF0Y2hpbmcgb2YgZXZlbnQgdXBkYXRlc1xuICAvLyBiZWNhdXNlIHdlJ3JlIGF0IHRoZSB0b3Agb2YgYSB0aW1lciBldmVudC5cbiAgcmVjb21wdXRlQ3VycmVudFJlbmRlcmVyVGltZSgpO1xuICBjdXJyZW50U2NoZWR1bGVyVGltZSA9IGN1cnJlbnRSZW5kZXJlclRpbWU7XG4gIGZsdXNoUm9vdChyb290LCBzdXNwZW5kZWRFeHBpcmF0aW9uVGltZSk7XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHJvb3QuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0Q3VycmVudFRpbWUoKSB7XG4gIC8vIHJlcXVlc3RDdXJyZW50VGltZSBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB0byBjb21wdXRlIGFuIGV4cGlyYXRpb25cbiAgLy8gdGltZS5cbiAgLy9cbiAgLy8gRXhwaXJhdGlvbiB0aW1lcyBhcmUgY29tcHV0ZWQgYnkgYWRkaW5nIHRvIHRoZSBjdXJyZW50IHRpbWUgKHRoZSBzdGFydFxuICAvLyB0aW1lKS4gSG93ZXZlciwgaWYgdHdvIHVwZGF0ZXMgYXJlIHNjaGVkdWxlZCB3aXRoaW4gdGhlIHNhbWUgZXZlbnQsIHdlXG4gIC8vIHNob3VsZCB0cmVhdCB0aGVpciBzdGFydCB0aW1lcyBhcyBzaW11bHRhbmVvdXMsIGV2ZW4gaWYgdGhlIGFjdHVhbCBjbG9ja1xuICAvLyB0aW1lIGhhcyBhZHZhbmNlZCBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgc2Vjb25kIGNhbGwuXG5cbiAgLy8gSW4gb3RoZXIgd29yZHMsIGJlY2F1c2UgZXhwaXJhdGlvbiB0aW1lcyBkZXRlcm1pbmUgaG93IHVwZGF0ZXMgYXJlIGJhdGNoZWQsXG4gIC8vIHdlIHdhbnQgYWxsIHVwZGF0ZXMgb2YgbGlrZSBwcmlvcml0eSB0aGF0IG9jY3VyIHdpdGhpbiB0aGUgc2FtZSBldmVudCB0b1xuICAvLyByZWNlaXZlIHRoZSBzYW1lIGV4cGlyYXRpb24gdGltZS4gT3RoZXJ3aXNlIHdlIGdldCB0ZWFyaW5nLlxuICAvL1xuICAvLyBXZSBrZWVwIHRyYWNrIG9mIHR3byBzZXBhcmF0ZSB0aW1lczogdGhlIGN1cnJlbnQgXCJyZW5kZXJlclwiIHRpbWUgYW5kIHRoZVxuICAvLyBjdXJyZW50IFwic2NoZWR1bGVyXCIgdGltZS4gVGhlIHJlbmRlcmVyIHRpbWUgY2FuIGJlIHVwZGF0ZWQgd2hlbmV2ZXI7IGl0XG4gIC8vIG9ubHkgZXhpc3RzIHRvIG1pbmltaXplIHRoZSBjYWxscyBwZXJmb3JtYW5jZS5ub3cuXG4gIC8vXG4gIC8vIEJ1dCB0aGUgc2NoZWR1bGVyIHRpbWUgY2FuIG9ubHkgYmUgdXBkYXRlZCBpZiB0aGVyZSdzIG5vIHBlbmRpbmcgd29yaywgb3JcbiAgLy8gaWYgd2Uga25vdyBmb3IgY2VydGFpbiB0aGF0IHdlJ3JlIG5vdCBpbiB0aGUgbWlkZGxlIG9mIGFuIGV2ZW50LlxuXG4gIGlmIChpc1JlbmRlcmluZykge1xuICAgIC8vIFdlJ3JlIGFscmVhZHkgcmVuZGVyaW5nLiBSZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgcmVhZCB0aW1lLlxuICAgIHJldHVybiBjdXJyZW50U2NoZWR1bGVyVGltZTtcbiAgfVxuICAvLyBDaGVjayBpZiB0aGVyZSdzIHBlbmRpbmcgd29yay5cbiAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgaWYgKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcGVuZGluZyB3b3JrLCBvciBpZiB0aGUgcGVuZGluZyB3b3JrIGlzIG9mZnNjcmVlbiwgd2UgY2FuXG4gICAgLy8gcmVhZCB0aGUgY3VycmVudCB0aW1lIHdpdGhvdXQgcmlzayBvZiB0ZWFyaW5nLlxuICAgIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKTtcbiAgICBjdXJyZW50U2NoZWR1bGVyVGltZSA9IGN1cnJlbnRSZW5kZXJlclRpbWU7XG4gICAgcmV0dXJuIGN1cnJlbnRTY2hlZHVsZXJUaW1lO1xuICB9XG4gIC8vIFRoZXJlJ3MgYWxyZWFkeSBwZW5kaW5nIHdvcmsuIFdlIG1pZ2h0IGJlIGluIHRoZSBtaWRkbGUgb2YgYSBicm93c2VyXG4gIC8vIGV2ZW50LiBJZiB3ZSB3ZXJlIHRvIHJlYWQgdGhlIGN1cnJlbnQgdGltZSwgaXQgY291bGQgY2F1c2UgbXVsdGlwbGUgdXBkYXRlc1xuICAvLyB3aXRoaW4gdGhlIHNhbWUgZXZlbnQgdG8gcmVjZWl2ZSBkaWZmZXJlbnQgZXhwaXJhdGlvbiB0aW1lcywgbGVhZGluZyB0b1xuICAvLyB0ZWFyaW5nLiBSZXR1cm4gdGhlIGxhc3QgcmVhZCB0aW1lLiBEdXJpbmcgdGhlIG5leHQgaWRsZSBjYWxsYmFjaywgdGhlXG4gIC8vIHRpbWUgd2lsbCBiZSB1cGRhdGVkLlxuICByZXR1cm4gY3VycmVudFNjaGVkdWxlclRpbWU7XG59XG5cbi8vIHJlcXVlc3RXb3JrIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHdoZW5ldmVyIGEgcm9vdCByZWNlaXZlcyBhbiB1cGRhdGUuXG4vLyBJdCdzIHVwIHRvIHRoZSByZW5kZXJlciB0byBjYWxsIHJlbmRlclJvb3QgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLlxuZnVuY3Rpb24gcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgYWRkUm9vdFRvU2NoZWR1bGUocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuIFJlbWFpbmluZyB3b3JrIHdpbGwgYmUgc2NoZWR1bGVkIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgY3VycmVudGx5IHJlbmRlcmluZyBiYXRjaC5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAvLyBGbHVzaCB3b3JrIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuICAgIGlmIChpc1VuYmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAvLyAuLi51bmxlc3Mgd2UncmUgaW5zaWRlIHVuYmF0Y2hlZFVwZGF0ZXMsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkXG4gICAgICAvLyBmbHVzaCBpdCBub3cuXG4gICAgICBuZXh0Rmx1c2hlZFJvb3QgPSByb290O1xuICAgICAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChyb290LCBTeW5jLCBmYWxzZSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IEdldCByaWQgb2YgU3luYyBhbmQgdXNlIGN1cnJlbnQgdGltZT9cbiAgaWYgKGV4cGlyYXRpb25UaW1lID09PSBTeW5jKSB7XG4gICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gIH0gZWxzZSB7XG4gICAgc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uVGltZShyb290LCBleHBpcmF0aW9uVGltZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUm9vdFRvU2NoZWR1bGUocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgLy8gQWRkIHRoZSByb290IHRvIHRoZSBzY2hlZHVsZS5cbiAgLy8gQ2hlY2sgaWYgdGhpcyByb290IGlzIGFscmVhZHkgcGFydCBvZiB0aGUgc2NoZWR1bGUuXG4gIGlmIChyb290Lm5leHRTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyByb290IGlzIG5vdCBhbHJlYWR5IHNjaGVkdWxlZC4gQWRkIGl0LlxuICAgIHJvb3QuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgc2NoZWR1bGVkLCBidXQgaXRzIHByaW9yaXR5IG1heSBoYXZlIGluY3JlYXNlZC5cbiAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICAgIGlmIChleHBpcmF0aW9uVGltZSA+IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LlxuICAgICAgcm9vdC5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpIHtcbiAgdmFyIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSBOb1dvcms7XG4gIHZhciBoaWdoZXN0UHJpb3JpdHlSb290ID0gbnVsbDtcbiAgaWYgKGxhc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290O1xuICAgIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgIHdoaWxlIChyb290ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LmV4cGlyYXRpb25UaW1lO1xuICAgICAgaWYgKHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID09PSBOb1dvcmspIHtcbiAgICAgICAgLy8gVGhpcyByb290IG5vIGxvbmdlciBoYXMgd29yay4gUmVtb3ZlIGl0IGZyb20gdGhlIHNjaGVkdWxlci5cblxuICAgICAgICAvLyBUT0RPOiBUaGlzIGNoZWNrIGlzIHJlZHVkYW50LCBidXQgRmxvdyBpcyBjb25mdXNlZCBieSB0aGUgYnJhbmNoXG4gICAgICAgIC8vIGJlbG93IHdoZXJlIHdlIHNldCBsYXN0U2NoZWR1bGVkUm9vdCB0byBudWxsLCBldmVuIHRob3VnaCB3ZSBicmVha1xuICAgICAgICAvLyBmcm9tIHRoZSBsb29wIHJpZ2h0IGFmdGVyLlxuICAgICAgICAhKHByZXZpb3VzU2NoZWR1bGVkUm9vdCAhPT0gbnVsbCAmJiBsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBhIHByZXZpb3VzIGFuZCBsYXN0IHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgIGlmIChyb290ID09PSByb290Lm5leHRTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBmaXJzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgIHZhciBuZXh0ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBsYXN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGxhc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPiBoaWdoZXN0UHJpb3JpdHlXb3JrKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eSwgaWYgaXQncyBoaWdoZXJcbiAgICAgICAgICBoaWdoZXN0UHJpb3JpdHlXb3JrID0gcmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgICAgaGlnaGVzdFByaW9yaXR5Um9vdCA9IHJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpZ2hlc3RQcmlvcml0eVdvcmsgPT09IFN5bmMpIHtcbiAgICAgICAgICAvLyBTeW5jIGlzIGhpZ2hlc3QgcHJpb3JpdHkgYnkgZGVmaW5pdGlvbiBzb1xuICAgICAgICAgIC8vIHdlIGNhbiBzdG9wIHNlYXJjaGluZy5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICByb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZXh0Rmx1c2hlZFJvb3QgPSBoaWdoZXN0UHJpb3JpdHlSb290O1xuICBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gaGlnaGVzdFByaW9yaXR5V29yaztcbn1cblxuLy8gVE9ETzogVGhpcyB3cmFwcGVyIGV4aXN0cyBiZWNhdXNlIG1hbnkgb2YgdGhlIG9sZGVyIHRlc3RzICh0aGUgb25lcyB0aGF0IHVzZVxuLy8gZmx1c2hEZWZlcnJlZFByaSkgcmVseSBvbiB0aGUgbnVtYmVyIG9mIHRpbWVzIGBzaG91bGRZaWVsZGAgaXMgY2FsbGVkLiBXZVxuLy8gc2hvdWxkIGdldCByaWQgb2YgaXQuXG52YXIgZGlkWWllbGQgPSBmYWxzZTtcbmZ1bmN0aW9uIHNob3VsZFlpZWxkVG9SZW5kZXJlcigpIHtcbiAgaWYgKGRpZFlpZWxkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNjaGVkdWxlci51bnN0YWJsZV9zaG91bGRZaWVsZCgpKSB7XG4gICAgZGlkWWllbGQgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcGVyZm9ybUFzeW5jV29yaygpIHtcbiAgdHJ5IHtcbiAgICBpZiAoIXNob3VsZFlpZWxkVG9SZW5kZXJlcigpKSB7XG4gICAgICAvLyBUaGUgY2FsbGJhY2sgdGltZWQgb3V0LiBUaGF0IG1lYW5zIGF0IGxlYXN0IG9uZSB1cGRhdGUgaGFzIGV4cGlyZWQuXG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHJvb3Qgc2NoZWR1bGUuIElmIHRoZXkgY29udGFpbiBleHBpcmVkIHdvcmssIHNldFxuICAgICAgLy8gdGhlIG5leHQgcmVuZGVyIGV4cGlyYXRpb24gdGltZSB0byB0aGUgY3VycmVudCB0aW1lLiBUaGlzIGhhcyB0aGUgZWZmZWN0XG4gICAgICAvLyBvZiBmbHVzaGluZyBhbGwgZXhwaXJlZCB3b3JrIGluIGEgc2luZ2xlIGJhdGNoLCBpbnN0ZWFkIG9mIGZsdXNoaW5nIGVhY2hcbiAgICAgIC8vIGxldmVsIG9uZSBhdCBhIHRpbWUuXG4gICAgICBpZiAoZmlyc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSB7XG4gICAgICAgIHJlY29tcHV0ZUN1cnJlbnRSZW5kZXJlclRpbWUoKTtcbiAgICAgICAgdmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBkaWRFeHBpcmVBdEV4cGlyYXRpb25UaW1lKHJvb3QsIGN1cnJlbnRSZW5kZXJlclRpbWUpO1xuICAgICAgICAgIC8vIFRoZSByb290IHNjaGVkdWxlIGlzIGNpcmN1bGFyLCBzbyB0aGlzIGlzIG5ldmVyIG51bGwuXG4gICAgICAgICAgcm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH0gd2hpbGUgKHJvb3QgIT09IGZpcnN0U2NoZWR1bGVkUm9vdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHBlcmZvcm1Xb3JrKE5vV29yaywgdHJ1ZSk7XG4gIH0gZmluYWxseSB7XG4gICAgZGlkWWllbGQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwZXJmb3JtU3luY1dvcmsoKSB7XG4gIHBlcmZvcm1Xb3JrKFN5bmMsIGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gcGVyZm9ybVdvcmsobWluRXhwaXJhdGlvblRpbWUsIGlzWWllbGR5KSB7XG4gIC8vIEtlZXAgd29ya2luZyBvbiByb290cyB1bnRpbCB0aGVyZSdzIG5vIG1vcmUgd29yaywgb3IgdW50aWwgdGhlcmUncyBhIGhpZ2hlclxuICAvLyBwcmlvcml0eSBldmVudC5cbiAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcblxuICBpZiAoaXNZaWVsZHkpIHtcbiAgICByZWNvbXB1dGVDdXJyZW50UmVuZGVyZXJUaW1lKCk7XG4gICAgY3VycmVudFNjaGVkdWxlclRpbWUgPSBjdXJyZW50UmVuZGVyZXJUaW1lO1xuXG4gICAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICAgIHZhciBkaWRFeHBpcmUgPSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID4gY3VycmVudFJlbmRlcmVyVGltZTtcbiAgICAgIHZhciB0aW1lb3V0ID0gZXhwaXJhdGlvblRpbWVUb01zKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUpO1xuICAgICAgc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSwgdGltZW91dCk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmsgJiYgbWluRXhwaXJhdGlvblRpbWUgPD0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAmJiAhKGRpZFlpZWxkICYmIGN1cnJlbnRSZW5kZXJlclRpbWUgPiBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lLCBjdXJyZW50UmVuZGVyZXJUaW1lID4gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgICAgcmVjb21wdXRlQ3VycmVudFJlbmRlcmVyVGltZSgpO1xuICAgICAgY3VycmVudFNjaGVkdWxlclRpbWUgPSBjdXJyZW50UmVuZGVyZXJUaW1lO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobmV4dEZsdXNoZWRSb290ICE9PSBudWxsICYmIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiBtaW5FeHBpcmF0aW9uVGltZSA8PSBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKSB7XG4gICAgICBwZXJmb3JtV29ya09uUm9vdChuZXh0Rmx1c2hlZFJvb3QsIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gV2UncmUgZG9uZSBmbHVzaGluZyB3b3JrLiBFaXRoZXIgd2UgcmFuIG91dCBvZiB0aW1lIGluIHRoaXMgY2FsbGJhY2ssXG4gIC8vIG9yIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGxlZnQgd2l0aCBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gIC8vIElmIHdlJ3JlIGluc2lkZSBhIGNhbGxiYWNrLCBzZXQgdGhpcyB0byBmYWxzZSBzaW5jZSB3ZSBqdXN0IGNvbXBsZXRlZCBpdC5cbiAgaWYgKGlzWWllbGR5KSB7XG4gICAgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICBjYWxsYmFja0lEID0gbnVsbDtcbiAgfVxuICAvLyBJZiB0aGVyZSdzIHdvcmsgbGVmdCBvdmVyLCBzY2hlZHVsZSBhIG5ldyBjYWxsYmFjay5cbiAgaWYgKG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvblRpbWUobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIC8vIENsZWFuLXVwLlxuICBmaW5pc2hSZW5kZXJpbmcoKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICd3b3JrLmNvbW1pdCgpOiBDYW5ub3QgY29tbWl0IHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLiBUaGlzIGxpa2VseSBtZWFucyB5b3UgYXR0ZW1wdGVkIHRvIGNvbW1pdCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuJykgOiB2b2lkIDA7XG4gIC8vIFBlcmZvcm0gd29yayBvbiByb290IGFzIGlmIHRoZSBnaXZlbiBleHBpcmF0aW9uIHRpbWUgaXMgdGhlIGN1cnJlbnQgdGltZS5cbiAgLy8gVGhpcyBoYXMgdGhlIGVmZmVjdCBvZiBzeW5jaHJvbm91c2x5IGZsdXNoaW5nIGFsbCB3b3JrIHVwIHRvIGFuZFxuICAvLyBpbmNsdWRpbmcgdGhlIGdpdmVuIHRpbWUuXG4gIG5leHRGbHVzaGVkUm9vdCA9IHJvb3Q7XG4gIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgLy8gRmx1c2ggYW55IHN5bmMgd29yayB0aGF0IHdhcyBzY2hlZHVsZWQgYnkgbGlmZWN5Y2xlc1xuICBwZXJmb3JtU3luY1dvcmsoKTtcbn1cblxuZnVuY3Rpb24gZmluaXNoUmVuZGVyaW5nKCkge1xuICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gIGxhc3RDb21taXR0ZWRSb290RHVyaW5nVGhpc0JhdGNoID0gbnVsbDtcblxuICBpZiAoY29tcGxldGVkQmF0Y2hlcyAhPT0gbnVsbCkge1xuICAgIHZhciBiYXRjaGVzID0gY29tcGxldGVkQmF0Y2hlcztcbiAgICBjb21wbGV0ZWRCYXRjaGVzID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiYXRjaCA9IGJhdGNoZXNbaV07XG4gICAgICB0cnkge1xuICAgICAgICBiYXRjaC5fb25Db21wbGV0ZSgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgdmFyIGVycm9yID0gdW5oYW5kbGVkRXJyb3I7XG4gICAgdW5oYW5kbGVkRXJyb3IgPSBudWxsO1xuICAgIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUsIGlzWWllbGR5KSB7XG4gICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdwZXJmb3JtV29ya09uUm9vdCB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIGlzUmVuZGVyaW5nID0gdHJ1ZTtcblxuICAvLyBDaGVjayBpZiB0aGlzIGlzIGFzeW5jIHdvcmsgb3Igc3luYy9leHBpcmVkIHdvcmsuXG4gIGlmICghaXNZaWVsZHkpIHtcbiAgICAvLyBGbHVzaCB3b3JrIHdpdGhvdXQgeWllbGRpbmcuXG4gICAgLy8gVE9ETzogTm9uLXlpZWxkeSB3b3JrIGRvZXMgbm90IG5lY2Vzc2FyaWx5IGltcGx5IGV4cGlyZWQgd29yay4gQSByZW5kZXJlclxuICAgIC8vIG1heSB3YW50IHRvIHBlcmZvcm0gc29tZSB3b3JrIHdpdGhvdXQgeWllbGRpbmcsIGJ1dCBhbHNvIHdpdGhvdXRcbiAgICAvLyByZXF1aXJpbmcgdGhlIHJvb3QgdG8gY29tcGxldGUgKGJ5IHRyaWdnZXJpbmcgcGxhY2Vob2xkZXJzKS5cblxuICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICBpZiAoZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgIGNvbXBsZXRlUm9vdChyb290LCBmaW5pc2hlZFdvcmssIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgLy8gSWYgdGhpcyByb290IHByZXZpb3VzbHkgc3VzcGVuZGVkLCBjbGVhciBpdHMgZXhpc3RpbmcgdGltZW91dCwgc2luY2VcbiAgICAgIC8vIHdlJ3JlIGFib3V0IHRvIHRyeSByZW5kZXJpbmcgYWdhaW4uXG4gICAgICB2YXIgdGltZW91dEhhbmRsZSA9IHJvb3QudGltZW91dEhhbmRsZTtcbiAgICAgIGlmICh0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuICAgICAgICBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgfVxuICAgICAgcmVuZGVyUm9vdChyb290LCBpc1lpZWxkeSk7XG4gICAgICBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UndmUgY29tcGxldGVkIHRoZSByb290LiBDb21taXQgaXQuXG4gICAgICAgIGNvbXBsZXRlUm9vdChyb290LCBmaW5pc2hlZFdvcmssIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRmx1c2ggYXN5bmMgd29yay5cbiAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgIGlmIChfZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgIGNvbXBsZXRlUm9vdChyb290LCBfZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgIC8vIElmIHRoaXMgcm9vdCBwcmV2aW91c2x5IHN1c3BlbmRlZCwgY2xlYXIgaXRzIGV4aXN0aW5nIHRpbWVvdXQsIHNpbmNlXG4gICAgICAvLyB3ZSdyZSBhYm91dCB0byB0cnkgcmVuZGVyaW5nIGFnYWluLlxuICAgICAgdmFyIF90aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuICAgICAgaWYgKF90aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAgICAgcm9vdC50aW1lb3V0SGFuZGxlID0gbm9UaW1lb3V0O1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuICAgICAgICBjYW5jZWxUaW1lb3V0KF90aW1lb3V0SGFuZGxlKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlclJvb3Qocm9vdCwgaXNZaWVsZHkpO1xuICAgICAgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UndmUgY29tcGxldGVkIHRoZSByb290LiBDaGVjayB0aGUgaWYgd2Ugc2hvdWxkIHlpZWxkIG9uZSBtb3JlIHRpbWVcbiAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgIGlmICghc2hvdWxkWWllbGRUb1JlbmRlcmVyKCkpIHtcbiAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICBjb21wbGV0ZVJvb3Qocm9vdCwgX2ZpbmlzaGVkV29yaywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0LiBNYXJrIHRoaXMgcm9vdCBhcyBjb21wbGV0ZS4gV2UnbGwgY29tZVxuICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICByb290LmZpbmlzaGVkV29yayA9IF9maW5pc2hlZFdvcms7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpc1JlbmRlcmluZyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVJvb3Qocm9vdCwgZmluaXNoZWRXb3JrLCBleHBpcmF0aW9uVGltZSkge1xuICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgYmF0Y2ggdGhhdCBtYXRjaGVzIHRoaXMgZXhwaXJhdGlvbiB0aW1lLlxuICB2YXIgZmlyc3RCYXRjaCA9IHJvb3QuZmlyc3RCYXRjaDtcbiAgaWYgKGZpcnN0QmF0Y2ggIT09IG51bGwgJiYgZmlyc3RCYXRjaC5fZXhwaXJhdGlvblRpbWUgPj0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY29tcGxldGVkQmF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgY29tcGxldGVkQmF0Y2hlcyA9IFtmaXJzdEJhdGNoXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGVkQmF0Y2hlcy5wdXNoKGZpcnN0QmF0Y2gpO1xuICAgIH1cbiAgICBpZiAoZmlyc3RCYXRjaC5fZGVmZXIpIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBibG9ja2VkIGZyb20gY29tbWl0dGluZyBieSBhIGJhdGNoLiBVbnNjaGVkdWxlIGl0IHVudGlsXG4gICAgICAvLyB3ZSByZWNlaXZlIGFub3RoZXIgdXBkYXRlLlxuICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBmaW5pc2hlZFdvcms7XG4gICAgICByb290LmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbW1pdCB0aGUgcm9vdC5cbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuXG4gIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBuZXN0ZWQgdXBkYXRlIChhIHN5bmMgdXBkYXRlIHNjaGVkdWxlZCBkdXJpbmcgdGhlXG4gIC8vIGNvbW1pdCBwaGFzZSkuXG4gIGlmIChyb290ID09PSBsYXN0Q29tbWl0dGVkUm9vdER1cmluZ1RoaXNCYXRjaCkge1xuICAgIC8vIElmIHRoZSBuZXh0IHJvb3QgaXMgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIHJvb3QsIHRoaXMgaXMgYSBuZXN0ZWRcbiAgICAvLyB1cGRhdGUuIFRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCwgaW5jcmVtZW50IHRoZSBuZXN0ZWQgdXBkYXRlIGNvdW50LlxuICAgIG5lc3RlZFVwZGF0ZUNvdW50Kys7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVzZXQgd2hlbmV2ZXIgd2Ugc3dpdGNoIHJvb3RzLlxuICAgIGxhc3RDb21taXR0ZWRSb290RHVyaW5nVGhpc0JhdGNoID0gcm9vdDtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gIH1cbiAgc2NoZWR1bGVyLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eShzY2hlZHVsZXIudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICBjb21taXRSb290KHJvb3QsIGZpbmlzaGVkV29yayk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBvblVuY2F1Z2h0RXJyb3IoZXJyb3IpIHtcbiAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAvLyBVbnNjaGVkdWxlIHRoaXMgcm9vdCBzbyB3ZSBkb24ndCB3b3JrIG9uIGl0IGFnYWluIHVudGlsIHRoZXJlJ3NcbiAgLy8gYW5vdGhlciB1cGRhdGUuXG4gIG5leHRGbHVzaGVkUm9vdC5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgIGhhc1VuaGFuZGxlZEVycm9yID0gdHJ1ZTtcbiAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICB9XG59XG5cbi8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbi8vIHRoZSByZWNvbmNpbGVyLlxuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMkMShmbiwgYSkge1xuICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZykge1xuICAgICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbi8vIHRoZSByZWNvbmNpbGVyLlxuZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbiwgYSkge1xuICBpZiAoaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzVW5iYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKGEpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmbihhKTtcbn1cblxuLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IHdpdGhpblxuLy8gdGhlIHJlY29uY2lsZXIuXG5mdW5jdGlvbiBmbHVzaFN5bmMoZm4sIGEpIHtcbiAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLicpIDogdm9pZCAwO1xuICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuLCBhKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJhY3RpdmVVcGRhdGVzJDEoZm4sIGEsIGIpIHtcbiAgLy8gSWYgdGhlcmUgYXJlIGFueSBwZW5kaW5nIGludGVyYWN0aXZlIHVwZGF0ZXMsIHN5bmNocm9ub3VzbHkgZmx1c2ggdGhlbS5cbiAgLy8gVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHdlIHJlYWQgYW55IGhhbmRsZXJzLCBiZWNhdXNlIHRoZSBlZmZlY3Qgb2ZcbiAgLy8gdGhlIHByZXZpb3VzIGV2ZW50IG1heSBpbmZsdWVuY2Ugd2hpY2ggaGFuZGxlcnMgYXJlIGNhbGxlZCBkdXJpbmdcbiAgLy8gdGhpcyBldmVudC5cbiAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcgJiYgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBmbHVzaCBwZW5kaW5nIGludGVyYWN0aXZlIHVwZGF0ZXMuXG4gICAgcGVyZm9ybVdvcmsobG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSwgZmFsc2UpO1xuICAgIGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIH1cbiAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBzY2hlZHVsZXIudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KHNjaGVkdWxlci51bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZuKGEsIGIpO1xuICAgIH0pO1xuICB9IGZpbmFsbHkge1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpZiAoIWlzQmF0Y2hpbmdVcGRhdGVzICYmICFpc1JlbmRlcmluZykge1xuICAgICAgcGVyZm9ybVN5bmNXb3JrKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoSW50ZXJhY3RpdmVVcGRhdGVzJDEoKSB7XG4gIGlmICghaXNSZW5kZXJpbmcgJiYgbG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBmbHVzaCBwZW5kaW5nIGludGVyYWN0aXZlIHVwZGF0ZXMuXG4gICAgcGVyZm9ybVdvcmsobG93ZXN0UHJpb3JpdHlQZW5kaW5nSW50ZXJhY3RpdmVFeHBpcmF0aW9uVGltZSwgZmFsc2UpO1xuICAgIGxvd2VzdFByaW9yaXR5UGVuZGluZ0ludGVyYWN0aXZlRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hDb250cm9sbGVkKGZuKSB7XG4gIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBzeW5jVXBkYXRlcyhmbik7XG4gIH0gZmluYWxseSB7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlmICghaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzUmVuZGVyaW5nKSB7XG4gICAgICBwZXJmb3JtU3luY1dvcmsoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gMCBpcyBQUk9ELCAxIGlzIERFVi5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxuXG5cbnZhciBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdm9pZCAwO1xudmFyIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlID0gdm9pZCAwO1xuXG57XG4gIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUgPSB7fTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KSB7XG4gIGlmICghcGFyZW50Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcblxuICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgIHZhciBDb21wb25lbnQgPSBmaWJlci50eXBlO1xuICAgIGlmIChpc0NvbnRleHRQcm92aWRlcihDb21wb25lbnQpKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgQ29tcG9uZW50LCBwYXJlbnRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFyZW50Q29udGV4dDtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVSb290VXBkYXRlKGN1cnJlbnQkJDEsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lLCBjYWxsYmFjaykge1xuICB7XG4gICAgaWYgKHBoYXNlID09PSAncmVuZGVyJyAmJiBjdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lKGN1cnJlbnQudHlwZSkgfHwgJ1Vua25vd24nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGV4cGlyYXRpb25UaW1lKTtcbiAgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG4gIHVwZGF0ZS5wYXlsb2FkID0geyBlbGVtZW50OiBlbGVtZW50IH07XG5cbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdyZW5kZXIoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxiYWNrKSA6IHZvaWQgMDtcbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgfVxuXG4gIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgZW5xdWV1ZVVwZGF0ZShjdXJyZW50JCQxLCB1cGRhdGUpO1xuICBzY2hlZHVsZVdvcmsoY3VycmVudCQkMSwgZXhwaXJhdGlvblRpbWUpO1xuXG4gIHJldHVybiBleHBpcmF0aW9uVGltZTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyQXRFeHBpcmF0aW9uVGltZShlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKSB7XG4gIC8vIFRPRE86IElmIHRoaXMgaXMgYSBuZXN0ZWQgY29udGFpbmVyLCB0aGlzIHdvbid0IGJlIHRoZSByb290LlxuICB2YXIgY3VycmVudCQkMSA9IGNvbnRhaW5lci5jdXJyZW50O1xuXG4gIHtcbiAgICBpZiAoUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgaWYgKGN1cnJlbnQkJDEuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uVXBkYXRlQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIHJldHVybiBzY2hlZHVsZVJvb3RVcGRhdGUoY3VycmVudCQkMSwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShjb21wb25lbnQpIHtcbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmIChmaWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0FyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6ICVzJywgT2JqZWN0LmtleXMoY29tcG9uZW50KSk7XG4gICAgfVxuICB9XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudCwgbWV0aG9kTmFtZSkge1xuICB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gICAgaWYgKGZpYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiAlcycsIE9iamVjdC5rZXlzKGNvbXBvbmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaG9zdEZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIudHlwZSkgfHwgJ0NvbXBvbmVudCc7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RNb2RlKSB7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4nICsgJ1xcbiVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6JyArICdcXG5odHRwczovL2ZiLm1lL3JlYWN0LXN0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChob3N0RmliZXIpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICcgKyAnJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCByZW5kZXJzIFN0cmljdE1vZGUgY2hpbGRyZW4uICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4nICsgJ1xcbiVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6JyArICdcXG5odHRwczovL2ZiLm1lL3JlYWN0LXN0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChob3N0RmliZXIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxuICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZShjb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb250YWluZXIoY29udGFpbmVySW5mbywgaXNDb25jdXJyZW50LCBoeWRyYXRlKSB7XG4gIHJldHVybiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgaXNDb25jdXJyZW50LCBoeWRyYXRlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudCQkMSA9IGNvbnRhaW5lci5jdXJyZW50O1xuICB2YXIgY3VycmVudFRpbWUgPSByZXF1ZXN0Q3VycmVudFRpbWUoKTtcbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50VGltZSwgY3VycmVudCQkMSk7XG4gIHJldHVybiB1cGRhdGVDb250YWluZXJBdEV4cGlyYXRpb25UaW1lKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBleHBpcmF0aW9uVGltZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBnZXRQdWJsaWNSb290SW5zdGFuY2UoY29udGFpbmVyKSB7XG4gIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgc3dpdGNoIChjb250YWluZXJGaWJlci5jaGlsZC50YWcpIHtcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xufVxuXG52YXIgb3ZlcnJpZGVQcm9wcyA9IG51bGw7XG5cbntcbiAgdmFyIGNvcHlXaXRoU2V0SW1wbCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIGlkeCwgdmFsdWUpIHtcbiAgICBpZiAoaWR4ID49IHBhdGgubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHZhciBrZXkgPSBwYXRoW2lkeF07XG4gICAgdmFyIHVwZGF0ZWQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF9hc3NpZ24oe30sIG9iaik7XG4gICAgLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoU2V0SW1wbChvYmpba2V5XSwgcGF0aCwgaWR4ICsgMSwgdmFsdWUpO1xuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFNldCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGNvcHlXaXRoU2V0SW1wbChvYmosIHBhdGgsIDAsIHZhbHVlKTtcbiAgfTtcblxuICAvLyBTdXBwb3J0IERldlRvb2xzIHByb3BzIGZvciBmdW5jdGlvbiBjb21wb25lbnRzLCBmb3J3YXJkUmVmLCBtZW1vLCBob3N0IGNvbXBvbmVudHMsIGV0Yy5cbiAgb3ZlcnJpZGVQcm9wcyA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCwgdmFsdWUpIHtcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhTZXQoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgdmFsdWUpO1xuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuICAgIHNjaGVkdWxlV29yayhmaWJlciwgU3luYyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluamVjdEludG9EZXZUb29scyhkZXZUb29sc0NvbmZpZykge1xuICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcbiAgdmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xuXG5cbiAgcmV0dXJuIGluamVjdEludGVybmFscyhfYXNzaWduKHt9LCBkZXZUb29sc0NvbmZpZywge1xuICAgIG92ZXJyaWRlUHJvcHM6IG92ZXJyaWRlUHJvcHMsXG4gICAgY3VycmVudERpc3BhdGNoZXJSZWY6IFJlYWN0Q3VycmVudERpc3BhdGNoZXIsXG4gICAgZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcbiAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICB9LFxuICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIGlmICghZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UpIHtcbiAgICAgICAgLy8gTWlnaHQgbm90IGJlIGltcGxlbWVudGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgIH1cbiAgfSkpO1xufVxuXG4vLyBUaGlzIGZpbGUgaW50ZW50aW9uYWxseSBkb2VzICpub3QqIGhhdmUgdGhlIEZsb3cgYW5ub3RhdGlvbi5cbi8vIERvbid0IGFkZCBpdC4gU2VlIGAuL2lubGluZS10eXBlZC5qc2AgZm9yIGFuIGV4cGxhbmF0aW9uLlxuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVySW5mbyxcbi8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxNi44LjYnO1xuXG4vLyBUT0RPOiBUaGlzIHR5cGUgaXMgc2hhcmVkIGJldHdlZW4gdGhlIHJlY29uY2lsZXIgYW5kIFJlYWN0RE9NLCBidXQgd2lsbFxuLy8gZXZlbnR1YWxseSBiZSBsaWZ0ZWQgb3V0IHRvIHRoZSByZW5kZXJlci5cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG5cbnZhciB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzID0gdm9pZCAwO1xudmFyIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IHZvaWQgMDtcbnZhciBkaWRXYXJuQWJvdXRVbnN0YWJsZUNyZWF0ZVBvcnRhbCA9IGZhbHNlO1xuXG57XG4gIGlmICh0eXBlb2YgTWFwICE9PSAnZnVuY3Rpb24nIHx8XG4gIC8vICRGbG93SXNzdWUgRmxvdyBpbmNvcnJlY3RseSB0aGlua3MgTWFwIGhhcyBubyBwcm90b3R5cGVcbiAgTWFwLnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBNYXAucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIFNldCAhPT0gJ2Z1bmN0aW9uJyB8fFxuICAvLyAkRmxvd0lzc3VlIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFNldCBoYXMgbm8gcHJvdG90eXBlXG4gIFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUmVhY3QgZGVwZW5kcyBvbiBNYXAgYW5kIFNldCBidWlsdC1pbiB0eXBlcy4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG5cbiAgdG9wTGV2ZWxVcGRhdGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5faW50ZXJuYWxSb290LmN1cnJlbnQpO1xuICAgICAgaWYgKGhvc3RJbnN0YW5jZSkge1xuICAgICAgICAhKGhvc3RJbnN0YW5jZS5wYXJlbnROb2RlID09PSBjb250YWluZXIpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICsgJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnICsgJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJyArICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShyb290RWwpKTtcblxuICAgICEoIWhhc05vblJvb3RSZWFjdENoaWxkIHx8IGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKSA6IHZvaWQgMDtcblxuICAgICEoY29udGFpbmVyLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJykgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpIDogdm9pZCAwO1xuICB9O1xuXG4gIHdhcm5PbkludmFsaWRDYWxsYmFjayA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgICEoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBjYWxsYmFjaykgOiB2b2lkIDA7XG4gIH07XG59XG5cbnNldFJlc3RvcmVJbXBsZW1lbnRhdGlvbihyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEpO1xuXG5mdW5jdGlvbiBSZWFjdEJhdGNoKHJvb3QpIHtcbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZVVuaXF1ZUFzeW5jRXhwaXJhdGlvbigpO1xuICB0aGlzLl9leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICB0aGlzLl9yb290ID0gcm9vdDtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gIHRoaXMuX2RpZENvbXBsZXRlID0gZmFsc2U7XG4gIHRoaXMuX2hhc0NoaWxkcmVuID0gZmFsc2U7XG4gIHRoaXMuX2NoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5fZGVmZXIgPSB0cnVlO1xufVxuUmVhY3RCYXRjaC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuKSB7XG4gICF0aGlzLl9kZWZlciA/IGludmFyaWFudChmYWxzZSwgJ2JhdGNoLnJlbmRlcjogQ2Fubm90IHJlbmRlciBhIGJhdGNoIHRoYXQgYWxyZWFkeSBjb21taXR0ZWQuJykgOiB2b2lkIDA7XG4gIHRoaXMuX2hhc0NoaWxkcmVuID0gdHJ1ZTtcbiAgdGhpcy5fY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdmFyIGludGVybmFsUm9vdCA9IHRoaXMuX3Jvb3QuX2ludGVybmFsUm9vdDtcbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gdGhpcy5fZXhwaXJhdGlvblRpbWU7XG4gIHZhciB3b3JrID0gbmV3IFJlYWN0V29yaygpO1xuICB1cGRhdGVDb250YWluZXJBdEV4cGlyYXRpb25UaW1lKGNoaWxkcmVuLCBpbnRlcm5hbFJvb3QsIG51bGwsIGV4cGlyYXRpb25UaW1lLCB3b3JrLl9vbkNvbW1pdCk7XG4gIHJldHVybiB3b3JrO1xufTtcblJlYWN0QmF0Y2gucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAob25Db21wbGV0ZSkge1xuICBpZiAodGhpcy5fZGlkQ29tcGxldGUpIHtcbiAgICBvbkNvbXBsZXRlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3M7XG4gIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgPSBbXTtcbiAgfVxuICBjYWxsYmFja3MucHVzaChvbkNvbXBsZXRlKTtcbn07XG5SZWFjdEJhdGNoLnByb3RvdHlwZS5jb21taXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbnRlcm5hbFJvb3QgPSB0aGlzLl9yb290Ll9pbnRlcm5hbFJvb3Q7XG4gIHZhciBmaXJzdEJhdGNoID0gaW50ZXJuYWxSb290LmZpcnN0QmF0Y2g7XG4gICEodGhpcy5fZGVmZXIgJiYgZmlyc3RCYXRjaCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdiYXRjaC5jb21taXQ6IENhbm5vdCBjb21taXQgYSBiYXRjaCBtdWx0aXBsZSB0aW1lcy4nKSA6IHZvaWQgMDtcblxuICBpZiAoIXRoaXMuX2hhc0NoaWxkcmVuKSB7XG4gICAgLy8gVGhpcyBiYXRjaCBpcyBlbXB0eS4gUmV0dXJuLlxuICAgIHRoaXMuX25leHQgPSBudWxsO1xuICAgIHRoaXMuX2RlZmVyID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lID0gdGhpcy5fZXhwaXJhdGlvblRpbWU7XG5cbiAgLy8gRW5zdXJlIHRoaXMgaXMgdGhlIGZpcnN0IGJhdGNoIGluIHRoZSBsaXN0LlxuICBpZiAoZmlyc3RCYXRjaCAhPT0gdGhpcykge1xuICAgIC8vIFRoaXMgYmF0Y2ggaXMgbm90IHRoZSBlYXJsaWVzdCBiYXRjaC4gV2UgbmVlZCB0byBtb3ZlIGl0IHRvIHRoZSBmcm9udC5cbiAgICAvLyBVcGRhdGUgaXRzIGV4cGlyYXRpb24gdGltZSB0byBiZSB0aGUgZXhwaXJhdGlvbiB0aW1lIG9mIHRoZSBlYXJsaWVzdFxuICAgIC8vIGJhdGNoLCBzbyB0aGF0IHdlIGNhbiBmbHVzaCBpdCB3aXRob3V0IGZsdXNoaW5nIHRoZSBvdGhlciBiYXRjaGVzLlxuICAgIGlmICh0aGlzLl9oYXNDaGlsZHJlbikge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSB0aGlzLl9leHBpcmF0aW9uVGltZSA9IGZpcnN0QmF0Y2guX2V4cGlyYXRpb25UaW1lO1xuICAgICAgLy8gUmVuZGVyaW5nIHRoaXMgYmF0Y2ggYWdhaW4gZW5zdXJlcyBpdHMgY2hpbGRyZW4gd2lsbCBiZSB0aGUgZmluYWwgc3RhdGVcbiAgICAgIC8vIHdoZW4gd2UgZmx1c2ggKHVwZGF0ZXMgYXJlIHByb2Nlc3NlZCBpbiBpbnNlcnRpb24gb3JkZXI6IGxhc3RcbiAgICAgIC8vIHVwZGF0ZSB3aW5zKS5cbiAgICAgIC8vIFRPRE86IFRoaXMgZm9yY2VzIGEgcmVzdGFydC4gU2hvdWxkIHdlIHByaW50IGEgd2FybmluZz9cbiAgICAgIHRoaXMucmVuZGVyKHRoaXMuX2NoaWxkcmVuKTtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdGhlIGJhdGNoIGZyb20gdGhlIGxpc3QuXG4gICAgdmFyIHByZXZpb3VzID0gbnVsbDtcbiAgICB2YXIgYmF0Y2ggPSBmaXJzdEJhdGNoO1xuICAgIHdoaWxlIChiYXRjaCAhPT0gdGhpcykge1xuICAgICAgcHJldmlvdXMgPSBiYXRjaDtcbiAgICAgIGJhdGNoID0gYmF0Y2guX25leHQ7XG4gICAgfVxuICAgICEocHJldmlvdXMgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYmF0Y2guY29tbWl0OiBDYW5ub3QgY29tbWl0IGEgYmF0Y2ggbXVsdGlwbGUgdGltZXMuJykgOiB2b2lkIDA7XG4gICAgcHJldmlvdXMuX25leHQgPSBiYXRjaC5fbmV4dDtcblxuICAgIC8vIEFkZCBpdCB0byB0aGUgZnJvbnQuXG4gICAgdGhpcy5fbmV4dCA9IGZpcnN0QmF0Y2g7XG4gICAgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoID0gdGhpcztcbiAgfVxuXG4gIC8vIFN5bmNocm9ub3VzbHkgZmx1c2ggYWxsIHRoZSB3b3JrIHVwIHRvIHRoaXMgYmF0Y2gncyBleHBpcmF0aW9uIHRpbWUuXG4gIHRoaXMuX2RlZmVyID0gZmFsc2U7XG4gIGZsdXNoUm9vdChpbnRlcm5hbFJvb3QsIGV4cGlyYXRpb25UaW1lKTtcblxuICAvLyBQb3AgdGhlIGJhdGNoIGZyb20gdGhlIGxpc3QuXG4gIHZhciBuZXh0ID0gdGhpcy5fbmV4dDtcbiAgdGhpcy5fbmV4dCA9IG51bGw7XG4gIGZpcnN0QmF0Y2ggPSBpbnRlcm5hbFJvb3QuZmlyc3RCYXRjaCA9IG5leHQ7XG5cbiAgLy8gQXBwZW5kIHRoZSBuZXh0IGVhcmxpZXN0IGJhdGNoJ3MgY2hpbGRyZW4gdG8gdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgaWYgKGZpcnN0QmF0Y2ggIT09IG51bGwgJiYgZmlyc3RCYXRjaC5faGFzQ2hpbGRyZW4pIHtcbiAgICBmaXJzdEJhdGNoLnJlbmRlcihmaXJzdEJhdGNoLl9jaGlsZHJlbik7XG4gIH1cbn07XG5SZWFjdEJhdGNoLnByb3RvdHlwZS5fb25Db21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2RpZENvbXBsZXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2RpZENvbXBsZXRlID0gdHJ1ZTtcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgaWYgKGNhbGxiYWNrcyA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBUT0RPOiBFcnJvciBoYW5kbGluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgX2NhbGxiYWNrID0gY2FsbGJhY2tzW2ldO1xuICAgIF9jYWxsYmFjaygpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBSZWFjdFdvcmsoKSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gIHRoaXMuX2RpZENvbW1pdCA9IGZhbHNlO1xuICAvLyBUT0RPOiBBdm9pZCBuZWVkIHRvIGJpbmQgYnkgcmVwbGFjaW5nIGNhbGxiYWNrcyBpbiB0aGUgdXBkYXRlIHF1ZXVlIHdpdGhcbiAgLy8gbGlzdCBvZiBXb3JrIG9iamVjdHMuXG4gIHRoaXMuX29uQ29tbWl0ID0gdGhpcy5fb25Db21taXQuYmluZCh0aGlzKTtcbn1cblJlYWN0V29yay5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uIChvbkNvbW1pdCkge1xuICBpZiAodGhpcy5fZGlkQ29tbWl0KSB7XG4gICAgb25Db21taXQoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgaWYgKGNhbGxiYWNrcyA9PT0gbnVsbCkge1xuICAgIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICB9XG4gIGNhbGxiYWNrcy5wdXNoKG9uQ29tbWl0KTtcbn07XG5SZWFjdFdvcmsucHJvdG90eXBlLl9vbkNvbW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2RpZENvbW1pdCkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9kaWRDb21taXQgPSB0cnVlO1xuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzO1xuICBpZiAoY2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFRPRE86IEVycm9yIGhhbmRsaW5nLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBfY2FsbGJhY2syID0gY2FsbGJhY2tzW2ldO1xuICAgICEodHlwZW9mIF9jYWxsYmFjazIgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzJywgX2NhbGxiYWNrMikgOiB2b2lkIDA7XG4gICAgX2NhbGxiYWNrMigpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBSZWFjdFJvb3QoY29udGFpbmVyLCBpc0NvbmN1cnJlbnQsIGh5ZHJhdGUpIHtcbiAgdmFyIHJvb3QgPSBjcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBpc0NvbmN1cnJlbnQsIGh5ZHJhdGUpO1xuICB0aGlzLl9pbnRlcm5hbFJvb3QgPSByb290O1xufVxuUmVhY3RSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICB7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVuZGVyJyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgd29yay50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICB1cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIG51bGwsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgd29yayA9IG5ldyBSZWFjdFdvcmsoKTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICB7XG4gICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVuZGVyJyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgd29yay50aGVuKGNhbGxiYWNrKTtcbiAgfVxuICB1cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgd29yay5fb25Db21taXQpO1xuICByZXR1cm4gd29yaztcbn07XG5SZWFjdFJvb3QucHJvdG90eXBlLmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX2ludGVybmFsUm9vdDtcbiAgdmFyIHdvcmsgPSBuZXcgUmVhY3RXb3JrKCk7XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAge1xuICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlbmRlcicpO1xuICB9XG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHdvcmsudGhlbihjYWxsYmFjayk7XG4gIH1cbiAgdXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBwYXJlbnRDb21wb25lbnQsIHdvcmsuX29uQ29tbWl0KTtcbiAgcmV0dXJuIHdvcms7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS5jcmVhdGVCYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJhdGNoID0gbmV3IFJlYWN0QmF0Y2godGhpcyk7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IGJhdGNoLl9leHBpcmF0aW9uVGltZTtcblxuICB2YXIgaW50ZXJuYWxSb290ID0gdGhpcy5faW50ZXJuYWxSb290O1xuICB2YXIgZmlyc3RCYXRjaCA9IGludGVybmFsUm9vdC5maXJzdEJhdGNoO1xuICBpZiAoZmlyc3RCYXRjaCA9PT0gbnVsbCkge1xuICAgIGludGVybmFsUm9vdC5maXJzdEJhdGNoID0gYmF0Y2g7XG4gICAgYmF0Y2guX25leHQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIEluc2VydCBzb3J0ZWQgYnkgZXhwaXJhdGlvbiB0aW1lIHRoZW4gaW5zZXJ0aW9uIG9yZGVyXG4gICAgdmFyIGluc2VydEFmdGVyID0gbnVsbDtcbiAgICB2YXIgaW5zZXJ0QmVmb3JlID0gZmlyc3RCYXRjaDtcbiAgICB3aGlsZSAoaW5zZXJ0QmVmb3JlICE9PSBudWxsICYmIGluc2VydEJlZm9yZS5fZXhwaXJhdGlvblRpbWUgPj0gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIGluc2VydEFmdGVyID0gaW5zZXJ0QmVmb3JlO1xuICAgICAgaW5zZXJ0QmVmb3JlID0gaW5zZXJ0QmVmb3JlLl9uZXh0O1xuICAgIH1cbiAgICBiYXRjaC5fbmV4dCA9IGluc2VydEJlZm9yZTtcbiAgICBpZiAoaW5zZXJ0QWZ0ZXIgIT09IG51bGwpIHtcbiAgICAgIGluc2VydEFmdGVyLl9uZXh0ID0gYmF0Y2g7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJhdGNoO1xufTtcblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlICcpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpO1xufVxuXG5zZXRCYXRjaGluZ0ltcGxlbWVudGF0aW9uKGJhdGNoZWRVcGRhdGVzJDEsIGludGVyYWN0aXZlVXBkYXRlcyQxLCBmbHVzaEludGVyYWN0aXZlVXBkYXRlcyQxKTtcblxudmFyIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IGZhbHNlO1xuXG5mdW5jdGlvbiBsZWdhY3lDcmVhdGVSb290RnJvbURPTUNvbnRhaW5lcihjb250YWluZXIsIGZvcmNlSHlkcmF0ZSkge1xuICB2YXIgc2hvdWxkSHlkcmF0ZSA9IGZvcmNlSHlkcmF0ZSB8fCBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKTtcbiAgLy8gRmlyc3QgY2xlYXIgYW55IGV4aXN0aW5nIGNvbnRlbnQuXG4gIGlmICghc2hvdWxkSHlkcmF0ZSkge1xuICAgIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgICB2YXIgcm9vdFNpYmxpbmcgPSB2b2lkIDA7XG4gICAgd2hpbGUgKHJvb3RTaWJsaW5nID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAge1xuICAgICAgICBpZiAoIXdhcm5lZCAmJiByb290U2libGluZy5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHJvb3RTaWJsaW5nLmhhc0F0dHJpYnV0ZShST09UX0FUVFJJQlVURV9OQU1FKSkge1xuICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgIH1cbiAgfVxuICB7XG4gICAgaWYgKHNob3VsZEh5ZHJhdGUgJiYgIWZvcmNlSHlkcmF0ZSAmJiAhd2FybmVkQWJvdXRIeWRyYXRlQVBJKSB7XG4gICAgICB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSB0cnVlO1xuICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdyZW5kZXIoKTogQ2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSB0byBoeWRyYXRlIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAgJyArICd3aWxsIHN0b3Agd29ya2luZyBpbiBSZWFjdCB2MTcuIFJlcGxhY2UgdGhlIFJlYWN0RE9NLnJlbmRlcigpIGNhbGwgJyArICd3aXRoIFJlYWN0RE9NLmh5ZHJhdGUoKSBpZiB5b3Ugd2FudCBSZWFjdCB0byBhdHRhY2ggdG8gdGhlIHNlcnZlciBIVE1MLicpO1xuICAgIH1cbiAgfVxuICAvLyBMZWdhY3kgcm9vdHMgYXJlIG5vdCBhc3luYyBieSBkZWZhdWx0LlxuICB2YXIgaXNDb25jdXJyZW50ID0gZmFsc2U7XG4gIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgaXNDb25jdXJyZW50LCBzaG91bGRIeWRyYXRlKTtcbn1cblxuZnVuY3Rpb24gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICB0b3BMZXZlbFVwZGF0ZVdhcm5pbmdzKGNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBUT0RPOiBXaXRob3V0IGBhbnlgIHR5cGUsIEZsb3cgc2F5cyBcIlByb3BlcnR5IGNhbm5vdCBiZSBhY2Nlc3NlZCBvbiBhbnlcbiAgLy8gbWVtYmVyIG9mIGludGVyc2VjdGlvbiB0eXBlLlwiIFdoeXl5eXl5LlxuICB2YXIgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICBpZiAoIXJvb3QpIHtcbiAgICAvLyBJbml0aWFsIG1vdW50XG4gICAgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbGVnYWN5Q3JlYXRlUm9vdEZyb21ET01Db250YWluZXIoY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUpO1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBvcmlnaW5hbENhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QuX2ludGVybmFsUm9vdCk7XG4gICAgICAgIG9yaWdpbmFsQ2FsbGJhY2suY2FsbChpbnN0YW5jZSk7XG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBJbml0aWFsIG1vdW50IHNob3VsZCBub3QgYmUgYmF0Y2hlZC5cbiAgICB1bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChwYXJlbnRDb21wb25lbnQgIT0gbnVsbCkge1xuICAgICAgICByb290LmxlZ2FjeV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGNoaWxkcmVuLCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LnJlbmRlcihjaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBfb3JpZ2luYWxDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290Ll9pbnRlcm5hbFJvb3QpO1xuICAgICAgICBfb3JpZ2luYWxDYWxsYmFjay5jYWxsKGluc3RhbmNlKTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIFVwZGF0ZVxuICAgIGlmIChwYXJlbnRDb21wb25lbnQgIT0gbnVsbCkge1xuICAgICAgcm9vdC5sZWdhY3lfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290LnJlbmRlcihjaGlsZHJlbiwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZ2V0UHVibGljUm9vdEluc3RhbmNlKHJvb3QuX2ludGVybmFsUm9vdCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCQkMShjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG4gIC8vIFRPRE86IHBhc3MgUmVhY3RET00gcG9ydGFsIGltcGxlbWVudGF0aW9uIGFzIHRoaXJkIGFyZ3VtZW50XG4gIHJldHVybiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVyLCBudWxsLCBrZXkpO1xufVxuXG52YXIgUmVhY3RET00gPSB7XG4gIGNyZWF0ZVBvcnRhbDogY3JlYXRlUG9ydGFsJCQxLFxuXG4gIGZpbmRET01Ob2RlOiBmdW5jdGlvbiAoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gICAge1xuICAgICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci5zdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcbiAgICAgICAgIXdhcm5lZEFib3V0UmVmc0luUmVuZGVyID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnJXMgaXMgYWNjZXNzaW5nIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyLnR5cGUpIHx8ICdBIGNvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgICAgICBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudE9yRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICAgIH1cbiAgICB7XG4gICAgICByZXR1cm4gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nKGNvbXBvbmVudE9yRWxlbWVudCwgJ2ZpbmRET01Ob2RlJyk7XG4gICAgfVxuICAgIHJldHVybiBmaW5kSG9zdEluc3RhbmNlKGNvbXBvbmVudE9yRWxlbWVudCk7XG4gIH0sXG4gIGh5ZHJhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG4gICAge1xuICAgICAgISFjb250YWluZXIuX3JlYWN0SGFzQmVlblBhc3NlZFRvQ3JlYXRlUm9vdERFViA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ1lvdSBhcmUgY2FsbGluZyBSZWFjdERPTS5oeWRyYXRlKCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSAnICsgJ3Bhc3NlZCB0byBSZWFjdERPTS4lcygpLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGNhbGwgY3JlYXRlUm9vdChjb250YWluZXIsIHtoeWRyYXRlOiB0cnVlfSkucmVuZGVyKGVsZW1lbnQpPycsIGVuYWJsZVN0YWJsZUNvbmN1cnJlbnRNb2RlQVBJcyA/ICdjcmVhdGVSb290JyA6ICd1bnN0YWJsZV9jcmVhdGVSb290JykgOiB2b2lkIDA7XG4gICAgfVxuICAgIC8vIFRPRE86IHRocm93IG9yIHdhcm4gaWYgd2UgY291bGRuJ3QgaHlkcmF0ZT9cbiAgICByZXR1cm4gbGVnYWN5UmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgZWxlbWVudCwgY29udGFpbmVyLCB0cnVlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgICB7XG4gICAgICAhIWNvbnRhaW5lci5fcmVhY3RIYXNCZWVuUGFzc2VkVG9DcmVhdGVSb290REVWID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlcigpIG9uIGEgY29udGFpbmVyIHRoYXQgd2FzIHByZXZpb3VzbHkgJyArICdwYXNzZWQgdG8gUmVhY3RET00uJXMoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBjYWxsIHJvb3QucmVuZGVyKGVsZW1lbnQpPycsIGVuYWJsZVN0YWJsZUNvbmN1cnJlbnRNb2RlQVBJcyA/ICdjcmVhdGVSb290JyA6ICd1bnN0YWJsZV9jcmVhdGVSb290JykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBsZWdhY3lSZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBlbGVtZW50LCBjb250YWluZXIsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBjYWxsYmFjaykge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lck5vZGUpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgICAhKHBhcmVudENvbXBvbmVudCAhPSBudWxsICYmIGhhcyhwYXJlbnRDb21wb25lbnQpKSA/IGludmFyaWFudChmYWxzZSwgJ3BhcmVudENvbXBvbmVudCBtdXN0IGJlIGEgdmFsaWQgUmVhY3QgQ29tcG9uZW50JykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgZWxlbWVudCwgY29udGFpbmVyTm9kZSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICd1bm1vdW50Q29tcG9uZW50QXROb2RlKC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG5cbiAgICB7XG4gICAgICAhIWNvbnRhaW5lci5fcmVhY3RIYXNCZWVuUGFzc2VkVG9DcmVhdGVSb290REVWID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUoKSBvbiBhIGNvbnRhaW5lciB0aGF0IHdhcyBwcmV2aW91c2x5ICcgKyAncGFzc2VkIHRvIFJlYWN0RE9NLiVzKCkuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgcm9vdC51bm1vdW50KCk/JywgZW5hYmxlU3RhYmxlQ29uY3VycmVudE1vZGVBUElzID8gJ2NyZWF0ZVJvb3QnIDogJ3Vuc3RhYmxlX2NyZWF0ZVJvb3QnKSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgcmVuZGVyZWRCeURpZmZlcmVudFJlYWN0ID0gcm9vdEVsICYmICFnZXRJbnN0YW5jZUZyb21Ob2RlJDEocm9vdEVsKTtcbiAgICAgICAgISFyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsIFwidW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50IFwiICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gICAgICB9XG5cbiAgICAgIC8vIFVubW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuICAgICAgdW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxlZ2FjeVJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG51bGwsIGNvbnRhaW5lciwgZmFsc2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvLyBJZiB5b3UgY2FsbCB1bm1vdW50Q29tcG9uZW50QXROb2RlIHR3aWNlIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHlvdSdsbFxuICAgICAgLy8gZ2V0IGB0cnVlYCB0d2ljZS4gVGhhdCdzIHByb2JhYmx5IGZpbmU/XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICB2YXIgX3Jvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShfcm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShfcm9vdEVsKSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICAhIWhhc05vblJvb3RSZWFjdENoaWxkID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCBcInVubW91bnRDb21wb25lbnRBdE5vZGUoKTogVGhlIG5vZGUgeW91J3JlIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBcIiArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LFxuXG5cbiAgLy8gVGVtcG9yYXJ5IGFsaWFzIHNpbmNlIHdlIGFscmVhZHkgc2hpcHBlZCBSZWFjdCAxNiBSQyB3aXRoIGl0LlxuICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuXG4gIHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghZGlkV2FybkFib3V0VW5zdGFibGVDcmVhdGVQb3J0YWwpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuc3RhYmxlQ3JlYXRlUG9ydGFsID0gdHJ1ZTtcbiAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnVGhlIFJlYWN0RE9NLnVuc3RhYmxlX2NyZWF0ZVBvcnRhbCgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RET00uY3JlYXRlUG9ydGFsKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSSwgJyArICdidXQgd2l0aG91dCB0aGUgXCJ1bnN0YWJsZV9cIiBwcmVmaXguJyk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwkJDEuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9LFxuXG5cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzJDEsXG5cbiAgdW5zdGFibGVfaW50ZXJhY3RpdmVVcGRhdGVzOiBpbnRlcmFjdGl2ZVVwZGF0ZXMkMSxcblxuICBmbHVzaFN5bmM6IGZsdXNoU3luYyxcblxuICB1bnN0YWJsZV9jcmVhdGVSb290OiBjcmVhdGVSb290LFxuICB1bnN0YWJsZV9mbHVzaENvbnRyb2xsZWQ6IGZsdXNoQ29udHJvbGxlZCxcblxuICBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDoge1xuICAgIC8vIEtlZXAgaW4gc3luYyB3aXRoIFJlYWN0RE9NVW5zdGFibGVOYXRpdmVEZXBlbmRlbmNpZXMuanNcbiAgICAvLyBhbmQgUmVhY3RUZXN0VXRpbHMuanMuIFRoaXMgaXMgYW4gYXJyYXkgZm9yIGJldHRlciBtaW5pZmljYXRpb24uXG4gICAgRXZlbnRzOiBbZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLCBnZXROb2RlRnJvbUluc3RhbmNlJDEsIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSwgaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSwgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcywgZW5xdWV1ZVN0YXRlUmVzdG9yZSwgcmVzdG9yZVN0YXRlSWZOZWVkZWQsIGRpc3BhdGNoRXZlbnQsIHJ1bkV2ZW50c0luQmF0Y2hdXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBlbmFibGVTdGFibGVDb25jdXJyZW50TW9kZUFQSXMgPyAnY3JlYXRlUm9vdCcgOiAndW5zdGFibGVfY3JlYXRlUm9vdCc7XG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicsIGZ1bmN0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIHtcbiAgICAhIWNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnWW91IGFyZSBjYWxsaW5nIFJlYWN0RE9NLiVzKCkgb24gYSBjb250YWluZXIgdGhhdCB3YXMgcHJldmlvdXNseSAnICsgJ3Bhc3NlZCB0byBSZWFjdERPTS5yZW5kZXIoKS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkLicsIGVuYWJsZVN0YWJsZUNvbmN1cnJlbnRNb2RlQVBJcyA/ICdjcmVhdGVSb290JyA6ICd1bnN0YWJsZV9jcmVhdGVSb290JykgOiB2b2lkIDA7XG4gICAgY29udGFpbmVyLl9yZWFjdEhhc0JlZW5QYXNzZWRUb0NyZWF0ZVJvb3RERVYgPSB0cnVlO1xuICB9XG4gIHZhciBoeWRyYXRlID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0ZSA9PT0gdHJ1ZTtcbiAgcmV0dXJuIG5ldyBSZWFjdFJvb3QoY29udGFpbmVyLCB0cnVlLCBoeWRyYXRlKTtcbn1cblxuaWYgKGVuYWJsZVN0YWJsZUNvbmN1cnJlbnRNb2RlQVBJcykge1xuICBSZWFjdERPTS5jcmVhdGVSb290ID0gY3JlYXRlUm9vdDtcbiAgUmVhY3RET00udW5zdGFibGVfY3JlYXRlUm9vdCA9IHVuZGVmaW5lZDtcbn1cblxudmFyIGZvdW5kRGV2VG9vbHMgPSBpbmplY3RJbnRvRGV2VG9vbHMoe1xuICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG4gIGJ1bmRsZVR5cGU6IDEsXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcbiAgcmVuZGVyZXJQYWNrYWdlTmFtZTogJ3JlYWN0LWRvbSdcbn0pO1xuXG57XG4gIGlmICghZm91bmREZXZUb29scyAmJiBjYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcbiAgICAvLyBJZiB3ZSdyZSBpbiBDaHJvbWUgb3IgRmlyZWZveCwgcHJvdmlkZSBhIGRvd25sb2FkIGxpbmsgaWYgbm90IGluc3RhbGxlZC5cbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA+IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRWRnZScpID09PSAtMSB8fCBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSA+IC0xKSB7XG4gICAgICB2YXIgcHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAvLyBEb24ndCB3YXJuIGluIGV4b3RpYyBjYXNlcyBsaWtlIGNocm9tZS1leHRlbnNpb246Ly8uXG4gICAgICBpZiAoL14oaHR0cHM/fGZpbGUpOiQvLnRlc3QocHJvdG9jb2wpKSB7XG4gICAgICAgIGNvbnNvbGUuaW5mbygnJWNEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgJyArICdmb3IgYSBiZXR0ZXIgZGV2ZWxvcG1lbnQgZXhwZXJpZW5jZTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyArIChwcm90b2NvbCA9PT0gJ2ZpbGU6JyA/ICdcXG5Zb3UgbWlnaHQgbmVlZCB0byB1c2UgYSBsb2NhbCBIVFRQIHNlcnZlciAoaW5zdGVhZCBvZiBmaWxlOi8vKTogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzLWZhcScgOiAnJyksICdmb250LXdlaWdodDpib2xkJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG52YXIgUmVhY3RET00kMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdERPTVxufSk7XG5cbnZhciBSZWFjdERPTSQzID0gKCBSZWFjdERPTSQyICYmIFJlYWN0RE9NICkgfHwgUmVhY3RET00kMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3REb20gPSBSZWFjdERPTSQzLmRlZmF1bHQgfHwgUmVhY3RET00kMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdERvbTtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY2hlY2tEQ0UoKSB7XG4gIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cbiAgaWYgKFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnIHx8XG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRSAhPT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBUaGlzIGJyYW5jaCBpcyB1bnJlYWNoYWJsZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgb25seSBjYWxsZWRcbiAgICAvLyBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGNvbmRpdGlvbiBpcyB0cnVlIG9ubHkgaW4gZGV2ZWxvcG1lbnQuXG4gICAgLy8gVGhlcmVmb3JlIGlmIHRoZSBicmFuY2ggaXMgc3RpbGwgaGVyZSwgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIHdhc24ndFxuICAgIC8vIHByb3Blcmx5IGFwcGxpZWQuXG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBtZXNzYWdlLiBSZWFjdCBEZXZUb29scyByZWxpZXMgb24gaXQuIEFsc28gbWFrZSBzdXJlXG4gICAgLy8gdGhpcyBtZXNzYWdlIGRvZXNuJ3Qgb2NjdXIgZWxzZXdoZXJlIGluIHRoaXMgZnVuY3Rpb24sIG9yIGl0IHdpbGwgY2F1c2VcbiAgICAvLyBhIGZhbHNlIHBvc2l0aXZlLlxuICAgIHRocm93IG5ldyBFcnJvcignXl9eJyk7XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBWZXJpZnkgdGhhdCB0aGUgY29kZSBhYm92ZSBoYXMgYmVlbiBkZWFkIGNvZGUgZWxpbWluYXRlZCAoRENFJ2QpLlxuICAgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5jaGVja0RDRShjaGVja0RDRSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIERldlRvb2xzIHNob3VsZG4ndCBjcmFzaCBSZWFjdCwgbm8gbWF0dGVyIHdoYXQuXG4gICAgLy8gV2Ugc2hvdWxkIHN0aWxsIHJlcG9ydCBpbiBjYXNlIHdlIGJyZWFrIHRoaXMgY29kZS5cbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH1cbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gRENFIGNoZWNrIHNob3VsZCBoYXBwZW4gYmVmb3JlIFJlYWN0RE9NIGJ1bmRsZSBleGVjdXRlcyBzbyB0aGF0XG4gIC8vIERldlRvb2xzIGNhbiByZXBvcnQgYmFkIG1pbmlmaWNhdGlvbiBkdXJpbmcgaW5qZWN0aW9uLlxuICBjaGVja0RDRSgpO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuOC42XG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuOC42JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7XG5cbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVXNlIGludmFyaWFudCgpIHRvIGFzc2VydCBzdGF0ZSB3aGljaCB5b3VyIHByb2dyYW0gYXNzdW1lcyB0byBiZSB0cnVlLlxuICpcbiAqIFByb3ZpZGUgc3ByaW50Zi1zdHlsZSBmb3JtYXQgKG9ubHkgJXMgaXMgc3VwcG9ydGVkKSBhbmQgYXJndW1lbnRzXG4gKiB0byBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgYnJva2UgYW5kIHdoYXQgeW91IHdlcmVcbiAqIGV4cGVjdGluZy5cbiAqXG4gKiBUaGUgaW52YXJpYW50IG1lc3NhZ2Ugd2lsbCBiZSBzdHJpcHBlZCBpbiBwcm9kdWN0aW9uLCBidXQgdGhlIGludmFyaWFudFxuICogd2lsbCByZW1haW4gdG8gZW5zdXJlIGxvZ2ljIGRvZXMgbm90IGRpZmZlciBpbiBwcm9kdWN0aW9uLlxuICovXG5cbnZhciB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3IgPSB2b2lkIDA7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIFJlbHlpbmcgb24gdGhlIGBpbnZhcmlhbnQoKWAgaW1wbGVtZW50YXRpb24gbGV0cyB1c1xuLy8gcHJlc2VydmUgdGhlIGZvcm1hdCBhbmQgcGFyYW1zIGluIHRoZSB3d3cgYnVpbGRzLlxuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Bsb3dQcmlvcml0eVdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nV2l0aG91dFN0YWNrID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgd2FybmluZ1dpdGhvdXRTdGFjayA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nV2l0aG91dFN0YWNrKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPiA4KSB7XG4gICAgICAvLyBDaGVjayBiZWZvcmUgdGhlIGNvbmRpdGlvbiB0byBjYXRjaCB2aW9sYXRpb25zIGVhcmx5LlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCd3YXJuaW5nV2l0aG91dFN0YWNrKCkgY3VycmVudGx5IHN1cHBvcnRzIGF0IG1vc3QgOCBhcmd1bWVudHMuJyk7XG4gICAgfVxuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuICcnICsgaXRlbTtcbiAgICAgIH0pO1xuICAgICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7XG5cbiAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmVycm9yLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbnZhciB3YXJuaW5nV2l0aG91dFN0YWNrJDEgPSB3YXJuaW5nV2l0aG91dFN0YWNrO1xuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsIFwiQ2FuJ3QgY2FsbCAlcyBvbiBhIGNvbXBvbmVudCB0aGF0IGlzIG5vdCB5ZXQgbW91bnRlZC4gXCIgKyAnVGhpcyBpcyBhIG5vLW9wLCBidXQgaXQgbWlnaHQgaW5kaWNhdGUgYSBidWcgaW4geW91ciBhcHBsaWNhdGlvbi4gJyArICdJbnN0ZWFkLCBhc3NpZ24gdG8gYHRoaXMuc3RhdGVgIGRpcmVjdGx5IG9yIGRlZmluZSBhIGBzdGF0ZSA9IHt9O2AgJyArICdjbGFzcyBwcm9wZXJ0eSB3aXRoIHRoZSBkZXNpcmVkIHN0YXRlIGluIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG57XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDb252ZW5pZW5jZSBjb21wb25lbnQgd2l0aCBkZWZhdWx0IHNoYWxsb3cgZXF1YWxpdHkgY2hlY2sgZm9yIHNDVS5cbiAqL1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIC8vIElmIGEgY29tcG9uZW50IGhhcyBzdHJpbmcgcmVmcywgd2Ugd2lsbCBhc3NpZ24gYSBkaWZmZXJlbnQgb2JqZWN0IGxhdGVyLlxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG4gIHtcbiAgICBPYmplY3Quc2VhbChyZWZPYmplY3QpO1xuICB9XG4gIHJldHVybiByZWZPYmplY3Q7XG59XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlci5cbiAqL1xudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgQkVGT1JFX1NMQVNIX1JFID0gL14oLiopW1xcXFxcXC9dLztcblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgdmFyIHNvdXJjZUluZm8gPSAnJztcbiAgaWYgKHNvdXJjZSkge1xuICAgIHZhciBwYXRoID0gc291cmNlLmZpbGVOYW1lO1xuICAgIHZhciBmaWxlTmFtZSA9IHBhdGgucmVwbGFjZShCRUZPUkVfU0xBU0hfUkUsICcnKTtcbiAgICB7XG4gICAgICAvLyBJbiBERVYsIGluY2x1ZGUgY29kZSBmb3IgYSBjb21tb24gc3BlY2lhbCBjYXNlOlxuICAgICAgLy8gcHJlZmVyIFwiZm9sZGVyL2luZGV4LmpzXCIgaW5zdGVhZCBvZiBqdXN0IFwiaW5kZXguanNcIi5cbiAgICAgIGlmICgvXmluZGV4XFwuLy50ZXN0KGZpbGVOYW1lKSkge1xuICAgICAgICB2YXIgbWF0Y2ggPSBwYXRoLm1hdGNoKEJFRk9SRV9TTEFTSF9SRSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHZhciBwYXRoQmVmb3JlU2xhc2ggPSBtYXRjaFsxXTtcbiAgICAgICAgICBpZiAocGF0aEJlZm9yZVNsYXNoKSB7XG4gICAgICAgICAgICB2YXIgZm9sZGVyTmFtZSA9IHBhdGhCZWZvcmVTbGFzaC5yZXBsYWNlKEJFRk9SRV9TTEFTSF9SRSwgJycpO1xuICAgICAgICAgICAgZmlsZU5hbWUgPSBmb2xkZXJOYW1lICsgJy8nICsgZmlsZU5hbWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZUluZm8gPSAnIChhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJztcbiAgfSBlbHNlIGlmIChvd25lck5hbWUpIHtcbiAgICBzb3VyY2VJbmZvID0gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknO1xuICB9XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgc291cmNlSW5mbztcbn07XG5cbnZhciBSZXNvbHZlZCA9IDE7XG5cblxuZnVuY3Rpb24gcmVmaW5lUmVzb2x2ZWRMYXp5Q29tcG9uZW50KGxhenlDb21wb25lbnQpIHtcbiAgcmV0dXJuIGxhenlDb21wb25lbnQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQgPyBsYXp5Q29tcG9uZW50Ll9yZXN1bHQgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgJygnICsgZnVuY3Rpb25OYW1lICsgJyknIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ0NvbmN1cnJlbnRNb2RlJztcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHJldHVybiAnQ29udGV4dC5Db25zdW1lcic7XG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHJldHVybiAnQ29udGV4dC5Qcm92aWRlcic7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLnR5cGUpO1xuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdGhlbmFibGUgPSB0eXBlO1xuICAgICAgICAgIHZhciByZXNvbHZlZFRoZW5hYmxlID0gcmVmaW5lUmVzb2x2ZWRMYXp5Q29tcG9uZW50KHRoZW5hYmxlKTtcbiAgICAgICAgICBpZiAocmVzb2x2ZWRUaGVuYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUocmVzb2x2ZWRUaGVuYWJsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IHt9O1xuXG52YXIgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIH1cbn1cblxue1xuICAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhY2sgPSAnJztcblxuICAgIC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcbiAgICBpZiAoY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC50eXBlKTtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9vd25lcjtcbiAgICAgIHN0YWNrICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgZ2V0Q29tcG9uZW50TmFtZShvd25lci50eXBlKSk7XG4gICAgfVxuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gIGFzc2lnbjogX2Fzc2lnblxufTtcblxue1xuICBfYXNzaWduKFJlYWN0U2hhcmVkSW50ZXJuYWxzLCB7XG4gICAgLy8gVGhlc2Ugc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiBwcm9kdWN0aW9uLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWU6IFJlYWN0RGVidWdDdXJyZW50RnJhbWUsXG4gICAgLy8gU2hpbSBmb3IgUmVhY3QgRE9NIDE2LjAuMCB3aGljaCBzdGlsbCBkZXN0cnVjdHVyZWQgKGJ1dCBub3QgdXNlZCkgdGhpcy5cbiAgICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuMC5cbiAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rOiB7fVxuICB9KTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSB3YXJuaW5nV2l0aG91dFN0YWNrJDE7XG5cbntcbiAgd2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC93YXJuaW5nLWFuZC1pbnZhcmlhbnQtYXJnc1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEuYXBwbHkodW5kZWZpbmVkLCBbZmFsc2UsIGZvcm1hdCArICclcyddLmNvbmNhdChhcmdzLCBbc3RhY2tdKSk7XG4gIH07XG59XG5cbnZhciB3YXJuaW5nJDEgPSB3YXJuaW5nO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgbm8gaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7XG4gICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pO1xuICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWUgPSB2b2lkIDA7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZmFjdG9yeVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgISEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSB1bmRlZmluZWQpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuY2xvbmVFbGVtZW50KC4uLik6IFRoZSBhcmd1bWVudCBtdXN0IGJlIGEgUmVhY3QgZWxlbWVudCwgYnV0IHlvdSBwYXNzZWQgJXMuJywgZWxlbWVudCkgOiB2b2lkIDA7XG5cbiAgdmFyIHByb3BOYW1lID0gdm9pZCAwO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdm9pZCAwO1xuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxudmFyIFBPT0xfU0laRSA9IDEwO1xudmFyIHRyYXZlcnNlQ29udGV4dFBvb2wgPSBbXTtcbmZ1bmN0aW9uIGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IHRyYXZlcnNlQ29udGV4dFBvb2wucG9wKCk7XG4gICAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbWFwRnVuY3Rpb247XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBtYXBSZXN1bHQsXG4gICAgICBrZXlQcmVmaXg6IGtleVByZWZpeCxcbiAgICAgIGZ1bmM6IG1hcEZ1bmN0aW9uLFxuICAgICAgY29udGV4dDogbWFwQ29udGV4dCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCkge1xuICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGggPCBQT09MX1NJWkUpIHtcbiAgICB0cmF2ZXJzZUNvbnRleHRQb29sLnB1c2godHJhdmVyc2VDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gdm9pZCAwO1xuICB2YXIgbmV4dE5hbWUgPSB2b2lkIDA7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICAhZGlkV2FybkFib3V0TWFwcyA/IHdhcm5pbmckMShmYWxzZSwgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJykgOiB2b2lkIDA7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwID0gdm9pZCAwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50ICE9PSBudWxsICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobnVsbCwgbnVsbCwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0LFxuICAgICAga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4LFxuICAgICAgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYztcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gY291bnRDaGlsZHJlbihjaGlsZHJlbikge1xuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9LCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZDtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QuQ2hpbGRyZW4ub25seSBleHBlY3RlZCB0byByZWNlaXZlIGEgc2luZ2xlIFJlYWN0IGVsZW1lbnQgY2hpbGQuJykgOiB2b2lkIDA7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgICEoY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09IG51bGwgfHwgdHlwZW9mIGNhbGN1bGF0ZUNoYW5nZWRCaXRzID09PSAnZnVuY3Rpb24nKSA/IHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuXG4gIGNvbnRleHQuUHJvdmlkZXIgPSB7XG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BST1ZJREVSX1RZUEUsXG4gICAgX2NvbnRleHQ6IGNvbnRleHRcbiAgfTtcblxuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gZmFsc2U7XG5cbiAge1xuICAgIC8vIEEgc2VwYXJhdGUgb2JqZWN0LCBidXQgcHJveGllcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9iamVjdCBmb3JcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAvLyB3YXJuIGZvciB0aGUgaW5jb3JyZWN0IHVzYWdlIG9mIENvbnRleHQgYXMgYSBDb25zdW1lci5cbiAgICB2YXIgQ29uc3VtZXIgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzXG4gICAgfTtcbiAgICAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBub3Qgc2V0dGluZyBhIHZhbHVlLCB3aGljaCBpcyBpbnRlbnRpb25hbCBoZXJlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuUHJvdmlkZXI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9Qcm92aWRlcikge1xuICAgICAgICAgIGNvbnRleHQuUHJvdmlkZXIgPSBfUHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll9jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBfY3VycmVudFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2N1cnJlbnRWYWx1ZTI6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKF9jdXJyZW50VmFsdWUyKSB7XG4gICAgICAgICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IF9jdXJyZW50VmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX3RocmVhZENvdW50OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0Ll90aHJlYWRDb3VudDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX3RocmVhZENvdW50KSB7XG4gICAgICAgICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBfdGhyZWFkQ291bnQ7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBDb25zdW1lcjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzKSB7XG4gICAgICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZW5kZXJpbmcgPENvbnRleHQuQ29uc3VtZXIuQ29uc3VtZXI+IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjb250ZXh0LkNvbnN1bWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbWlzc2luZyBwcm9wZXJ0aWVzIGJlY2F1c2UgaXQgZG9lc24ndCB1bmRlcnN0YW5kIGRlZmluZVByb3BlcnR5XG4gICAgY29udGV4dC5Db25zdW1lciA9IENvbnN1bWVyO1xuICB9XG5cbiAge1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IG51bGw7XG4gICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IG51bGw7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gbGF6eShjdG9yKSB7XG4gIHZhciBsYXp5VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTEFaWV9UWVBFLFxuICAgIF9jdG9yOiBjdG9yLFxuICAgIC8vIFJlYWN0IHVzZXMgdGhlc2UgZmllbGRzIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgX3N0YXR1czogLTEsXG4gICAgX3Jlc3VsdDogbnVsbFxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHZvaWQgMDtcbiAgICB2YXIgcHJvcFR5cGVzID0gdm9pZCAwO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlUeXBlLCB7XG4gICAgICBkZWZhdWx0UHJvcHM6IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZGVmYXVsdFByb3BzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChuZXdEZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdSZWFjdC5sYXp5KC4uLik6IEl0IGlzIG5vdCBzdXBwb3J0ZWQgdG8gYXNzaWduIGBkZWZhdWx0UHJvcHNgIHRvICcgKyAnYSBsYXp5IGNvbXBvbmVudCBpbXBvcnQuIEVpdGhlciBzcGVjaWZ5IHRoZW0gd2hlcmUgdGhlIGNvbXBvbmVudCAnICsgJ2lzIGRlZmluZWQsIG9yIGNyZWF0ZSBhIHdyYXBwaW5nIGNvbXBvbmVudCBhcm91bmQgaXQuJyk7XG4gICAgICAgICAgZGVmYXVsdFByb3BzID0gbmV3RGVmYXVsdFByb3BzO1xuICAgICAgICAgIC8vIE1hdGNoIHByb2R1Y3Rpb24gYmVoYXZpb3IgbW9yZSBjbG9zZWx5OlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsYXp5VHlwZSwgJ2RlZmF1bHRQcm9wcycsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb3BUeXBlczoge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wVHlwZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKG5ld1Byb3BUeXBlcykge1xuICAgICAgICAgIHdhcm5pbmckMShmYWxzZSwgJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcbiAgICAgICAgICBwcm9wVHlwZXMgPSBuZXdQcm9wVHlwZXM7XG4gICAgICAgICAgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ2ZvcndhcmRSZWYgcmVxdWlyZXMgYSByZW5kZXIgZnVuY3Rpb24gYnV0IHJlY2VpdmVkIGEgYG1lbW9gICcgKyAnY29tcG9uZW50LiBJbnN0ZWFkIG9mIGZvcndhcmRSZWYobWVtbyguLi4pKSwgdXNlICcgKyAnbWVtbyhmb3J3YXJkUmVmKC4uLikpLicpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnZm9yd2FyZFJlZiByZXF1aXJlcyBhIHJlbmRlciBmdW5jdGlvbiBidXQgd2FzIGdpdmVuICVzLicsIHJlbmRlciA9PT0gbnVsbCA/ICdudWxsJyA6IHR5cGVvZiByZW5kZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAhKFxuICAgICAgLy8gRG8gbm90IHdhcm4gZm9yIDAgYXJndW1lbnRzIGJlY2F1c2UgaXQgY291bGQgYmUgZHVlIHRvIHVzYWdlIG9mIHRoZSAnYXJndW1lbnRzJyBvYmplY3RcbiAgICAgIHJlbmRlci5sZW5ndGggPT09IDAgfHwgcmVuZGVyLmxlbmd0aCA9PT0gMikgPyB3YXJuaW5nV2l0aG91dFN0YWNrJDEoZmFsc2UsICdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgYWNjZXB0IGV4YWN0bHkgdHdvIHBhcmFtZXRlcnM6IHByb3BzIGFuZCByZWYuICVzJywgcmVuZGVyLmxlbmd0aCA9PT0gMSA/ICdEaWQgeW91IGZvcmdldCB0byB1c2UgdGhlIHJlZiBwYXJhbWV0ZXI/JyA6ICdBbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXIgd2lsbCBiZSB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG4gICAgfVxuXG4gICAgaWYgKHJlbmRlciAhPSBudWxsKSB7XG4gICAgICAhKHJlbmRlci5kZWZhdWx0UHJvcHMgPT0gbnVsbCAmJiByZW5kZXIucHJvcFR5cGVzID09IG51bGwpID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnZm9yd2FyZFJlZiByZW5kZXIgZnVuY3Rpb25zIGRvIG5vdCBzdXBwb3J0IHByb3BUeXBlcyBvciBkZWZhdWx0UHJvcHMuICcgKyAnRGlkIHlvdSBhY2NpZGVudGFsbHkgcGFzcyBhIFJlYWN0IGNvbXBvbmVudD8nKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgIHJlbmRlcjogcmVuZGVyXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHxcbiAgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKTtcbn1cblxuZnVuY3Rpb24gbWVtbyh0eXBlLCBjb21wYXJlKSB7XG4gIHtcbiAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSkge1xuICAgICAgd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9NRU1PX1RZUEUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjb21wYXJlOiBjb21wYXJlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29tcGFyZVxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG4gICEoZGlzcGF0Y2hlciAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uJykgOiB2b2lkIDA7XG4gIHJldHVybiBkaXNwYXRjaGVyO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHtcbiAgICAhKHVuc3RhYmxlX29ic2VydmVkQml0cyA9PT0gdW5kZWZpbmVkKSA/IHdhcm5pbmckMShmYWxzZSwgJ3VzZUNvbnRleHQoKSBzZWNvbmQgYXJndW1lbnQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSAnICsgJ3VzZSBpbiBSZWFjdC4gUGFzc2luZyBpdCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1lvdSBwYXNzZWQ6ICVzLiVzJywgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzLCB0eXBlb2YgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1syXSkgPyAnXFxuXFxuRGlkIHlvdSBjYWxsIGFycmF5Lm1hcCh1c2VDb250ZXh0KT8gJyArICdDYWxsaW5nIEhvb2tzIGluc2lkZSBhIGxvb3AgaXMgbm90IHN1cHBvcnRlZC4gJyArICdMZWFybiBtb3JlIGF0IGh0dHBzOi8vZmIubWUvcnVsZXMtb2YtaG9va3MnIDogJycpIDogdm9pZCAwO1xuXG4gICAgLy8gVE9ETzogYWRkIGEgbW9yZSBnZW5lcmljIHdhcm5pbmcgZm9yIGludmFsaWQgdmFsdWVzLlxuICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7XG4gICAgICAvLyBEb24ndCBkZWR1cGxpY2F0ZSBiZWNhdXNlIHRoaXMgbGVnaXRpbWF0ZWx5IGNhdXNlcyBidWdzXG4gICAgICAvLyBhbmQgbm9ib2R5IHNob3VsZCBiZSB1c2luZyB0aGlzIGluIGV4aXN0aW5nIGNvZGUuXG4gICAgICBpZiAocmVhbENvbnRleHQuQ29uc3VtZXIgPT09IENvbnRleHQpIHtcbiAgICAgICAgd2FybmluZyQxKGZhbHNlLCAnQ2FsbGluZyB1c2VDb250ZXh0KENvbnRleHQuQ29uc3VtZXIpIGlzIG5vdCBzdXBwb3J0ZWQsIG1heSBjYXVzZSBidWdzLCBhbmQgd2lsbCBiZSAnICsgJ3JlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIGNhbGwgdXNlQ29udGV4dChDb250ZXh0KSBpbnN0ZWFkPycpO1xuICAgICAgfSBlbHNlIGlmIChyZWFsQ29udGV4dC5Qcm92aWRlciA9PT0gQ29udGV4dCkge1xuICAgICAgICB3YXJuaW5nJDEoZmFsc2UsICdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNvbnRleHQoQ29udGV4dCwgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzKTtcbn1cblxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cblxuZnVuY3Rpb24gdXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbn1cblxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZihpbml0aWFsVmFsdWUpO1xufVxuXG5mdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBpbnB1dHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VFZmZlY3QoY3JlYXRlLCBpbnB1dHMpO1xufVxuXG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBpbnB1dHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBpbnB1dHMpO1xufVxuXG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgaW5wdXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ2FsbGJhY2soY2FsbGJhY2ssIGlucHV0cyk7XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBpbnB1dHMpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSByZXNvbHZlRGlzcGF0Y2hlcigpO1xuICByZXR1cm4gZGlzcGF0Y2hlci51c2VNZW1vKGNyZWF0ZSwgaW5wdXRzKTtcbn1cblxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgaW5wdXRzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgaW5wdXRzKTtcbn1cblxuZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAge1xuICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdm9pZCAwO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnRQcm9wcy5fX3NvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnRQcm9wcy5fX3NvdXJjZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJ1xcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIudHlwZSkgKyAnLic7XG4gIH1cblxuICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcbiAge1xuICAgIHdhcm5pbmckMShmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuICB9XG4gIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwID0gdm9pZCAwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgdmFyIHByb3BUeXBlcyA9IHZvaWQgMDtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8XG4gIC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHByb3BUeXBlcykge1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0pO1xuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgIHdhcm5pbmdXaXRob3V0U3RhY2skMShmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID8gd2FybmluZ1dpdGhvdXRTdGFjayQxKGZhbHNlLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICB3YXJuaW5nJDEoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuICB9XG5cbiAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTtcblxuICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShwcm9wcyk7XG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZVN0cmluZyA9IHZvaWQgMDtcbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9ICc8JyArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArICcgLz4nO1xuICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgfVxuXG4gICAgd2FybmluZyQxKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gIC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgaWYgKHZhbGlkVHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIC8vIExlZ2FjeSBob29rOiByZW1vdmUgaXRcbiAge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxuXG5cbi8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxuXG5cbi8vIFRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIGRlYnVnZ2VyLCB3ZVxuLy8gcmVwbGF5IHRoZSBiZWdpbiBwaGFzZSBvZiBhIGZhaWxlZCBjb21wb25lbnQgaW5zaWRlIGludm9rZUd1YXJkZWRDYWxsYmFjay5cblxuXG4vLyBXYXJuIGFib3V0IGRlcHJlY2F0ZWQsIGFzeW5jLXVuc2FmZSBsaWZlY3ljbGVzOyByZWxhdGVzIHRvIFJGQyAjNjpcblxuXG4vLyBHYXRoZXIgYWR2YW5jZWQgdGltaW5nIG1ldHJpY3MgZm9yIFByb2ZpbGVyIHN1YnRyZWVzLlxuXG5cbi8vIFRyYWNlIHdoaWNoIGludGVyYWN0aW9ucyB0cmlnZ2VyIGVhY2ggY29tbWl0LlxuXG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuIC8vIFRPRE86IHRydWU/IEhlcmUgaXQgbWlnaHQganVzdCBiZSBmYWxzZS5cblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cblxuLy8gUmVhY3QgRmlyZTogcHJldmVudCB0aGUgdmFsdWUgYW5kIGNoZWNrZWQgYXR0cmlidXRlcyBmcm9tIHN5bmNpbmdcbi8vIHdpdGggdGhlaXIgcmVsYXRlZCBET00gcHJvcGVydGllc1xuXG5cbi8vIFRoZXNlIEFQSXMgd2lsbCBubyBsb25nZXIgYmUgXCJ1bnN0YWJsZVwiIGluIHRoZSB1cGNvbWluZyAxNi43IHJlbGVhc2UsXG4vLyBDb250cm9sIHRoaXMgYmVoYXZpb3Igd2l0aCBhIGZsYWcgdG8gc3VwcG9ydCAxNi42IG1pbm9yIHJlbGVhc2VzIGluIHRoZSBtZWFud2hpbGUuXG52YXIgZW5hYmxlU3RhYmxlQ29uY3VycmVudE1vZGVBUElzID0gZmFsc2U7XG5cbnZhciBSZWFjdCA9IHtcbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IG1hcENoaWxkcmVuLFxuICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIGNyZWF0ZVJlZjogY3JlYXRlUmVmLFxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcblxuICBjcmVhdGVDb250ZXh0OiBjcmVhdGVDb250ZXh0LFxuICBmb3J3YXJkUmVmOiBmb3J3YXJkUmVmLFxuICBsYXp5OiBsYXp5LFxuICBtZW1vOiBtZW1vLFxuXG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayxcbiAgdXNlQ29udGV4dDogdXNlQ29udGV4dCxcbiAgdXNlRWZmZWN0OiB1c2VFZmZlY3QsXG4gIHVzZUltcGVyYXRpdmVIYW5kbGU6IHVzZUltcGVyYXRpdmVIYW5kbGUsXG4gIHVzZURlYnVnVmFsdWU6IHVzZURlYnVnVmFsdWUsXG4gIHVzZUxheW91dEVmZmVjdDogdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VNZW1vOiB1c2VNZW1vLFxuICB1c2VSZWR1Y2VyOiB1c2VSZWR1Y2VyLFxuICB1c2VSZWY6IHVzZVJlZixcbiAgdXNlU3RhdGU6IHVzZVN0YXRlLFxuXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuICBTdHJpY3RNb2RlOiBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFLFxuICBTdXNwZW5zZTogUkVBQ1RfU1VTUEVOU0VfVFlQRSxcblxuICBjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24sXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24sXG4gIGNyZWF0ZUZhY3Rvcnk6IGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbixcbiAgaXNWYWxpZEVsZW1lbnQ6IGlzVmFsaWRFbGVtZW50LFxuXG4gIHZlcnNpb246IFJlYWN0VmVyc2lvbixcblxuICB1bnN0YWJsZV9Db25jdXJyZW50TW9kZTogUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUsXG4gIHVuc3RhYmxlX1Byb2ZpbGVyOiBSRUFDVF9QUk9GSUxFUl9UWVBFLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiBSZWFjdFNoYXJlZEludGVybmFsc1xufTtcblxuLy8gTm90ZTogc29tZSBBUElzIGFyZSBhZGRlZCB3aXRoIGZlYXR1cmUgZmxhZ3MuXG4vLyBNYWtlIHN1cmUgdGhhdCBzdGFibGUgYnVpbGRzIGZvciBvcGVuIHNvdXJjZVxuLy8gZG9uJ3QgbW9kaWZ5IHRoZSBSZWFjdCBvYmplY3QgdG8gYXZvaWQgZGVvcHRzLlxuLy8gQWxzbyBsZXQncyBub3QgZXhwb3NlIHRoZWlyIG5hbWVzIGluIHN0YWJsZSBidWlsZHMuXG5cbmlmIChlbmFibGVTdGFibGVDb25jdXJyZW50TW9kZUFQSXMpIHtcbiAgUmVhY3QuQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbiAgUmVhY3QuUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBSZWFjdC51bnN0YWJsZV9Db25jdXJyZW50TW9kZSA9IHVuZGVmaW5lZDtcbiAgUmVhY3QudW5zdGFibGVfUHJvZmlsZXIgPSB1bmRlZmluZWQ7XG59XG5cblxuXG52YXIgUmVhY3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdFxufSk7XG5cbnZhciBSZWFjdCQzID0gKCBSZWFjdCQyICYmIFJlYWN0ICkgfHwgUmVhY3QkMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3QgPSBSZWFjdCQzLmRlZmF1bHQgfHwgUmVhY3QkMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdDtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYwLjEzLjZcbiAqIHNjaGVkdWxlci10cmFjaW5nLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbi8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiBiZWdpbi1waGFzZSBsaWZlY3ljbGUgaG9va3MgYW5kIHNldFN0YXRlIHJlZHVjZXJzOlxuXG5cbi8vIEluIHNvbWUgY2FzZXMsIFN0cmljdE1vZGUgc2hvdWxkIGFsc28gZG91YmxlLXJlbmRlciBsaWZlY3ljbGVzLlxuLy8gVGhpcyBjYW4gYmUgY29uZnVzaW5nIGZvciB0ZXN0cyB0aG91Z2gsXG4vLyBBbmQgaXQgY2FuIGJlIGJhZCBmb3IgcGVyZm9ybWFuY2UgaW4gcHJvZHVjdGlvbi5cbi8vIFRoaXMgZmVhdHVyZSBmbGFnIGNhbiBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yOlxuXG5cbi8vIFRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uIGNhdWdodCBleGNlcHRpb25zXCIgYmVoYXZpb3Igb2YgdGhlIGRlYnVnZ2VyLCB3ZVxuLy8gcmVwbGF5IHRoZSBiZWdpbiBwaGFzZSBvZiBhIGZhaWxlZCBjb21wb25lbnQgaW5zaWRlIGludm9rZUd1YXJkZWRDYWxsYmFjay5cblxuXG4vLyBXYXJuIGFib3V0IGRlcHJlY2F0ZWQsIGFzeW5jLXVuc2FmZSBsaWZlY3ljbGVzOyByZWxhdGVzIHRvIFJGQyAjNjpcblxuXG4vLyBHYXRoZXIgYWR2YW5jZWQgdGltaW5nIG1ldHJpY3MgZm9yIFByb2ZpbGVyIHN1YnRyZWVzLlxuXG5cbi8vIFRyYWNlIHdoaWNoIGludGVyYWN0aW9ucyB0cmlnZ2VyIGVhY2ggY29tbWl0LlxudmFyIGVuYWJsZVNjaGVkdWxlclRyYWNpbmcgPSB0cnVlO1xuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cbiAvLyBUT0RPOiB0cnVlPyBIZXJlIGl0IG1pZ2h0IGp1c3QgYmUgZmFsc2UuXG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG5cbi8vIFJlYWN0IEZpcmU6IHByZXZlbnQgdGhlIHZhbHVlIGFuZCBjaGVja2VkIGF0dHJpYnV0ZXMgZnJvbSBzeW5jaW5nXG4vLyB3aXRoIHRoZWlyIHJlbGF0ZWQgRE9NIHByb3BlcnRpZXNcblxuXG4vLyBUaGVzZSBBUElzIHdpbGwgbm8gbG9uZ2VyIGJlIFwidW5zdGFibGVcIiBpbiB0aGUgdXBjb21pbmcgMTYuNyByZWxlYXNlLFxuLy8gQ29udHJvbCB0aGlzIGJlaGF2aW9yIHdpdGggYSBmbGFnIHRvIHN1cHBvcnQgMTYuNiBtaW5vciByZWxlYXNlcyBpbiB0aGUgbWVhbndoaWxlLlxuXG52YXIgREVGQVVMVF9USFJFQURfSUQgPSAwO1xuXG4vLyBDb3VudGVycyB1c2VkIHRvIGdlbmVyYXRlIHVuaXF1ZSBJRHMuXG52YXIgaW50ZXJhY3Rpb25JRENvdW50ZXIgPSAwO1xudmFyIHRocmVhZElEQ291bnRlciA9IDA7XG5cbi8vIFNldCBvZiBjdXJyZW50bHkgdHJhY2VkIGludGVyYWN0aW9ucy5cbi8vIEludGVyYWN0aW9ucyBcInN0YWNrXCLigJNcbi8vIE1lYW5pbmcgdGhhdCBuZXdseSB0cmFjZWQgaW50ZXJhY3Rpb25zIGFyZSBhcHBlbmRlZCB0byB0aGUgcHJldmlvdXNseSBhY3RpdmUgc2V0LlxuLy8gV2hlbiBhbiBpbnRlcmFjdGlvbiBnb2VzIG91dCBvZiBzY29wZSwgdGhlIHByZXZpb3VzIHNldCAoaWYgYW55KSBpcyByZXN0b3JlZC5cbmV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYgPSBudWxsO1xuXG4vLyBMaXN0ZW5lcihzKSB0byBub3RpZnkgd2hlbiBpbnRlcmFjdGlvbnMgYmVnaW4gYW5kIGVuZC5cbmV4cG9ydHMuX19zdWJzY3JpYmVyUmVmID0gbnVsbDtcblxuaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZiA9IHtcbiAgICBjdXJyZW50OiBuZXcgU2V0KClcbiAgfTtcbiAgZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYgPSB7XG4gICAgY3VycmVudDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jbGVhcihjYWxsYmFjaykge1xuICBpZiAoIWVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuXG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBuZXcgU2V0KCk7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBwcmV2SW50ZXJhY3Rpb25zO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEN1cnJlbnQoKSB7XG4gIGlmICghZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0VGhyZWFkSUQoKSB7XG4gIHJldHVybiArK3RocmVhZElEQ291bnRlcjtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfdHJhY2UobmFtZSwgdGltZXN0YW1wLCBjYWxsYmFjaykge1xuICB2YXIgdGhyZWFkSUQgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IERFRkFVTFRfVEhSRUFEX0lEO1xuXG4gIGlmICghZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIHJldHVybiBjYWxsYmFjaygpO1xuICB9XG5cbiAgdmFyIGludGVyYWN0aW9uID0ge1xuICAgIF9fY291bnQ6IDEsXG4gICAgaWQ6IGludGVyYWN0aW9uSURDb3VudGVyKyssXG4gICAgbmFtZTogbmFtZSxcbiAgICB0aW1lc3RhbXA6IHRpbWVzdGFtcFxuICB9O1xuXG4gIHZhciBwcmV2SW50ZXJhY3Rpb25zID0gZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50O1xuXG4gIC8vIFRyYWNlZCBpbnRlcmFjdGlvbnMgc2hvdWxkIHN0YWNrL2FjY3VtdWxhdGUuXG4gIC8vIFRvIGRvIHRoYXQsIGNsb25lIHRoZSBjdXJyZW50IGludGVyYWN0aW9ucy5cbiAgLy8gVGhlIHByZXZpb3VzIHNldCB3aWxsIGJlIHJlc3RvcmVkIHVwb24gY29tcGxldGlvbi5cbiAgdmFyIGludGVyYWN0aW9ucyA9IG5ldyBTZXQocHJldkludGVyYWN0aW9ucyk7XG4gIGludGVyYWN0aW9ucy5hZGQoaW50ZXJhY3Rpb24pO1xuICBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQgPSBpbnRlcmFjdGlvbnM7XG5cbiAgdmFyIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuICB2YXIgcmV0dXJuVmFsdWUgPSB2b2lkIDA7XG5cbiAgdHJ5IHtcbiAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uVHJhY2VkKGludGVyYWN0aW9uKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gcHJldkludGVyYWN0aW9ucztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0b3BwZWQoaW50ZXJhY3Rpb25zLCB0aHJlYWRJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTtcblxuICAgICAgICAgIC8vIElmIG5vIGFzeW5jIHdvcmsgd2FzIHNjaGVkdWxlZCBmb3IgdGhpcyBpbnRlcmFjdGlvbixcbiAgICAgICAgICAvLyBOb3RpZnkgc3Vic2NyaWJlcnMgdGhhdCBpdCdzIGNvbXBsZXRlZC5cbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCAmJiBpbnRlcmFjdGlvbi5fX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3dyYXAoY2FsbGJhY2spIHtcbiAgdmFyIHRocmVhZElEID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBERUZBVUxUX1RIUkVBRF9JRDtcblxuICBpZiAoIWVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICByZXR1cm4gY2FsbGJhY2s7XG4gIH1cblxuICB2YXIgd3JhcHBlZEludGVyYWN0aW9ucyA9IGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudDtcblxuICB2YXIgc3Vic2NyaWJlciA9IGV4cG9ydHMuX19zdWJzY3JpYmVyUmVmLmN1cnJlbnQ7XG4gIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgc3Vic2NyaWJlci5vbldvcmtTY2hlZHVsZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBwZW5kaW5nIGFzeW5jIHdvcmsgY291bnQgZm9yIHRoZSBjdXJyZW50IGludGVyYWN0aW9ucy5cbiAgLy8gVXBkYXRlIGFmdGVyIGNhbGxpbmcgc3Vic2NyaWJlcnMgaW4gY2FzZSBvZiBlcnJvci5cbiAgd3JhcHBlZEludGVyYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgIGludGVyYWN0aW9uLl9fY291bnQrKztcbiAgfSk7XG5cbiAgdmFyIGhhc1J1biA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWQoKSB7XG4gICAgdmFyIHByZXZJbnRlcmFjdGlvbnMgPSBleHBvcnRzLl9faW50ZXJhY3Rpb25zUmVmLmN1cnJlbnQ7XG4gICAgZXhwb3J0cy5fX2ludGVyYWN0aW9uc1JlZi5jdXJyZW50ID0gd3JhcHBlZEludGVyYWN0aW9ucztcblxuICAgIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHZvaWQgMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHN1YnNjcmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBzdWJzY3JpYmVyLm9uV29ya1N0YXJ0ZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVyblZhbHVlID0gY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGV4cG9ydHMuX19pbnRlcmFjdGlvbnNSZWYuY3VycmVudCA9IHByZXZJbnRlcmFjdGlvbnM7XG5cbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3Vic2NyaWJlci5vbldvcmtTdG9wcGVkKHdyYXBwZWRJbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoIWhhc1J1bikge1xuICAgICAgICAvLyBXZSBvbmx5IGV4cGVjdCBhIHdyYXBwZWQgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSxcbiAgICAgICAgLy8gQnV0IGluIHRoZSBldmVudCB0aGF0IGl0J3MgZXhlY3V0ZWQgbW9yZSB0aGFuIG9uY2XigJNcbiAgICAgICAgLy8gT25seSBkZWNyZW1lbnQgdGhlIG91dHN0YW5kaW5nIGludGVyYWN0aW9uIGNvdW50cyBvbmNlLlxuICAgICAgICBoYXNSdW4gPSB0cnVlO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBwZW5kaW5nIGFzeW5jIGNvdW50cyBmb3IgYWxsIHdyYXBwZWQgaW50ZXJhY3Rpb25zLlxuICAgICAgICAvLyBJZiB0aGlzIHdhcyB0aGUgbGFzdCBzY2hlZHVsZWQgYXN5bmMgd29yayBmb3IgYW55IG9mIHRoZW0sXG4gICAgICAgIC8vIE1hcmsgdGhlbSBhcyBjb21wbGV0ZWQuXG4gICAgICAgIHdyYXBwZWRJbnRlcmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgICBpbnRlcmFjdGlvbi5fX2NvdW50LS07XG5cbiAgICAgICAgICBpZiAoc3Vic2NyaWJlciAhPT0gbnVsbCAmJiBpbnRlcmFjdGlvbi5fX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyLm9uSW50ZXJhY3Rpb25TY2hlZHVsZWRXb3JrQ29tcGxldGVkKGludGVyYWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHdyYXBwZWQuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHN1YnNjcmliZXIgPSBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChzdWJzY3JpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIHN1YnNjcmliZXIub25Xb3JrQ2FuY2VsZWQod3JhcHBlZEludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBVcGRhdGUgcGVuZGluZyBhc3luYyBjb3VudHMgZm9yIGFsbCB3cmFwcGVkIGludGVyYWN0aW9ucy5cbiAgICAgIC8vIElmIHRoaXMgd2FzIHRoZSBsYXN0IHNjaGVkdWxlZCBhc3luYyB3b3JrIGZvciBhbnkgb2YgdGhlbSxcbiAgICAgIC8vIE1hcmsgdGhlbSBhcyBjb21wbGV0ZWQuXG4gICAgICB3cmFwcGVkSW50ZXJhY3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGludGVyYWN0aW9uKSB7XG4gICAgICAgIGludGVyYWN0aW9uLl9fY291bnQtLTtcblxuICAgICAgICBpZiAoc3Vic2NyaWJlciAmJiBpbnRlcmFjdGlvbi5fX2NvdW50ID09PSAwKSB7XG4gICAgICAgICAgc3Vic2NyaWJlci5vbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZChpbnRlcmFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gd3JhcHBlZDtcbn1cblxudmFyIHN1YnNjcmliZXJzID0gbnVsbDtcbmlmIChlbmFibGVTY2hlZHVsZXJUcmFjaW5nKSB7XG4gIHN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9zdWJzY3JpYmUoc3Vic2NyaWJlcikge1xuICBpZiAoZW5hYmxlU2NoZWR1bGVyVHJhY2luZykge1xuICAgIHN1YnNjcmliZXJzLmFkZChzdWJzY3JpYmVyKTtcblxuICAgIGlmIChzdWJzY3JpYmVycy5zaXplID09PSAxKSB7XG4gICAgICBleHBvcnRzLl9fc3Vic2NyaWJlclJlZi5jdXJyZW50ID0ge1xuICAgICAgICBvbkludGVyYWN0aW9uU2NoZWR1bGVkV29ya0NvbXBsZXRlZDogb25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQsXG4gICAgICAgIG9uSW50ZXJhY3Rpb25UcmFjZWQ6IG9uSW50ZXJhY3Rpb25UcmFjZWQsXG4gICAgICAgIG9uV29ya0NhbmNlbGVkOiBvbldvcmtDYW5jZWxlZCxcbiAgICAgICAgb25Xb3JrU2NoZWR1bGVkOiBvbldvcmtTY2hlZHVsZWQsXG4gICAgICAgIG9uV29ya1N0YXJ0ZWQ6IG9uV29ya1N0YXJ0ZWQsXG4gICAgICAgIG9uV29ya1N0b3BwZWQ6IG9uV29ya1N0b3BwZWRcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3Vuc3Vic2NyaWJlKHN1YnNjcmliZXIpIHtcbiAgaWYgKGVuYWJsZVNjaGVkdWxlclRyYWNpbmcpIHtcbiAgICBzdWJzY3JpYmVycy5kZWxldGUoc3Vic2NyaWJlcik7XG5cbiAgICBpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgZXhwb3J0cy5fX3N1YnNjcmliZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG9uSW50ZXJhY3Rpb25UcmFjZWQoaW50ZXJhY3Rpb24pIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblRyYWNlZChpbnRlcmFjdGlvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmICghZGlkQ2F0Y2hFcnJvcikge1xuICAgICAgICBkaWRDYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmIChkaWRDYXRjaEVycm9yKSB7XG4gICAgdGhyb3cgY2F1Z2h0RXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25JbnRlcmFjdGlvblNjaGVkdWxlZFdvcmtDb21wbGV0ZWQoaW50ZXJhY3Rpb24pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9uV29ya1NjaGVkdWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya1NjaGVkdWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbldvcmtTdGFydGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RhcnRlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbldvcmtTdG9wcGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpIHtcbiAgdmFyIGRpZENhdGNoRXJyb3IgPSBmYWxzZTtcbiAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcblxuICBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1YnNjcmliZXIub25Xb3JrU3RvcHBlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKCFkaWRDYXRjaEVycm9yKSB7XG4gICAgICAgIGRpZENhdGNoRXJyb3IgPSB0cnVlO1xuICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgaWYgKGRpZENhdGNoRXJyb3IpIHtcbiAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbldvcmtDYW5jZWxlZChpbnRlcmFjdGlvbnMsIHRocmVhZElEKSB7XG4gIHZhciBkaWRDYXRjaEVycm9yID0gZmFsc2U7XG4gIHZhciBjYXVnaHRFcnJvciA9IG51bGw7XG5cbiAgc3Vic2NyaWJlcnMuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHRyeSB7XG4gICAgICBzdWJzY3JpYmVyLm9uV29ya0NhbmNlbGVkKGludGVyYWN0aW9ucywgdGhyZWFkSUQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIWRpZENhdGNoRXJyb3IpIHtcbiAgICAgICAgZGlkQ2F0Y2hFcnJvciA9IHRydWU7XG4gICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGlkQ2F0Y2hFcnJvcikge1xuICAgIHRocm93IGNhdWdodEVycm9yO1xuICB9XG59XG5cbmV4cG9ydHMudW5zdGFibGVfY2xlYXIgPSB1bnN0YWJsZV9jbGVhcjtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Q3VycmVudCA9IHVuc3RhYmxlX2dldEN1cnJlbnQ7XG5leHBvcnRzLnVuc3RhYmxlX2dldFRocmVhZElEID0gdW5zdGFibGVfZ2V0VGhyZWFkSUQ7XG5leHBvcnRzLnVuc3RhYmxlX3RyYWNlID0gdW5zdGFibGVfdHJhY2U7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXAgPSB1bnN0YWJsZV93cmFwO1xuZXhwb3J0cy51bnN0YWJsZV9zdWJzY3JpYmUgPSB1bnN0YWJsZV9zdWJzY3JpYmU7XG5leHBvcnRzLnVuc3RhYmxlX3Vuc3Vic2NyaWJlID0gdW5zdGFibGVfdW5zdWJzY3JpYmU7XG4gIH0pKCk7XG59XG4iLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjAuMTMuNlxuICogc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgPSBmYWxzZTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyICovXG5cbi8vIFRPRE86IFVzZSBzeW1ib2xzP1xudmFyIEltbWVkaWF0ZVByaW9yaXR5ID0gMTtcbnZhciBVc2VyQmxvY2tpbmdQcmlvcml0eSA9IDI7XG52YXIgTm9ybWFsUHJpb3JpdHkgPSAzO1xudmFyIExvd1ByaW9yaXR5ID0gNDtcbnZhciBJZGxlUHJpb3JpdHkgPSA1O1xuXG4vLyBNYXggMzEgYml0IGludGVnZXIuIFRoZSBtYXggaW50ZWdlciBzaXplIGluIFY4IGZvciAzMi1iaXQgc3lzdGVtcy5cbi8vIE1hdGgucG93KDIsIDMwKSAtIDFcbi8vIDBiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXG52YXIgbWF4U2lnbmVkMzFCaXRJbnQgPSAxMDczNzQxODIzO1xuXG4vLyBUaW1lcyBvdXQgaW1tZWRpYXRlbHlcbnZhciBJTU1FRElBVEVfUFJJT1JJVFlfVElNRU9VVCA9IC0xO1xuLy8gRXZlbnR1YWxseSB0aW1lcyBvdXRcbnZhciBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZID0gMjUwO1xudmFyIE5PUk1BTF9QUklPUklUWV9USU1FT1VUID0gNTAwMDtcbnZhciBMT1dfUFJJT1JJVFlfVElNRU9VVCA9IDEwMDAwO1xuLy8gTmV2ZXIgdGltZXMgb3V0XG52YXIgSURMRV9QUklPUklUWSA9IG1heFNpZ25lZDMxQml0SW50O1xuXG4vLyBDYWxsYmFja3MgYXJlIHN0b3JlZCBhcyBhIGNpcmN1bGFyLCBkb3VibHkgbGlua2VkIGxpc3QuXG52YXIgZmlyc3RDYWxsYmFja05vZGUgPSBudWxsO1xuXG52YXIgY3VycmVudERpZFRpbWVvdXQgPSBmYWxzZTtcbi8vIFBhdXNpbmcgdGhlIHNjaGVkdWxlciBpcyB1c2VmdWwgZm9yIGRlYnVnZ2luZy5cbnZhciBpc1NjaGVkdWxlclBhdXNlZCA9IGZhbHNlO1xuXG52YXIgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbnZhciBjdXJyZW50RXZlbnRTdGFydFRpbWUgPSAtMTtcbnZhciBjdXJyZW50RXhwaXJhdGlvblRpbWUgPSAtMTtcblxuLy8gVGhpcyBpcyBzZXQgd2hlbiBhIGNhbGxiYWNrIGlzIGJlaW5nIGV4ZWN1dGVkLCB0byBwcmV2ZW50IHJlLWVudHJhbmN5LlxudmFyIGlzRXhlY3V0aW5nQ2FsbGJhY2sgPSBmYWxzZTtcblxudmFyIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbnZhciBoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdyA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gZW5zdXJlSG9zdENhbGxiYWNrSXNTY2hlZHVsZWQoKSB7XG4gIGlmIChpc0V4ZWN1dGluZ0NhbGxiYWNrKSB7XG4gICAgLy8gRG9uJ3Qgc2NoZWR1bGUgd29yayB5ZXQ7IHdhaXQgdW50aWwgdGhlIG5leHQgdGltZSB3ZSB5aWVsZC5cbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2NoZWR1bGUgdGhlIGhvc3QgY2FsbGJhY2sgdXNpbmcgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gaW4gdGhlIGxpc3QuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IGZpcnN0Q2FsbGJhY2tOb2RlLmV4cGlyYXRpb25UaW1lO1xuICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkKSB7XG4gICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIENhbmNlbCB0aGUgZXhpc3RpbmcgaG9zdCBjYWxsYmFjay5cbiAgICBjYW5jZWxIb3N0Q2FsbGJhY2soKTtcbiAgfVxuICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yaywgZXhwaXJhdGlvblRpbWUpO1xufVxuXG5mdW5jdGlvbiBmbHVzaEZpcnN0Q2FsbGJhY2soKSB7XG4gIHZhciBmbHVzaGVkTm9kZSA9IGZpcnN0Q2FsbGJhY2tOb2RlO1xuXG4gIC8vIFJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSBsaXN0IGJlZm9yZSBjYWxsaW5nIHRoZSBjYWxsYmFjay4gVGhhdCB3YXkgdGhlXG4gIC8vIGxpc3QgaXMgaW4gYSBjb25zaXN0ZW50IHN0YXRlIGV2ZW4gaWYgdGhlIGNhbGxiYWNrIHRocm93cy5cbiAgdmFyIG5leHQgPSBmaXJzdENhbGxiYWNrTm9kZS5uZXh0O1xuICBpZiAoZmlyc3RDYWxsYmFja05vZGUgPT09IG5leHQpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IGNhbGxiYWNrIGluIHRoZSBsaXN0LlxuICAgIGZpcnN0Q2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgICBuZXh0ID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFzdENhbGxiYWNrTm9kZSA9IGZpcnN0Q2FsbGJhY2tOb2RlLnByZXZpb3VzO1xuICAgIGZpcnN0Q2FsbGJhY2tOb2RlID0gbGFzdENhbGxiYWNrTm9kZS5uZXh0ID0gbmV4dDtcbiAgICBuZXh0LnByZXZpb3VzID0gbGFzdENhbGxiYWNrTm9kZTtcbiAgfVxuXG4gIGZsdXNoZWROb2RlLm5leHQgPSBmbHVzaGVkTm9kZS5wcmV2aW91cyA9IG51bGw7XG5cbiAgLy8gTm93IGl0J3Mgc2FmZSB0byBjYWxsIHRoZSBjYWxsYmFjay5cbiAgdmFyIGNhbGxiYWNrID0gZmx1c2hlZE5vZGUuY2FsbGJhY2s7XG4gIHZhciBleHBpcmF0aW9uVGltZSA9IGZsdXNoZWROb2RlLmV4cGlyYXRpb25UaW1lO1xuICB2YXIgcHJpb3JpdHlMZXZlbCA9IGZsdXNoZWROb2RlLnByaW9yaXR5TGV2ZWw7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgdmFyIHByZXZpb3VzRXhwaXJhdGlvblRpbWUgPSBjdXJyZW50RXhwaXJhdGlvblRpbWU7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudEV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHZhciBjb250aW51YXRpb25DYWxsYmFjaztcbiAgdHJ5IHtcbiAgICBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gICAgY3VycmVudEV4cGlyYXRpb25UaW1lID0gcHJldmlvdXNFeHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIC8vIEEgY2FsbGJhY2sgbWF5IHJldHVybiBhIGNvbnRpbnVhdGlvbi4gVGhlIGNvbnRpbnVhdGlvbiBzaG91bGQgYmUgc2NoZWR1bGVkXG4gIC8vIHdpdGggdGhlIHNhbWUgcHJpb3JpdHkgYW5kIGV4cGlyYXRpb24gYXMgdGhlIGp1c3QtZmluaXNoZWQgY2FsbGJhY2suXG4gIGlmICh0eXBlb2YgY29udGludWF0aW9uQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgY29udGludWF0aW9uTm9kZSA9IHtcbiAgICAgIGNhbGxiYWNrOiBjb250aW51YXRpb25DYWxsYmFjayxcbiAgICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICBuZXh0OiBudWxsLFxuICAgICAgcHJldmlvdXM6IG51bGxcbiAgICB9O1xuXG4gICAgLy8gSW5zZXJ0IHRoZSBuZXcgY2FsbGJhY2sgaW50byB0aGUgbGlzdCwgc29ydGVkIGJ5IGl0cyBleHBpcmF0aW9uLiBUaGlzIGlzXG4gICAgLy8gYWxtb3N0IHRoZSBzYW1lIGFzIHRoZSBjb2RlIGluIGBzY2hlZHVsZUNhbGxiYWNrYCwgZXhjZXB0IHRoZSBjYWxsYmFja1xuICAgIC8vIGlzIGluc2VydGVkIGludG8gdGhlIGxpc3QgKmJlZm9yZSogY2FsbGJhY2tzIG9mIGVxdWFsIGV4cGlyYXRpb24gaW5zdGVhZFxuICAgIC8vIG9mIGFmdGVyLlxuICAgIGlmIChmaXJzdENhbGxiYWNrTm9kZSA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgY2FsbGJhY2sgaW4gdGhlIGxpc3QuXG4gICAgICBmaXJzdENhbGxiYWNrTm9kZSA9IGNvbnRpbnVhdGlvbk5vZGUubmV4dCA9IGNvbnRpbnVhdGlvbk5vZGUucHJldmlvdXMgPSBjb250aW51YXRpb25Ob2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dEFmdGVyQ29udGludWF0aW9uID0gbnVsbDtcbiAgICAgIHZhciBub2RlID0gZmlyc3RDYWxsYmFja05vZGU7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChub2RlLmV4cGlyYXRpb25UaW1lID49IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgLy8gVGhpcyBjYWxsYmFjayBleHBpcmVzIGF0IG9yIGFmdGVyIHRoZSBjb250aW51YXRpb24uIFdlIHdpbGwgaW5zZXJ0XG4gICAgICAgICAgLy8gdGhlIGNvbnRpbnVhdGlvbiAqYmVmb3JlKiB0aGlzIGNhbGxiYWNrLlxuICAgICAgICAgIG5leHRBZnRlckNvbnRpbnVhdGlvbiA9IG5vZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dDtcbiAgICAgIH0gd2hpbGUgKG5vZGUgIT09IGZpcnN0Q2FsbGJhY2tOb2RlKTtcblxuICAgICAgaWYgKG5leHRBZnRlckNvbnRpbnVhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBObyBlcXVhbCBvciBsb3dlciBwcmlvcml0eSBjYWxsYmFjayB3YXMgZm91bmQsIHdoaWNoIG1lYW5zIHRoZSBuZXdcbiAgICAgICAgLy8gY2FsbGJhY2sgaXMgdGhlIGxvd2VzdCBwcmlvcml0eSBjYWxsYmFjayBpbiB0aGUgbGlzdC5cbiAgICAgICAgbmV4dEFmdGVyQ29udGludWF0aW9uID0gZmlyc3RDYWxsYmFja05vZGU7XG4gICAgICB9IGVsc2UgaWYgKG5leHRBZnRlckNvbnRpbnVhdGlvbiA9PT0gZmlyc3RDYWxsYmFja05vZGUpIHtcbiAgICAgICAgLy8gVGhlIG5ldyBjYWxsYmFjayBpcyB0aGUgaGlnaGVzdCBwcmlvcml0eSBjYWxsYmFjayBpbiB0aGUgbGlzdC5cbiAgICAgICAgZmlyc3RDYWxsYmFja05vZGUgPSBjb250aW51YXRpb25Ob2RlO1xuICAgICAgICBlbnN1cmVIb3N0Q2FsbGJhY2tJc1NjaGVkdWxlZCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldmlvdXMgPSBuZXh0QWZ0ZXJDb250aW51YXRpb24ucHJldmlvdXM7XG4gICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dEFmdGVyQ29udGludWF0aW9uLnByZXZpb3VzID0gY29udGludWF0aW9uTm9kZTtcbiAgICAgIGNvbnRpbnVhdGlvbk5vZGUubmV4dCA9IG5leHRBZnRlckNvbnRpbnVhdGlvbjtcbiAgICAgIGNvbnRpbnVhdGlvbk5vZGUucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hJbW1lZGlhdGVXb3JrKCkge1xuICBpZiAoXG4gIC8vIENvbmZpcm0gd2UndmUgZXhpdGVkIHRoZSBvdXRlciBtb3N0IGV2ZW50IGhhbmRsZXJcbiAgY3VycmVudEV2ZW50U3RhcnRUaW1lID09PSAtMSAmJiBmaXJzdENhbGxiYWNrTm9kZSAhPT0gbnVsbCAmJiBmaXJzdENhbGxiYWNrTm9kZS5wcmlvcml0eUxldmVsID09PSBJbW1lZGlhdGVQcmlvcml0eSkge1xuICAgIGlzRXhlY3V0aW5nQ2FsbGJhY2sgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBkbyB7XG4gICAgICAgIGZsdXNoRmlyc3RDYWxsYmFjaygpO1xuICAgICAgfSB3aGlsZSAoXG4gICAgICAvLyBLZWVwIGZsdXNoaW5nIHVudGlsIHRoZXJlIGFyZSBubyBtb3JlIGltbWVkaWF0ZSBjYWxsYmFja3NcbiAgICAgIGZpcnN0Q2FsbGJhY2tOb2RlICE9PSBudWxsICYmIGZpcnN0Q2FsbGJhY2tOb2RlLnByaW9yaXR5TGV2ZWwgPT09IEltbWVkaWF0ZVByaW9yaXR5KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNFeGVjdXRpbmdDYWxsYmFjayA9IGZhbHNlO1xuICAgICAgaWYgKGZpcnN0Q2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZXJlJ3Mgc3RpbGwgd29yayByZW1haW5pbmcuIFJlcXVlc3QgYW5vdGhlciBjYWxsYmFjay5cbiAgICAgICAgZW5zdXJlSG9zdENhbGxiYWNrSXNTY2hlZHVsZWQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoV29yayhkaWRUaW1lb3V0KSB7XG4gIC8vIEV4aXQgcmlnaHQgYXdheSBpZiB3ZSdyZSBjdXJyZW50bHkgcGF1c2VkXG5cbiAgaWYgKGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyAmJiBpc1NjaGVkdWxlclBhdXNlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlzRXhlY3V0aW5nQ2FsbGJhY2sgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNEaWRUaW1lb3V0ID0gY3VycmVudERpZFRpbWVvdXQ7XG4gIGN1cnJlbnREaWRUaW1lb3V0ID0gZGlkVGltZW91dDtcbiAgdHJ5IHtcbiAgICBpZiAoZGlkVGltZW91dCkge1xuICAgICAgLy8gRmx1c2ggYWxsIHRoZSBleHBpcmVkIGNhbGxiYWNrcyB3aXRob3V0IHlpZWxkaW5nLlxuICAgICAgd2hpbGUgKGZpcnN0Q2FsbGJhY2tOb2RlICE9PSBudWxsICYmICEoZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nICYmIGlzU2NoZWR1bGVyUGF1c2VkKSkge1xuICAgICAgICAvLyBUT0RPIFdyYXAgaW4gZmVhdHVyZSBmbGFnXG4gICAgICAgIC8vIFJlYWQgdGhlIGN1cnJlbnQgdGltZS4gRmx1c2ggYWxsIHRoZSBjYWxsYmFja3MgdGhhdCBleHBpcmUgYXQgb3JcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoYXQgdGltZS4gVGhlbiByZWFkIHRoZSBjdXJyZW50IHRpbWUgYWdhaW4gYW5kIHJlcGVhdC5cbiAgICAgICAgLy8gVGhpcyBvcHRpbWl6ZXMgZm9yIGFzIGZldyBwZXJmb3JtYW5jZS5ub3cgY2FsbHMgYXMgcG9zc2libGUuXG4gICAgICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG4gICAgICAgIGlmIChmaXJzdENhbGxiYWNrTm9kZS5leHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGZsdXNoRmlyc3RDYWxsYmFjaygpO1xuICAgICAgICAgIH0gd2hpbGUgKGZpcnN0Q2FsbGJhY2tOb2RlICE9PSBudWxsICYmIGZpcnN0Q2FsbGJhY2tOb2RlLmV4cGlyYXRpb25UaW1lIDw9IGN1cnJlbnRUaW1lICYmICEoZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nICYmIGlzU2NoZWR1bGVyUGF1c2VkKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEtlZXAgZmx1c2hpbmcgY2FsbGJhY2tzIHVudGlsIHdlIHJ1biBvdXQgb2YgdGltZSBpbiB0aGUgZnJhbWUuXG4gICAgICBpZiAoZmlyc3RDYWxsYmFja05vZGUgIT09IG51bGwpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChlbmFibGVTY2hlZHVsZXJEZWJ1Z2dpbmcgJiYgaXNTY2hlZHVsZXJQYXVzZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaEZpcnN0Q2FsbGJhY2soKTtcbiAgICAgICAgfSB3aGlsZSAoZmlyc3RDYWxsYmFja05vZGUgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkVG9Ib3N0KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBpc0V4ZWN1dGluZ0NhbGxiYWNrID0gZmFsc2U7XG4gICAgY3VycmVudERpZFRpbWVvdXQgPSBwcmV2aW91c0RpZFRpbWVvdXQ7XG4gICAgaWYgKGZpcnN0Q2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGVyZSdzIHN0aWxsIHdvcmsgcmVtYWluaW5nLiBSZXF1ZXN0IGFub3RoZXIgY2FsbGJhY2suXG4gICAgICBlbnN1cmVIb3N0Q2FsbGJhY2tJc1NjaGVkdWxlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBCZWZvcmUgZXhpdGluZywgZmx1c2ggYWxsIHRoZSBpbW1lZGlhdGUgd29yayB0aGF0IHdhcyBzY2hlZHVsZWQuXG4gICAgZmx1c2hJbW1lZGlhdGVXb3JrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5KHByaW9yaXR5TGV2ZWwsIGV2ZW50SGFuZGxlcikge1xuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgY2FzZSBOb3JtYWxQcmlvcml0eTpcbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eTtcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgdmFyIHByZXZpb3VzRXZlbnRTdGFydFRpbWUgPSBjdXJyZW50RXZlbnRTdGFydFRpbWU7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudEV2ZW50U3RhcnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICBjdXJyZW50RXZlbnRTdGFydFRpbWUgPSBwcmV2aW91c0V2ZW50U3RhcnRUaW1lO1xuXG4gICAgLy8gQmVmb3JlIGV4aXRpbmcsIGZsdXNoIGFsbCB0aGUgaW1tZWRpYXRlIHdvcmsgdGhhdCB3YXMgc2NoZWR1bGVkLlxuICAgIGZsdXNoSW1tZWRpYXRlV29yaygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX25leHQoZXZlbnRIYW5kbGVyKSB7XG4gIHZhciBwcmlvcml0eUxldmVsID0gdm9pZCAwO1xuICBzd2l0Y2ggKGN1cnJlbnRQcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgICAvLyBTaGlmdCBkb3duIHRvIG5vcm1hbCBwcmlvcml0eVxuICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEFueXRoaW5nIGxvd2VyIHRoYW4gbm9ybWFsIHByaW9yaXR5IHNob3VsZCByZW1haW4gYXQgdGhlIGN1cnJlbnQgbGV2ZWwuXG4gICAgICBwcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBwcmV2aW91c1ByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgdmFyIHByZXZpb3VzRXZlbnRTdGFydFRpbWUgPSBjdXJyZW50RXZlbnRTdGFydFRpbWU7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcbiAgY3VycmVudEV2ZW50U3RhcnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICBjdXJyZW50RXZlbnRTdGFydFRpbWUgPSBwcmV2aW91c0V2ZW50U3RhcnRUaW1lO1xuXG4gICAgLy8gQmVmb3JlIGV4aXRpbmcsIGZsdXNoIGFsbCB0aGUgaW1tZWRpYXRlIHdvcmsgdGhhdCB3YXMgc2NoZWR1bGVkLlxuICAgIGZsdXNoSW1tZWRpYXRlV29yaygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3dyYXBDYWxsYmFjayhjYWxsYmFjaykge1xuICB2YXIgcGFyZW50UHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoaXMgaXMgYSBmb3JrIG9mIHJ1bldpdGhQcmlvcml0eSwgaW5saW5lZCBmb3IgcGVyZm9ybWFuY2UuXG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICAgIHZhciBwcmV2aW91c0V2ZW50U3RhcnRUaW1lID0gY3VycmVudEV2ZW50U3RhcnRUaW1lO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcGFyZW50UHJpb3JpdHlMZXZlbDtcbiAgICBjdXJyZW50RXZlbnRTdGFydFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICAgIGN1cnJlbnRFdmVudFN0YXJ0VGltZSA9IHByZXZpb3VzRXZlbnRTdGFydFRpbWU7XG4gICAgICBmbHVzaEltbWVkaWF0ZVdvcmsoKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHJlY2F0ZWRfb3B0aW9ucykge1xuICB2YXIgc3RhcnRUaW1lID0gY3VycmVudEV2ZW50U3RhcnRUaW1lICE9PSAtMSA/IGN1cnJlbnRFdmVudFN0YXJ0VGltZSA6IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgdmFyIGV4cGlyYXRpb25UaW1lO1xuICBpZiAodHlwZW9mIGRlcHJlY2F0ZWRfb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgZGVwcmVjYXRlZF9vcHRpb25zICE9PSBudWxsICYmIHR5cGVvZiBkZXByZWNhdGVkX29wdGlvbnMudGltZW91dCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBGSVhNRTogUmVtb3ZlIHRoaXMgYnJhbmNoIG9uY2Ugd2UgbGlmdCBleHBpcmF0aW9uIHRpbWVzIG91dCBvZiBSZWFjdC5cbiAgICBleHBpcmF0aW9uVGltZSA9IHN0YXJ0VGltZSArIGRlcHJlY2F0ZWRfb3B0aW9ucy50aW1lb3V0O1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAoY3VycmVudFByaW9yaXR5TGV2ZWwpIHtcbiAgICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgICAgIGV4cGlyYXRpb25UaW1lID0gc3RhcnRUaW1lICsgSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBzdGFydFRpbWUgKyBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSWRsZVByaW9yaXR5OlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IHN0YXJ0VGltZSArIElETEVfUFJJT1JJVFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBzdGFydFRpbWUgKyBMT1dfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBzdGFydFRpbWUgKyBOT1JNQUxfUFJJT1JJVFlfVElNRU9VVDtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV3Tm9kZSA9IHtcbiAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgcHJpb3JpdHlMZXZlbDogY3VycmVudFByaW9yaXR5TGV2ZWwsXG4gICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgIG5leHQ6IG51bGwsXG4gICAgcHJldmlvdXM6IG51bGxcbiAgfTtcblxuICAvLyBJbnNlcnQgdGhlIG5ldyBjYWxsYmFjayBpbnRvIHRoZSBsaXN0LCBvcmRlcmVkIGZpcnN0IGJ5IGV4cGlyYXRpb24sIHRoZW5cbiAgLy8gYnkgaW5zZXJ0aW9uLiBTbyB0aGUgbmV3IGNhbGxiYWNrIGlzIGluc2VydGVkIGFueSBvdGhlciBjYWxsYmFjayB3aXRoXG4gIC8vIGVxdWFsIGV4cGlyYXRpb24uXG4gIGlmIChmaXJzdENhbGxiYWNrTm9kZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGNhbGxiYWNrIGluIHRoZSBsaXN0LlxuICAgIGZpcnN0Q2FsbGJhY2tOb2RlID0gbmV3Tm9kZS5uZXh0ID0gbmV3Tm9kZS5wcmV2aW91cyA9IG5ld05vZGU7XG4gICAgZW5zdXJlSG9zdENhbGxiYWNrSXNTY2hlZHVsZWQoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbmV4dCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaXJzdENhbGxiYWNrTm9kZTtcbiAgICBkbyB7XG4gICAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFRoZSBuZXcgY2FsbGJhY2sgZXhwaXJlcyBiZWZvcmUgdGhpcyBvbmUuXG4gICAgICAgIG5leHQgPSBub2RlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gZmlyc3RDYWxsYmFja05vZGUpO1xuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIE5vIGNhbGxiYWNrIHdpdGggYSBsYXRlciBleHBpcmF0aW9uIHdhcyBmb3VuZCwgd2hpY2ggbWVhbnMgdGhlIG5ld1xuICAgICAgLy8gY2FsbGJhY2sgaGFzIHRoZSBsYXRlc3QgZXhwaXJhdGlvbiBpbiB0aGUgbGlzdC5cbiAgICAgIG5leHQgPSBmaXJzdENhbGxiYWNrTm9kZTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IGZpcnN0Q2FsbGJhY2tOb2RlKSB7XG4gICAgICAvLyBUaGUgbmV3IGNhbGxiYWNrIGhhcyB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiBpbiB0aGUgZW50aXJlIGxpc3QuXG4gICAgICBmaXJzdENhbGxiYWNrTm9kZSA9IG5ld05vZGU7XG4gICAgICBlbnN1cmVIb3N0Q2FsbGJhY2tJc1NjaGVkdWxlZCgpO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91cyA9IG5leHQucHJldmlvdXM7XG4gICAgcHJldmlvdXMubmV4dCA9IG5leHQucHJldmlvdXMgPSBuZXdOb2RlO1xuICAgIG5ld05vZGUubmV4dCA9IG5leHQ7XG4gICAgbmV3Tm9kZS5wcmV2aW91cyA9IHByZXZpb3VzO1xuICB9XG5cbiAgcmV0dXJuIG5ld05vZGU7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uKCkge1xuICBpc1NjaGVkdWxlclBhdXNlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uKCkge1xuICBpc1NjaGVkdWxlclBhdXNlZCA9IGZhbHNlO1xuICBpZiAoZmlyc3RDYWxsYmFja05vZGUgIT09IG51bGwpIHtcbiAgICBlbnN1cmVIb3N0Q2FsbGJhY2tJc1NjaGVkdWxlZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlKCkge1xuICByZXR1cm4gZmlyc3RDYWxsYmFja05vZGU7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX2NhbmNlbENhbGxiYWNrKGNhbGxiYWNrTm9kZSkge1xuICB2YXIgbmV4dCA9IGNhbGxiYWNrTm9kZS5uZXh0O1xuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIEFscmVhZHkgY2FuY2VsbGVkLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChuZXh0ID09PSBjYWxsYmFja05vZGUpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHNjaGVkdWxlZCBjYWxsYmFjay4gQ2xlYXIgdGhlIGxpc3QuXG4gICAgZmlyc3RDYWxsYmFja05vZGUgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBpdHMgcG9zaXRpb24gaW4gdGhlIGxpc3QuXG4gICAgaWYgKGNhbGxiYWNrTm9kZSA9PT0gZmlyc3RDYWxsYmFja05vZGUpIHtcbiAgICAgIGZpcnN0Q2FsbGJhY2tOb2RlID0gbmV4dDtcbiAgICB9XG4gICAgdmFyIHByZXZpb3VzID0gY2FsbGJhY2tOb2RlLnByZXZpb3VzO1xuICAgIHByZXZpb3VzLm5leHQgPSBuZXh0O1xuICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgfVxuXG4gIGNhbGxiYWNrTm9kZS5uZXh0ID0gY2FsbGJhY2tOb2RlLnByZXZpb3VzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfc2hvdWxkWWllbGQoKSB7XG4gIHJldHVybiAhY3VycmVudERpZFRpbWVvdXQgJiYgKGZpcnN0Q2FsbGJhY2tOb2RlICE9PSBudWxsICYmIGZpcnN0Q2FsbGJhY2tOb2RlLmV4cGlyYXRpb25UaW1lIDwgY3VycmVudEV4cGlyYXRpb25UaW1lIHx8IHNob3VsZFlpZWxkVG9Ib3N0KCkpO1xufVxuXG4vLyBUaGUgcmVtYWluaW5nIGNvZGUgaXMgZXNzZW50aWFsbHkgYSBwb2x5ZmlsbCBmb3IgcmVxdWVzdElkbGVDYWxsYmFjay4gSXRcbi8vIHdvcmtzIGJ5IHNjaGVkdWxpbmcgYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIHN0b3JpbmcgdGhlIHRpbWUgZm9yIHRoZSBzdGFydFxuLy8gb2YgdGhlIGZyYW1lLCB0aGVuIHNjaGVkdWxpbmcgYSBwb3N0TWVzc2FnZSB3aGljaCBnZXRzIHNjaGVkdWxlZCBhZnRlciBwYWludC5cbi8vIFdpdGhpbiB0aGUgcG9zdE1lc3NhZ2UgaGFuZGxlciBkbyBhcyBtdWNoIHdvcmsgYXMgcG9zc2libGUgdW50aWwgdGltZSArIGZyYW1lXG4vLyByYXRlLiBCeSBzZXBhcmF0aW5nIHRoZSBpZGxlIGNhbGwgaW50byBhIHNlcGFyYXRlIGV2ZW50IHRpY2sgd2UgZW5zdXJlIHRoYXRcbi8vIGxheW91dCwgcGFpbnQgYW5kIG90aGVyIGJyb3dzZXIgd29yayBpcyBjb3VudGVkIGFnYWluc3QgdGhlIGF2YWlsYWJsZSB0aW1lLlxuLy8gVGhlIGZyYW1lIHJhdGUgaXMgZHluYW1pY2FsbHkgYWRqdXN0ZWQuXG5cbi8vIFdlIGNhcHR1cmUgYSBsb2NhbCByZWZlcmVuY2UgdG8gYW55IGdsb2JhbCwgaW4gY2FzZSBpdCBnZXRzIHBvbHlmaWxsZWQgYWZ0ZXJcbi8vIHRoaXMgbW9kdWxlIGlzIGluaXRpYWxseSBldmFsdWF0ZWQuIFdlIHdhbnQgdG8gYmUgdXNpbmcgYVxuLy8gY29uc2lzdGVudCBpbXBsZW1lbnRhdGlvbi5cbnZhciBsb2NhbERhdGUgPSBEYXRlO1xuXG4vLyBUaGlzIGluaXRpYWxpemF0aW9uIGNvZGUgbWF5IHJ1biBldmVuIG9uIHNlcnZlciBlbnZpcm9ubWVudHMgaWYgYSBjb21wb25lbnRcbi8vIGp1c3QgaW1wb3J0cyBSZWFjdERPTSAoZS5nLiBmb3IgZmluZERPTU5vZGUpLiBTb21lIGVudmlyb25tZW50cyBtaWdodCBub3Rcbi8vIGhhdmUgc2V0VGltZW91dCBvciBjbGVhclRpbWVvdXQuIEhvd2V2ZXIsIHdlIGFsd2F5cyBleHBlY3QgdGhlbSB0byBiZSBkZWZpbmVkXG4vLyBvbiB0aGUgY2xpZW50LiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMzA4OFxudmFyIGxvY2FsU2V0VGltZW91dCA9IHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nID8gc2V0VGltZW91dCA6IHVuZGVmaW5lZDtcbnZhciBsb2NhbENsZWFyVGltZW91dCA9IHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBjbGVhclRpbWVvdXQgOiB1bmRlZmluZWQ7XG5cbi8vIFdlIGRvbid0IGV4cGVjdCBlaXRoZXIgb2YgdGhlc2UgdG8gbmVjZXNzYXJpbHkgYmUgZGVmaW5lZCwgYnV0IHdlIHdpbGwgZXJyb3Jcbi8vIGxhdGVyIGlmIHRoZXkgYXJlIG1pc3Npbmcgb24gdGhlIGNsaWVudC5cbnZhciBsb2NhbFJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiB1bmRlZmluZWQ7XG52YXIgbG9jYWxDYW5jZWxBbmltYXRpb25GcmFtZSA9IHR5cGVvZiBjYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJyA/IGNhbmNlbEFuaW1hdGlvbkZyYW1lIDogdW5kZWZpbmVkO1xuXG4vLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZG9lcyBub3QgcnVuIHdoZW4gdGhlIHRhYiBpcyBpbiB0aGUgYmFja2dyb3VuZC4gSWZcbi8vIHdlJ3JlIGJhY2tncm91bmRlZCB3ZSBwcmVmZXIgZm9yIHRoYXQgd29yayB0byBoYXBwZW4gc28gdGhhdCB0aGUgcGFnZVxuLy8gY29udGludWVzIHRvIGxvYWQgaW4gdGhlIGJhY2tncm91bmQuIFNvIHdlIGFsc28gc2NoZWR1bGUgYSAnc2V0VGltZW91dCcgYXNcbi8vIGEgZmFsbGJhY2suXG4vLyBUT0RPOiBOZWVkIGEgYmV0dGVyIGhldXJpc3RpYyBmb3IgYmFja2dyb3VuZGVkIHdvcmsuXG52YXIgQU5JTUFUSU9OX0ZSQU1FX1RJTUVPVVQgPSAxMDA7XG52YXIgckFGSUQ7XG52YXIgckFGVGltZW91dElEO1xudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZVdpdGhUaW1lb3V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIC8vIHNjaGVkdWxlIHJBRiBhbmQgYWxzbyBhIHNldFRpbWVvdXRcbiAgckFGSUQgPSBsb2NhbFJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgLy8gY2FuY2VsIHRoZSBzZXRUaW1lb3V0XG4gICAgbG9jYWxDbGVhclRpbWVvdXQockFGVGltZW91dElEKTtcbiAgICBjYWxsYmFjayh0aW1lc3RhbXApO1xuICB9KTtcbiAgckFGVGltZW91dElEID0gbG9jYWxTZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjYW5jZWwgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgIGxvY2FsQ2FuY2VsQW5pbWF0aW9uRnJhbWUockFGSUQpO1xuICAgIGNhbGxiYWNrKGV4cG9ydHMudW5zdGFibGVfbm93KCkpO1xuICB9LCBBTklNQVRJT05fRlJBTUVfVElNRU9VVCk7XG59O1xuXG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgdmFyIFBlcmZvcm1hbmNlID0gcGVyZm9ybWFuY2U7XG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbERhdGUubm93KCk7XG4gIH07XG59XG5cbnZhciByZXF1ZXN0SG9zdENhbGxiYWNrO1xudmFyIGNhbmNlbEhvc3RDYWxsYmFjaztcbnZhciBzaG91bGRZaWVsZFRvSG9zdDtcblxudmFyIGdsb2JhbFZhbHVlID0gbnVsbDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBnbG9iYWxWYWx1ZSA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgZ2xvYmFsVmFsdWUgPSBnbG9iYWw7XG59XG5cbmlmIChnbG9iYWxWYWx1ZSAmJiBnbG9iYWxWYWx1ZS5fc2NoZWRNb2NrKSB7XG4gIC8vIER5bmFtaWMgaW5qZWN0aW9uLCBvbmx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICB2YXIgZ2xvYmFsSW1wbCA9IGdsb2JhbFZhbHVlLl9zY2hlZE1vY2s7XG4gIHJlcXVlc3RIb3N0Q2FsbGJhY2sgPSBnbG9iYWxJbXBsWzBdO1xuICBjYW5jZWxIb3N0Q2FsbGJhY2sgPSBnbG9iYWxJbXBsWzFdO1xuICBzaG91bGRZaWVsZFRvSG9zdCA9IGdsb2JhbEltcGxbMl07XG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZ2xvYmFsSW1wbFszXTtcbn0gZWxzZSBpZiAoXG4vLyBJZiBTY2hlZHVsZXIgcnVucyBpbiBhIG5vbi1ET00gZW52aXJvbm1lbnQsIGl0IGZhbGxzIGJhY2sgdG8gYSBuYWl2ZVxuLy8gaW1wbGVtZW50YXRpb24gdXNpbmcgc2V0VGltZW91dC5cbnR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8XG4vLyBDaGVjayBpZiBNZXNzYWdlQ2hhbm5lbCBpcyBzdXBwb3J0ZWQsIHRvby5cbnR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAvLyBJZiB0aGlzIGFjY2lkZW50YWxseSBnZXRzIGltcG9ydGVkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQsIGUuZy4gSmF2YVNjcmlwdENvcmUsXG4gIC8vIGZhbGxiYWNrIHRvIGEgbmFpdmUgaW1wbGVtZW50YXRpb24uXG4gIHZhciBfY2FsbGJhY2sgPSBudWxsO1xuICB2YXIgX2ZsdXNoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZGlkVGltZW91dCkge1xuICAgIGlmIChfY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIF9jYWxsYmFjayhkaWRUaW1lb3V0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9jYWxsYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXF1ZXN0SG9zdENhbGxiYWNrID0gZnVuY3Rpb24gKGNiLCBtcykge1xuICAgIGlmIChfY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIC8vIFByb3RlY3QgYWdhaW5zdCByZS1lbnRyYW5jeS5cbiAgICAgIHNldFRpbWVvdXQocmVxdWVzdEhvc3RDYWxsYmFjaywgMCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfY2FsbGJhY2sgPSBjYjtcbiAgICAgIHNldFRpbWVvdXQoX2ZsdXNoQ2FsbGJhY2ssIDAsIGZhbHNlKTtcbiAgICB9XG4gIH07XG4gIGNhbmNlbEhvc3RDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICBfY2FsbGJhY2sgPSBudWxsO1xuICB9O1xuICBzaG91bGRZaWVsZFRvSG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59IGVsc2Uge1xuICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gVE9ETzogUmVtb3ZlIGZiLm1lIGxpbmtcbiAgICBpZiAodHlwZW9mIGxvY2FsUmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuIFwiICsgJ01ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cHM6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsb2NhbENhbmNlbEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiVGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBjYW5jZWxBbmltYXRpb25GcmFtZS4gXCIgKyAnTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwczovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBudWxsO1xuICB2YXIgaXNNZXNzYWdlRXZlbnRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIHRpbWVvdXRUaW1lID0gLTE7XG5cbiAgdmFyIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICB2YXIgaXNGbHVzaGluZ0hvc3RDYWxsYmFjayA9IGZhbHNlO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lID0gMDtcbiAgLy8gV2Ugc3RhcnQgb3V0IGFzc3VtaW5nIHRoYXQgd2UgcnVuIGF0IDMwZnBzIGJ1dCB0aGVuIHRoZSBoZXVyaXN0aWMgdHJhY2tpbmdcbiAgLy8gd2lsbCBhZGp1c3QgdGhpcyB2YWx1ZSB0byBhIGZhc3RlciBmcHMgaWYgd2UgZ2V0IG1vcmUgZnJlcXVlbnQgYW5pbWF0aW9uXG4gIC8vIGZyYW1lcy5cbiAgdmFyIHByZXZpb3VzRnJhbWVUaW1lID0gMzM7XG4gIHZhciBhY3RpdmVGcmFtZVRpbWUgPSAzMztcblxuICBzaG91bGRZaWVsZFRvSG9zdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnJhbWVEZWFkbGluZSA8PSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuICB9O1xuXG4gIC8vIFdlIHVzZSB0aGUgcG9zdE1lc3NhZ2UgdHJpY2sgdG8gZGVmZXIgaWRsZSB3b3JrIHVudGlsIGFmdGVyIHRoZSByZXBhaW50LlxuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaXNNZXNzYWdlRXZlbnRTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIHZhciBwcmV2U2NoZWR1bGVkQ2FsbGJhY2sgPSBzY2hlZHVsZWRIb3N0Q2FsbGJhY2s7XG4gICAgdmFyIHByZXZUaW1lb3V0VGltZSA9IHRpbWVvdXRUaW1lO1xuICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gICAgdGltZW91dFRpbWUgPSAtMTtcblxuICAgIHZhciBjdXJyZW50VGltZSA9IGV4cG9ydHMudW5zdGFibGVfbm93KCk7XG5cbiAgICB2YXIgZGlkVGltZW91dCA9IGZhbHNlO1xuICAgIGlmIChmcmFtZURlYWRsaW5lIC0gY3VycmVudFRpbWUgPD0gMCkge1xuICAgICAgLy8gVGhlcmUncyBubyB0aW1lIGxlZnQgaW4gdGhpcyBpZGxlIHBlcmlvZC4gQ2hlY2sgaWYgdGhlIGNhbGxiYWNrIGhhc1xuICAgICAgLy8gYSB0aW1lb3V0IGFuZCB3aGV0aGVyIGl0J3MgYmVlbiBleGNlZWRlZC5cbiAgICAgIGlmIChwcmV2VGltZW91dFRpbWUgIT09IC0xICYmIHByZXZUaW1lb3V0VGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgICAvLyBFeGNlZWRlZCB0aGUgdGltZW91dC4gSW52b2tlIHRoZSBjYWxsYmFjayBldmVuIHRob3VnaCB0aGVyZSdzIG5vXG4gICAgICAgIC8vIHRpbWUgbGVmdC5cbiAgICAgICAgZGlkVGltZW91dCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyB0aW1lb3V0LlxuICAgICAgICBpZiAoIWlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbm90aGVyIGFuaW1hdGlvbiBjYWxsYmFjayBzbyB3ZSByZXRyeSBsYXRlci5cbiAgICAgICAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWVXaXRoVGltZW91dChhbmltYXRpb25UaWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeGl0IHdpdGhvdXQgaW52b2tpbmcgdGhlIGNhbGxiYWNrLlxuICAgICAgICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBwcmV2U2NoZWR1bGVkQ2FsbGJhY2s7XG4gICAgICAgIHRpbWVvdXRUaW1lID0gcHJldlRpbWVvdXRUaW1lO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZTY2hlZHVsZWRDYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgaXNGbHVzaGluZ0hvc3RDYWxsYmFjayA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBwcmV2U2NoZWR1bGVkQ2FsbGJhY2soZGlkVGltZW91dCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpc0ZsdXNoaW5nSG9zdENhbGxiYWNrID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBhbmltYXRpb25UaWNrID0gZnVuY3Rpb24gKHJhZlRpbWUpIHtcbiAgICBpZiAoc2NoZWR1bGVkSG9zdENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAvLyBFYWdlcmx5IHNjaGVkdWxlIHRoZSBuZXh0IGFuaW1hdGlvbiBjYWxsYmFjayBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICAgICAgLy8gZnJhbWUuIElmIHRoZSBzY2hlZHVsZXIgcXVldWUgaXMgbm90IGVtcHR5IGF0IHRoZSBlbmQgb2YgdGhlIGZyYW1lLCBpdFxuICAgICAgLy8gd2lsbCBjb250aW51ZSBmbHVzaGluZyBpbnNpZGUgdGhhdCBjYWxsYmFjay4gSWYgdGhlIHF1ZXVlICppcyogZW1wdHksXG4gICAgICAvLyB0aGVuIGl0IHdpbGwgZXhpdCBpbW1lZGlhdGVseS4gUG9zdGluZyB0aGUgY2FsbGJhY2sgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAgLy8gZnJhbWUgZW5zdXJlcyBpdCdzIGZpcmVkIHdpdGhpbiB0aGUgZWFybGllc3QgcG9zc2libGUgZnJhbWUuIElmIHdlXG4gICAgICAvLyB3YWl0ZWQgdW50aWwgdGhlIGVuZCBvZiB0aGUgZnJhbWUgdG8gcG9zdCB0aGUgY2FsbGJhY2ssIHdlIHJpc2sgdGhlXG4gICAgICAvLyBicm93c2VyIHNraXBwaW5nIGEgZnJhbWUgYW5kIG5vdCBmaXJpbmcgdGhlIGNhbGxiYWNrIHVudGlsIHRoZSBmcmFtZVxuICAgICAgLy8gYWZ0ZXIgdGhhdC5cbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZVdpdGhUaW1lb3V0KGFuaW1hdGlvblRpY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBwZW5kaW5nIHdvcmsuIEV4aXQuXG4gICAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRGcmFtZVRpbWUgPSByYWZUaW1lIC0gZnJhbWVEZWFkbGluZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAobmV4dEZyYW1lVGltZSA8IGFjdGl2ZUZyYW1lVGltZSAmJiBwcmV2aW91c0ZyYW1lVGltZSA8IGFjdGl2ZUZyYW1lVGltZSkge1xuICAgICAgaWYgKG5leHRGcmFtZVRpbWUgPCA4KSB7XG4gICAgICAgIC8vIERlZmVuc2l2ZSBjb2RpbmcuIFdlIGRvbid0IHN1cHBvcnQgaGlnaGVyIGZyYW1lIHJhdGVzIHRoYW4gMTIwaHouXG4gICAgICAgIC8vIElmIHRoZSBjYWxjdWxhdGVkIGZyYW1lIHRpbWUgZ2V0cyBsb3dlciB0aGFuIDgsIGl0IGlzIHByb2JhYmx5IGEgYnVnLlxuICAgICAgICBuZXh0RnJhbWVUaW1lID0gODtcbiAgICAgIH1cbiAgICAgIC8vIElmIG9uZSBmcmFtZSBnb2VzIGxvbmcsIHRoZW4gdGhlIG5leHQgb25lIGNhbiBiZSBzaG9ydCB0byBjYXRjaCB1cC5cbiAgICAgIC8vIElmIHR3byBmcmFtZXMgYXJlIHNob3J0IGluIGEgcm93LCB0aGVuIHRoYXQncyBhbiBpbmRpY2F0aW9uIHRoYXQgd2VcbiAgICAgIC8vIGFjdHVhbGx5IGhhdmUgYSBoaWdoZXIgZnJhbWUgcmF0ZSB0aGFuIHdoYXQgd2UncmUgY3VycmVudGx5IG9wdGltaXppbmcuXG4gICAgICAvLyBXZSBhZGp1c3Qgb3VyIGhldXJpc3RpYyBkeW5hbWljYWxseSBhY2NvcmRpbmdseS4gRm9yIGV4YW1wbGUsIGlmIHdlJ3JlXG4gICAgICAvLyBydW5uaW5nIG9uIDEyMGh6IGRpc3BsYXkgb3IgOTBoeiBWUiBkaXNwbGF5LlxuICAgICAgLy8gVGFrZSB0aGUgbWF4IG9mIHRoZSB0d28gaW4gY2FzZSBvbmUgb2YgdGhlbSB3YXMgYW4gYW5vbWFseSBkdWUgdG9cbiAgICAgIC8vIG1pc3NlZCBmcmFtZSBkZWFkbGluZXMuXG4gICAgICBhY3RpdmVGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lIDwgcHJldmlvdXNGcmFtZVRpbWUgPyBwcmV2aW91c0ZyYW1lVGltZSA6IG5leHRGcmFtZVRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZpb3VzRnJhbWVUaW1lID0gbmV4dEZyYW1lVGltZTtcbiAgICB9XG4gICAgZnJhbWVEZWFkbGluZSA9IHJhZlRpbWUgKyBhY3RpdmVGcmFtZVRpbWU7XG4gICAgaWYgKCFpc01lc3NhZ2VFdmVudFNjaGVkdWxlZCkge1xuICAgICAgaXNNZXNzYWdlRXZlbnRTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcG9ydC5wb3N0TWVzc2FnZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgfTtcblxuICByZXF1ZXN0SG9zdENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBhYnNvbHV0ZVRpbWVvdXQpIHtcbiAgICBzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aW1lb3V0VGltZSA9IGFic29sdXRlVGltZW91dDtcbiAgICBpZiAoaXNGbHVzaGluZ0hvc3RDYWxsYmFjayB8fCBhYnNvbHV0ZVRpbWVvdXQgPCAwKSB7XG4gICAgICAvLyBEb24ndCB3YWl0IGZvciB0aGUgbmV4dCBmcmFtZS4gQ29udGludWUgd29ya2luZyBBU0FQLCBpbiBhIG5ldyBldmVudC5cbiAgICAgIHBvcnQucG9zdE1lc3NhZ2UodW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKCFpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkKSB7XG4gICAgICAvLyBJZiByQUYgZGlkbid0IGFscmVhZHkgc2NoZWR1bGUgb25lLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgZnJhbWUuXG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIHJBRiBkb2Vzbid0IG1hdGVyaWFsaXplIGJlY2F1c2UgdGhlIGJyb3dzZXIgdGhyb3R0bGVzLCB3ZVxuICAgICAgLy8gbWlnaHQgd2FudCB0byBzdGlsbCBoYXZlIHNldFRpbWVvdXQgdHJpZ2dlciBySUMgYXMgYSBiYWNrdXAgdG8gZW5zdXJlXG4gICAgICAvLyB0aGF0IHdlIGtlZXAgcGVyZm9ybWluZyB3b3JrLlxuICAgICAgaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWVXaXRoVGltZW91dChhbmltYXRpb25UaWNrKTtcbiAgICB9XG4gIH07XG5cbiAgY2FuY2VsSG9zdENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIHNjaGVkdWxlZEhvc3RDYWxsYmFjayA9IG51bGw7XG4gICAgaXNNZXNzYWdlRXZlbnRTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB0aW1lb3V0VGltZSA9IC0xO1xuICB9O1xufVxuXG5leHBvcnRzLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX05vcm1hbFByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX0lkbGVQcmlvcml0eSA9IElkbGVQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfTG93UHJpb3JpdHkgPSBMb3dQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfcnVuV2l0aFByaW9yaXR5ID0gdW5zdGFibGVfcnVuV2l0aFByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9uZXh0ID0gdW5zdGFibGVfbmV4dDtcbmV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IHVuc3RhYmxlX3dyYXBDYWxsYmFjaztcbmV4cG9ydHMudW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwgPSB1bnN0YWJsZV9nZXRDdXJyZW50UHJpb3JpdHlMZXZlbDtcbmV4cG9ydHMudW5zdGFibGVfc2hvdWxkWWllbGQgPSB1bnN0YWJsZV9zaG91bGRZaWVsZDtcbmV4cG9ydHMudW5zdGFibGVfY29udGludWVFeGVjdXRpb24gPSB1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbjtcbmV4cG9ydHMudW5zdGFibGVfcGF1c2VFeGVjdXRpb24gPSB1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbjtcbmV4cG9ydHMudW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUgPSB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZTtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLXRyYWNpbmcucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLXRyYWNpbmcuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRUYXJnZXQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCl7XG4gICAgcmV0dXJuIHBhcmVudC5xdWVyeVNlbGVjdG9yKHRhcmdldCk7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbn07XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbih0YXJnZXQsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHBhc3NpbmcgZnVuY3Rpb24gaW4gb3B0aW9ucywgdGhlbiB1c2UgaXQgZm9yIHJlc29sdmUgXCJoZWFkXCIgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgZm9yIFNoYWRvdyBSb290IHN0eWxlIGkuZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGluc2VydEludG86IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9vXCIpLnNoYWRvd1Jvb3QgfVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZ2V0VGFyZ2V0LmNhbGwodGhpcywgdGFyZ2V0LCBwYXJlbnQpO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblx0XHRcdGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHQvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuXHRcdFx0XHRcdC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0c3R5bGVUYXJnZXQgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bdGFyZ2V0XVxuXHR9O1xufSkoKTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24gJiYgdHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uICE9PSBcImJvb2xlYW5cIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcbiAgICAgICAgaWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcIm9iamVjdFwiICYmIG9wdGlvbnMuaW5zZXJ0QXQuYmVmb3JlKSB7XG5cdFx0dmFyIG5leHRTaWJsaW5nID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEF0LmJlZm9yZSwgdGFyZ2V0KTtcblx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBuZXh0U2libGluZyk7XG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiW1N0eWxlIExvYWRlcl1cXG5cXG4gSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcgKCdvcHRpb25zLmluc2VydEF0JykgZm91bmQuXFxuIE11c3QgYmUgJ3RvcCcsICdib3R0b20nLCBvciBPYmplY3QuXFxuIChodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlciNpbnNlcnRhdClcXG5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblxuXHRpZihvcHRpb25zLmF0dHJzLm5vbmNlID09PSB1bmRlZmluZWQpIHtcblx0XHR2YXIgbm9uY2UgPSBnZXROb25jZSgpO1xuXHRcdGlmIChub25jZSkge1xuXHRcdFx0b3B0aW9ucy5hdHRycy5ub25jZSA9IG5vbmNlO1xuXHRcdH1cblx0fVxuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGdldE5vbmNlKCkge1xuXHRpZiAodHlwZW9mIF9fd2VicGFja19ub25jZV9fID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0cmV0dXJuIF9fd2VicGFja19ub25jZV9fO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdCA/IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpIFxuXHRcdCA6IG9wdGlvbnMudHJhbnNmb3JtLmRlZmF1bHQob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG4iLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPS9bXFwwLVxceDFGXFx4N0YtXFx4OUZdLyIsIm1vZHVsZS5leHBvcnRzPS9bXFx4QURcXHUwNjAwLVxcdTA2MDVcXHUwNjFDXFx1MDZERFxcdTA3MEZcXHUwOEUyXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2NFxcdTIwNjYtXFx1MjA2RlxcdUZFRkZcXHVGRkY5LVxcdUZGRkJdfFxcdUQ4MDRbXFx1RENCRFxcdURDQ0RdfFxcdUQ4MkZbXFx1RENBMC1cXHVEQ0EzXXxcXHVEODM0W1xcdURENzMtXFx1REQ3QV18XFx1REI0MFtcXHVEQzAxXFx1REMyMC1cXHVEQzdGXS8iLCJtb2R1bGUuZXhwb3J0cz0vWyEtIyUtXFwqLC1cXC86O1xcP0BcXFstXFxdX1xce1xcfVxceEExXFx4QTdcXHhBQlxceEI2XFx4QjdcXHhCQlxceEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTA5RkRcXHUwQTc2XFx1MEFGMFxcdTBDODRcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNEVcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QThGQ1xcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XXxcXHVEODAwW1xcdUREMDAtXFx1REQwMlxcdURGOUZcXHVERkQwXXxcXHVEODAxXFx1REQ2RnxcXHVEODAyW1xcdURDNTdcXHVERDFGXFx1REQzRlxcdURFNTAtXFx1REU1OFxcdURFN0ZcXHVERUYwLVxcdURFRjZcXHVERjM5LVxcdURGM0ZcXHVERjk5LVxcdURGOUNdfFxcdUQ4MDNbXFx1REY1NS1cXHVERjU5XXxcXHVEODA0W1xcdURDNDctXFx1REM0RFxcdURDQkJcXHVEQ0JDXFx1RENCRS1cXHVEQ0MxXFx1REQ0MC1cXHVERDQzXFx1REQ3NFxcdURENzVcXHVEREM1LVxcdUREQzhcXHVERENEXFx1REREQlxcdUREREQtXFx1RERERlxcdURFMzgtXFx1REUzRFxcdURFQTldfFxcdUQ4MDVbXFx1REM0Qi1cXHVEQzRGXFx1REM1QlxcdURDNURcXHVEQ0M2XFx1RERDMS1cXHVEREQ3XFx1REU0MS1cXHVERTQzXFx1REU2MC1cXHVERTZDXFx1REYzQy1cXHVERjNFXXxcXHVEODA2W1xcdURDM0JcXHVERTNGLVxcdURFNDZcXHVERTlBLVxcdURFOUNcXHVERTlFLVxcdURFQTJdfFxcdUQ4MDdbXFx1REM0MS1cXHVEQzQ1XFx1REM3MFxcdURDNzFcXHVERUY3XFx1REVGOF18XFx1RDgwOVtcXHVEQzcwLVxcdURDNzRdfFxcdUQ4MUFbXFx1REU2RVxcdURFNkZcXHVERUY1XFx1REYzNy1cXHVERjNCXFx1REY0NF18XFx1RDgxQltcXHVERTk3LVxcdURFOUFdfFxcdUQ4MkZcXHVEQzlGfFxcdUQ4MzZbXFx1REU4Ny1cXHVERThCXXxcXHVEODNBW1xcdURENUVcXHVERDVGXS8iLCJtb2R1bGUuZXhwb3J0cz0vWyBcXHhBMFxcdTE2ODBcXHUyMDAwLVxcdTIwMEFcXHUyMDI4XFx1MjAyOVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLkFueSA9IHJlcXVpcmUoJy4vcHJvcGVydGllcy9BbnkvcmVnZXgnKTtcbmV4cG9ydHMuQ2MgID0gcmVxdWlyZSgnLi9jYXRlZ29yaWVzL0NjL3JlZ2V4Jyk7XG5leHBvcnRzLkNmICA9IHJlcXVpcmUoJy4vY2F0ZWdvcmllcy9DZi9yZWdleCcpO1xuZXhwb3J0cy5QICAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvUC9yZWdleCcpO1xuZXhwb3J0cy5aICAgPSByZXF1aXJlKCcuL2NhdGVnb3JpZXMvWi9yZWdleCcpO1xuIiwibW9kdWxlLmV4cG9ydHM9L1tcXDAtXFx1RDdGRlxcdUUwMDAtXFx1RkZGRl18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS8iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCIvLyBEcm9wTGlzdFxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0ICcuL2luZGV4Lmxlc3MnXG5cbmNsYXNzIERyb3BMaXN0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5oYW5kbGVDbG9zZSA9IHRoaXMuX2hhbmRsZUNsb3NlLmJpbmQodGhpcyk7XG4gIH1cbiAgX2hhbmRsZUNsb3NlKGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgY29uc3QgeyBvbkNsb3NlIH0gPSB0aGlzLnByb3BzXG4gICAgdHlwZW9mIG9uQ2xvc2UgPT09ICdmdW5jdGlvbicgJiYgb25DbG9zZSgpXG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YGRyb3Atd3JhcCAke3RoaXMucHJvcHMuc2hvdyA/ICdzaG93JyA6ICdoaWRkZW4nfWB9IG9uQ2xpY2s9e3RoaXMuaGFuZGxlQ2xvc2V9PlxuICAgICAgICB7dHlwZW9mIHRoaXMucHJvcHMucmVuZGVyID09PSAnZnVuY3Rpb24nICYmIHRoaXMucHJvcHMucmVuZGVyKCl9XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IERyb3BMaXN0IiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5sZXNzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLy8gSGVhZGVyTGlzdFxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0ICcuL2luZGV4Lmxlc3MnXG5cbmNsYXNzIEhlYWRlckxpc3QgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBoYW5kbGVIZWFkZXIoaGVhZGVyKSB7XG4gICAgY29uc3QgeyBvblNlbGVjdEhlYWRlciB9ID0gdGhpcy5wcm9wc1xuICAgIHR5cGVvZiBvblNlbGVjdEhlYWRlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvblNlbGVjdEhlYWRlcihoZWFkZXIpXG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8dWwgY2xhc3NOYW1lPVwiaGVhZGVyLWxpc3RcIj5cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cImxpc3QtaXRlbVwiPjxoMSBvbkNsaWNrPXt0aGlzLmhhbmRsZUhlYWRlci5iaW5kKHRoaXMsICdoMScpfT5IMTwvaDE+PC9saT5cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cImxpc3QtaXRlbVwiPjxoMiBvbkNsaWNrPXt0aGlzLmhhbmRsZUhlYWRlci5iaW5kKHRoaXMsICdoMicpfT5IMjwvaDI+PC9saT5cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cImxpc3QtaXRlbVwiPjxoMyBvbkNsaWNrPXt0aGlzLmhhbmRsZUhlYWRlci5iaW5kKHRoaXMsICdoMycpfT5IMzwvaDM+PC9saT5cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cImxpc3QtaXRlbVwiPjxoNCBvbkNsaWNrPXt0aGlzLmhhbmRsZUhlYWRlci5iaW5kKHRoaXMsICdoNCcpfT5INDwvaDQ+PC9saT5cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cImxpc3QtaXRlbVwiPjxoNSBvbkNsaWNrPXt0aGlzLmhhbmRsZUhlYWRlci5iaW5kKHRoaXMsICdoNScpfT5INTwvaDU+PC9saT5cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cImxpc3QtaXRlbVwiPjxoNiBvbkNsaWNrPXt0aGlzLmhhbmRsZUhlYWRlci5iaW5kKHRoaXMsICdoNicpfT5INjwvaDY+PC9saT5cbiAgICAgIDwvdWw+XG4gICAgKVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBIZWFkZXJMaXN0IiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5sZXNzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2ZvbnQubGVzc1wiKTtcblxuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5cbnZhciB0cmFuc2Zvcm07XG52YXIgaW5zZXJ0SW50bztcblxuXG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cblxub3B0aW9ucy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cbm9wdGlvbnMuaW5zZXJ0SW50byA9IHVuZGVmaW5lZDtcblxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscztcblxuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNi0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZm9udC5sZXNzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNi0xIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xlc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vZm9udC5sZXNzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiMTc5OWJmM2M1OTZkMWFjZjZhNjlmNmE1YjYzNjk3ZWMud29mZlwiOyIsIi8vIEljb25cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCAnLi9mb250Lmxlc3MnXG5cbmNsYXNzIEljb24gZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7ICAgXG4gICAgcmV0dXJuICggXG4gICAgICA8c3BhbiBjbGFzc05hbWU9e3RoaXMucHJvcHMudHlwZX0gPjwvc3Bhbj5cbiAgICApXG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEljb24iLCIvLyBUYWJsZUxpc3RcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCAnLi9pbmRleC5sZXNzJ1xuXG5jbGFzcyBJbnB1dEZpbGUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICB9XG5cbiAgY2xpY2soKSB7XG4gICAgaWYgKHRoaXMubG9ja2VkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5sb2NrZWQgPSB0cnVlXG4gICAgdGhpcy5pbnB1dC52YWx1ZSA9ICcnXG4gICAgdGhpcy5pbnB1dC5jbGljaygpXG4gICAgdGhpcy50aW1lcklkICYmIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpXG4gICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7IHRoaXMubG9ja2VkID0gZmFsc2UgfSwgMjAwKVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy50aW1lcklkICYmIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxpbnB1dCB0eXBlPVwiZmlsZVwiXG4gICAgICAgIHJlZj17KGVsKSA9PiB7IHRoaXMuaW5wdXQgPSBlbCB9fVxuICAgICAgICBzdHlsZT17e1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHpJbmRleDogLTEsXG4gICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgIH19XG4gICAgICAgIG9uQ2hhbmdlPXt0aGlzLnByb3BzLm9uQ2hhbmdlfSAvPlxuICAgIClcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgSW5wdXRGaWxlIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5sZXNzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLy8gbmF2aWdhdGlvbkJhclxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuY2xhc3MgTmF2aWdhdGlvbkJhciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpXG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17J3JjLW1kLW5hdmlnYXRpb24nfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuYXZpZ2F0aW9uLW5hdiBsZWZ0XCI+XG4gICAgICAgICAge3RoaXMucHJvcHMubGVmdH1cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibmF2aWdhdGlvbi1uYXYgbWlkZGxlXCI+XG4gICAgICAgICAge3RoaXMucHJvcHMubWlkZGxlfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJuYXZpZ2F0aW9uLW5hdiByaWdodFwiPlxuICAgICAgICAgIHt0aGlzLnByb3BzLnJpZ2h0fVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgTmF2aWdhdGlvbkJhciIsIi8vIFRhYmxlTGlzdFxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0ICcuL2luZGV4Lmxlc3MnXG5cbmNsYXNzIFRhYmxlTGlzdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbmZpZyA9IHtcbiAgICBwYWRkaW5nOiAzLFxuICAgIHdpZHRoOiAyMCxcbiAgICBoZWlnaHQ6IDIwXG4gIH1cblxuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIGNvbnN0IHsgbWF4Um93ID0gNSwgbWF4Q29sID0gNiB9ID0gcHJvcHNcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgbWF4Um93OiBtYXhSb3csXG4gICAgICBtYXhDb2w6IG1heENvbCxcbiAgICAgIGxpc3Q6IHRoaXMuZm9ybWF0VGFibGVNb2RlbChtYXhSb3csIG1heENvbClcbiAgICB9XG4gIH1cblxuICBmb3JtYXRUYWJsZU1vZGVsKG1heFJvdyA9IDAsIG1heENvbCA9IDApIHtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobWF4Um93KS5maWxsKClcbiAgICByZXR1cm4gcmVzdWx0Lm1hcCh2ID0+IHtcbiAgICAgIHJldHVybiBuZXcgQXJyYXkobWF4Q29sKS5maWxsKDApXG4gICAgfSlcbiAgfVxuXG4gIGNhbGNXcmFwU3R5bGUoKSB7XG4gICAgY29uc3QgeyBtYXhSb3csIG1heENvbCB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcgfSA9IHRoaXMuY29uZmlnXG4gICAgY29uc3Qgd3JhcFdpZHRoID0gKHdpZHRoICsgcGFkZGluZykgKiBtYXhDb2wgLSBwYWRkaW5nXG4gICAgY29uc3Qgd3JhcEhlaWdodCA9IChoZWlnaHQgKyBwYWRkaW5nKSAqIG1heFJvdyAtIHBhZGRpbmdcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IGAke3dyYXBXaWR0aH1weGAsXG4gICAgICBoZWlnaHQ6IGAke3dyYXBIZWlnaHR9cHhgLFxuICAgIH1cbiAgfVxuXG4gIGNhbGNJdGVtU3R5bGUocm93ID0gMCwgY29sID0gMCkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgcGFkZGluZyB9ID0gdGhpcy5jb25maWdcbiAgICBjb25zdCB0b3AgPSAoaGVpZ2h0ICsgcGFkZGluZykgKiByb3dcbiAgICBjb25zdCBsZWZ0ID0gKHdpZHRoICsgcGFkZGluZykgKiBjb2xcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBgJHt0b3B9cHhgLFxuICAgICAgbGVmdDogYCR7bGVmdH1weGAsXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlSG92ZXIoaSwgaikge1xuICAgIGNvbnN0IHsgbGlzdCB9ID0gdGhpcy5zdGF0ZVxuICAgIGNvbnN0IG5ld0xpc3QgPSBsaXN0Lm1hcCgodiwgcm93KSA9PiB7XG4gICAgICByZXR1cm4gdi5tYXAoKGl0ZW0sIGNvbCkgPT4ge1xuICAgICAgICBpZiAocm93IDw9IGkgJiYgY29sIDw9IGopIHtcbiAgICAgICAgICBpdGVtID0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW0gPSAwXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW1cbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGxpc3Q6IG5ld0xpc3RcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlU2V0VGFibGUoaSwgaikge1xuICAgIGNvbnN0IHsgb25TZXRUYWJsZSB9ID0gdGhpcy5wcm9wc1xuICAgIHR5cGVvZiBvblNldFRhYmxlID09PSAnZnVuY3Rpb24nICYmIG9uU2V0VGFibGUoeyByb3c6IGksIGNvbDogaiB9KVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgbGlzdCB9ID0gdGhpcy5zdGF0ZVxuICAgIHJldHVybiAoXG4gICAgICA8dWwgY2xhc3NOYW1lPVwidGFibGUtbGlzdCB3cmFwXCIgc3R5bGU9e3RoaXMuY2FsY1dyYXBTdHlsZSgpfT5cbiAgICAgICAge2xpc3QubWFwKChyb3csIGkpID0+IHtcbiAgICAgICAgICByZXR1cm4gcm93Lm1hcCgoY29sLCBqKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gPGxpXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17YGxpc3QtaXRlbSAke2NvbCA9PT0gMSA/ICdhY3RpdmUnIDogJyd9YH1cbiAgICAgICAgICAgICAga2V5PXtgJHtpfS0ke2p9YH1cbiAgICAgICAgICAgICAgc3R5bGU9e3RoaXMuY2FsY0l0ZW1TdHlsZShpLCBqKX1cbiAgICAgICAgICAgICAgb25Nb3VzZU92ZXI9e3RoaXMuaGFuZGxlSG92ZXIuYmluZCh0aGlzLCBpLCBqKX1cbiAgICAgICAgICAgICAgb25DbGljaz17dGhpcy5oYW5kbGVTZXRUYWJsZS5iaW5kKHRoaXMsIGksIGopfVxuICAgICAgICAgICAgPjwvbGk+XG4gICAgICAgICAgfSlcbiAgICAgICAgfSl9XG4gICAgICA8L3VsPlxuICAgIClcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgVGFibGVMaXN0IiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5sZXNzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0ICcuL2luZGV4Lmxlc3MnXG5cbmNsYXNzIFRvb2xCYXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidG9vbC1iYXJcIiBzdHlsZT17dGhpcy5wcm9wcy5zdHlsZX0+XG4gICAgICAgIHt0aGlzLnByb3BzLmNoaWxkcmVufVxuICAgICAgPC9kaXY+XG4gICAgKVxuICB9XG59XG5leHBvcnQgZGVmYXVsdCBUb29sQmFyIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LTEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5sZXNzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLyoqXG4gKiBjb25maWdcbiAqL1xuXG5jb25zdCBjb25maWcgPSB7XG4gIHRoZW1lIDogJ2RlZmF1bHQnLFxuICB2aWV3OiB7XG4gICAgbWVudTogdHJ1ZSxcbiAgICBtZDogdHJ1ZSxcbiAgICBodG1sOiB0cnVlXG4gIH0sXG4gIGxvZ2dlcjoge1xuICAgIGludGVydmFsOiAzMDAwXG4gIH0sXG4gIHN5bmNoU2Nyb2xsOiB0cnVlLFxuICBpbWFnZVVybDogJycsXG4gIGxpbmtVcmw6ICcnLFxuICB0YWJsZToge1xuICAgIG1heFJvdzogNCxcbiAgICBtYXhDb2w6IDZcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb25maWciLCIvLyBtYXJrZG93biBlZGl0b3IgXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJ1xuXG5pbXBvcnQgKiBhcyB0b29sIGZyb20gJy4uL3V0aWxzL3Rvb2wnXG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4uL3V0aWxzL2xvZ2dlcidcbmltcG9ydCBEZWNvcmF0ZSBmcm9tICcuLi91dGlscy9kZWNvcmF0ZSdcbmltcG9ydCBOYXZpZ2F0aW9uQmFyIGZyb20gJy4uL2NvbXBvbmVudHMvTmF2aWdhdGlvbkJhcidcbmltcG9ydCBEcm9wTGlzdCBmcm9tICcuLi9jb21wb25lbnRzL0Ryb3BMaXN0J1xuaW1wb3J0IEhlYWRlckxpc3QgZnJvbSAnLi4vY29tcG9uZW50cy9IZWFkZXJMaXN0J1xuaW1wb3J0IFRhYmxlTGlzdCBmcm9tICcuLi9jb21wb25lbnRzL1RhYmxlTGlzdCdcbmltcG9ydCBJbnB1dEZpbGUgZnJvbSAnLi4vY29tcG9uZW50cy9JbnB1dEZpbGUnXG5pbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24nXG5pbXBvcnQgVG9vbEJhciBmcm9tICcuLi9jb21wb25lbnRzL1Rvb2xCYXInXG5pbXBvcnQgX2NvbmZpZyBmcm9tICcuLi9jb25maWcuanMnXG5cbmltcG9ydCAnLi9pbmRleC5sZXNzJ1xuXG5leHBvcnQgY2xhc3MgSHRtbFJlbmRlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBkYW5nZXJvdXNseVNldElubmVySFRNTD17eyBfX2h0bWw6IHRoaXMucHJvcHMuaHRtbCB9fSBjbGFzc05hbWU9eydjdXN0b20taHRtbC1zdHlsZSd9IC8+XG4gICAgKVxuICB9XG59XG5cbmNsYXNzIEh0bWxDb2RlIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiAoXG4gICAgICA8dGV4dGFyZWEgY2xhc3NOYW1lPVwiaHRtbC1jb2RlXCIgdmFsdWU9e3RoaXMucHJvcHMuaHRtbH0gb25DaGFuZ2U9eygpID0+IHsgfX0+PC90ZXh0YXJlYT5cbiAgICApXG4gIH1cbn1cblxuY2xhc3MgTWRFZGl0b3IgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuXG4gIGNvbmZpZyA9IHt9XG5cbiAgbG9nZ2VyID0ge31cblxuICBsb2dnZXJUaW1lcklkID0gbnVsbFxuXG4gIG1kanMgPSBudWxsXG5cbiAgbm9kZU1kVGV4dCA9IG51bGxcblxuICBub2RlTWRQcmV2aWV3ID0gbnVsbFxuXG4gIG5vZGVNZFByZXZpZXdXcmFwZXIgPSBudWxsXG5cbiAgaW5wdXRGaWxlID0gbnVsbFxuXG4gIHNjYWxlID0gMFxuXG4gIHdpbGxTY3JvbGxFbGUgPSAnJyAvLyDljbPlsIbmu5rliqjnmoTlhYPntKAgbWQgaHRtbFxuXG4gIGhhc0NvbnRlbnRDaGFuZ2VkID0gdHJ1ZVxuXG4gIGluaXRpYWxTZWxlY3Rpb24gPSB7XG4gICAgaXNTZWxlY3RlZDogZmFsc2UsXG4gICAgc3RhcnQ6IDAsXG4gICAgZW5kOiAwLFxuICAgIHRleHQ6ICcnXG4gIH1cblxuICBzZWxlY3Rpb24gPSB7IC4uLnRoaXMuaW5pdGlhbFNlbGVjdGlvbiB9XG5cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMuaW5pdENvbmZpZygpXG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdGV4dDogKHRoaXMuZm9ybWF0U3RyaW5nKHRoaXMucHJvcHMudmFsdWUpIHx8ICcnKS5yZXBsYWNlKC/ihrUvZywgJ1xcbicpLFxuICAgICAgaHRtbDogJycsXG4gICAgICB2aWV3OiB0aGlzLmNvbmZpZy52aWV3LFxuICAgICAgaHRtbFR5cGU6ICdyZW5kZXInLCAvLyAncmVuZGVyJyAnc291cmNlJ1xuICAgICAgZHJvcEJ1dHRvbjoge1xuICAgICAgICBoZWFkZXI6IGZhbHNlLFxuICAgICAgICB0YWJsZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBmdWxsU2NyZWVuOiBmYWxzZSxcbiAgICAgIHRhYmxlOiB0aGlzLmNvbmZpZy50YWJsZVxuICAgIH1cbiAgICB0aGlzLmhhbmRsZUNoYW5nZSA9IHRoaXMuX2hhbmRsZUNoYW5nZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVJbnB1dFNlbGVjdCA9IHRoaXMuX2hhbmRsZUlucHV0U2VsZWN0LmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZUltYWdlVXBsb2FkID0gdGhpcy5faGFuZGxlSW1hZ2VVcGxvYWQuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlRW1wdHkgPSB0aGlzLl9oYW5kbGVFbXB0eS5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVVbmRvID0gdGhpcy5faGFuZGxlVW5kby5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVSZWRvID0gdGhpcy5faGFuZGxlUmVkby5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVUb2dnbGVGdWxsU2NyZWVuID0gdGhpcy5faGFuZGxlVG9nZ2xlRnVsbFNjcmVlbi5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVUb2dnbGVNZW51ID0gdGhpcy5faGFuZGxlVG9nZ2xlTWVudS5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVUb2dnbGVWaWV3ID0gdGhpcy5faGFuZGxlVG9nZ2xlVmlldy5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVNZFByZXZpZXcgPSB0aGlzLl9oYW5kbGVNZFByZXZpZXcuYmluZCh0aGlzKVxuICAgIHRoaXMuaGFuZGxlSHRtbFByZXZpZXcgPSB0aGlzLl9oYW5kbGVIdG1sUHJldmlldy5iaW5kKHRoaXMpXG4gICAgdGhpcy5oYW5kbGVUb2dnbGVIdG1sVHlwZSA9IHRoaXMuX2hhbmRsZVRvZ2dsZUh0bWxUeXBlLmJpbmQodGhpcylcbiAgICB0aGlzLmhhbmRsZW9uS2V5RG93biA9IHRoaXMuX2hhbmRsZW9uS2V5RG93bi5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLmhhbmRsZUlucHV0U2Nyb2xsID0gdG9vbC50aHJvdHRsZSgoZSkgPT4ge1xuICAgICAgY29uc3QgeyBzeW5jaFNjcm9sbCB9ID0gdGhpcy5jb25maWdcbiAgICAgIGlmICghc3luY2hTY3JvbGwpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBlLnBlcnNpc3QoKVxuICAgICAgaWYgKHRoaXMud2lsbFNjcm9sbEVsZSA9PT0gJ21kJykge1xuICAgICAgICB0aGlzLmhhc0NvbnRlbnRDaGFuZ2VkICYmIHRoaXMuX3NldFNjcm9sbFZhbHVlKClcbiAgICAgICAgdGhpcy5ub2RlTWRQcmV2aWV3V3JhcGVyLnNjcm9sbFRvcCA9IHRoaXMubm9kZU1kVGV4dC5zY3JvbGxUb3AgLyB0aGlzLnNjYWxlXG4gICAgICB9XG4gICAgfSwgMTAwMCAvIDYwKVxuICAgIHRoaXMuaGFuZGxlUHJldmlld1Njcm9sbCA9IHRvb2wudGhyb3R0bGUoKGUpID0+IHtcbiAgICAgIGNvbnN0IHsgc3luY2hTY3JvbGwgfSA9IHRoaXMuY29uZmlnXG4gICAgICBpZiAoIXN5bmNoU2Nyb2xsKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZS5wZXJzaXN0KClcbiAgICAgIGlmICh0aGlzLndpbGxTY3JvbGxFbGUgPT09ICdodG1sJykge1xuICAgICAgICB0aGlzLmhhc0NvbnRlbnRDaGFuZ2VkICYmIHRoaXMuX3NldFNjcm9sbFZhbHVlKClcbiAgICAgICAgdGhpcy5ub2RlTWRUZXh0LnNjcm9sbFRvcCA9IHRoaXMubm9kZU1kUHJldmlld1dyYXBlci5zY3JvbGxUb3AgKiB0aGlzLnNjYWxlXG4gICAgICB9XG4gICAgfSwgMTAwMCAvIDYwKVxuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5yZW5kZXJIVE1MKHRoaXMucHJvcHMudmFsdWUgfHwgXCJcIilcbiAgICAgIC50aGVuKGh0bWwgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBodG1sOiBodG1sXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIHRoaXMuaW5pdExvZ2dlcigpXG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgIGlmIChuZXh0UHJvcHMudmFsdWUgPT09IHRoaXMucHJvcHMudmFsdWUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCd2YWx1ZSBub3QgY2hhbmdlJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBsZXQgeyB2YWx1ZSB9ID0gbmV4dFByb3BzXG4gICAgdmFsdWUgPSB0aGlzLmZvcm1hdFN0cmluZyh2YWx1ZSlcbiAgICB2YWx1ZSA9IHZhbHVlICYmIHZhbHVlLnJlcGxhY2UoL+KGtS9nLCAnXFxuJylcbiAgICB0aGlzLnJlbmRlckhUTUwodmFsdWUpXG4gICAgICAudGhlbihodG1sID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgdGV4dDogdmFsdWUsXG4gICAgICAgICAgaHRtbDogaHRtbFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuZW5kTG9nZ2VyKClcbiAgfVxuXG4gIGZvcm1hdFN0cmluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5wcm9wcy52YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnNvbGUgJiYgY29uc29sZS5lcnJvciAmJiBjb25zb2xlLmVycm9yKCdUaGUgdHlwZSBvZiBcInZhbHVlXCIgbXVzdCBiZSBTdHJpbmchJylcbiAgICAgIHJldHVybiBuZXcgU3RyaW5nKHZhbHVlKS50b1N0cmluZygpXG4gICAgfVxuICAgIHJldHVybiB2YWx1ZVxuICB9XG5cbiAgaW5pdENvbmZpZygpIHtcbiAgICByZXR1cm4geyAuLi5fY29uZmlnLCAuLi50aGlzLnByb3BzLmNvbmZpZyB9XG4gIH1cblxuICBpbml0TG9nZ2VyKCkge1xuICAgIHRoaXMubG9nZ2VyID0gbmV3IExvZ2dlcigpXG4gICAgdGhpcy5zdGFydExvZ2dlcigpXG4gICAgdGhpcy5sb2dnZXIucHVzaFJlY29yZCh0aGlzLnN0YXRlLnRleHQpXG4gIH1cblxuICBzdGFydExvZ2dlcigpIHtcbiAgICBpZiAoIXRoaXMubG9nZ2VyVGltZXJJZCkge1xuICAgICAgdGhpcy5sb2dnZXJUaW1lcklkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHRleHQgfSA9IHRoaXMuc3RhdGVcbiAgICAgICAgaWYgKHRoaXMubG9nZ2VyLmdldExhc3RSZWNvcmQoKSAhPT0gdGV4dCkge1xuICAgICAgICAgIHRoaXMubG9nZ2VyLnB1c2hSZWNvcmQodGV4dClcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5jb25maWcubG9nZ2VyLmludGVydmFsKVxuICAgIH1cbiAgICAvLyDmuIXnqbpyZWRv5Y6G5Y+yXG4gICAgdGhpcy5sb2dnZXIuY2xlYW5SZWRvTGlzdCgpXG4gIH1cblxuICBlbmRMb2dnZXIoKSB7XG4gICAgaWYgKHRoaXMubG9nZ2VyVGltZXJJZCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmxvZ2dlclRpbWVySWQpXG4gICAgICB0aGlzLmxvZ2dlclRpbWVySWQgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgaGFuZGxlR2V0TG9nZ2VyKCkge1xuICAgIGNvbnNvbGUubG9nKCdoYW5kbGVHZXRMb2dnZXInLCB0aGlzLmxvZ2dlcilcbiAgfVxuXG4gIF9oYW5kbGVVbmRvKCkge1xuICAgIHRoaXMubG9nZ2VyLnVuZG8oKGxhc3QpID0+IHtcbiAgICAgIHRoaXMuZW5kTG9nZ2VyKClcbiAgICAgIHRoaXMuX3NldE1kVGV4dChsYXN0KVxuICAgIH0pXG4gIH1cblxuICBfaGFuZGxlUmVkbygpIHtcbiAgICB0aGlzLmxvZ2dlci5yZWRvKChsYXN0KSA9PiB7XG4gICAgICB0aGlzLl9zZXRNZFRleHQobGFzdClcbiAgICB9KVxuICB9XG5cbiAgaGFuZGxlRGVjb3JhdGUodHlwZSwgb3B0aW9uID0ge30pIHtcbiAgICBjb25zdCBjbGVhckxpc3QgPSBbXG4gICAgICAnaDEnLFxuICAgICAgJ2gyJyxcbiAgICAgICdoMycsXG4gICAgICAnaDQnLFxuICAgICAgJ2g1JyxcbiAgICAgICdoNicsXG4gICAgICAnYm9sZCcsXG4gICAgICAnaXRhbGljJyxcbiAgICAgICd1bmRlcmxpbmUnLFxuICAgICAgJ3N0cmlrZXRocm91Z2gnLFxuICAgICAgJ3Vub3JkZXInLFxuICAgICAgJ29yZGVyJyxcbiAgICAgICdxdW90ZScsXG4gICAgICAnaHInLFxuICAgICAgJ2lubGluZWNvZGUnLFxuICAgICAgJ2NvZGUnLFxuICAgICAgJ3RhYmxlJyxcbiAgICAgICdpbWFnZScsXG4gICAgICAnbGluaydcbiAgICBdXG4gICAgaWYgKGNsZWFyTGlzdC5pbmRleE9mKHR5cGUpID4gLTEpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb24uaXNTZWxlY3RlZCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLl9nZXREZWNvcmF0ZWRUZXh0KHR5cGUsIG9wdGlvbilcbiAgICAgIHRoaXMuX3NldE1kVGV4dChjb250ZW50KVxuICAgICAgdGhpcy5fY2xlYXJTZWxlY3Rpb24oKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fZ2V0RGVjb3JhdGVkVGV4dCh0eXBlLCBvcHRpb24pXG4gICAgICB0aGlzLl9zZXRNZFRleHQoY29udGVudClcbiAgICB9XG4gIH1cblxuICBfZ2V0RGVjb3JhdGVkVGV4dCh0eXBlLCBvcHRpb24pIHtcbiAgICBjb25zdCB7IHRleHQgPSAnJyB9ID0gdGhpcy5zdGF0ZVxuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0aGlzXG4gICAgY29uc3QgYmVmb3JlQ29udGVudCA9IHRleHQuc2xpY2UoMCwgc2VsZWN0aW9uLnN0YXJ0KVxuICAgIGNvbnN0IGFmdGVyQ29udGVudCA9IHRleHQuc2xpY2Uoc2VsZWN0aW9uLmVuZCwgdGV4dC5sZW5ndGgpXG4gICAgY29uc3QgZGVjb3JhdGUgPSBuZXcgRGVjb3JhdGUoc2VsZWN0aW9uLnRleHQpXG4gICAgbGV0IGRlY29yYXRlZFRleHQgPSAnJ1xuICAgIGlmICh0eXBlID09PSAnaW1hZ2UnKSB7XG4gICAgICBkZWNvcmF0ZWRUZXh0ID0gZGVjb3JhdGUuZ2V0RGVjb3JhdGVkVGV4dCh0eXBlLCB7XG4gICAgICAgIGltYWdlVXJsOiBvcHRpb24uaW1hZ2VVcmwgfHwgdGhpcy5jb25maWcuaW1hZ2VVcmxcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnbGluaycpIHtcbiAgICAgIGRlY29yYXRlZFRleHQgPSBkZWNvcmF0ZS5nZXREZWNvcmF0ZWRUZXh0KHR5cGUsIHtcbiAgICAgICAgbGlua1VybDogdGhpcy5jb25maWcubGlua1VybFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjb3JhdGVkVGV4dCA9IGRlY29yYXRlLmdldERlY29yYXRlZFRleHQodHlwZSwgb3B0aW9uKVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBiZWZvcmVDb250ZW50ICsgYCR7ZGVjb3JhdGVkVGV4dH1gICsgYWZ0ZXJDb250ZW50XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcmVuZGVySFRNTChtYXJrZG93blRleHQpIHtcbiAgICBjb25zdCByZXMgPSB0aGlzLnByb3BzLnJlbmRlckhUTUwobWFya2Rvd25UZXh0KVxuICAgIGlmICh0eXBlb2YgKHJlcykgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzXG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZVRvZ2dsZUZ1bGxTY3JlZW4oKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBmdWxsU2NyZWVuOiAhdGhpcy5zdGF0ZS5mdWxsU2NyZWVuXG4gICAgfSlcbiAgfVxuXG4gIGNoYW5nZVZpZXcodG8pIHtcbiAgICBjb25zdCB2aWV3ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS52aWV3LCB0bylcbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHZpZXc6IHZpZXdcbiAgICB9KVxuICB9XG5cbiAgX2hhbmRsZVRvZ2dsZU1lbnUoKSB7XG4gICAgdGhpcy5jaGFuZ2VWaWV3KHtcbiAgICAgICdtZW51JzogIXRoaXMuc3RhdGUudmlldy5tZW51XG4gICAgfSlcbiAgfVxuXG4gIF9oYW5kbGVUb2dnbGVWaWV3KHR5cGUpIHtcbiAgICBpZiAodHlwZSA9PT0gJ21kJykge1xuICAgICAgdGhpcy5jaGFuZ2VWaWV3KHtcbiAgICAgICAgJ21kJzogZmFsc2UsXG4gICAgICAgICdodG1sJzogdHJ1ZVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFuZ2VWaWV3KHtcbiAgICAgICAgJ21kJzogdHJ1ZSxcbiAgICAgICAgJ2h0bWwnOiBmYWxzZVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlTWRQcmV2aWV3KCkge1xuICAgIHRoaXMuY2hhbmdlVmlldyh7XG4gICAgICAnaHRtbCc6ICF0aGlzLnN0YXRlLnZpZXcuaHRtbFxuICAgIH0pXG4gIH1cblxuICBfaGFuZGxlSHRtbFByZXZpZXcoKSB7XG4gICAgdGhpcy5jaGFuZ2VWaWV3KHtcbiAgICAgICdtZCc6ICF0aGlzLnN0YXRlLnZpZXcubWRcbiAgICB9KVxuICB9XG5cbiAgX2hhbmRsZVRvZ2dsZUh0bWxUeXBlKCkge1xuICAgIGxldCB7IGh0bWxUeXBlIH0gPSB0aGlzLnN0YXRlXG4gICAgaWYgKGh0bWxUeXBlID09PSAncmVuZGVyJykge1xuICAgICAgaHRtbFR5cGUgPSAnc291cmNlJ1xuICAgIH0gZWxzZSBpZiAoaHRtbFR5cGUgPT09ICdzb3VyY2UnKSB7XG4gICAgICBodG1sVHlwZSA9ICdyZW5kZXInXG4gICAgfVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgaHRtbFR5cGU6IGh0bWxUeXBlXG4gICAgfSlcbiAgfVxuXG4gIF9oYW5kbGVFbXB0eSgpIHtcbiAgICBpZiAod2luZG93LmNvbmZpcm0pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHdpbmRvdy5jb25maXJtKCdBcmUgeW91IHN1cmUgdG8gZW1wdHkgbWFya2Rvd24gPycpXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgIGh0bWw6ICcnXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZUltYWdlVXBsb2FkKCkge1xuICAgIGNvbnN0IHsgb25JbWFnZVVwbG9hZCB9ID0gdGhpcy5wcm9wc1xuICAgIGlmICh0eXBlb2Ygb25JbWFnZVVwbG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5pbnB1dEZpbGUgJiYgdGhpcy5pbnB1dEZpbGUuY2xpY2soKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhhbmRsZURlY29yYXRlKCdpbWFnZScpXG4gICAgfVxuICB9XG5cbiAgb25JbWFnZUNoYW5nZWQoZmlsZSkge1xuICAgIGNvbnN0IHsgb25JbWFnZVVwbG9hZCB9ID0gdGhpcy5wcm9wc1xuICAgIG9uSW1hZ2VVcGxvYWQoZmlsZSwgKGltYWdlVXJsKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZURlY29yYXRlKCdpbWFnZScsIHsgaW1hZ2VVcmwgfSlcbiAgICB9KVxuICB9XG5cbiAgX2hhbmRsZUNoYW5nZShlKSB7XG4gICAgdGhpcy5zdGFydExvZ2dlcigpXG4gICAgY29uc3QgdmFsdWUgPSBlLnRhcmdldC52YWx1ZVxuICAgIGlmICghdGhpcy5oYXNDb250ZW50Q2hhbmdlZCkge1xuICAgICAgdGhpcy5oYXNDb250ZW50Q2hhbmdlZCA9IHRydWVcbiAgICB9XG4gICAgdGhpcy5fc2V0TWRUZXh0KHZhbHVlKVxuICB9XG5cbiAgX2hhbmRsZUlucHV0U2VsZWN0KGUpIHtcbiAgICBlLnBlcnNpc3QoKVxuICAgIHRoaXMuc2VsZWN0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zZWxlY3Rpb24sIHsgaXNTZWxlY3RlZDogdHJ1ZSB9LCB0aGlzLl9nZXRTZWxlY3Rpb25JbmZvKGUpKVxuICB9XG5cbiAgaGFuZGxlU2Nyb2xsRWxlKG5vZGUpIHtcbiAgICB0aGlzLndpbGxTY3JvbGxFbGUgPSBub2RlXG4gIH1cblxuICBfc2V0U2Nyb2xsVmFsdWUoKSB7XG4gICAgLy8g6K6+572u5YC877yM5pa55L6/IHNjcm9sbEJ5IOaTjeS9nFxuICAgIGNvbnN0IHsgbm9kZU1kVGV4dCwgbm9kZU1kUHJldmlldywgbm9kZU1kUHJldmlld1dyYXBlciB9ID0gdGhpc1xuICAgIHRoaXMuc2NhbGUgPSAobm9kZU1kVGV4dC5zY3JvbGxIZWlnaHQgLSBub2RlTWRUZXh0Lm9mZnNldEhlaWdodCkgLyAobm9kZU1kUHJldmlldy5vZmZzZXRIZWlnaHQgLSBub2RlTWRQcmV2aWV3V3JhcGVyLm9mZnNldEhlaWdodClcbiAgICB0aGlzLmhhc0NvbnRlbnRDaGFuZ2VkID0gZmFsc2VcbiAgfVxuXG4gIF9jbGVhclNlbGVjdGlvbigpIHtcbiAgICB0aGlzLnNlbGVjdGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaW5pdGlhbFNlbGVjdGlvbilcbiAgfVxuXG4gIF9nZXRTZWxlY3Rpb25JbmZvKGUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBlLnNyY0VsZW1lbnQgfHwgZS50YXJnZXRcbiAgICBjb25zdCBzdGFydCA9IHNvdXJjZS5zZWxlY3Rpb25TdGFydFxuICAgIGNvbnN0IGVuZCA9IHNvdXJjZS5zZWxlY3Rpb25FbmRcbiAgICBjb25zdCB0ZXh0ID0gKHNvdXJjZS52YWx1ZSB8fCAnJykuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB7IHN0YXJ0LCBlbmQsIHRleHQgfVxuICAgIHJldHVybiBzZWxlY3Rpb25cbiAgfVxuXG4gIF9zZXRNZFRleHQodmFsdWUgPSAnJykge1xuICAgIGNvbnN0IHRleHQgPSB2YWx1ZS5yZXBsYWNlKC/ihrUvZywgJ1xcbicpXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB0ZXh0OiB2YWx1ZVxuICAgIH0pXG4gICAgdGhpcy5yZW5kZXJIVE1MKHRleHQpXG4gICAgICAudGhlbihodG1sID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaHRtbFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLm9uRW1pdCh7XG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICBodG1sXG4gICAgICAgIH0pXG4gICAgICB9KVxuICB9XG5cbiAgX2lzS2V5TWF0Y2goZXZlbnQsIGtleSwga2V5Q29kZSwgd2l0aEN0cmwgPSBmYWxzZSkge1xuICAgIGlmIChldmVudC5jdHJsS2V5ICE9PSB3aXRoQ3RybCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmIChldmVudC5rZXkpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXkgPT09IGtleVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZSA9PT0ga2V5Q29kZVxuICAgIH1cbiAgfVxuXG4gIF9oYW5kbGVvbktleURvd24oZSkge1xuICAgIGlmICh0aGlzLl9pc0tleU1hdGNoKGUsICd6JywgOTAsIHRydWUpKSB7XG4gICAgICB0aGlzLl9oYW5kbGVVbmRvKClcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIH1cbiAgICBpZiAodGhpcy5faXNLZXlNYXRjaChlLCAneScsIDg5LCB0cnVlKSkge1xuICAgICAgdGhpcy5faGFuZGxlUmVkbygpXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICB9XG4gIH1cblxuICBvbkVtaXQob3V0cHV0KSB7XG4gICAgY29uc3QgeyBvbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICBvbkNoYW5nZSAmJiBvbkNoYW5nZShvdXRwdXQpXG4gIH1cblxuICBnZXRNZFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnRleHRcbiAgfVxuXG4gIGdldEh0bWxWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5odG1sXG4gIH1cblxuICBzaG93RHJvcExpc3QodHlwZSA9ICdoZWFkZXInLCBmbGFnKSB7XG4gICAgY29uc3QgeyBkcm9wQnV0dG9uIH0gPSB0aGlzLnN0YXRlXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBkcm9wQnV0dG9uOiB7IC4uLmRyb3BCdXR0b24sIFt0eXBlXTogZmxhZyB9XG4gICAgfSlcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IHZpZXcsIGRyb3BCdXR0b24sIGZ1bGxTY3JlZW4sIHRhYmxlIH0gPSB0aGlzLnN0YXRlXG4gICAgY29uc3QgcmVuZGVyTmF2aWdhdGlvbiA9ICgpID0+IHtcbiAgICAgIHJldHVybiB2aWV3Lm1lbnUgJiZcbiAgICAgICAgPE5hdmlnYXRpb25CYXJcbiAgICAgICAgICBsZWZ0PXtcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uLXdyYXBcIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYnV0dG9uXCIgdGl0bGU9XCJoZWFkZXJcIlxuICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17KCkgPT4gdGhpcy5zaG93RHJvcExpc3QoJ2hlYWRlcicsIHRydWUpfVxuICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZT17KCkgPT4gdGhpcy5zaG93RHJvcExpc3QoJ2hlYWRlcicsIGZhbHNlKX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxJY29uIHR5cGU9XCJpY29uLWhlYWRlclwiIC8+XG4gICAgICAgICAgICAgICAgPERyb3BMaXN0XG4gICAgICAgICAgICAgICAgICBzaG93PXtkcm9wQnV0dG9uLmhlYWRlcn1cbiAgICAgICAgICAgICAgICAgIG9uQ2xvc2U9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93RHJvcExpc3QoJ2hlYWRlcicsIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgIHJlbmRlcj17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgIDxIZWFkZXJMaXN0IG9uU2VsZWN0SGVhZGVyPXsoaGVhZGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURlY29yYXRlKGhlYWRlcilcbiAgICAgICAgICAgICAgICAgICAgICB9fSAvPlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYnV0dG9uXCIgdGl0bGU9XCJib2xkXCIgb25DbGljaz17KCkgPT4gdGhpcy5oYW5kbGVEZWNvcmF0ZSgnYm9sZCcpfT48SWNvbiB0eXBlPVwiaWNvbi1ib2xkXCIgLz48L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJ1dHRvblwiIHRpdGxlPVwiaXRhbGljXCIgb25DbGljaz17KCkgPT4gdGhpcy5oYW5kbGVEZWNvcmF0ZSgnaXRhbGljJyl9PjxJY29uIHR5cGU9XCJpY29uLWl0YWxpY1wiIC8+PC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJidXR0b25cIiB0aXRsZT1cIml0YWxpY1wiIG9uQ2xpY2s9eygpID0+IHRoaXMuaGFuZGxlRGVjb3JhdGUoJ3VuZGVybGluZScpfT48SWNvbiB0eXBlPVwiaWNvbi11bmRlcmxpbmVcIiAvPjwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYnV0dG9uXCIgdGl0bGU9XCJzdHJpa2V0aHJvdWdoXCIgb25DbGljaz17KCkgPT4gdGhpcy5oYW5kbGVEZWNvcmF0ZSgnc3RyaWtldGhyb3VnaCcpfT48SWNvbiB0eXBlPVwiaWNvbi1zdHJpa2V0aHJvdWdoXCIgLz48L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJ1dHRvblwiIHRpdGxlPVwidW5vcmRlclwiIG9uQ2xpY2s9eygpID0+IHRoaXMuaGFuZGxlRGVjb3JhdGUoJ3Vub3JkZXInKX0+PEljb24gdHlwZT1cImljb24tbGlzdC11bFwiIC8+PC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJidXR0b25cIiB0aXRsZT1cIm9yZGVyXCIgb25DbGljaz17KCkgPT4gdGhpcy5oYW5kbGVEZWNvcmF0ZSgnb3JkZXInKX0+PEljb24gdHlwZT1cImljb24tbGlzdC1vbFwiIC8+PC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJidXR0b25cIiB0aXRsZT1cInF1b3RlXCIgb25DbGljaz17KCkgPT4gdGhpcy5oYW5kbGVEZWNvcmF0ZSgncXVvdGUnKX0+PEljb24gdHlwZT1cImljb24tcXVvdGUtbGVmdFwiIC8+PC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJidXR0b25cIiB0aXRsZT1cImhyXCIgb25DbGljaz17KCkgPT4gdGhpcy5oYW5kbGVEZWNvcmF0ZSgnaHInKX0+PEljb24gdHlwZT1cImljb24td2luZG93LW1pbmltaXplXCIgLz48L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJ1dHRvblwiIHRpdGxlPVwiaW5saW5lIGNvZGVcIiBvbkNsaWNrPXsoKSA9PiB0aGlzLmhhbmRsZURlY29yYXRlKCdpbmxpbmVjb2RlJyl9PjxJY29uIHR5cGU9XCJpY29uLWVtYmVkXCIgLz48L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJ1dHRvblwiIHRpdGxlPVwiY29kZVwiIG9uQ2xpY2s9eygpID0+IHRoaXMuaGFuZGxlRGVjb3JhdGUoJ2NvZGUnKX0+PEljb24gdHlwZT1cImljb24tZW1iZWQyXCIgLz48L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJ1dHRvblwiIHRpdGxlPVwidGFibGVcIlxuICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcj17KCkgPT4gdGhpcy5zaG93RHJvcExpc3QoJ3RhYmxlJywgdHJ1ZSl9XG4gICAgICAgICAgICAgICAgb25Nb3VzZUxlYXZlPXsoKSA9PiB0aGlzLnNob3dEcm9wTGlzdCgndGFibGUnLCBmYWxzZSl9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwiaWNvbi10YWJsZVwiIC8+XG4gICAgICAgICAgICAgICAgPERyb3BMaXN0XG4gICAgICAgICAgICAgICAgICBzaG93PXtkcm9wQnV0dG9uLnRhYmxlfVxuICAgICAgICAgICAgICAgICAgb25DbG9zZT17KCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dEcm9wTGlzdCgndGFibGUnLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgICByZW5kZXI9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgICA8VGFibGVMaXN0IG1heFJvdz17dGFibGUubWF4Um93fSBtYXhDb2w9e3RhYmxlLm1heENvbH0gb25TZXRUYWJsZT17KG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEZWNvcmF0ZSgndGFibGUnLCBvcHRpb24pXG4gICAgICAgICAgICAgICAgICAgICAgfX0gLz5cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJ1dHRvblwiIHRpdGxlPVwiaW1hZ2VcIiBvbkNsaWNrPXt0aGlzLmhhbmRsZUltYWdlVXBsb2FkfSBzdHlsZT17eyBwb3NpdGlvbjogJ3JlbGF0aXZlJyB9fT5cbiAgICAgICAgICAgICAgICA8SWNvbiB0eXBlPVwiaWNvbi1waG90b1wiIC8+XG4gICAgICAgICAgICAgICAgPElucHV0RmlsZSByZWY9eyhpbnB1dCkgPT4geyB0aGlzLmlucHV0RmlsZSA9IGlucHV0IH19IG9uQ2hhbmdlPXsoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgZS5wZXJzaXN0KClcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBlLnRhcmdldC5maWxlc1swXVxuICAgICAgICAgICAgICAgICAgdGhpcy5vbkltYWdlQ2hhbmdlZChmaWxlKVxuICAgICAgICAgICAgICAgIH19IC8+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYnV0dG9uXCIgdGl0bGU9XCJsaW5rXCIgb25DbGljaz17KCkgPT4gdGhpcy5oYW5kbGVEZWNvcmF0ZSgnbGluaycpfT48SWNvbiB0eXBlPVwiaWNvbi1saW5rXCIgLz48L3NwYW4+XG5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYnV0dG9uXCIgdGl0bGU9XCJlbXB0eVwiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlRW1wdHl9PjxJY29uIHR5cGU9XCJpY29uLXRyYXNoXCIgLz48L3NwYW4+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJ1dHRvblwiIHRpdGxlPVwidW5kb1wiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlVW5kb30+PEljb24gdHlwZT1cImljb24tcmVwbHlcIiAvPjwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYnV0dG9uXCIgdGl0bGU9XCJyZWRvXCIgb25DbGljaz17dGhpcy5oYW5kbGVSZWRvfT48SWNvbiB0eXBlPVwiaWNvbi1zaGFyZVwiIC8+PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgfVxuICAgICAgICAgIHJpZ2h0PXtcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYnV0dG9uLXdyYXBcIj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYnV0dG9uXCIgdGl0bGU9XCJmdWxsIHNjcmVlblwiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlVG9nZ2xlRnVsbFNjcmVlbn0+XG4gICAgICAgICAgICAgICAge2Z1bGxTY3JlZW4gPyA8SWNvbiB0eXBlPVwiaWNvbi1zaHJpbmtcIiAvPiA6IDxJY29uIHR5cGU9XCJpY29uLWVubGFyZ2VcIiAvPn1cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgfVxuICAgICAgICAvPlxuICAgIH1cbiAgICBjb25zdCByZW5kZXJDb250ZW50ID0gKCkgPT4ge1xuICAgICAgY29uc3QgeyBodG1sLCB0ZXh0LCB2aWV3LCBodG1sVHlwZSB9ID0gdGhpcy5zdGF0ZVxuICAgICAgY29uc3QgcmVzID0gW11cbiAgICAgIGlmICh2aWV3Lm1kKSB7XG4gICAgICAgIHJlcy5wdXNoKFxuICAgICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT17J3NlYy1tZCd9IGtleT1cIm1kXCI+XG4gICAgICAgICAgICA8VG9vbEJhcj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYnV0dG9uXCIgdGl0bGU9e3ZpZXcubWVudSA/ICdoaWRkZW4gbWVudScgOiAnc2hvdyBtZW51J30gb25DbGljaz17dGhpcy5oYW5kbGVUb2dnbGVNZW51fT5cbiAgICAgICAgICAgICAgICB7dmlldy5tZW51ID8gPEljb24gdHlwZT1cImljb24tY2hldnJvbi11cFwiIC8+IDogPEljb24gdHlwZT1cImljb24tY2hldnJvbi1kb3duXCIgLz59XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYnV0dG9uXCIgdGl0bGU9e3ZpZXcuaHRtbCA/ICdwcmV2aWV3JyA6ICdjb2x1bW4nfSBvbkNsaWNrPXt0aGlzLmhhbmRsZU1kUHJldmlld30+XG4gICAgICAgICAgICAgICAge3ZpZXcuaHRtbCA/IDxJY29uIHR5cGU9XCJpY29uLWRlc2t0b3BcIiAvPiA6IDxJY29uIHR5cGU9XCJpY29uLWNvbHVtbnNcIiAvPn1cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJidXR0b25cIiB0aXRsZT17J3RvZ2dsZSd9IG9uQ2xpY2s9eygpID0+IHRoaXMuaGFuZGxlVG9nZ2xlVmlldygnbWQnKX0+PEljb24gdHlwZT1cImljb24tcmVmcmVzaFwiIC8+PC9zcGFuPlxuICAgICAgICAgICAgPC9Ub29sQmFyPlxuICAgICAgICAgICAgPHRleHRhcmVhXG4gICAgICAgICAgICAgIGlkPVwidGV4dGFyZWFcIlxuICAgICAgICAgICAgICByZWY9e25vZGUgPT4gdGhpcy5ub2RlTWRUZXh0ID0gbm9kZX1cbiAgICAgICAgICAgICAgdmFsdWU9e3RleHR9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17J2lucHV0J31cbiAgICAgICAgICAgICAgd3JhcD1cImhhcmRcIlxuICAgICAgICAgICAgICBvbkNoYW5nZT17dGhpcy5oYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgICAgIG9uU2VsZWN0PXt0aGlzLmhhbmRsZUlucHV0U2VsZWN0fVxuICAgICAgICAgICAgICBvblNjcm9sbD17dGhpcy5oYW5kbGVJbnB1dFNjcm9sbH1cbiAgICAgICAgICAgICAgb25Nb3VzZU92ZXI9eygpID0+IHRoaXMuaGFuZGxlU2Nyb2xsRWxlKCdtZCcpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L3NlY3Rpb24+KVxuICAgICAgfVxuICAgICAgaWYgKHZpZXcuaHRtbCkge1xuICAgICAgICByZXMucHVzaChcbiAgICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9eydzZWMtaHRtbCd9IGtleT1cImh0bWxcIj5cbiAgICAgICAgICAgIDxUb29sQmFyIHN0eWxlPXt7IHJpZ2h0OiAnMjBweCcgfX0+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJ1dHRvblwiIHRpdGxlPXt2aWV3Lm1lbnUgPyAnaGlkZGVuIG1lbnUnIDogJ3Nob3cgbWVudSd9IG9uQ2xpY2s9e3RoaXMuaGFuZGxlVG9nZ2xlTWVudX0+XG4gICAgICAgICAgICAgICAge3ZpZXcubWVudSA/IDxJY29uIHR5cGU9XCJpY29uLWNoZXZyb24tdXBcIiAvPlxuICAgICAgICAgICAgICAgICAgOiA8SWNvbiB0eXBlPVwiaWNvbi1jaGV2cm9uLWRvd25cIiAvPlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJidXR0b25cIiB0aXRsZT17dmlldy5tZCA/ICdwcmV2aWV3JyA6ICdjb2x1bW4nfSBvbkNsaWNrPXt0aGlzLmhhbmRsZUh0bWxQcmV2aWV3fT5cbiAgICAgICAgICAgICAgICB7dmlldy5tZCA/IDxJY29uIHR5cGU9XCJpY29uLWRlc2t0b3BcIiAvPlxuICAgICAgICAgICAgICAgICAgOiA8SWNvbiB0eXBlPVwiaWNvbi1jb2x1bW5zXCIgLz5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiYnV0dG9uXCIgdGl0bGU9eyd0b2dnbGUnfSBvbkNsaWNrPXsoKSA9PiB0aGlzLmhhbmRsZVRvZ2dsZVZpZXcoJ2h0bWwnKX0+PEljb24gdHlwZT1cImljb24tcmVmcmVzaFwiIC8+PC9zcGFuPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJidXR0b25cIiB0aXRsZT1cIkhUTUwgY29kZVwiIG9uQ2xpY2s9e3RoaXMuaGFuZGxlVG9nZ2xlSHRtbFR5cGV9PlxuICAgICAgICAgICAgICAgIHtodG1sVHlwZSA9PT0gJ3JlbmRlcicgPyA8SWNvbiB0eXBlPVwiaWNvbi1jb2RlXCIgLz5cbiAgICAgICAgICAgICAgICAgIDogPEljb24gdHlwZT1cImljb24tZXllXCIgLz5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDwvVG9vbEJhcj5cbiAgICAgICAgICAgIHtodG1sVHlwZSA9PT0gJ3JlbmRlcicgP1xuICAgICAgICAgICAgICAoPGRpdiBjbGFzc05hbWU9XCJodG1sLXdyYXBcIlxuICAgICAgICAgICAgICAgIHJlZj17bm9kZSA9PiB0aGlzLm5vZGVNZFByZXZpZXdXcmFwZXIgPSBub2RlfVxuICAgICAgICAgICAgICAgIG9uTW91c2VPdmVyPXsoKSA9PiB0aGlzLmhhbmRsZVNjcm9sbEVsZSgnaHRtbCcpfVxuICAgICAgICAgICAgICAgIG9uU2Nyb2xsPXt0aGlzLmhhbmRsZVByZXZpZXdTY3JvbGx9PlxuICAgICAgICAgICAgICAgIDxIdG1sUmVuZGVyIGh0bWw9e2h0bWx9IHJlZj17bm9kZSA9PiB0aGlzLm5vZGVNZFByZXZpZXcgPSBSZWFjdERPTS5maW5kRE9NTm9kZShub2RlKX0gLz5cbiAgICAgICAgICAgICAgPC9kaXY+KVxuICAgICAgICAgICAgICA6ICg8ZGl2IGNsYXNzTmFtZT17J2h0bWwtY29kZS13cmFwJ31cbiAgICAgICAgICAgICAgICByZWY9e25vZGUgPT4gdGhpcy5ub2RlTWRQcmV2aWV3V3JhcGVyID0gUmVhY3RET00uZmluZERPTU5vZGUobm9kZSl9XG4gICAgICAgICAgICAgICAgb25TY3JvbGw9e3RoaXMuaGFuZGxlUHJldmlld1Njcm9sbH0+XG4gICAgICAgICAgICAgICAgPEh0bWxDb2RlIGh0bWw9e2h0bWx9IHJlZj17bm9kZSA9PiB0aGlzLm5vZGVNZFByZXZpZXcgPSBSZWFjdERPTS5maW5kRE9NTm9kZShub2RlKX0gLz5cbiAgICAgICAgICAgICAgPC9kaXY+KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc1xuICAgIH1cbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9e2ByYy1tZC1lZGl0b3IgJHtmdWxsU2NyZWVuID8gJ2Z1bGwnIDogJyd9YH0gc3R5bGU9e3RoaXMucHJvcHMuc3R5bGV9IG9uS2V5RG93bj17dGhpcy5oYW5kbGVvbktleURvd259PlxuICAgICAgICB7cmVuZGVyTmF2aWdhdGlvbigpfVxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImVkaXRvci1jb250YWluZXJcIj5cbiAgICAgICAgICB7cmVuZGVyQ29udGVudCgpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIClcbiAgfVxufVxuTWRFZGl0b3IuSHRtbFJlbmRlciA9IEh0bWxSZW5kZXJcbmV4cG9ydCBkZWZhdWx0IE1kRWRpdG9yIiwiXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtMSEuLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uL25vZGVfbW9kdWxlcy9sZXNzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL2luZGV4Lmxlc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LTEhLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi9ub2RlX21vZHVsZXMvbGVzcy1sb2FkZXIvZGlzdC9janMuanMhLi9pbmRleC5sZXNzXCIpO1xuXG5cdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cblx0XHR2YXIgbG9jYWxzID0gKGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBrZXksIGlkeCA9IDA7XG5cblx0XHRcdGZvcihrZXkgaW4gYSkge1xuXHRcdFx0XHRpZighYiB8fCBhW2tleV0gIT09IGJba2V5XSkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZHgrKztcblx0XHRcdH1cblxuXHRcdFx0Zm9yKGtleSBpbiBiKSBpZHgtLTtcblxuXHRcdFx0cmV0dXJuIGlkeCA9PT0gMDtcblx0XHR9KGNvbnRlbnQubG9jYWxzLCBuZXdDb250ZW50LmxvY2FscykpO1xuXG5cdFx0aWYoIWxvY2FscykgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGluZyBDU1MgSE1SIGR1ZSB0byBjaGFuZ2VkIGNzcy1tb2R1bGVzIGxvY2Fscy4nKTtcblxuXHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0fSk7XG5cblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiaW1wb3J0IE1kRWRpdG9yIGZyb20gJy4vZWRpdG9yJ1xuXG5leHBvcnQgZGVmYXVsdCBNZEVkaXRvcjsiLCIvLyBkZWFsIHdpdGggc2VsZWN0aW9uIHRleHRcblxuY2xhc3MgRGVjb3JhdGUge1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldFxuICB9XG4gIG5hbWUgPSAnc2VsZWN0aW9uIGRlY29yYXRpb24nXG4gIHRhcmdldCA9ICcnXG4gIHR5cGUgPSAnJ1xuICBvcHRpb24gPSB7fVxuICByZXN1bHQgPSAnJ1xuICBnZXREZWNvcmF0ZWRUZXh0KHR5cGUsIG9wdGlvbiA9IHt9KSB7XG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMub3B0aW9uID0gb3B0aW9uXG4gICAgcmV0dXJuIHRoaXMucmVzdWx0ID0gdGhpcy5jYWxjRGVjb3JhdGVUZXh0KHRoaXMudHlwZSwgb3B0aW9uKVxuICB9XG4gIGNhbGNEZWNvcmF0ZVRleHQodHlwZSwgb3B0aW9uID0ge30pIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgICAgcmV0dXJuIGBcXG4jICR7dGhpcy50YXJnZXR9IFxcbmBcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgICAgcmV0dXJuIGBcXG4jIyAke3RoaXMudGFyZ2V0fSBcXG5gXG4gICAgICBjYXNlICdoMyc6XG4gICAgICAgIHJldHVybiBgXFxuIyMjICR7dGhpcy50YXJnZXR9IFxcbmBcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgICAgcmV0dXJuIGBcXG4jIyMjICR7dGhpcy50YXJnZXR9IFxcbmBcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgICAgcmV0dXJuIGBcXG4jIyMjIyAke3RoaXMudGFyZ2V0fSBcXG5gXG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBgXFxuIyMjIyMjICR7dGhpcy50YXJnZXR9IFxcbmBcbiAgICAgIGNhc2UgJ2JvbGQnOlxuICAgICAgICByZXR1cm4gYCoqJHt0aGlzLnRhcmdldH0qKmBcbiAgICAgIGNhc2UgJ2l0YWxpYyc6XG4gICAgICAgIHJldHVybiBgKiR7dGhpcy50YXJnZXR9KmBcbiAgICAgIGNhc2UgJ3VuZGVybGluZSc6XG4gICAgICAgIHJldHVybiBgKyske3RoaXMudGFyZ2V0fSsrYFxuICAgICAgY2FzZSAnc3RyaWtldGhyb3VnaCc6XG4gICAgICAgIHJldHVybiBgfn4ke3RoaXMudGFyZ2V0fX5+YFxuICAgICAgY2FzZSAndW5vcmRlcic6XG4gICAgICAgIHJldHVybiBgXFxuLSAke3RoaXMudGFyZ2V0fVxcbmBcbiAgICAgIGNhc2UgJ29yZGVyJzpcbiAgICAgICAgcmV0dXJuIGBcXG4xLiAke3RoaXMudGFyZ2V0fVxcbmBcbiAgICAgIGNhc2UgJ3F1b3RlJzpcbiAgICAgICAgcmV0dXJuIGBcXG4+ICR7dGhpcy50YXJnZXR9XFxuYFxuICAgICAgY2FzZSAnaHInOlxuICAgICAgICByZXR1cm4gYFxcbi0tLVxcbmBcbiAgICAgIGNhc2UgJ2lubGluZWNvZGUnOlxuICAgICAgICByZXR1cm4gYFxcYCR7dGhpcy50YXJnZXR9XFxgYFxuICAgICAgY2FzZSAnY29kZSc6XG4gICAgICAgIHJldHVybiBgXFxuXFxgXFxgXFxgXFxuJHt0aGlzLnRhcmdldH1cXG5cXGBcXGBcXGBcXG5gXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIC8vIHJldHVybiBgXFxufCAke3RoaXMudGFyZ2V0fSB8ICB8XFxufCAtLSB8IC0tIHxcXG58ICB8ICB8XFxuYFxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRUYWJsZVRleHQodGhpcy50YXJnZXQsIG9wdGlvbilcbiAgICAgIGNhc2UgJ2ltYWdlJzogXG4gICAgICAgIHJldHVybiBgIVske3RoaXMudGFyZ2V0fV0oJHtvcHRpb24uaW1hZ2VVcmwgfHwgJyd9KWBcbiAgICAgIGNhc2UgJ2xpbmsnOiBcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnRhcmdldH1dKCR7b3B0aW9uLmxpbmtVcmwgfHwgJyd9KWBcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnRhcmdldH1gXG4gICAgfVxuICB9XG4gIGZvcm1hdFRhYmxlVGV4dCh0YXJnZXQsIG9wdGlvbikge1xuICAgIGNvbnN0IHtyb3cgPSAyLCBjb2wgPSAyfSA9IG9wdGlvblxuICAgIGxldCByb3dIZWFkZXIgPSBbJ3wnXVxuICAgIGxldCByb3dEYXRhID0gWyd8J11cbiAgICBsZXQgcm93RGl2aXNpb24gPSBbJ3wnXVxuICAgIGxldCBjb2xTdHIgPSAnJ1xuICAgIGxldCByZXN1bHQgPSAnJ1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGNvbDsgaSsrKSB7XG4gICAgICByb3dIZWFkZXIucHVzaCgnIEhlYWQgfCcpICAgICAgXG4gICAgICByb3dEaXZpc2lvbi5wdXNoKCcgLS0tIHwnKVxuICAgICAgcm93RGF0YS5wdXNoKCcgRGF0YSB8JylcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPD0gcm93OyBqKyspIHtcbiAgICAgIGNvbFN0ciA9IGNvbFN0ciArICdcXG4nICsgcm93RGF0YS5qb2luKCcnKVxuICAgIH1cbiAgICByZXN1bHQgPSAnXFxuJyArIHJvd0hlYWRlci5qb2luKCcnKSArICdcXG4nICsgcm93RGl2aXNpb24uam9pbignJykgKyBjb2xTdHIgKyAnXFxuJ1xuICAgIHJldHVybiByZXN1bHRcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBEZWNvcmF0ZSIsIi8qKlxuICogbG9nZ2VyOiB1bmRvIHJlZG9cbiAqL1xuXG5jbGFzcyBMb2dnZXIgeyAgXG5cbiAgbmFtZSA9ICdsb2dnZXInXG5cbiAgcmVjb3JkID0gW11cblxuICByZWN5Y2xlID0gW11cblxuICBwdXNoUmVjb3JkKHZhbCkge1xuICAgIHJldHVybiB0aGlzLnJlY29yZC5wdXNoKHZhbClcbiAgfVxuXG4gIGdldFJlY29yZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWNvcmRcbiAgfVxuXG4gIGdldExhc3RSZWNvcmQoKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdGhpcy5yZWNvcmQubGVuZ3RoXG4gICAgcmV0dXJuIHRoaXMucmVjb3JkW2xlbmd0aCAtIDFdXG4gIH1cblxuICB1bmRvKGNiKSB7XG4gICAgY29uc3QgbGFzdFJlY29yZCA9IHRoaXMucmVjb3JkLnBvcCgpXG4gICAgdGhpcy5yZWN5Y2xlLnB1c2gobGFzdFJlY29yZClcbiAgICB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicgJiYgY2IodGhpcy5nZXRMYXN0UmVjb3JkKCkpXG4gIH1cblxuICByZWRvKGNiKSB7XG4gICAgaWYgKHRoaXMucmVjeWNsZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBoaXN0b3J5ID0gdGhpcy5yZWN5Y2xlLnBvcCgpXG4gICAgICB0aGlzLnJlY29yZC5wdXNoKGhpc3RvcnkpXG4gICAgICB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicgJiYgY2IodGhpcy5nZXRMYXN0UmVjb3JkKCkpXG4gICAgfSAgICBcbiAgfVxuXG4gIGNsZWFuUmVkb0xpc3QoY2IpIHtcbiAgICB0aGlzLnJlY3ljbGUgPSBbXVxuICAgIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJyAmJiBjYigpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTG9nZ2VyIiwiZXhwb3J0IGZ1bmN0aW9uIGRlZXBDbG9uZSAob2JqKSB7XG4gIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9ialxuICB9XG4gIGxldCBvYmpBcnJheSA9IEFycmF5LmlzQXJyYXkob2JqKSA/IFtdIDoge31cbiAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAobGV0IGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAvLyDlpoLmnpxvYmrnmoTlsZ7mgKfmmK/lr7nosaHvvIzpgJLlvZLmk43kvZxcbiAgICAgICAgaWYgKG9ialtrZXldICYmIHR5cGVvZiBvYmpba2V5XSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBvYmpBcnJheVtrZXldID0gZGVlcENsb25lKG9ialtrZXldKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iakFycmF5W2tleV0gPSBvYmpba2V5XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmpBcnJheVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcbiAgLy8g5Yik5pat5a2X56ym5piv5ZCm5Li656m655qE5pa55rOVXG4gIGlmICh0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJyB8fCBvYmogPT09IG51bGwgfHwgb2JqID09PSAnJykge1xuICAgIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5leHBvcnQgZnVuY3Rpb24gaXNSZXBlYXQoYXJyKSB7XG4gIHZhciBoYXNoID0ge31cbiAgZm9yICh2YXIgaSBpbiBhcnIpIHtcbiAgICBpZiAoaGFzaFthcnJbaV1dKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBoYXNoW2FycltpXV0gPSB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5leHBvcnQgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgZGVsdGFYKSB7XG4gIGxldCBsYXN0Q2FsbGVkQXQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsYXN0Q2FsbGVkQXQgPj0gZGVsdGFYKSB7XG4gICAgICBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIGxhc3RDYWxsZWRBdCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgfVxuICB9XG59Il0sInNvdXJjZVJvb3QiOiIifQ==